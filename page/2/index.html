<!DOCTYPE html>



  


<html class="theme-next gemini use-motion" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>
<meta name="theme-color" content="#222">









<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />
















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />







<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.4" rel="stylesheet" type="text/css" />


  <link rel="apple-touch-icon" sizes="180x180" href="/images/apple-touch-icon-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="32x32" href="/images/favicon-32x32-next.png?v=5.1.4">


  <link rel="icon" type="image/png" sizes="16x16" href="/images/favicon-16x16-next.png?v=5.1.4">


  <link rel="mask-icon" href="/images/logo.svg?v=5.1.4" color="#222">





  <meta name="keywords" content="Hexo, NexT" />










<meta name="description" content="Base on front-end, more than front-end">
<meta property="og:type" content="website">
<meta property="og:title" content="Frankl&#39;s Personal Blog">
<meta property="og:url" content="www.lpldplws.cn/page/2/index.html">
<meta property="og:site_name" content="Frankl&#39;s Personal Blog">
<meta property="og:description" content="Base on front-end, more than front-end">
<meta property="og:locale" content="zh-Hans">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="Frankl&#39;s Personal Blog">
<meta name="twitter:description" content="Base on front-end, more than front-end">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Gemini',
    version: '5.1.4',
    sidebar: {"position":"left","display":"post","offset":12,"b2t":false,"scrollpercent":false,"onmobile":false},
    fancybox: true,
    tabs: true,
    motion: {"enable":true,"async":false,"transition":{"post_block":"fadeIn","post_header":"slideDownIn","post_body":"slideDownIn","coll_header":"slideLeftIn","sidebar":"slideUpIn"}},
    duoshuo: {
      userId: '0',
      author: 'Author'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="www.lpldplws.cn/page/2/"/>





  <title>Frankl's Personal Blog</title>
  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?d093c12303d4a743548946b3dd3ab3a1";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>




</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  
  
    
  

  <div class="container sidebar-position-left 
  page-home">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">Frankl's Personal Blog</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
            Startseite
          </a>
        </li>
      
        
        <li class="menu-item menu-item-categories">
          <a href="/categories" rel="section">
            
            Kategorien
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
            Archiv
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
            Tags
          </a>
        </li>
      
        
        <li class="menu-item menu-item-schedule">
          <a href="/schedule" rel="section">
            
            Schedule
          </a>
        </li>
      
        
        <li class="menu-item menu-item-about">
          <a href="/about" rel="section">
            
            Über
          </a>
        </li>
      
        
        <li class="menu-item menu-item-sitemap">
          <a href="/sitemap.xml" rel="section">
            
            Sitemap
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.lpldplws.cn/2018/06/11/ES6/03.变量的解构赋值/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frankl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frankl's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/11/ES6/03.变量的解构赋值/" itemprop="url">ES6 -- 03.变量的解构赋值</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-11T10:04:16+08:00">
                2018-06-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index">
                    <span itemprop="name">ES6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/11/ES6/03.变量的解构赋值/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count fb-comments-count" data-href="www.lpldplws.cn/2018/06/11/ES6/03.变量的解构赋值/" itemprop="commentCount">0</span> comments
                </a>
              </span>
            
          

          
          
             <span id="/2018/06/11/ES6/03.变量的解构赋值/" class="leancloud_visitors" data-flag-title="ES6 -- 03.变量的解构赋值">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="1-变量的解构赋值"><a href="#1-变量的解构赋值" class="headerlink" title="1.变量的解构赋值"></a>1.变量的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code>let a = 1;
let b = 2;
let c = 3;
</code></pre><p>ES6 允许写成下面这样。</p>
<pre><code>let [a, b, c] = [1, 2, 3];
</code></pre><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>
<pre><code>let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&#39;a&#39;];
x // &quot;a&quot;
y // undefined
z // []
</code></pre><p>如果解构不成功，变量的值就等于undefined。</p>
<pre><code>let [foo] = [];
let [bar, foo] = [1];
</code></pre><p>以上两种情况都属于解构不成功，foo的值都会等于undefined。</p>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<pre><code>let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
</code></pre><p>上面两个例子，都属于不完全解构，但是可以成功。</p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<pre><code>// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
</code></pre><p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p>
<p>对于 Set 结构，也可以使用数组的解构赋值。</p>
<pre><code>let [x, y, z] = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);
x // &quot;a&quot;
</code></pre><p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<pre><code>function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
</code></pre><p>上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。</p>
<pre><code>let [foo = true] = [];
foo // true

let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;
let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;
</code></pre><p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</p>
<pre><code>let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
</code></pre><p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<pre><code>function f() {
  console.log(&#39;aaa&#39;);
}

let [x = f()] = [1];
</code></pre><p>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。</p>
<pre><code>let x;
if ([1][0] === undefined) {
  x = f();
} else {
  x = [1][0];
}
</code></pre><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<pre><code>let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError: y is not defined
</code></pre><p>上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。</p>
<h3 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2.对象的解构赋值"></a>2.对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。</p>
<pre><code>let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;
</code></pre><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code>let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // undefined
</code></pre><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<pre><code>let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
baz // &quot;aaa&quot;

let obj = { first: &#39;hello&#39;, last: &#39;world&#39; };
let { first: f, last: l } = obj;
f // &#39;hello&#39;
l // &#39;world&#39;
</code></pre><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>
<pre><code>let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
</code></pre><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<pre><code>let { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p>
<p>与数组一样，解构也可以用于嵌套结构的对象。</p>
<pre><code>let obj = {
  p: [
    &#39;Hello&#39;,
    { y: &#39;World&#39; }
  ]
};

let { p: [x, { y }] } = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
</code></pre><p>注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。</p>
<pre><code>let obj = {
  p: [
    &#39;Hello&#39;,
    { y: &#39;World&#39; }
  ]
};

let { p, p: [x, { y }] } = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
p // [&quot;Hello&quot;, {y: &quot;World&quot;}]
</code></pre><p>下面是另一个例子。</p>
<pre><code>const node = {
  loc: {
    start: {
      line: 1,
      column: 5
    }
  }
};

let { loc, loc: { start }, loc: { start: { line }} } = node;
line // 1
loc  // Object {start: Object}
start // Object {line: 1, column: 5}
</code></pre><p>上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。</p>
<p>下面是嵌套赋值的例子。</p>
<pre><code>let obj = {};
let arr = [];

({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

obj // {prop:123}
arr // [true]
</code></pre><p>对象的解构也可以指定默认值。</p>
<pre><code>var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5

var { message: msg = &#39;Something went wrong&#39; } = {};
msg // &quot;Something went wrong&quot;
</code></pre><p>默认值生效的条件是，对象的属性值严格等于undefined。</p>
<pre><code>var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
</code></pre><p>上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。</p>
<p>如果解构失败，变量的值等于undefined。</p>
<pre><code>let {foo} = {bar: &#39;baz&#39;};
foo // undefined
</code></pre><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>
<pre><code>// 报错
let {foo: {bar}} = {baz: &#39;baz&#39;};
</code></pre><p>上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。</p>
<pre><code>let _tmp = {baz: &#39;baz&#39;};
_tmp.foo.bar // 报错
</code></pre><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
<pre><code>// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
</code></pre><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
<pre><code>// 正确的写法
let x;
({x} = {x: 1});
</code></pre><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p>
<p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p>
<pre><code>({} = [true, false]);
({} = &#39;abc&#39;);
({} = []);
</code></pre><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<pre><code>let { log, sin, cos } = Math;
</code></pre><p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p>
<p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<pre><code>let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
</code></pre><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）</p>
<h3 id="3-字符串的解构赋值"><a href="#3-字符串的解构赋值" class="headerlink" title="3.字符串的解构赋值"></a>3.字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<pre><code>const [a, b, c, d, e] = &#39;hello&#39;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;
</code></pre><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<pre><code>let {length : len} = &#39;hello&#39;;
len // 5
</code></pre><h3 id="4-数值和布尔值的解构赋值"><a href="#4-数值和布尔值的解构赋值" class="headerlink" title="4.数值和布尔值的解构赋值"></a>4.数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<pre><code>let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
</code></pre><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<pre><code>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。

解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
</code></pre><h3 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5.函数参数的解构赋值"></a>5.函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。</p>
<pre><code>function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
</code></pre><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p>
<p>下面是另一个例子。</p>
<pre><code>[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);
</code></pre><p>函数参数的解构也可以使用默认值。</p>
<pre><code>function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
</code></pre><p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p>
<p>注意，下面的写法会得到不一样的结果。</p>
<pre><code>function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
</code></pre><p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p>
<p>undefined就会触发函数参数的默认值。</p>
<pre><code>[1, undefined, 3].map((x = &#39;yes&#39;) =&gt; x);
// [ 1, &#39;yes&#39;, 3 ]
</code></pre><h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><p>以下三种解构赋值不得使用圆括号。</p>
<p>（1）变量声明语句</p>
<pre><code>// 全部报错
let [(a)] = [1];

let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};

let { o: ({ p: p }) } = { o: { p: 2 } };
</code></pre><p>（2）函数参数</p>
<p>函数参数也属于变量声明，因此不能带有圆括号。</p>
<pre><code>// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
</code></pre><p>（3）赋值语句的模式</p>
<pre><code>// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];
</code></pre><p>上面代码将整个模式放在圆括号之中，导致报错。</p>
<pre><code>// 报错
[({ p: a }), { x: c }] = [{}, {}];
</code></pre><p>上面代码将一部分模式放在圆括号之中，导致报错。</p>
<h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<pre><code>[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
</code></pre><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p>
<h3 id="7-用途"><a href="#7-用途" class="headerlink" title="7.用途"></a>7.用途</h3><p>变量的解构赋值用途很多。</p>
<p>（1）交换变量的值</p>
<pre><code>let x = 1;
let y = 2;

[x, y] = [y, x];
</code></pre><p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<p>（2）从函数返回多个值</p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<pre><code>// 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
</code></pre><p>（3）函数参数的定义</p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<pre><code>// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
</code></pre><p>（4）提取 JSON 数据</p>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<pre><code>let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]
</code></pre><p>上面代码可以快速提取 JSON 数据的值。</p>
<p>（5）函数参数的默认值</p>
<pre><code>jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
</code></pre><p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<p>（6）遍历 Map 结构</p>
<p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code>const map = new Map();
map.set(&#39;first&#39;, &#39;hello&#39;);
map.set(&#39;second&#39;, &#39;world&#39;);

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world
</code></pre><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<pre><code>// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
</code></pre><p>（7）输入模块的指定方法</p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<pre><code>const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.lpldplws.cn/2018/06/08/ES6/02.let和const命令/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frankl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frankl's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/08/ES6/02.let和const命令/" itemprop="url">ES6 -- 02.let 和 const 命令</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-08T16:04:16+08:00">
                2018-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index">
                    <span itemprop="name">ES6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/08/ES6/02.let和const命令/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count fb-comments-count" data-href="www.lpldplws.cn/2018/06/08/ES6/02.let和const命令/" itemprop="commentCount">0</span> comments
                </a>
              </span>
            
          

          
          
             <span id="/2018/06/08/ES6/02.let和const命令/" class="leancloud_visitors" data-flag-title="ES6 -- 02.let 和 const 命令">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Let-和-Const-命令"><a href="#Let-和-Const-命令" class="headerlink" title="Let 和 Const 命令"></a>Let 和 Const 命令</h2><h3 id="1-Let-命令"><a href="#1-Let-命令" class="headerlink" title="1. Let 命令"></a>1. Let 命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法:"></a>基本用法:</h4><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<pre><code>{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
</code></pre><p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</p>
<p>for循环的计数器，就很合适使用let命令。</p>
<pre><code>for (let i = 0; i &lt; 10; i++) {
  // ...
}

console.log(i);
// ReferenceError: i is not defined
</code></pre><p>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。</p>
<p>下面的代码如果使用var，最后输出的是10。</p>
<pre><code>var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
</code></pre><p>上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。</p>
<p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<pre><code>var a = [];
for (let i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
</code></pre><p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p>
<p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<pre><code>for (let i = 0; i &lt; 3; i++) {
  let i = &#39;abc&#39;;
  console.log(i);
}
// abc
// abc
// abc
</code></pre><p>上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<pre><code>// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre><p>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<pre><code>if (true) {
  // TDZ开始
  tmp = &#39;abc&#39;; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
</code></pre><p>上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。</p>
<p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。</p>
<pre><code>typeof x; // ReferenceError
let x;
</code></pre><p>上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。</p>
<p>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。</p>
<pre><code>typeof undeclared_variable // &quot;undefined&quot;
</code></pre><p>上面代码中，undeclared variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>
<p>有些“死区”比较隐蔽，不太容易发现。</p>
<pre><code>function bar(x = y, y = 2) {
  return [x, y];
}

bar(); // 报错
</code></pre><p>上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。</p>
<pre><code>function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]
</code></pre><p>另外，下面的代码也会报错，与var的行为不同。</p>
<pre><code>// 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined
</code></pre><p>上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。</p>
<p>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p>let不允许在相同作用域内，重复声明同一个变量。</p>
<pre><code>// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}
</code></pre><p>因此，不能在函数内部重新声明参数。</p>
<pre><code>function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}
</code></pre><h3 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2.块级作用域"></a>2.块级作用域</h3><h4 id="为什么需要块级作用域"><a href="#为什么需要块级作用域" class="headerlink" title="为什么需要块级作用域"></a>为什么需要块级作用域</h4><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
<pre><code>var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = &#39;hello world&#39;;
  }
}

f(); // undefined
</code></pre><p>上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<pre><code>var s = &#39;hello&#39;;

for (var i = 0; i &lt; s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
</code></pre><p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h4 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h4><p>let实际上为 JavaScript 新增了块级作用域。</p>
<pre><code>function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
</code></pre><p>上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。</p>
<p>ES6 允许块级作用域的任意嵌套。</p>
<pre><code>{{{{{let insane = 'Hello World'}}}}};
</code></pre><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p>
<pre><code>{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};
</code></pre><p>内层作用域可以定义外层作用域的同名变量。</p>
<pre><code>{{{{
  let insane = 'Hello World';
  {let insane = 'Hello World'}
}}}};
</code></pre><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<pre><code>// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
</code></pre><h4 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h4><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<pre><code>// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
  // ...
}
</code></pre><p>上面两种函数声明，根据 ES5 的规定都是非法的。</p>
<p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p>
<pre><code>function f() { console.log(&#39;I am outside!&#39;); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log(&#39;I am inside!&#39;); }
  }

  f();
}());
</code></pre><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。</p>
<pre><code>// ES5 环境
function f() { console.log(&#39;I am outside!&#39;); }

(function () {
  function f() { console.log(&#39;I am inside!&#39;); }
  if (false) {
  }
  f();
}());
</code></pre><p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p>
<p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics" target="_blank" rel="noopener">附录B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a href="http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6" target="_blank" rel="noopener">行为方式</a>。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p>
<p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</p>
<pre><code>// 浏览器的 ES6 环境
function f() { console.log(&#39;I am outside!&#39;); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log(&#39;I am inside!&#39;); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
</code></pre><p>上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。</p>
<pre><code>// 浏览器的 ES6 环境
function f() { console.log(&#39;I am outside!&#39;); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log(&#39;I am inside!&#39;); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
</code></pre><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<pre><code>// 函数声明语句
{
  let a = &#39;secret&#39;;
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = &#39;secret&#39;;
  let f = function () {
    return a;
  };
}
</code></pre><p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p>
<pre><code>// 不报错
&#39;use strict&#39;;
if (true) {
  function f() {}
}

// 报错
&#39;use strict&#39;;
if (true)
  function f() {}
</code></pre><h3 id="3-const命令"><a href="#3-const命令" class="headerlink" title="3.const命令"></a>3.const命令</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<pre><code>const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
</code></pre><p>上面代码表明改变常量的值会报错。</p>
<p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<pre><code>const foo;
// SyntaxError: Missing initializer in const declaration
</code></pre><p>上面代码表示，对于const来说，只声明不赋值，就会报错。</p>
<p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
<pre><code>if (true) {
  const MAX = 5;
}

MAX // Uncaught ReferenceError: MAX is not defined
</code></pre><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<pre><code>if (true) {
  console.log(MAX); // ReferenceError
  const MAX = 5;
}
</code></pre><p>上面代码在常量MAX声明之前就调用，结果报错。</p>
<p>const声明的常量，也与let一样不可重复声明。</p>
<pre><code>var message = &quot;Hello!&quot;;
let age = 25;

// 以下两行都会报错
const message = &quot;Goodbye!&quot;;
const age = 30;
</code></pre><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<pre><code>const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: &quot;foo&quot; is read-only
</code></pre><p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<pre><code>const a = [];
a.push(&#39;Hello&#39;); // 可执行
a.length = 0;    // 可执行
a = [&#39;Dave&#39;];    // 报错
</code></pre><p>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。</p>
<p>如果真的想将对象冻结，应该使用Object.freeze方法。</p>
<pre><code>const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
</code></pre><p>上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<pre><code>var constantize = (obj) =&gt; {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; {
    if ( typeof obj[key] === &#39;object&#39; ) {
      constantize( obj[key] );
    }
  });
};
</code></pre><h4 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h4><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。</p>
<h3 id="4-顶层对象的属性"><a href="#4-顶层对象的属性" class="headerlink" title="4.顶层对象的属性"></a>4.顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>
<pre><code>window.a = 1;
a // 1

a = 2;
window.a // 2
</code></pre><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<pre><code>var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
</code></pre><p>上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。</p>
<h3 id="5-global对象"><a href="#5-global对象" class="headerlink" title="5.global对象"></a>5.global对象</h3><p>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p>
<ul>
<li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li>
<li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。</li>
<li>Node 里面，顶层对象是global，但其他环境都不支持。</li>
</ul>
<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p>
<ul>
<li>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。</li>
<li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li>
<li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li>
</ul>
<p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p>
<pre><code>// 方法一
(typeof window !== &#39;undefined&#39;
   ? window
   : (typeof process === &#39;object&#39; &amp;&amp;
      typeof require === &#39;function&#39; &amp;&amp;
      typeof global === &#39;object&#39;)
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== &#39;undefined&#39;) { return self; }
  if (typeof window !== &#39;undefined&#39;) { return window; }
  if (typeof global !== &#39;undefined&#39;) { return global; }
  throw new Error(&#39;unable to locate global object&#39;);
};
</code></pre><p>现在有一个<a href="https://github.com/tc39/proposal-global" target="_blank" rel="noopener">提案</a>，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p>
<p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。</p>
<pre><code>// CommonJS 的写法
require(&#39;system.global/shim&#39;)();

// ES6 模块的写法
import shim from &#39;system.global/shim&#39;; shim();
</code></pre><p>上面代码可以保证各种环境里面，global对象都是存在的。</p>
<pre><code>// CommonJS 的写法
var global = require(&#39;system.global&#39;)();

// ES6 模块的写法
import getGlobal from &#39;system.global&#39;;
const global = getGlobal();
</code></pre><p>上面代码将顶层对象放入变量global。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.lpldplws.cn/2018/06/08/ES6/01.ECMAScript/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frankl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frankl's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/06/08/ES6/01.ECMAScript/" itemprop="url">ES6 -- 01.ECMAScript 6 简介</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-06-08T15:04:16+08:00">
                2018-06-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/ES6/" itemprop="url" rel="index">
                    <span itemprop="name">ES6</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/06/08/ES6/01.ECMAScript/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count fb-comments-count" data-href="www.lpldplws.cn/2018/06/08/ES6/01.ECMAScript/" itemprop="commentCount">0</span> comments
                </a>
              </span>
            
          

          
          
             <span id="/2018/06/08/ES6/01.ECMAScript/" class="leancloud_visitors" data-flag-title="ES6 -- 01.ECMAScript 6 简介">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="ECMAScript-6-简介"><a href="#ECMAScript-6-简介" class="headerlink" title="ECMAScript 6 简介"></a>ECMAScript 6 简介</h2><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<hr>
<h3 id="1-ECMAScript-和-JavaScript-的关系"><a href="#1-ECMAScript-和-JavaScript-的关系" class="headerlink" title="1.ECMAScript 和 JavaScript 的关系"></a>1.ECMAScript 和 JavaScript 的关系</h3><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p>
<p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p>
<p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p>
<h3 id="2-ES6-与-ECMAScript-2015-的关系"><a href="#2-ES6-与-ECMAScript-2015-的关系" class="headerlink" title="2.ES6 与 ECMAScript 2015 的关系"></a>2.ES6 与 ECMAScript 2015 的关系</h3><p>ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？</p>
<p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。</p>
<p>但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。</p>
<p>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。</p>
<p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。</p>
<p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。</p>
<p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。</p>
<h3 id="3-语法提案的批准流程"><a href="#3-语法提案的批准流程" class="headerlink" title="3.语法提案的批准流程"></a>3.语法提案的批准流程</h3><p>任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。</p>
<p>一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。</p>
<ul>
<li>Stage 0 - Strawman（展示阶段）</li>
<li>Stage 1 - Proposal（征求意见阶段）</li>
<li>Stage 2 - Draft（草案阶段）</li>
<li>Stage 3 - Candidate（候选人阶段）</li>
<li>Stage 4 - Finished（定案阶段）</li>
</ul>
<p>一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站<a href="https://github.com/tc39/ecma262" target="_blank" rel="noopener">Github.com/tc39/ecma262</a>查看。</p>
<p>本书的写作目标之一，是跟踪 ECMAScript 语言的最新进展，介绍 5.1 版本以后所有的新语法。对于那些明确或很有希望，将要列入标准的新语法，都将予以介绍。</p>
<h3 id="4-ECMAScript-的历史"><a href="#4-ECMAScript-的历史" class="headerlink" title="4.ECMAScript 的历史"></a>4.ECMAScript 的历史</h3><p>ES6 从开始制定到最后发布，整整用了 15 年。</p>
<p>前面提到，ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。</p>
<p>2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。</p>
<p>为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。</p>
<p>2007 年 10 月，ECMAScript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。</p>
<p>2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。</p>
<p>2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 委员会的总体考虑是，ES5 与 ES3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是 ES6，第六版发布以后，就指 ES7。TC39 的判断是，ES5 会在 2013 年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。</p>
<p>2011 年 6 月，ECMAscript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。</p>
<p>2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。</p>
<p>2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。</p>
<p>2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。</p>
<h3 id="5-部署进度"><a href="#5-部署进度" class="headerlink" title="5.部署进度"></a>5.部署进度</h3><p>各大浏览器的最新版本，对 ES6 的支持可以查看<a href="https://kangax.github.io/es5-compat-table/es6/" target="_blank" rel="noopener">kangax.github.io/es5-compat-table/es6/</a>。随着时间的推移，支持度已经越来越高了，超过 90%的 ES6 语法特性都实现了。</p>
<p>Node 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node 已经实现的 ES6 特性。</p>
<pre><code>$ node --v8-options | grep harmony
</code></pre><p>上面命令的输出结果，会因为版本的不同而有所不同。</p>
<h3 id="6-Babel-转码器"><a href="#6-Babel-转码器" class="headerlink" title="6.Babel 转码器"></a>6.Babel 转码器</h3><p>Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。</p>
<pre><code>// 转码前
input.map(item =&gt; item + 1);

// 转码后
input.map(function (item) {
  return item + 1;
});
</code></pre><p>上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。</p>
<h4 id="配置文件-babelrc"><a href="#配置文件-babelrc" class="headerlink" title="配置文件.babelrc"></a>配置文件.babelrc</h4><p>Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。</p>
<p>该文件用来设置转码规则和插件，基本格式如下。</p>
<pre><code>{
  &quot;presets&quot;: [],
  &quot;plugins&quot;: []
}
</code></pre><p>presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</p>
<pre><code># 最新转码规则
$ npm install --save-dev babel-preset-latest

# react 转码规则
$ npm install --save-dev babel-preset-react

# 不同阶段语法提案的转码规则（共有4个阶段），选装一个
$ npm install --save-dev babel-preset-stage-0
$ npm install --save-dev babel-preset-stage-1
$ npm install --save-dev babel-preset-stage-2
$ npm install --save-dev babel-preset-stage-3
</code></pre><p>然后，将这些规则加入.babelrc。</p>
<pre><code> {
    &quot;presets&quot;: [
      &quot;latest&quot;,
      &quot;react&quot;,
      &quot;stage-2&quot;
    ],
    &quot;plugins&quot;: []
  }
</code></pre><p>注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。</p>
<h4 id="命令行转码babel-cli"><a href="#命令行转码babel-cli" class="headerlink" title="命令行转码babel-cli"></a>命令行转码babel-cli</h4><p>Babel 提供babel-cli工具，用于命令行转码。</p>
<p>它的安装命令如下。</p>
<pre><code>$ npm install --global babel-cli
</code></pre><p>基本用法如下。</p>
<pre><code># 转码结果输出到标准输出
$ babel example.js

# 转码结果写入一个文件
# --out-file 或 -o 参数指定输出文件
$ babel example.js --out-file compiled.js
# 或者
$ babel example.js -o compiled.js

# 整个目录转码
# --out-dir 或 -d 参数指定输出目录
$ babel src --out-dir lib
# 或者
$ babel src -d lib

# -s 参数生成source map文件
$ babel src -d lib -s
</code></pre><p>上面代码是在全局环境下，进行 Babel 转码。这意味着，如果项目要运行，全局环境必须有 Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的 Babel。</p>
<p>一个解决办法是将babel-cli安装在项目之中。</p>
<pre><code># 安装
$ npm install --save-dev babel-cli
</code></pre><p>然后，改写package.json。</p>
<pre><code>{
  // ...
  &quot;devDependencies&quot;: {
    &quot;babel-cli&quot;: &quot;^6.0.0&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;babel src -d lib&quot;
  },
}
</code></pre><p>转码的时候，就执行下面的命令。</p>
<pre><code>$ npm run build
</code></pre><h4 id="babel-node"><a href="#babel-node" class="headerlink" title="babel-node"></a>babel-node</h4><p>babel-cli工具自带一个babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。</p>
<p>它不用单独安装，而是随babel-cli一起安装。然后，执行babel-node就进入 REPL 环境。</p>
<pre><code>$ babel-node
&gt; (x =&gt; x * 2)(1)
2
</code></pre><p>babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。</p>
<pre><code>$ babel-node es6.js
2
</code></pre><p>babel-node也可以安装在项目中。</p>
<pre><code>$ npm install --save-dev babel-cli
</code></pre><p>然后，改写package.json。</p>
<pre><code>{
  &quot;scripts&quot;: {
    &quot;script-name&quot;: &quot;babel-node script.js&quot;
  }
}
</code></pre><p>上面代码中，使用babel-node替代node，这样script.js本身就不用做任何转码处理。</p>
<h4 id="babel-register"><a href="#babel-register" class="headerlink" title="babel-register"></a>babel-register</h4><p>babel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。</p>
<pre><code>$ npm install --save-dev babel-register
</code></pre><p>使用时，必须首先加载babel-register。</p>
<pre><code>require(&quot;babel-register&quot;);
require(&quot;./index.js&quot;);
</code></pre><p>然后，就不需要手动对index.js转码了。</p>
<p>需要注意的是，babel-register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。</p>
<h4 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h4><p>如果某些代码需要调用 Babel 的 API 进行转码，就要使用babel-core模块。</p>
<p>安装命令如下。</p>
<pre><code>$ npm install babel-core --save
</code></pre><p>然后，在项目中就可以调用babel-core。</p>
<pre><code>var babel = require(&#39;babel-core&#39;);

// 字符串转码
babel.transform(&#39;code();&#39;, options);
// =&gt; { code, map, ast }

// 文件转码（异步）
babel.transformFile(&#39;filename.js&#39;, options, function(err, result) {
  result; // =&gt; { code, map, ast }
});

// 文件转码（同步）
babel.transformFileSync(&#39;filename.js&#39;, options);
// =&gt; { code, map, ast }

// Babel AST转码
babel.transformFromAst(ast, code, options);
// =&gt; { code, map, ast }
</code></pre><p>配置对象options，可以参看官方文档<a href="http://babeljs.io/docs/usage/options/" target="_blank" rel="noopener">http://babeljs.io/docs/usage/options/</a>。</p>
<p>下面是一个例子。</p>
<pre><code>var es6Code = &#39;let x = n =&gt; n + 1&#39;;
var es5Code = require(&#39;babel-core&#39;)
  .transform(es6Code, {
    presets: [&#39;latest&#39;]
  })
  .code;
// &#39;&quot;use strict&quot;;\n\nvar x = function x(n) {\n  return n + 1;\n};&#39;
</code></pre><p>上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。</p>
<h4 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h4><p>Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。</p>
<p>举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。</p>
<p>安装命令如下。</p>
<pre><code>$ npm install --save babel-polyfill
</code></pre><p>然后，在脚本头部，加入如下一行代码。</p>
<pre><code>import &#39;babel-polyfill&#39;;
// 或者
require(&#39;babel-polyfill&#39;);
</code></pre><p>Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的<a href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/definitions.js" target="_blank" rel="noopener">definitions.js</a>文件。</p>
<h4 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h4><p>Babel 也可以用于浏览器环境。但是，从 Babel 6.0 开始，不再直接提供浏览器版本，而是要用构建工具构建出来。如果你没有或不想使用构建工具，可以使用babel-standalone模块提供的浏览器版本，将其插入网页。</p>
<pre><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
// Your ES6 code
&lt;/script&gt;
</code></pre><p>注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。</p>
<p>下面是如何将代码打包成浏览器可以使用的脚本，以Babel配合Browserify为例。首先，安装babelify模块。</p>
<pre><code>$ npm install --save-dev babelify babel-preset-latest
</code></pre><p>然后，再用命令行转换 ES6 脚本。</p>
<pre><code>$  browserify script.js -o bundle.js \
  -t [ babelify --presets [ latest ] ]
</code></pre><p>上面代码将 ES6 脚本script.js，转为bundle.js，浏览器直接加载后者就可以了。</p>
<p>在package.json设置下面的代码，就不用每次命令行都输入参数了。</p>
<pre><code>{
  &quot;browserify&quot;: {
    &quot;transform&quot;: [[&quot;babelify&quot;, { &quot;presets&quot;: [&quot;latest&quot;] }]]
  }
}
</code></pre><h4 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h4><p>Babel 提供一个<a href="https://babeljs.io/repl/" target="_blank" rel="noopener">REPL 在线编译器</a>，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
<h4 id="与其他工具的配合"><a href="#与其他工具的配合" class="headerlink" title="与其他工具的配合"></a>与其他工具的配合</h4><p>许多工具需要 Babel 进行前置转码，这里举两个例子：ESLint 和 Mocha。</p>
<p>ESLint 用于静态检查代码的语法和风格，安装命令如下。</p>
<pre><code>$ npm install --save-dev eslint babel-eslint
</code></pre><p>然后，在项目根目录下，新建一个配置文件.eslintrc，在其中加入parser字段。</p>
<pre><code>{
  &quot;parser&quot;: &quot;babel-eslint&quot;,
  &quot;rules&quot;: {
    ...
  }
}
</code></pre><p>再在package.json之中，加入相应的scripts脚本。</p>
<pre><code>  {
    &quot;name&quot;: &quot;my-module&quot;,
    &quot;scripts&quot;: {
      &quot;lint&quot;: &quot;eslint my-files.js&quot;
    },
    &quot;devDependencies&quot;: {
      &quot;babel-eslint&quot;: &quot;...&quot;,
      &quot;eslint&quot;: &quot;...&quot;
    }
  }
</code></pre><p>Mocha 则是一个测试框架，如果需要执行使用 ES6 语法的测试脚本，可以修改package.json的scripts.test。</p>
<pre><code>&quot;scripts&quot;: {
  &quot;test&quot;: &quot;mocha --ui qunit --compilers js:babel-core/register&quot;
}
</code></pre><p>上面命令中，–compilers参数指定脚本的转码器，规定后缀名为js的文件，都需要使用babel-core/register先转码。</p>
<h3 id="7-Traceur-转码器"><a href="#7-Traceur-转码器" class="headerlink" title="7.Traceur 转码器"></a>7.Traceur 转码器</h3><p>Google 公司的<a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a>转码器，也可以将 ES6 代码转为 ES5 代码。</p>
<h4 id="直接插入网页"><a href="#直接插入网页" class="headerlink" title="直接插入网页"></a>直接插入网页</h4><p>Traceur 允许将 ES6 代码直接插入网页。首先，必须在网页头部加载 Traceur 库文件。</p>
<pre><code>&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/BrowserSystem.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;module&quot;&gt;
  import &#39;./Greeter.js&#39;;
&lt;/script&gt;
</code></pre><p>上面代码中，一共有 4 个script标签。第一个是加载 Traceur 的库文件，第二个和第三个是将这个库文件用于浏览器环境，第四个则是加载用户脚本，这个脚本里面可以使用 ES6 代码。</p>
<p>注意，第四个script标签的type属性的值是module，而不是text/javascript。这是 Traceur 编译器识别 ES6 代码的标志，编译器会自动将所有type=module的代码编译为 ES5，然后再交给浏览器执行。</p>
<p>除了引用外部 ES6 脚本，也可以直接在网页中放置 ES6 代码。</p>
<pre><code>&lt;script type=&quot;module&quot;&gt;
  class Calc {
    constructor() {
      console.log(&#39;Calc constructor&#39;);
    }
    add(a, b) {
      return a + b;
    }
  }

  var c = new Calc();
  console.log(c.add(4,5));
&lt;/script&gt;
</code></pre><p>正常情况下，上面代码会在控制台打印出9。</p>
<p>如果想对 Traceur 的行为有精确控制，可以采用下面参数配置的写法。</p>
<pre><code>&lt;script&gt;
  // Create the System object
  window.System = new traceur.runtime.BrowserTraceurLoader();
  // Set some experimental options
  var metadata = {
    traceurOptions: {
      experimental: true,
      properTailCalls: true,
      symbols: true,
      arrayComprehension: true,
      asyncFunctions: true,
      asyncGenerators: exponentiation,
      forOn: true,
      generatorComprehension: true
    }
  };
  // Load your module
  System.import(&#39;./myModule.js&#39;, {metadata: metadata}).catch(function(ex) {
    console.error(&#39;Import failed&#39;, ex.stack || ex);
  });
&lt;/script&gt;
</code></pre><p>上面代码中，首先生成 Traceur 的全局对象window.System，然后System.import方法可以用来加载 ES6。加载的时候，需要传入一个配置对象metadata，该对象的traceurOptions属性可以配置支持 ES6 功能。如果设为experimental: true，就表示除了 ES6 以外，还支持一些实验性的新功能。</p>
<h4 id="在线转换-1"><a href="#在线转换-1" class="headerlink" title="在线转换"></a>在线转换</h4><p>Traceur 也提供一个<a href="http://google.github.io/traceur-compiler/demo/repl.html" target="_blank" rel="noopener">在线编译器</a>，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
<p>上面的例子转为 ES5 代码运行，就是下面这个样子。</p>
<pre><code>&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/BrowserSystem.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
$traceurRuntime.ModuleStore.getAnonymousModule(function() {
  &quot;use strict&quot;;

  var Calc = function Calc() {
    console.log(&#39;Calc constructor&#39;);
  };

  ($traceurRuntime.createClass)(Calc, {add: function(a, b) {
    return a + b;
  }}, {});

  var c = new Calc();
  console.log(c.add(4, 5));
  return {};
});
&lt;/script&gt;
</code></pre><h4 id="命令行转换"><a href="#命令行转换" class="headerlink" title="命令行转换"></a>命令行转换</h4><p>作为命令行工具使用时，Traceur 是一个 Node 的模块，首先需要用 npm 安装。</p>
<pre><code>$ npm install -g traceur
</code></pre><p>安装成功后，就可以在命令行下使用 Traceur 了。</p>
<p>Traceur 直接运行 ES6 脚本文件，会在标准输出显示运行结果，以前面的calc.js为例。</p>
<pre><code>$ traceur calc.js
Calc constructor
9
</code></pre><p>如果要将 ES6 脚本转为 ES5 保存，要采用下面的写法。</p>
<pre><code>$ traceur --script calc.es6.js --out calc.es5.js
</code></pre><p>上面代码的–script选项表示指定输入文件，–out选项表示指定输出文件。</p>
<p>为了防止有些特性编译不成功，最好加上–experimental选项。</p>
<pre><code>$ traceur --script calc.es6.js --out calc.es5.js --experimental
</code></pre><p>命令行下转换生成的文件，就可以直接放到浏览器中运行。</p>
<h4 id="Node-环境的用法"><a href="#Node-环境的用法" class="headerlink" title="Node 环境的用法"></a>Node 环境的用法</h4><p>Traceur 的 Node 用法如下（假定已安装traceur模块）。</p>
<pre><code>var traceur = require(&#39;traceur&#39;);
var fs = require(&#39;fs&#39;);

// 将 ES6 脚本转为字符串
var contents = fs.readFileSync(&#39;es6-file.js&#39;).toString();

var result = traceur.compile(contents, {
  filename: &#39;es6-file.js&#39;,
  sourceMap: true,
  // 其他设置
  modules: &#39;commonjs&#39;
});

if (result.error)
  throw result.error;

// result 对象的 js 属性就是转换后的 ES5 代码
fs.writeFileSync(&#39;out.js&#39;, result.js);
// sourceMap 属性对应 map 文件
fs.writeFileSync(&#39;out.js.map&#39;, result.sourceMap);
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.lpldplws.cn/2018/05/11/react/02.Quick_Start/06.Handling_Events/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frankl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frankl's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/react/02.Quick_Start/06.Handling_Events/" itemprop="url">02.Quick Start -- 06.Handling Events</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-11T17:54:05+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-document/" itemprop="url" rel="index">
                    <span itemprop="name">react document</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/11/react/02.Quick_Start/06.Handling_Events/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count fb-comments-count" data-href="www.lpldplws.cn/2018/05/11/react/02.Quick_Start/06.Handling_Events/" itemprop="commentCount">0</span> comments
                </a>
              </span>
            
          

          
          
             <span id="/2018/05/11/react/02.Quick_Start/06.Handling_Events/" class="leancloud_visitors" data-flag-title="02.Quick Start -- 06.Handling Events">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Handling-Events-处理事件"><a href="#Handling-Events-处理事件" class="headerlink" title="Handling Events(处理事件)"></a>Handling Events(处理事件)</h2><p>Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:</p>
<p>用React元素处理事件与在DOM元素上处理事件非常相似。这里有一些语法不同：</p>
<ul>
<li>React events are named using camelCase, rather than lowercase.</li>
<li>With JSX you pass a function as the event handler, rather than a string.</li>
</ul>
<hr>
<ul>
<li>React事件使用驼峰命名法，而不是小写字母命名法。</li>
<li>使用JSX作为您函数事件处理的参数，而不是字符串。</li>
</ul>
<p>For example, the HTML:</p>
<p>例如，HTML：</p>
<pre><code>&lt;button onclick=&quot;activateLasers()&quot;&gt;
  Activate Lasers
&lt;/button&gt;
</code></pre><p>is slightly different in React:</p>
<p>在React中有点不同：</p>
<pre><code>&lt;button onClick={activateLasers}&gt;
  Activate Lasers
&lt;/button&gt;
</code></pre><p>Another difference is that you cannot return false to prevent default behavior in React. You must call preventDefault explicitly. For example, with plain HTML, to prevent the default link behavior of opening a new page, you can write:</p>
<p>另一个不同是您不能返回false来阻止React中的默认事件。您必须明确地调用preventDefault。例如，在HTML代码中，为了阻止默认点击事件，打开一个新的页面的表现，您可以这么写：</p>
<pre><code>&lt;a href=&quot;#&quot; onclick=&quot;console.log(&#39;The link was clicked.&#39;); return false&quot;&gt;
  Click me
&lt;/a&gt;
</code></pre><p>In React, this could instead be:</p>
<p>在React中，应当是这样的：</p>
<pre><code>function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log(&#39;The link was clicked.&#39;);
  }

  return (
    &lt;a href=&quot;#&quot; onClick={handleClick}&gt;
      Click me
    &lt;/a&gt;
  );
}
</code></pre><p>Here, e is a synthetic event. React defines these synthetic events according to the <a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C spec</a>, so you don’t need to worry about cross-browser compatibility. See the <a href="https://reactjs.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent</a> reference guide to learn more.</p>
<p>这里，e代表了一个事件。React根据<a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C</a>规范定义了这些事件，因此您不必担心跨浏览器兼容性。 请参阅<a href="https://reactjs.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent</a>参考指南以了解更多信息。</p>
<p>When using React you should generally not need to call addEventListener to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.</p>
<p>在使用React时，通常不需要调用addEventListener在创建DOM元素后向其添加监听器。相反，只需在元素初始呈现时添加监听器。</p>
<p>When you define a component using an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>, a common pattern is for an event handler to be a method on the class. For example, this Toggle component renders a button that lets the user toggle between “ON” and “OFF” states:</p>
<p>当您使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6的类</a>来定义一个组件时，一个常见的模式是让一个事件处理器成为该类的一个方法。 例如，这个Toggle组件呈现一个按钮，让用户在“ON”和“OFF”状态之间切换：</p>
<pre><code>class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // This binding is necessary to make `this` work in the callback
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState =&gt; ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        {this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;}
      &lt;/button&gt;
    );
  }
}

ReactDOM.render(
  &lt;Toggle /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="http://codepen.io/gaearon/pen/xEmzGg?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>You have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">bound</a> by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called.</p>
<p>您必须在JSX回调中注意这一点的含义。在JavaScript中，类方法默认没有<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">绑定</a>。如果您忘记绑定this.handleClick并将其传递给onClick，则在实际调用该函数时，这将是未定义的。</p>
<p>This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.</p>
<p>这不是React特定的表现; 在JavaScript中它是函数的一部分。一般来说，如果你在它后面引用一个没有()的方法，比如onClick = {this.handleClick}，你就应该绑定该方法。</p>
<p>If calling bind annoys you, there are two ways you can get around this. If you are using the experimental <a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">public class fields syntax</a>, you can use class fields to correctly bind callbacks:</p>
<p>如果调用bind会让你感到困扰，那么有两种方法可以解决这个问题。 如果您使用的是尝试性的<a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">公共类字段语法</a>，则可以使用类字段来正确地绑定回调：</p>
<pre><code>class LoggingButton extends React.Component {
  // This syntax ensures `this` is bound within handleClick.
  // Warning: this is *experimental* syntax.
  handleClick = () =&gt; {
    console.log(&#39;this is:&#39;, this);
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}
</code></pre><p>This syntax is enabled by default in <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>.</p>
<p>这种语法在<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>中是默认启用的。</p>
<p>If you aren’t using class fields syntax, you can use an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow function</a> in the callback:</p>
<p>如果您不使用类字段语法，则可以在回调中使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>：</p>
<pre><code>class LoggingButton extends React.Component {
  handleClick() {
    console.log(&#39;this is:&#39;, this);
  }

  render() {
    // This syntax ensures `this` is bound within handleClick
    return (
      &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}
</code></pre><p>The problem with this syntax is that a different callback is created each time the LoggingButton renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.</p>
<p>这个语法的问题是每次LoggingButton呈现时都会创建一个不同的回调函数。 在大多数情况下，这没有问题。但是，如果将此回调作为参数传递给较低组件，则这些组件可能会重新渲染。我们通常建议在构造函数中绑定或使用类字段语法来避免此类性能问题。</p>
<h3 id="Passing-Arguments-to-Event-Handlers-将参数传递给事件处理程序"><a href="#Passing-Arguments-to-Event-Handlers-将参数传递给事件处理程序" class="headerlink" title="Passing Arguments to Event Handlers(将参数传递给事件处理程序)"></a>Passing Arguments to Event Handlers(将参数传递给事件处理程序)</h3><p>Inside a loop it is common to want to pass an extra parameter to an event handler. For example, if id is the row ID, either of the following would work:</p>
<p>在循环内部，通常需要将一个额外的参数传递给事件处理程序。 例如，如果id是行ID，则以下任一项都可以工作</p>
<pre><code>&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;
&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;
</code></pre><p>The above two lines are equivalent, and use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow functions</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">Function.prototype.bind</a> respectively.</p>
<p>以上两行都是相等的，分别使用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">Function.prototype.bind</a>。</p>
<p>In both cases, the e argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically forwarded.</p>
<p>在这两种情况下，e参数代表了React事件，并将作为ID之后的第二个参数传递。使用箭头函数，我们必须明确地传递它，但是任何额外的参数都会自动绑定起来，并自动转发。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.lpldplws.cn/2018/05/11/react/02.Quick_Start/05.State_and_Lifecycle/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frankl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frankl's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/react/02.Quick_Start/05.State_and_Lifecycle/" itemprop="url">02.Quick Start -- 05.State and Lifecycle</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-11T16:28:01+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-document/" itemprop="url" rel="index">
                    <span itemprop="name">react document</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/11/react/02.Quick_Start/05.State_and_Lifecycle/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count fb-comments-count" data-href="www.lpldplws.cn/2018/05/11/react/02.Quick_Start/05.State_and_Lifecycle/" itemprop="commentCount">0</span> comments
                </a>
              </span>
            
          

          
          
             <span id="/2018/05/11/react/02.Quick_Start/05.State_and_Lifecycle/" class="leancloud_visitors" data-flag-title="02.Quick Start -- 05.State and Lifecycle">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="State-and-Lifecycle"><a href="#State-and-Lifecycle" class="headerlink" title="State and Lifecycle"></a>State and Lifecycle</h2><p>Consider the ticking clock example from <a href="https://reactjs.org/docs/rendering-elements.html#updating-the-rendered-element" target="_blank" rel="noopener">one of the previous sections</a>.</p>
<p>考虑在<a href="https://reactjs.org/docs/rendering-elements.html#updating-the-rendered-element" target="_blank" rel="noopener">前几章节</a>中涉及到的秒钟案例。</p>
<p>So far we have only learned one way to update the UI.</p>
<p>直到现在，我们都只学了一种更新UI的方法。</p>
<p>We call ReactDOM.render() to change the rendered output:</p>
<p>我们会调用ReactDOM.render()来更新渲染输出:</p>
<pre><code>function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
  ReactDOM.render(
    element,
    document.getElementById(&#39;root&#39;)
  );
}

setInterval(tick, 1000);
</code></pre><p><a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>In this section, we will learn how to make the Clock component truly reusable and encapsulated. It will set up its own timer and update itself every second.</p>
<p>这一章节中，我们将学到如何构建一个真正可复用和封装良好的Clock组件。它每秒都会被重新设置并更新其本身。</p>
<p>We can start by encapsulating how the clock looks:</p>
<p>我们可以简单的构建出钟表最开始的样式：</p>
<pre><code>function Clock(props) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
}

function tick() {
  ReactDOM.render(
    &lt;Clock date={new Date()} /&gt;,
    document.getElementById(&#39;root&#39;)
  );
}

setInterval(tick, 1000);
</code></pre><p><a href="http://codepen.io/gaearon/pen/dpdoYR?editors=0010" target="_blank" rel="noopener">Try it on CodePen</a></p>
<p>However, it misses a crucial requirement: the fact that the Clock sets up a timer and updates the UI every second should be an implementation detail of the Clock.</p>
<p>然而，它忘了一个重要的先决条件：事实就是设置一个计时器并每秒都更新UI是Clock本身应该实现的一个细节。</p>
<p>Ideally we want to write this once and have the Clock update itself:</p>
<p>理想情况下，我们只想写一次Clock并由其本身完成更新：</p>
<pre><code>ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>To implement this, we need to add “state” to the Clock component.</p>
<p>为了实现这个目标，我们应该为Clock组件添加“状态”。</p>
<p>State is similar to props, but it is private and fully controlled by the component.</p>
<p>状态和属性相似，但是它是私密的，并且完全由组件控制。</p>
<p>We <a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">mentioned before</a> that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes.</p>
<p>我们<a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">之前提到</a>，当组件被定义为类时会有一些额外的特性。本地状态就是其中一种：一个只对类有效的特性。</p>
<h3 id="Converting-a-Function-to-a-Class-将一个函数转化为类"><a href="#Converting-a-Function-to-a-Class-将一个函数转化为类" class="headerlink" title="Converting a Function to a Class(将一个函数转化为类)"></a>Converting a Function to a Class(将一个函数转化为类)</h3><p>You can convert a functional component like Clock to a class in five steps:</p>
<p>您可以通过以下五步将一个函数组件转化为类：</p>
<ol>
<li>Create an ES6 class, with the same name, that extends React.Component.</li>
<li>Add a single empty method to it called render().</li>
<li>Move the body of the function into the render() method.</li>
<li>Replace props with this.props in the render() body.</li>
<li>Delete the remaining empty function declaration.</li>
</ol>
<hr>
<ol>
<li>创建一个具有相同名字，由React.Component扩展出来的ES6的类。</li>
<li>添加一个单一的空的方法，并由render()调用。</li>
<li>将函数主体移动到render()方法中。</li>
<li>在render()主体内，用this.props取代props。</li>
<li>删除剩余的空的函数声明。</li>
</ol>
<pre><code>class Clock extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p><a href="http://codepen.io/gaearon/pen/zKRGpo?editors=001" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Clock is now defined as a class rather than a function.</p>
<p>Clock现在被定义为一个类而不是函数。</p>
<p>This lets us use additional features such as local state and lifecycle hooks.</p>
<p>这样可以让我们添加一些额外的特性，如本地状态和生命周期钩子。</p>
<h3 id="Adding-Local-State-to-a-Class-向一个类中添加本地状态"><a href="#Adding-Local-State-to-a-Class-向一个类中添加本地状态" class="headerlink" title="Adding Local State to a Class(向一个类中添加本地状态)"></a>Adding Local State to a Class(向一个类中添加本地状态)</h3><p>We will move the date from props to state in three steps:</p>
<p>我们将用三步将时间从属性移动到状态里：</p>
<ol>
<li>Replace this.props.date with this.state.date in the render() method:(在render()方法中用this.state.date取代this.props.date)</li>
</ol>
<pre><code>class Clock extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><ol>
<li>Add a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor" target="_blank" rel="noopener">class constructor</a> that assigns the initial this.state:(添加一个类的构造函数来初始化this.state)</li>
</ol>
<pre><code>class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>Note how we pass props to the base constructor:</p>
<p>注意我们是如何将参数传给基本的构造函数的：</p>
<pre><code> constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }
</code></pre><p>Class components should always call the base constructor with props.</p>
<p>类组件应该永远由带有参数的基本的构造函数来调用。</p>
<ol>
<li>Remove the date prop from the Clock element:(从Clock中移除时间属性)</li>
</ol>
<pre><code>ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>We will later add the timer code back to the component itself.</p>
<p>我们稍后会将计时器组件代码到这个组件本身中。</p>
<p>The result looks like this:</p>
<p>最后的结果大致如下：</p>
<pre><code>class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="http://codepen.io/gaearon/pen/KgQpJd?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Next, we’ll make the Clock set up its own timer and update itself every second.</p>
<p>接下来，我们将为Clock设置它自己的计时器并每秒都更新它。</p>
<h3 id="Adding-Lifecycle-Methods-to-a-Class-为类添加生命周期方法"><a href="#Adding-Lifecycle-Methods-to-a-Class-为类添加生命周期方法" class="headerlink" title="Adding Lifecycle Methods to a Class(为类添加生命周期方法)"></a>Adding Lifecycle Methods to a Class(为类添加生命周期方法)</h3><p>In applications with many components, it’s very important to free up resources taken by the components when they are destroyed.</p>
<p>在具有多个组件的应用程序中在销毁组件时释放所占用的资源是非常重要的。</p>
<p>We want to <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener">set up a timer</a> whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React.</p>
<p>我们想当Clock在被DOM初次渲染时<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener">设置一个计时器</a>，这在React中叫做“挂载”。</p>
<p>We also want to <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval" target="_blank" rel="noopener">clear that timer</a> whenever the DOM produced by the Clock is removed. This is called “unmounting” in React.</p>
<p>我们也想在Clock在被DOM中移除时<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval" target="_blank" rel="noopener">清除计时器</a>。这在React中叫做“解挂”。</p>
<p>We can declare special methods on the component class to run some code when a component mounts and unmounts:</p>
<p>当组件被挂载和解挂时，我们可以在组件类中声明特殊的方法来运行一些代码：</p>
<pre><code>class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {

  }

  componentWillUnmount() {

  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>These methods are called “lifecycle hooks”.</p>
<p>这些方法叫做“生命周期钩子”。</p>
<p>The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer:</p>
<p>componentDidMount()钩子会在组件输出被渲染到DOM后执行。这是一个好的设置计时器的时间点：</p>
<pre><code> componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      1000
    );
  }
</code></pre><p>Note how we save the timer ID right on this.</p>
<p>现在我们在其上设置计时器的ID。</p>
<p>While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that doesn’t participate in the data flow (like a timer ID).</p>
<p>因为this.props由React自己设置，this.state具有特殊含义，但如果您需要存储不参与数据流的内容（例如计时器ID），则需要手动将其他字段添加到类中）。</p>
<p>We will tear down the timer in the componentWillUnmount() lifecycle hook:</p>
<p>我们将会在componentWillUnmount()生命周期钩子中卸载计时器：</p>
<pre><code>componentWillUnmount() {
    clearInterval(this.timerID);
}
</code></pre><p>Finally, we will implement a method called tick() that the Clock component will run every second.</p>
<p>最后，我们将会应用一个叫做tick()的方法让Clock组件每秒都运行。</p>
<p>It will use this.setState() to schedule updates to the component local state:</p>
<p>它会使用this.setState()来设置更新计时器的本地状态：</p>
<pre><code>class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="http://codepen.io/gaearon/pen/amqdNA?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Now the clock ticks every second.</p>
<p>现在，钟表将会每秒都运行。</p>
<p>Let’s quickly recap what’s going on and the order in which the methods are called:</p>
<p>让我们简单回顾一下在这个方法被调用时发生了什么，和它们的次序是什么：</p>
<ol>
<li>When Clock is passed to ReactDOM.render(), React calls the constructor of the Clock component. Since Clock needs to display the current time, it initializes this.state with an object including the current time. We will later update this state.</li>
<li>React then calls the Clock component’s render() method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the Clock’s render output.</li>
<li>When the Clock output is inserted in the DOM, React calls the componentDidMount() lifecycle hook. Inside it, the Clock component asks the browser to set up a timer to call the component’s tick() method once a second.</li>
<li>Every second the browser calls the tick() method. Inside it, the Clock component schedules a UI update by calling setState() with an object containing the current time. Thanks to the setState() call, React knows the state has changed, and calls the render() method again to learn what should be on the screen. This time, this.state.date in the render() method will be different, and so the render output will include the updated time. React updates the DOM accordingly.</li>
<li>If the Clock component is ever removed from the DOM, React calls the componentWillUnmount() lifecycle hook so the timer is stopped.</li>
</ol>
<hr>
<ol>
<li>当Clock传递给ReactDOM.render()时，React调用Clock组件的构造函数。由于Clock需要显示当前时间，因此它会使用包含当前时间的对象初始化this.state。我们稍后将更新这个状态。</li>
<li>然后React调用Clock组件的render()方法。这就是React如何在屏幕上显示对应的内容。然后React更新DOM以匹配时钟的渲染输出。</li>
<li>当时钟输出插入到DOM中时，React调用componentDidMount()生命周期钩子。在它里面，Clock组件要求浏览器设置一个定时器，每秒调用一次该组件的tick（）方法。</li>
<li>浏览器每秒钟都会调用tick()方法。在它里面，Clock组件通过调用setState()和包含当前时间的对象来调度UI更新。因为setState()已经被调用，React知道状态已经改变，并再次调用render()方法在屏幕上显示应有的内容。这一次，render()方法中的this.state.date将会不同，所以渲染的结果包含更新的时间。并且React会相应地更新DOM。</li>
<li>如果Clock组件从DOM中删除，React将调用componentWillUnmount()生命周期钩子，定时器也随之停止。</li>
</ol>
<h3 id="Using-State-Correctly-正确地使用状态"><a href="#Using-State-Correctly-正确地使用状态" class="headerlink" title="Using State Correctly(正确地使用状态)"></a>Using State Correctly(正确地使用状态)</h3><p>There are three things you should know about setState().</p>
<p>您应当知道有关setState()的三个事情。</p>
<h4 id="Do-Not-Modify-State-Directly-不要直接调整状态"><a href="#Do-Not-Modify-State-Directly-不要直接调整状态" class="headerlink" title="Do Not Modify State Directly(不要直接调整状态)"></a>Do Not Modify State Directly(不要直接调整状态)</h4><p>There are three things you should know about setState().</p>
<p>有关setState()，您应当知道三件事情。</p>
<h4 id="Do-Not-Modify-State-Directly-不要直接调整状态-1"><a href="#Do-Not-Modify-State-Directly-不要直接调整状态-1" class="headerlink" title="Do Not Modify State Directly(不要直接调整状态)"></a>Do Not Modify State Directly(不要直接调整状态)</h4><p>For example, this will not re-render a component:</p>
<p>例如，下列代码不会重新渲染组件：</p>
<pre><code>// Wrong
this.state.comment = &#39;Hello&#39;;
</code></pre><p>Instead, use setState():</p>
<p>相反的，您应当使用setState():</p>
<pre><code>// Correct
this.setState({comment: &#39;Hello&#39;});
</code></pre><p>The only place where you can assign this.state is the constructor.</p>
<p>您唯一能设置this.state的地方就是构造函数。</p>
<h4 id="State-Updates-May-Be-Asynchronous-状态更新可能是异步的"><a href="#State-Updates-May-Be-Asynchronous-状态更新可能是异步的" class="headerlink" title="State Updates May Be Asynchronous(状态更新可能是异步的)"></a>State Updates May Be Asynchronous(状态更新可能是异步的)</h4><p>React may batch multiple setState() calls into a single update for performance.</p>
<p>React可能会批量处理多个setState(),以便为单个更新提高性能。</p>
<p>Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.</p>
<p>因为this.props和this.state可能会异步更新，所以不应该依赖它们的值来计算下一个状态。</p>
<p>For example, this code may fail to update the counter:</p>
<p>例如，此代码可能无法更新计数器:</p>
<pre><code>// Wrong
this.setState({
  counter: this.state.counter + this.props.increment,
});
</code></pre><p>To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:</p>
<p>为了修复它，我们可以使用接受函数的setState()而不是一个对象。该函数将接收前一个状态作为第一个参数，并将更新应用时的状态作为第二个参数：</p>
<pre><code>// Correct
this.setState((prevState, props) =&gt; ({
  counter: prevState.counter + props.increment
}));
</code></pre><p>We used an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow function</a> above, but it also works with regular functions:</p>
<p>我们在此使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，但是它也对常规函数起作用：</p>
<pre><code>// Correct
this.setState(function(prevState, props) {
  return {
    counter: prevState.counter + props.increment
  };
});
</code></pre><h4 id="State-Updates-are-Merged-状态更新已合并"><a href="#State-Updates-are-Merged-状态更新已合并" class="headerlink" title="State Updates are Merged(状态更新已合并)"></a>State Updates are Merged(状态更新已合并)</h4><p>When you call setState(), React merges the object you provide into the current state.</p>
<p>当您调用setState()时，React会合并您当前状态下提供的对象。</p>
<p>For example, your state may contain several independent variables:</p>
<p>例如，您的状态可能包含几个相互独立的变量：</p>
<pre><code>constructor(props) {
  super(props);
  this.state = {
  posts: [],
  comments: []
  };
}
</code></pre><p>Then you can update them independently with separate setState() calls:</p>
<p>然后您可以独立地使用setState()调用来更新它们：</p>
<pre><code>componentDidMount() {
    fetchPosts().then(response =&gt; {
      this.setState({
        posts: response.posts
      });
    });

    fetchComments().then(response =&gt; {
      this.setState({
        comments: response.comments
      });
    });
  }
</code></pre><p>The merging is shallow, so this.setState({comments}) leaves this.state.posts intact, but completely replaces this.state.comments.</p>
<p>合并是浅层的，所以this.setState({comments})会完整保留this.state.posts，但完全取代了this.state.comments。</p>
<h3 id="The-Data-Flows-Down-数据流失向下的"><a href="#The-Data-Flows-Down-数据流失向下的" class="headerlink" title="The Data Flows Down(数据流失向下的)"></a>The Data Flows Down(数据流失向下的)</h3><p>Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care whether it is defined as a function or a class.</p>
<p>父组件和孩组件都不知道某个组件是有状态的还是无状态的，并且它们不应该关心它是被定义为一个函数还是一个类。</p>
<p>This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.</p>
<p>这就是为什么状态通常被称作本地的或被封装的。除了包含和设置它的组件之外，其他任何组件都无法访问它。</p>
<p>A component may choose to pass its state down as props to its child components:</p>
<p>组件可以选择将其状态作为参数传递给其子组件：</p>
<pre><code>&lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
</code></pre><p>This also works for user-defined components:</p>
<p>这对用户自定义的组件也有效：</p>
<pre><code>&lt;FormattedDate date={this.state.date} /&gt;
</code></pre><p>The FormattedDate component would receive the date in its props and wouldn’t know whether it came from the Clock’s state, from the Clock’s props, or was typed by hand:</p>
<p>FormattedDate组件应当在它们的属性中接受数据并不会知道它是来自Clock的状态，Clock的属性还是人为输入的。</p>
<pre><code>function FormattedDate(props) {
  return &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;;
}
</code></pre><p><a href="http://codepen.io/gaearon/pen/zKRqNB?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>This is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components “below” them in the tree.</p>
<p>通常这被称之为“自顶向下”或者“无方向”的数据流。任何状态总是由某个特定组件拥有，并且从该状态派生的任何数据或UI只能影响树中“在其下”的组件。</p>
<p>If you imagine a component tree as a waterfall of props, each component’s state is like an additional water source that joins it at an arbitrary point but also flows down.</p>
<p>如果将组件树想象成参数的瀑布，则每个组件的状态就像是一个额外的水源，它可以在任意点加入它，但也会向下流。</p>
<p>To show that all components are truly isolated, we can create an App component that renders three Clocks:</p>
<p>为了显示所有组件都是真正隔离的，我们可以创建一个呈现三个Clock的App组件：</p>
<pre><code>function App() {
  return (
    &lt;div&gt;
      &lt;Clock /&gt;
      &lt;Clock /&gt;
      &lt;Clock /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="http://codepen.io/gaearon/pen/vXdGmd?editors=0010" target="_blank" rel="noopener">Try it on CondePen.</a></p>
<p>Each Clock sets up its own timer and updates independently.</p>
<p>每个表都会独立地设置它本身的计时器并独立更新。</p>
<p>In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.</p>
<p>在React应用中，无论组件是有状态的还是无状态的，都被视为可能随时间而改变的组件的细节。您可以在有状态组件内使用无状态组件，反之亦然。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.lpldplws.cn/2018/05/11/git/git_problem/01.git_problem/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frankl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frankl's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/11/git/git_problem/01.git_problem/" itemprop="url">git problem -- 1.git&gerrit邮箱不匹配</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-11T14:21:46+08:00">
                2018-05-11
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/git/" itemprop="url" rel="index">
                    <span itemprop="name">git</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/11/git/git_problem/01.git_problem/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count fb-comments-count" data-href="www.lpldplws.cn/2018/05/11/git/git_problem/01.git_problem/" itemprop="commentCount">0</span> comments
                </a>
              </span>
            
          

          
          
             <span id="/2018/05/11/git/git_problem/01.git_problem/" class="leancloud_visitors" data-flag-title="git problem -- 1.git&gerrit邮箱不匹配">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="git-problem-–-git-amp-gerrit邮箱不匹配"><a href="#git-problem-–-git-amp-gerrit邮箱不匹配" class="headerlink" title="git problem – git&amp;gerrit邮箱不匹配"></a>git problem – git&amp;gerrit邮箱不匹配</h2><p>Git邮箱不匹配问题 does not match your user account</p>
<p>在活动比较多，使用分支开发的时候，从远端拉取分支，在完成fetch-&gt;rebase-&gt;修改代码以后，执行gerrit push指令时，提示用户信息不匹配。类似于下图所示：</p>
<p><img src="/images/git/01.git_account.png"></p>
<pre><code>remote: ERROR:  In commit 024c0bd88da87274f956a10dfa6b41e8c69ebd04
remote: ERROR:  author email address xxxxx@xx.com
remote: ERROR:  does not match your user account.
</code></pre><p>此问题解决方法：（不仅仅限于分支，master分支出现类似问题也可以用此方法）</p>
<pre><code>(1)git  config user.email (email地址)
(2)git checkout -b another_branch（如果已经被占，随便再换一个）
(3)git branch -D pre_branch(删除出现问题的分支)
(4)git checkout --track origin/pre_branch
(5)git push origin/pre_branch:refs/for/pre_branch  此时原先出现问题的分支就可以push成功了
</code></pre>
          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.lpldplws.cn/2018/05/08/react/02.Quick_Start/04.Components_and_Props/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frankl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frankl's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/08/react/02.Quick_Start/04.Components_and_Props/" itemprop="url">02.Quick Start -- 04.Components and Props</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-08T16:39:57+08:00">
                2018-05-08
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-document/" itemprop="url" rel="index">
                    <span itemprop="name">react document</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/08/react/02.Quick_Start/04.Components_and_Props/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count fb-comments-count" data-href="www.lpldplws.cn/2018/05/08/react/02.Quick_Start/04.Components_and_Props/" itemprop="commentCount">0</span> comments
                </a>
              </span>
            
          

          
          
             <span id="/2018/05/08/react/02.Quick_Start/04.Components_and_Props/" class="leancloud_visitors" data-flag-title="02.Quick Start -- 04.Components and Props">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Components-and-Props"><a href="#Components-and-Props" class="headerlink" title="Components and Props"></a>Components and Props</h2><p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.</p>
<p>组件可以让您将用户界面分成独立的，可重复使用的部分，并且每一部分都相互独立。</p>
<p>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.</p>
<p>从概念上讲，组件就像JavaScript的函数一样。他可以接受任意值的输入（我们通常称之为“参数”）并返回显示在屏幕上的React元素。</p>
<h3 id="Functional-and-Class-Components-函数和类组件"><a href="#Functional-and-Class-Components-函数和类组件" class="headerlink" title="Functional and Class Components(函数和类组件)"></a>Functional and Class Components(函数和类组件)</h3><p>The simplest way to define a component is to write a JavaScript function:</p>
<p>定义一个组件最简单的方法是写一个JavaScript函数：</p>
<pre><code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}
</code></pre><p>This function is a valid React component because it accepts a single “props” (which stands for properties) object argument with data and returns a React element. We call such components “functional” because they are literally JavaScript functions.</p>
<p>这个函数是一个有效的React组件，因为它可以接受一个带有数据的单一的“参数”（通常代表着属性）对象并返回一个React元素。我们称这样的组件是“函数化”的，因为它们都是JavaScript字面上的方法。</p>
<p>You can also use an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a> to define a component:</p>
<p>您也可以使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>来定义一个组件：</p>
<pre><code>class Welcome extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}
</code></pre><p>The above two components are equivalent from React’s point of view.</p>
<p>以上两种组件对于React来说是等价的。</p>
<p>Classes have some additional features that we will discuss in the <a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">next sections</a>. Until then, we will use functional components for their conciseness.</p>
<p>类通常有一些额外的特性，我们会在<a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一章节</a>讨论这些内容。在此之前，我们将会使用更为简洁的函数组件。</p>
<h3 id="Rendering-a-Component-渲染一个组件"><a href="#Rendering-a-Component-渲染一个组件" class="headerlink" title="Rendering a Component(渲染一个组件)"></a>Rendering a Component(渲染一个组件)</h3><p>Previously, we only encountered React elements that represent DOM tags:</p>
<p>在此之前，我们仅仅遇到过使用DOM标签表示的React元素：</p>
<pre><code>const element = &lt;div /&gt;;
</code></pre><p>However, elements can also represent user-defined components:</p>
<p>然而，元素也可以代表用户自定义的组件：</p>
<pre><code>const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;
</code></pre><p>When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object “props”.</p>
<p>当React遇到一个用户自定义的组件时，他就会传递JSX属性作为单一的对象给它们的组件。我们称之为对象的“属性”。</p>
<p>For example, this code renders “Hello, Sara” on the page:</p>
<p>例如，以下代码将会把“Hello, Sara”渲染到页面上：</p>
<pre><code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;
ReactDOM.render(
  element,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/rendering-a-component" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Let’s recap what happens in this example:</p>
<p>让我们回顾一下上述代码发生了什么：</p>
<ol>
<li>We call <code>ReactDOM.render()</code> with the <code><welcome name="Sara"></welcome></code> element.</li>
<li>React calls the <code>Welcome</code> component with <code>{name: ‘Sara’}</code> as the props.</li>
<li>Our <code>Welcome</code> component returns a <code>Hello, Sara</code> element as the result.</li>
<li>React DOM efficiently updates the DOM to match <code>Hello, Sara</code>.</li>
</ol>
<hr>
<ol>
<li>我们对<code><welcome name="Sara"></welcome></code>元素调用了<code>ReactDOM.render()</code>。</li>
<li>React调用了<code>Welcome</code>组件，并将<code>{name: ‘Sara’}</code>作为参数。</li>
<li>我们的<code>Welcome</code>返回一个<code>Hello, Sara</code>元素作为结果。</li>
<li>React DOM会很快更新DOM，并显示<code>Hello, Sara</code>。</li>
</ol>
<blockquote>
<p>Note: Always start component names with a capital letter.<br>React treats components starting with lowercase letters as DOM tags. For example, <code>div</code> represents an HTML div tag, but <code>Welcome</code> represents a component and requires Welcome to be in scope.<br>You can read more about the reasoning behind this convention <a href="https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized" target="_blank" rel="noopener">here</a>.</p>
</blockquote>
<hr>
<blockquote>
<p>注意：通常一个组件的命名是以大写字母开始的。<br>React会将以小写字母开头的组件视为DOM标签。例如，<code>div</code>表示一个HTML div标签，但<code>Welcome</code>表示一个组件，并且要求Welcome在作用域内。<br>您可以在<a href="https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized" target="_blank" rel="noopener">这里</a>阅读更多关于背后的内容。</p>
</blockquote>
<h3 id="Composing-Components-构成组件"><a href="#Composing-Components-构成组件" class="headerlink" title="Composing Components(构成组件)"></a>Composing Components(构成组件)</h3><p>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</p>
<p>组件能在它们的输出中引用其他的组件。这让我们可以对任何有相同内容的细节抽象出相同的部分。例如一个按钮，一个表格，一个对话框，一个屏幕：在React应用程序中，所有这些都通常表示为组件。</p>
<p>For example, we can create an App component that renders Welcome many times:</p>
<p>例如，我们可以创建一个App组件来渲染很多遍Welcome：</p>
<pre><code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

function App() {
  return (
    &lt;div&gt;
      &lt;Welcome name=&quot;Sara&quot; /&gt;
      &lt;Welcome name=&quot;Cahal&quot; /&gt;
      &lt;Welcome name=&quot;Edite&quot; /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/composing-components" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Typically, new React apps have a single <code>App</code> component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like <code>Button</code> and gradually work your way to the top of the view hierarchy.</p>
<p>通常情况下，一个新的React<code>APP</code>会在顶层架构上有单一的应用组件。但是，如果您将React集成到现有的应用程序中，则可以使用<code>Button</code>之类的小组件自下而上地嵌入进去，并逐渐转向视图层次结构的顶部。</p>
<h3 id="Extracting-Components-抽象组件"><a href="#Extracting-Components-抽象组件" class="headerlink" title="Extracting Components(抽象组件)"></a>Extracting Components(抽象组件)</h3><p>Don’t be afraid to split components into smaller components.</p>
<p>永远不要担心将组件分成更小的组件。</p>
<p>For example, consider this <code>Comment</code> component:</p>
<p>观看下列例子，考虑<code>Comment</code>组件：</p>
<pre><code>function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;img className=&quot;Avatar&quot;
          src={props.author.avatarUrl}
          alt={props.author.name}
        /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/extracting-components" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>It accepts author (an object), text (a string), and date (a date) as props, and describes a comment on a social media website.</p>
<p>它会接受用户(一个对象)，文本(一个字符串)，和日期(一个时间)作为参数，并且可以描述一个社交媒体平台上的一个评论。</p>
<p>This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let’s extract a few components from it.</p>
<p>因为有大量的嵌套，这个组件可能会变得很棘手，并且它的单一部分也很难复用。让我们将它抽象成一些小的组件。</p>
<p>First, we will extract Avatar:</p>
<p>首先，我们会抽象出Avatar：</p>
<pre><code>function Avatar(props) {
  return (
    &lt;img className=&quot;Avatar&quot;
      src={props.user.avatarUrl}
      alt={props.user.name}
    /&gt;

  );
}
</code></pre><p>The Avatar doesn’t need to know that it is being rendered inside a Comment. This is why we have given its prop a more generic name: user rather than author.</p>
<p>Avatar不需要知道它是否被渲染在一个评论中。这也是为什么我们可以将它的参数设置为一个更符合的名字：使用user而不是author</p>
<p>We recommend naming props from the component’s own point of view rather than the context in which it is being used.</p>
<p>我们建议从组件自身的角度命名参数而不是从它使用的环境下命名。</p>
<p>We can now simplify Comment a tiny bit:</p>
<p>因此我们可以将评论简化一些：</p>
<pre><code>function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;Avatar user={props.author} /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>Next, we will extract a UserInfo component that renders an Avatar next to the user’s name:</p>
<p>接下来，我们将会将UserInfo组件抽象出来，该组件会将Avatar呈现给旁边的用户的姓名出来：</p>
<pre><code>function UserInfo(props) {
  return (
    &lt;div className=&quot;UserInfo&quot;&gt;
      &lt;Avatar user={props.user} /&gt;
      &lt;div className=&quot;UserInfo-name&quot;&gt;
        {props.user.name}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>This lets us simplify Comment even further:</p>
<p>这样Comment比之前更加简化了。</p>
<pre><code>function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;UserInfo user={props.author} /&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/extracting-components-continued" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be a reusable component.</p>
<p>首先提取组件可能看起来像重复工作，但在更大的应用程序中，我们可以提取出可重用的部分。一个好的经验法则是，如果你的用户界面的一部分被多次使用（按钮，面板，头像），或者它本身已经足够复杂，那么它会是一个好的可重用组件的选择。</p>
<h3 id="Props-are-Read-Only-属性是只读的"><a href="#Props-are-Read-Only-属性是只读的" class="headerlink" title="Props are Read-Only(属性是只读的)"></a>Props are Read-Only(属性是只读的)</h3><p>Whether you declare a component as a function or a class, it must never modify its own props. Consider this sum function:</p>
<p>不管您是否是通过函数或者类来声明组件的，它永远都不能修改属于它自己的参数。考虑下面的加法函数：</p>
<pre><code>function sum(a, b) {
  return a + b;
}
</code></pre><p>Such functions are called <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“pure”</a> because they do not attempt to change their inputs, and always return the same result for the same inputs.</p>
<p>这样的函数是<a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“纯函数”</a>，因为它们不会试图改变它们的输入，并总会对于相同的输入返回相同的值。</p>
<p>In contrast, this function is impure because it changes its own input:</p>
<p>相反的，下面这个函数就是动机不纯的，因为它会改变它本身的输入：</p>
<pre><code>function withdraw(account, amount) {
  account.total -= amount;
}
</code></pre><p>React is pretty flexible but it has a single strict rule:</p>
<p>React十分灵活，但是它有一个特别严格的规定：</p>
<p><strong>All React components must act like pure functions with respect to their props.</strong></p>
<p><strong>所有的React组件都必须表现的想一个纯函数一样，并不会修改它们的属性。</strong></p>
<p>Of course, application UIs are dynamic and change over time. In the <a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">next section</a>, we will introduce a new concept of “state”. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.</p>
<p>当然，应用的UI是动态的，并且会随时间的改变而改变。在<a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一章节</a>中，我们会介绍一个新的概念“状态”。状态允许React组件随着用户的动作，网络的反馈和任何其他事情的来随时改变它们的输出，并且不会违背这个规则。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.lpldplws.cn/2018/05/04/react/02.Quick_Start/03.Rendering_Elements/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frankl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frankl's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/react/02.Quick_Start/03.Rendering_Elements/" itemprop="url">02.Quick Start -- 03.Rendering Elements</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T21:10:32+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-document/" itemprop="url" rel="index">
                    <span itemprop="name">react document</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/04/react/02.Quick_Start/03.Rendering_Elements/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count fb-comments-count" data-href="www.lpldplws.cn/2018/05/04/react/02.Quick_Start/03.Rendering_Elements/" itemprop="commentCount">0</span> comments
                </a>
              </span>
            
          

          
          
             <span id="/2018/05/04/react/02.Quick_Start/03.Rendering_Elements/" class="leancloud_visitors" data-flag-title="02.Quick Start -- 03.Rendering Elements">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Rendering-Elements"><a href="#Rendering-Elements" class="headerlink" title="Rendering Elements"></a>Rendering Elements</h2><p>Elements are the smallest building blocks of React apps.</p>
<p>元素是React 应用中最小的构建组块。</p>
<p>An element describes what you want to see on the screen:</p>
<p>以下是一个描述了您在在屏幕上想看到的元素：</p>
<pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
</code></pre><p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p>
<p>不想浏览器的DOM元素，React元素是普通对象，并且很容易创建。React DOM负责更新DOM以便于匹配React元素。</p>
<blockquote>
<p>Note:<br>One might confuse elements with a more widely known concept of “components”. We will introduce components in the <a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">next section</a>. Elements are what components are “made of”, and we encourage you to read this section before jumping ahead.</p>
<p>注意：<br>人们可能会将元素与更广为人知的“组件”概念混为一谈。 我们将在<a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">下一部分</a>介绍组件。 组件是由元素“组成”的，我们鼓励您在跳过本节之前先阅读本节内容。</p>
</blockquote>
<h3 id="Rendering-an-Element-into-the-DOM-渲染一个在DOM中的元素"><a href="#Rendering-an-Element-into-the-DOM-渲染一个在DOM中的元素" class="headerlink" title="Rendering an Element into the DOM(渲染一个在DOM中的元素)"></a>Rendering an Element into the DOM(渲染一个在DOM中的元素)</h3><p>Let’s say there is a <code><div></div></code> somewhere in your HTML file:</p>
<p>以下是一个在您的HTML文件中的<code><div></div></code></p>
<pre><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre><p>We call this a “root” DOM node because everything inside it will be managed by React DOM.</p>
<p>我们叫它为“root”DOM节点，因为它其中的所有元素都由React DOM控制。</p>
<p>Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.</p>
<p>仅使用React构建的应用程序通常只有单个根DOM节点。如果您将React集成到现有的应用程序中，您可以根据需要选择多个独立的根DOM节点。</p>
<p>To render a React element into a root DOM node, pass both to <code>ReactDOM.render()</code>:</p>
<p>为了将一个React元素渲染到一个根DOM节点，将它们全部传给<code>ReactDOM.render()</code>:</p>
<pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
ReactDOM.render(element, document.getElementById(&#39;root&#39;));
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/rendering-elements/render-an-element" target="_blank" rel="noopener">Try it on CodePen</a></p>
<p>It displays “Hello, world” on the page.</p>
<p>它将会在页面上显示“Hello, world”。</p>
<h3 id="Updating-the-Rendered-Element-更新渲染的元素"><a href="#Updating-the-Rendered-Element-更新渲染的元素" class="headerlink" title="Updating the Rendered Element(更新渲染的元素)"></a>Updating the Rendered Element(更新渲染的元素)</h3><p>React elements are <code>immutable</code>. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</p>
<p>React元素是<code>不可变的</code>。一旦您创建了一个元素，您就不能改变它的子元素或者属性。一个元素就像电影里的一帧：它代表着一个特定时间点的UI。</p>
<p>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to <code>ReactDOM.render()</code>.</p>
<p>以我们目前所有的知识，更新UI的唯一方法就是创建一个新的元素，并将它传给<code>ReactDOM.render()</code>。</p>
<p>Consider this ticking clock example:</p>
<p>考虑以下秒表的例子：</p>
<pre><code>function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
  ReactDOM.render(element, document.getElementById(&#39;root&#39;));
}

setInterval(tick, 1000);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">Try it on CodePen</a></p>
<p>It calls <code>ReactDOM.render()</code> every second from a setInterval() callback.</p>
<p>它会每秒从setInterval()函数的回调函数中调用<code>ReactDOM.render()</code>。</p>
<blockquote>
<p>Note:<br>In practice, most React apps only call <code>ReactDOM.render()</code> once. In the next sections we will learn how such code gets encapsulated into stateful components.<br>We recommend that you don’t skip topics because they build on each other.</p>
<p>注意：<br>在实际使用过程中，大多数的React应用仅仅只调用<code>ReactDOM.render()</code>一次。在接下来的部分中，我们将学习如何将这些代码封装到有状态的组件中。<br>我们建议您不要跳过这些内容，因为它们互相之间都有联系。</p>
</blockquote>
<h3 id="React-Only-Updates-What’s-Necessary-React只有在必须的时候才会更新"><a href="#React-Only-Updates-What’s-Necessary-React只有在必须的时候才会更新" class="headerlink" title="React Only Updates What’s Necessary(React只有在必须的时候才会更新)"></a>React Only Updates What’s Necessary(React只有在必须的时候才会更新)</h3><p>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</p>
<p>React DOM 会将元素和它的子元素与上一个状态的元素和子元素比较，并且只在DOM必须更新的时候才会让DOM变化到期待的状态。</p>
<p>You can verify by inspecting the <a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">last example</a> with the browser tools:</p>
<p>您可以通过浏览器工具监视<a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">最后一个例子</a>。</p>
<p><img src="/images/react_document/02-03-ticking_click.gif"></p>
<p>Even though we create an element describing the whole UI tree on every tick, only the text node whose contents has changed gets updated by React DOM.</p>
<p>尽管我们创建了一个元素来描述在每秒钟的整个结构，但是只有内容改变的文本节点会被React DOM更新。</p>
<p>In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.</p>
<p>根据我们的经验，思考如何在任何特定时刻看到UI，而不是随着时间的推移如何改变，从而消除了一整类错误。根据我们的经验，考率如何在任何特定时刻看到特定的样式，而不是随着时间的推移而变化，只有这样做才能消除了一系列相关的错误。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.lpldplws.cn/2018/05/04/react/02.Quick_Start/02.Introducing_JSX/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frankl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frankl's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/react/02.Quick_Start/02.Introducing_JSX/" itemprop="url">02.Quick Start -- 02.Introducing JSX</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T16:18:32+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-document/" itemprop="url" rel="index">
                    <span itemprop="name">react document</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/04/react/02.Quick_Start/02.Introducing_JSX/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count fb-comments-count" data-href="www.lpldplws.cn/2018/05/04/react/02.Quick_Start/02.Introducing_JSX/" itemprop="commentCount">0</span> comments
                </a>
              </span>
            
          

          
          
             <span id="/2018/05/04/react/02.Quick_Start/02.Introducing_JSX/" class="leancloud_visitors" data-flag-title="02.Quick Start -- 02.Introducing JSX">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Introducing-JSX"><a href="#Introducing-JSX" class="headerlink" title="Introducing JSX"></a>Introducing JSX</h2><p>Consider this variable declaration:</p>
<p>考虑以下变量声明：</p>
<pre><code>const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
</code></pre><p>This funny tag syntax is neither a string nor HTML.</p>
<p>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</p>
<p>它叫做JSX，并且它是基于JavaScript的语法进行扩展的。我们建议是在React中使用它来描述UI的样式。JSX也许让您想起一些模板语言，但是它具有JavaScript的全部功能。</p>
<p>JSX produces React “elements”. We will explore rendering them to the DOM in the <a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener">next section</a>. Below, you can find the basics of JSX necessary to get you started.</p>
<p>JSX生成了React“元素”。我们将在<a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener">下一章节</a>内探索它是如果将React渲染到DOM上的。除此之外，您还可以学习到使用JSX的基本知识。</p>
<h3 id="Why-JSX-为什么使用JSX"><a href="#Why-JSX-为什么使用JSX" class="headerlink" title="Why JSX?(为什么使用JSX?)"></a>Why JSX?(为什么使用JSX?)</h3><p>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.</p>
<p>React认为渲染逻辑与其他UI逻辑是有耦合的：事件如何处理，状态如何随时间变化以及数据如何准备显示。</p>
<p>Instead of artificially separating technologies by putting markup and logic in separate files, React <a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">separates concerns</a> with loosely coupled units called “components” that contain both. We will come back to components in a <a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">further section</a>, but if you’re not yet comfortable putting markup in JS, <a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank" rel="noopener">this talk</a> might convince you otherwise.</p>
<p>React不再人为地通过将标记和逻辑放在单独的文件中来分离技术，React通过将问题与“组件”–一个松散耦合的单元<a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">分隔开</a>。我们将在<a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">接下来的章节内</a>回到组件中，但如果你不习惯在JS中添加标记，那么<a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank" rel="noopener">这个话题</a>可能会让你习惯这个改变。</p>
<p>React <a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">doesn’t require</a> using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.</p>
<p>React<a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">不需要</a>使用JSX，但是大多数人认为在JavaScript代码中使用它时，有助于从视觉上更清晰地理解代码。它还允许React显示更多有用的错误和警告消息。</p>
<p>With that out of the way, let’s get started!</p>
<p>那就这样，让我们开始吧！</p>
<h3 id="Embedding-Expressions-in-JSX-在JSX中嵌入表达式"><a href="#Embedding-Expressions-in-JSX-在JSX中嵌入表达式" class="headerlink" title="Embedding Expressions in JSX(在JSX中嵌入表达式)"></a>Embedding Expressions in JSX(在JSX中嵌入表达式)</h3><p>You can embed any <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript expression</a> in JSX by wrapping it in curly braces.</p>
<p>您可以用大括号在JSX中包括任何<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript表达式</a>。</p>
<p>For example, <code>2 + 2</code>, <code>user.firstName</code>, and <code>formatName(user)</code> are all valid expressions:</p>
<p>例如，<code>2 + 2</code>, <code>user.firstName</code>, and <code>formatName(user)</code>都是有效的表达式：</p>
<pre><code>function formatName(user) {
  return user.firstName + &#39; &#39; + user.lastName;
}

const user = {
  firstName: &#39;Harper&#39;,
  lastName: &#39;Perez&#39;
};

const element = (
  &lt;h1&gt;
    Hello, {formatName(user)}!
  &lt;/h1&gt;
);

ReactDOM.render(
  element,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/introducing-jsx" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>We split JSX over multiple lines for readability. While it isn’t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of <a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">automatic semicolon insertion</a>.</p>
<p>为了便于阅读，我们将JSX分成多行。虽然这不是必需的，但是我们还建议将其包装在括号内以避免<a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">自动分号插入</a>的缺陷。</p>
<h3 id="JSX-is-an-Expression-Too-JSX也是一个表达式"><a href="#JSX-is-an-Expression-Too-JSX也是一个表达式" class="headerlink" title="JSX is an Expression Too(JSX也是一个表达式)"></a>JSX is an Expression Too(JSX也是一个表达式)</h3><p>After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects.</p>
<p>在编译完后，JSX表达式会变成常规的JavaScript方法的调用，并且会转为JavaScript对象。</p>
<p>This means that you can use JSX inside of <code>if</code> statements and <code>for</code> loops, assign it to variables, accept it as arguments, and return it from functions:</p>
<p>这意味着您可以在if语句和for循环中使用JSX，将其分配给变量，将其作为参数接受，并从函数中返回：</p>
<pre><code>function getGreeting(user) {
  if (user) {
    return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;
  }
  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;
}
</code></pre><h3 id="Specifying-Attributes-with-JSX-使用JSX指定属性"><a href="#Specifying-Attributes-with-JSX-使用JSX指定属性" class="headerlink" title="Specifying Attributes with JSX(使用JSX指定属性)"></a>Specifying Attributes with JSX(使用JSX指定属性)</h3><p>You may use quotes to specify string literals as attributes:</p>
<p>您可以使用引号将字符串文字指定为属性：</p>
<pre><code>const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;
</code></pre><p>You may also use curly braces to embed a JavaScript expression in an attribute:</p>
<p>您也可以使用大括号包裹JavaScript表达式作为属性：</p>
<pre><code>const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;
</code></pre><p>Don’t put quotes around curly braces when embedding a JavaScript expression in an attribute. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.</p>
<p>当将JavaScript表达式作为属性时，不要在大括号外边加引号。您应该要么使用引号（对于字符串的值来说）或者大括号（对于表达式来说）,但是不能两者一起使用。</p>
<blockquote>
<p>Warning:<br>Since JSX is closer to JavaScript than to HTML, React DOM uses camelCase property naming convention instead of HTML attribute names.<br>For example, class becomes className in JSX, and tabindex becomes tabIndex.</p>
<p>警告：<br>因为JSX相对于HTML来说更接近于JavaScript，React Dom使用传统的驼峰命名方法来命名，而不是像HTML属性一样命名。<br>例如，在JSX中，class应该是className，tabindex应该是tabIndex</p>
</blockquote>
<h3 id="Specifying-Children-with-JSX-用JSX指定子元素"><a href="#Specifying-Children-with-JSX-用JSX指定子元素" class="headerlink" title="Specifying Children with JSX(用JSX指定子元素)"></a>Specifying Children with JSX(用JSX指定子元素)</h3><p>If a tag is empty, you may close it immediately with <code>/&gt;</code>, like XML:</p>
<p>如果一个标签是空的，您应该立即使用<code>/&gt;</code>的方式关闭它，像XML一样：</p>
<pre><code>const element = &lt;img src={user.avatarUrl} /&gt;;
</code></pre><p>JSX tags may contain children:</p>
<p>JSX标签可以包含子元素：</p>
<pre><code>const element = (
  &lt;div&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;h2&gt;Good to see you here.&lt;/h2&gt;
  &lt;/div&gt;
);
</code></pre><h3 id="JSX-Prevents-Injection-Attacks-JSX可以防止注入攻击"><a href="#JSX-Prevents-Injection-Attacks-JSX可以防止注入攻击" class="headerlink" title="JSX Prevents Injection Attacks(JSX可以防止注入攻击)"></a>JSX Prevents Injection Attacks(JSX可以防止注入攻击)</h3><p>It is safe to embed user input in JSX:</p>
<p>将用户输入置于JSX中是安全的：</p>
<pre><code>const title = response.potentiallyMaliciousInput;
// This is safe:
const element = &lt;h1&gt;{title}&lt;/h1&gt;;
</code></pre><p>By default, React DOM <a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">escapes</a> any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS (cross-site-scripting)</a> attacks.</p>
<p>默认情况下，React DOM在渲染之前会<a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">转义</a>嵌入在JSX中的任何值。因此它确保您永远不会注入任何未明确的写入应用程序中的内容。在呈现之前，所有内容都会转换为字符串。这有助于防止<a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS(跨站点脚本)</a>攻击。</p>
<h3 id="JSX-Represents-Objects-JSX表示对象"><a href="#JSX-Represents-Objects-JSX表示对象" class="headerlink" title="JSX Represents Objects(JSX表示对象)"></a>JSX Represents Objects(JSX表示对象)</h3><p>Babel compiles JSX down to <code>React.createElement()</code> calls.</p>
<p>Babel会将JSX编译成<code>React.createElement()</code>的调用。</p>
<p>These two examples are identical:</p>
<p>以下两个例子是一样的：</p>
<pre><code>const element = (
  &lt;h1 className=&quot;greeting&quot;&gt;
    Hello, world!
  &lt;/h1&gt;
);
</code></pre><pre><code>const element = React.createElement(
  &#39;h1&#39;,
  {className: &#39;greeting&#39;},
  &#39;Hello, world!&#39;
);
</code></pre><p><code>React.createElement()</code> performs a few checks to help you write bug-free code but essentially it creates an object like this:</p>
<p><code>React.createElement()</code>会执行一些检查来帮助您编写无错代码，但本质上它会创建一个如下所示的对象：</p>
<pre><code>// Note: this structure is simplified
const element = {
  type: &#39;h1&#39;,
  props: {
    className: &#39;greeting&#39;,
    children: &#39;Hello, world!&#39;
  }
};
</code></pre><p>These objects are called “React elements”. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.</p>
<p>这些对象被称为“React元素”。你可以把它们想象成你想要在屏幕上看到的东西。React会读取这些对象并使用它们来构建DOM并使其保持最新状态。</p>
<p>We will explore rendering React elements to the DOM in the next section.</p>
<p>我们将会在下一章里探索如何在DOM中渲染React元素。</p>
<blockquote>
<p>Tip:<br>We recommend using the <a href="http://babeljs.io/docs/editors" target="_blank" rel="noopener">“Babel” language definition</a> for your editor of choice so that both ES6 and JSX code is properly highlighted. This website uses the <a href="https://labs.voronianski.com/oceanic-next-color-scheme/" target="_blank" rel="noopener">Oceanic Next</a> color scheme which is compatible with it.<br>提示：<br>我们将以使用<a href="http://babeljs.io/docs/editors" target="_blank" rel="noopener">“Babel”语言定义</a>作为您的编译器，以便正确突出显示ES6和JSX代码。本网站采用与其兼容的Oceanic Next色彩方案。</p>
</blockquote>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal" itemscope itemtype="http://schema.org/Article">
  
  
  
  <div class="post-block">
    <link itemprop="mainEntityOfPage" href="www.lpldplws.cn/2018/05/04/react/02.Quick_Start/01.Hello_World/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="Frankl">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/cat.jpg">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="Frankl's Personal Blog">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2018/05/04/react/02.Quick_Start/01.Hello_World/" itemprop="url">02.Quick Start -- 01.Hello World</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">Veröffentlicht am</span>
              
              <time title="Post created" itemprop="dateCreated datePublished" datetime="2018-05-04T15:55:32+08:00">
                2018-05-04
              </time>
            

            

            
          </span>

          
            <span class="post-category" >
            
              <span class="post-meta-divider">|</span>
            
              <span class="post-meta-item-icon">
                <i class="fa fa-folder-o"></i>
              </span>
              
                <span class="post-meta-item-text">in</span>
              
              
                <span itemprop="about" itemscope itemtype="http://schema.org/Thing">
                  <a href="/categories/react-document/" itemprop="url" rel="index">
                    <span itemprop="name">react document</span>
                  </a>
                </span>

                
                
              
            </span>
          

          
            
              <span class="post-comments-count">
                <span class="post-meta-divider">|</span>
                <span class="post-meta-item-icon">
                  <i class="fa fa-comment-o"></i>
                </span>
                <a href="/2018/05/04/react/02.Quick_Start/01.Hello_World/#comments" itemprop="discussionUrl">
                  <span class="post-comments-count fb-comments-count" data-href="www.lpldplws.cn/2018/05/04/react/02.Quick_Start/01.Hello_World/" itemprop="commentCount">0</span> comments
                </a>
              </span>
            
          

          
          
             <span id="/2018/05/04/react/02.Quick_Start/01.Hello_World/" class="leancloud_visitors" data-flag-title="02.Quick Start -- 01.Hello World">
               <span class="post-meta-divider">|</span>
               <span class="post-meta-item-icon">
                 <i class="fa fa-eye"></i>
               </span>
               
                 <span class="post-meta-item-text">Visitors&#58;</span>
               
                 <span class="leancloud-visitors-count"></span>
             </span>
          

          

          

          

        </div>
      </header>
    

    
    
    
    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h4>The easiest way to get started with React is to use <a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">this Hello World example code on CodePen</a>. You don’t need to install anything; you can just open it in another tab and follow along as we go through examples. If you’d rather use a local development environment, check out the <a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">Installation</a> section.</h4>

<h4>开始学习React最简单的方式是使用<a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">Codepen上的Hello World的例子</a>。您不必安装任何东西；您只需要在另一个窗口打开就能查看我们写下的例子。如果您想在本地搭建环境，请查看<a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">安装</a>章节。</h4>

<hr>
<p>The smallest React example looks like this:</p>
<p>最小的React例子像这个样子：</p>
<pre><code>ReactDOM.render(
  &lt;h1&gt;Hello, world!&lt;/h1&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>It renders a heading saying “Hello, world!” on the page.</p>
<p>它将会在页面上渲染一个写着“Hello World”的标题。</p>
<p>The next few sections will gradually introduce you to using React. We will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.</p>
<p>接下来的章节将会逐渐向您介绍如何使用React。我们将检查React应用程序的构建部分：元素和组件。一旦您掌握了它们，您就可以通过小型可重复使用的部分创建复杂的应用程序。</p>
<h3 id="A-Note-on-JavaScript-一个关于JavaScript的注意点"><a href="#A-Note-on-JavaScript-一个关于JavaScript的注意点" class="headerlink" title="A Note on JavaScript(一个关于JavaScript的注意点)"></a>A Note on JavaScript(一个关于JavaScript的注意点)</h3><p>React is a JavaScript library, and so we’ll assume you have a basic understanding of the JavaScript language. If you don’t feel very confident, we recommend <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">refreshing your JavaScript knowledge</a> so you can follow along more easily.</p>
<p>React是一个JavaScript库，因此我们假设您对于JavaScript语言有一个基本的了解。如果您不是很自信，我们建议您<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">重新回顾JavaScript的相关知识</a>，以便能让您在接下来的内容上更容易。</p>
<p>We also use some of the ES6 syntax in the examples. We try to use it sparingly because it’s still relatively new, but we encourage you to get familiar with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow functions</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">classes</a>, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">template literals</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">let</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener">const</a> statements. You can use the <a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA" target="_blank" rel="noopener">Babel REPL</a> to check what ES6 code compiles to.</p>
<p>我们在案例中也使用了一些ES6的语法。我们尽量少的使用它们，因为它们还相对较新，但是我们还是建议您熟悉<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">类</a>，<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">模板字面量</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">let</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener">const</a>等概念。您可以使用<a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA" target="_blank" rel="noopener">Babel REPL</a>来查看ES6代码编译过后的结果。</p>

          
        
      
    </div>
    
    
    

    

    

    

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </div>
  
  
  
  </article>


    
  </section>

  
  <nav class="pagination">
    <a class="extend prev" rel="prev" href="/"><i class="fa fa-angle-left"></i></a><a class="page-number" href="/">1</a><span class="page-number current">2</span><a class="page-number" href="/page/3/">3</a><span class="space">&hellip;</span><a class="page-number" href="/page/6/">6</a><a class="extend next" rel="next" href="/page/3/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    
    <div class="sidebar-inner">

      

      

      <section class="site-overview-wrap sidebar-panel sidebar-panel-active">
        <div class="site-overview">
          <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
            
              <img class="site-author-image" itemprop="image"
                src="/images/cat.jpg"
                alt="Frankl" />
            
              <p class="site-author-name" itemprop="name">Frankl</p>
              <p class="site-description motion-element" itemprop="description">Base on front-end, more than front-end</p>
          </div>

          <nav class="site-state motion-element">

            
              <div class="site-state-item site-state-posts">
              
                <a href="/archives">
              
                  <span class="site-state-item-count">53</span>
                  <span class="site-state-item-name">Artikel</span>
                </a>
              </div>
            

            
              
              
              <div class="site-state-item site-state-categories">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">Kategorien</span>
                
              </div>
            

            
              
              
              <div class="site-state-item site-state-tags">
                
                  <span class="site-state-item-count">5</span>
                  <span class="site-state-item-name">Tags</span>
                
              </div>
            

          </nav>

          

          

          
          

          
          

          

        </div>
      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright">&copy; <span itemprop="copyrightYear">2018</span>
  <span class="with-love">
    <i class="fa fa-user"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">Frankl</span>

  
</div>


  <div class="powered-by">Erstellt mit  <a class="theme-link" target="_blank" href="https://hexo.io">Hexo</a></div>



  <span class="post-meta-divider">|</span>



  <div class="theme-info">Theme &mdash; <a class="theme-link" target="_blank" href="https://github.com/iissnan/hexo-theme-next">NexT.Gemini</a> v5.1.4</div>




        







        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

    

    
  	    <!-- custom analytics part create by xiamo -->
<script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.1.js"></script>
<script>AV.initialize("aUG4vd9Krriqy647ANRoSSer-gzGzoHsz", "kdMloa4KY0uLCvse71kG5F7x");</script>
<script>
function showTime(Counter) {
	var query = new AV.Query(Counter);
	$(".leancloud_visitors").each(function() {
		var url = $(this).attr("id").trim();
		query.equalTo("url", url);
		query.find({
			success: function(results) {
				if (results.length == 0) {
					var content = $(document.getElementById(url)).text() + ': 0';
					$(document.getElementById(url)).text(content);
					return;
				}
				for (var i = 0; i < results.length; i++) {
					var object = results[i];
					var content = $(document.getElementById(url)).text() + ': ' + object.get('time');
					$(document.getElementById(url)).text(content);
				}
			},
			error: function(object, error) {
				console.log("Error: " + error.code + " " + error.message);
			}
		});

	});
}

function addCount(Counter) {
	var Counter = AV.Object.extend("Counter");
	url = $(".leancloud_visitors").attr('id').trim();
	title = $(".leancloud_visitors").attr('data-flag-title').trim();
	var query = new AV.Query(Counter);
	query.equalTo("url", url);
	query.find({
		success: function(results) {
			if (results.length > 0) {
				var counter = results[0];
				counter.fetchWhenSave(true);
				counter.increment("time");
				counter.save(null, {
					success: function(counter) {
						var content = $(document.getElementById(url)).text() + ': ' + counter.get('time');
						$(document.getElementById(url)).text(content);
					},
					error: function(counter, error) {
						console.log('Failed to save Visitor num, with error message: ' + error.message);
					}
				});
			} else {
				var newcounter = new Counter();
				newcounter.set("title", title);
				newcounter.set("url", url);
				newcounter.set("time", 1);
				newcounter.save(null, {
					success: function(newcounter) {
					    console.log("newcounter.get('time')="+newcounter.get('time'));
						var content = $(document.getElementById(url)).text() + ': ' + newcounter.get('time');
						$(document.getElementById(url)).text(content);
					},
					error: function(newcounter, error) {
						console.log('Failed to create');
					}
				});
			}
		},
		error: function(error) {
			console.log('Error:' + error.code + " " + error.message);
		}
	});
}
$(function() {
	var Counter = AV.Object.extend("Counter");
	if ($('.leancloud_visitors').length == 1) {
		addCount(Counter);
	} else if ($('.post-title-link').length > 1) {
		showTime(Counter);
	}
});
</script>

      
    
  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  
    <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>
  

  
  
    <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>
  

  
  
    <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>
  

  
  
    <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>
  


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.4"></script>



  
  


  <script type="text/javascript" src="/js/src/affix.js?v=5.1.4"></script>

  <script type="text/javascript" src="/js/src/schemes/pisces.js?v=5.1.4"></script>



  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.4"></script>



  


  

    
      <script id="dsq-count-scr" src="https://lpldplws.disqus.com/count.js" async></script>
    

    

  




	





  














  





  

  
  <script src="https://cdn1.lncld.net/static/js/av-core-mini-0.6.4.js"></script>
  <script>AV.initialize("aUG4vd9Krriqy647ANRoSSer-gzGzoHsz", "kdMloa4KY0uLCvse71kG5F7x");</script>
  <script>
    function showTime(Counter) {
      var query = new AV.Query(Counter);
      var entries = [];
      var $visitors = $(".leancloud_visitors");

      $visitors.each(function () {
        entries.push( $(this).attr("id").trim() );
      });

      query.containedIn('url', entries);
      query.find()
        .done(function (results) {
          var COUNT_CONTAINER_REF = '.leancloud-visitors-count';

          if (results.length === 0) {
            $visitors.find(COUNT_CONTAINER_REF).text(0);
            return;
          }

          for (var i = 0; i < results.length; i++) {
            var item = results[i];
            var url = item.get('url');
            var time = item.get('time');
            var element = document.getElementById(url);

            $(element).find(COUNT_CONTAINER_REF).text(time);
          }
          for(var i = 0; i < entries.length; i++) {
            var url = entries[i];
            var element = document.getElementById(url);
            var countSpan = $(element).find(COUNT_CONTAINER_REF);
            if( countSpan.text() == '') {
              countSpan.text(0);
            }
          }
        })
        .fail(function (object, error) {
          console.log("Error: " + error.code + " " + error.message);
        });
    }

    function addCount(Counter) {
      var $visitors = $(".leancloud_visitors");
      var url = $visitors.attr('id').trim();
      var title = $visitors.attr('data-flag-title').trim();
      var query = new AV.Query(Counter);

      query.equalTo("url", url);
      query.find({
        success: function(results) {
          if (results.length > 0) {
            var counter = results[0];
            counter.fetchWhenSave(true);
            counter.increment("time");
            counter.save(null, {
              success: function(counter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(counter.get('time'));
              },
              error: function(counter, error) {
                console.log('Failed to save Visitor num, with error message: ' + error.message);
              }
            });
          } else {
            var newcounter = new Counter();
            /* Set ACL */
            var acl = new AV.ACL();
            acl.setPublicReadAccess(true);
            acl.setPublicWriteAccess(true);
            newcounter.setACL(acl);
            /* End Set ACL */
            newcounter.set("title", title);
            newcounter.set("url", url);
            newcounter.set("time", 1);
            newcounter.save(null, {
              success: function(newcounter) {
                var $element = $(document.getElementById(url));
                $element.find('.leancloud-visitors-count').text(newcounter.get('time'));
              },
              error: function(newcounter, error) {
                console.log('Failed to create');
              }
            });
          }
        },
        error: function(error) {
          console.log('Error:' + error.code + " " + error.message);
        }
      });
    }

    $(function() {
      var Counter = AV.Object.extend("Counter");
      if ($('.leancloud_visitors').length == 1) {
        addCount(Counter);
      } else if ($('.post-title-link').length > 1) {
        showTime(Counter);
      }
    });
  </script>



  

  

  
  

  

  

  

</body>
</html>
