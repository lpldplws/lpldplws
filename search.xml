<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[2.5~2.9所遇问题]]></title>
      <url>/2018/02/09/blog/2.5~2.9_questions/</url>
      <content type="html"><![CDATA[<h2 id="2-5-2-9所遇问题"><a href="#2-5-2-9所遇问题" class="headerlink" title="2.5~2.9所遇问题"></a>2.5~2.9所遇问题</h2><h3 id="一-开发所遇问题"><a href="#一-开发所遇问题" class="headerlink" title="一.开发所遇问题"></a>一.开发所遇问题</h3><p>在这次开发过程中，是真正自己做的第一个迭代版本，在开发中主要遇到的问题有：从理清思路到代码的实现；代码的格式规范与模块化；如何与后台人员沟通好。</p>
<ol>
<li>从理清思路到代码的实现</li>
</ol>
<p>这部分内容主要是因为自己以前写的代码只考虑到最后呈现的效果，没有具体深入探讨如何高效的写代码，拿生庆哥的话讲就是：没有真正明白要做什么。这个做什么不仅仅是你要实现的效果是什么，还包括你对整体项目的思路。之前我写代码都是只想到大概有哪些代码块，但是几个代码块传参是什么，怎么传，情况考虑全不全，整体的逻辑也是只有个大概的印象就开始动手，造成的结果就是每个代码块之间都有一定的耦合，没有全部拆分开，这造成的结果就是会有很多重复的代码，本来能拆分成函数的内容都没有抽象出来，每个函数功能目的不明确，有很多“胶水代码”，归根结底是因为一开始太着急动手，写代码时又没有细究逻辑，功能是完成了，但过不了组内review的关卡，所以总结一句话：解决问题从源头开始，这次实现代码后发现，原本想象的多复杂多复杂的代码，其实并没有想象中那么难，只要逻辑正确，思路正确其实还是很好解决的。</p>
<ol>
<li>代码的格式规范与模块化</li>
</ol>
<p>这次写代码的过程真真切切的明白了一个道理：良好的命名的重要性，因为一开始想的功能不全，所以在中途添加了不少变量，这就造成了不断添加变量，但是因为函数的功能性不清晰，所以在定义变量的时候又会有代码名称比较接近的结果，一开始还没觉得什么，但是写的稍微多一点就会发现，自己不知道当时为什么要用这个变量名定义了，虽然名称有一定的含义，但是有一个变量名跟预期的函数功能还是有偏差，还得重新看一遍代码的过程，也是一个不好的习惯。</p>
<ol>
<li>如何与后台人员沟通</li>
</ol>
<p>因为这次的后台是千仪哥提供的，自己刚刚来，总是觉得千仪哥做的肯定没问题，所以在看接口的时候当不满足自己这边的需求时，在检查完对应的接口功能发现有问题时，先自己偷偷的看能不能自己生产这样的过程。在中间造成了不小的麻烦，经过这件事懂得了：尊重规范，按规范办事，这样才是解决问题最有效也是最便捷的方法。</p>
<h3 id="二-如何生成一个比1px更短的边框"><a href="#二-如何生成一个比1px更短的边框" class="headerlink" title="二.如何生成一个比1px更短的边框"></a>二.如何生成一个比1px更短的边框</h3><p>因为css提供最短的就是1px的长度，这也是屏幕的最短像素，所以要生成1px的边框长度也是有一定的技巧的；</p>
<ol>
<li>使用rgba，通过添加透明度来在视觉上减少边框的长度。</li>
</ol>
<p>这个是没什么好说的，效果虽然有，但是不是一个好的解决方法。</p>
<ol>
<li><p>利用box-shadow实现窄边框</p>
<pre><code>box-shadow:0 0 1px 0 red
</code></pre><p>利用了盒子阴影绘制。可以用于各种场景。但是最后的颜色会变暗，而且box-shadow不占位置，语义化不符合标准。不是实际意义的边框。</p>
</li>
<li><p>多背景渐变实现</p>
</li>
</ol>
<pre><code>background:
linear-gradient(180deg, red, red 50%, transparent 50%) top left / 100% 1px no-repeat, 
linear-gradient(90deg, red, red 50%, transparent 50%) top right / 1px 100% no-repeat, 
linear-gradient(0deg, red, red 50%, transparent 50%) bottom right / 100% 1px no-repeat, 
linear-gradient(-270deg, red, red 50%, transparent 50%) bottom left / 1px 100% no-repeat;
</code></pre><p>可以通过不同的四种角度的渐变，实现边框，颜色可以自定义。缺点是代码比较多，而且不能实现圆角。</p>
<ol>
<li>伪类 + transform 实现</li>
</ol>
<pre><code>:after{
    content: &#39;&#39;; 
    position: absolute; 
    top: 0; left: 0; 
    border: 1px solid red; 
    -webkit-box-sizing: border-box; 
    box-sizing: border-box; 
    width: 200%; 
    height: 200%; 
    -webkit-transform: scale(0.5); 
    transform: scale(0.5); 
    -webkit-transform-origin: left top; 
    transform-origin: left top; 
}
</code></pre><p>利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半， 然后进行绝对定位，这种方法现在没有发现问题。</p>
<h3 id="三-图的遍历"><a href="#三-图的遍历" class="headerlink" title="三.图的遍历"></a>三.图的遍历</h3><p>这部分是上次分享没有添加的内容：</p>
<p>广度优先 搜索(Breadth-First Search，BFS)和深度优先搜索(Depth-First Search，DFS)。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通等。</p>
<p>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</p>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点。</p>
<p>以下是从顶点v开始的广度优先搜索算法所遵循的步骤。<br>(1) 创建一个队列Q。<br>(2) 将v标注为被发现的(灰色)，并将v入队列Q。<br>(3) 如果Q非空，则运行以下步骤:<br>    (a) 将u从Q中出队列;<br>    (b) 将标注u为被发现的(灰色);<br>    (c) 将u所有未被访问过的邻点(白色)入队列;<br>    (d) 将u标注为已被探索的(黑色)。</p>
<pre><code>var initializeColor = function(){ 
    var color = [];
    for (var i=0; i&lt;vertices.length; i++){
         color[vertices[i]] = &#39;white&#39;; 
    }
    return color; 
};
    this.bfs = function(v, callback){
        var color = initializeColor(),  
        queue = new Queue();
        queue.enqueue(v);
        while (!queue.isEmpty()){
            var u = queue.dequeue(), neighbors = adjList.get(u); 
            color[u] = &#39;grey&#39;;                    
            for (var i=0; i&lt;neighbors.length; i++){ 
            var w = neighbors[i];
            if (color[w] === &#39;white&#39;){
                color[w] = &#39;grey&#39;;
                queue.enqueue(w);
            } }
            color[u] = &#39;black&#39;; 
            if (callback) {    
                callback(u);
            }
        } 
    };
</code></pre><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点。</p>
<pre><code>this.dfs = function(callback){
    var color = initializeColor(); 
    for (var i=0; i&lt;vertices.length; i++){ 
        if (color[vertices[i]] === &#39;white&#39;){ 
            dfsVisit(vertices[i], color, callback); 
        }
    } 
};
var dfsVisit = function(u, color, callback){
    color[u] = &#39;grey&#39;; 
    if (callback) {    }
        callback(u);
    }
    var neighbors = adjList.get(u);
    for (var i=0; i&lt;neighbors.length; i++){ 
        var w = neighbors[i];
        if (color[w] === &#39;white&#39;){
            dfsVisit(w, color, callback);
        }
    }
    color[u] = &#39;black&#39;; 
};
</code></pre><p>以上是两个基本的图的遍历方法。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 23.Missing Number]]></title>
      <url>/2018/02/02/leetCode/23.Missing_Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-23-Missing-Number"><a href="#Problem-23-Missing-Number" class="headerlink" title="Problem 23.Missing Number"></a>Problem 23.Missing Number</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p><strong>Example 1</strong></p>
<blockquote>
<p><strong>Input:</strong> [3,0,1]<br><strong>Output:</strong> 2</p>
</blockquote>
<p><strong>Example 2</strong><br><strong>Input:</strong> [9,6,4,2,3,5,7,0,1]<br><strong>Output:</strong> 8</p>
<p><strong>Note:</strong><br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<p><strong>Credits:</strong><br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p>
<p><strong>solution</strong></p>
<p>1.这道题也是比较简单，只要先对数组排好序，然后跟序数进行对比，返回不相等的下标即可。</p>
<pre><code>var missingNumber = function(nums) {
    nums.sort(function(a,b){return a-b;});
    for (var i = 0; i &lt; nums.length; i++) {
        if(nums[i] != i) {
            return i;
        }
    }
    return nums.length;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 22.Maximum Product of Three Numbers]]></title>
      <url>/2018/02/02/leetCode/22.Maximum_Product_of_Three_Numbers/</url>
      <content type="html"><![CDATA[<h2 id="Problem-22-Maximum-Product-of-Three-Numbers"><a href="#Problem-22-Maximum-Product-of-Three-Numbers" class="headerlink" title="Problem 22.Maximum Product of Three Numbers"></a>Problem 22.Maximum Product of Three Numbers</h2><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,3]<br><strong>Output:</strong> 6</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,3,4]<br><strong>Output:</strong> 24</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The length of the given array will be in range [3,10<sup>4</sup>] and all elements are in the range [-1000, 1000].</li>
<li>Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer.</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.因为最短数组长度为3，所以不要考虑数组长度小于3的情况。本题的元素大小可能为负数，若都为正数或都为负数，则取前三个元素，若有正数有负数，通过查资料可以得到，此时3个数之积的最大值为max(第一大数<em>第二大数</em>第三大数， 第一大数<em>最小数</em>倒数第二小数)。这个方法可以记住。</p>
<pre><code>var maximumProduct = function(nums) {
    nums.sort(function(a,b){return b-a;});
    return Math.max(nums[nums.length - 1] * nums[nums.length - 2] * nums[0], nums[0] * nums[1] * nums[2]);
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 21. Image Smoother]]></title>
      <url>/2018/02/02/leetCode/21.Image_Smoother/</url>
      <content type="html"><![CDATA[<h2 id="Problem-21-Image-Smoother"><a href="#Problem-21-Image-Smoother" class="headerlink" title="Problem 21. Image Smoother"></a>Problem 21. Image Smoother</h2><p>Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>[[1,1,1],<br> [1,0,1],<br> [1,1,1]]<br><strong>Output:</strong><br>[[0, 0, 0],<br> [0, 0, 0],<br> [0, 0, 0]]<br><strong>Explanation:</strong><br>For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0<br>For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0<br>For the point (1,1): floor(8/9) = floor(0.88888889) = 0</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The value in the given matrix is in the range of [0, 255].</li>
<li>The length and width of the given matrix are in the range of [1, 150].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.这道题想了半天没想出什么好点的方法，就用最笨的方法写了，判断周围八个位置是否正常，如果正常，就计算到总额里并得到平均值。注意，js里不满1会向上取整，所以应该用Math.floor()。代码如下：</p>
<pre><code>var imageSmoother = function(M) {
        var nx = M.length;
        var ny = M[0].length;
        var res = new Array(nx);
        for(var n = 0; n &lt; nx; n++){
            res[n] = new Array(ny);
        } ;
        for (var i = 0; i &lt; nx; i++) {
            for (var j = 0; j &lt; ny; j++) {
                res[i][j] = smooth(M, i, j);
            }
        }
        return res;
    }
    var smooth = function(M, x, y) {
        var nx = M.length;
        var ny = M[0].length;
        var sum = 0;
        var count = 0;
        for (var i = -1; i &lt;= 1; i++) {
           for (var j = -1; j &lt;= 1; j++) {
             if (x + i &lt; 0 || x + i &gt;= nx || y + j &lt; 0 || y + j &gt;= ny) {
                 continue;
             }
             count++;
             sum += M[x + i][y + j];
           }
        }
        return Math.floor(sum / count);
    }
</code></pre><p>复杂度分析：<br> Time Complexity：O(r X c),r为M.length,c为M[0].length.</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 20.Contains Duplicate]]></title>
      <url>/2018/01/31/leetCode/20.Contains_Duplicate/</url>
      <content type="html"><![CDATA[<h2 id="Problem-20-Contains-Duplicate"><a href="#Problem-20-Contains-Duplicate" class="headerlink" title="Problem 20:Contains Duplicate"></a>Problem 20:Contains Duplicate</h2><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p><strong>solution:</strong></p>
<p>1.先对数组进行sort，然后除去特殊情况下判断只要元素周围两侧元素有一个相同，就返回true，否则为false。</p>
<pre><code>var containsDuplicate = function(nums) {
    nums.sort(function(a,b){return a-b});
    if(nums.length == 0) return false;
    if(nums.length == 1) return false;
    if(nums.length == 2 &amp;&amp; nums[0] ==nums[1]) return true;
    for(var i = 1; i &lt; nums.length - 1; i++) {
        if(nums[i] == nums[i-1] || nums[i] == nums[i+1]) {
            return true;
        }
    }
    return false;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 19.Degree of an Array]]></title>
      <url>/2018/01/31/leetCode/19.Degree_of_an_Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-19-Degree-of-an-Array"><a href="#Problem-19-Degree-of-an-Array" class="headerlink" title="Problem 19: Degree of an Array"></a>Problem 19: Degree of an Array</h2><p>Given a non-empty array of non-negative integers nums, the <strong>degree</strong> of this array is defined as the maximum frequency of any one of its elements.</p>
<p>Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1, 2, 2, 3, 1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong><br>The input array has a degree of 2 because both elements 1 and 2 appear twice.<br>Of the subarrays that have the same degree:<br>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]<br>The shortest length is 2. So return 2.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,2,3,1,4,2]<br><strong>Output:</strong> 6</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>nums.length will be between 1 and 50,000.</li>
<li>nums[i] will be an integer between 0 and 49,999.</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.本题本来想用数组的方式解决，但感觉比较麻烦，所以选择map来解决</p>
<pre><code>var findShortestSubArray = function(nums) {
    var m = new Map(),
    degree = 1,
    whichDegree = nums[0]
    for (var i = 0; i &lt; nums.length; i++) {
        if (m.has(nums[i])) {
        var pos = m.get(nums[i])
        pos.push(i)
        if (pos.length &gt; degree) {
            degree = pos.length
            whichDegree = nums[i]
        } else if (pos.length == degree &amp;&amp; pos[pos.length - 1] - pos[0] &lt; m.get(whichDegree)[m.get(whichDegree).length - 1] - m.get(whichDegree)[0]) {
        degree = pos.length
        whichDegree = nums[i]
        }
        } else 
            m.set(nums[i], [i])
    }
    return m.get(whichDegree)[m.get(whichDegree).length - 1] - m.get(whichDegree)[0] + 1
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 18.Two Sum II - Input array is sorted]]></title>
      <url>/2018/01/31/leetCode/18.Two_Sum_II_Input_array_is_sorted/</url>
      <content type="html"><![CDATA[<h2 id="Problem-18-Two-Sum-II-Input-array-is-sorted"><a href="#Problem-18-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="Problem 18: Two Sum II - Input array is sorted"></a>Problem 18: Two Sum II - Input array is sorted</h2><p>Given an array of integers that is already <em>sorted in ascending order</em>, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p><strong>Input:</strong> numbers={2, 7, 11, 15}, target=9<br><strong>Output:</strong> index1=1, index2=2</p>
<p><strong>solution:</strong></p>
<p>1.因为已经是升序的，所以只要从数组头尾往中间收拢，就必然会找到对应的两个数。</p>
<pre><code>var twoSum = function(numbers, target) {
    var left = 0, right= numbers.length - 1;
    var sum = 0;
    while (left &lt; right) {
        sum = numbers[left] + numbers[right];
        if (sum == target){return [left + 1, right + 1];}
        else if(sum &lt; target) left++;
        else right--;
    }
    return [];
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 17.Majority Element]]></title>
      <url>/2018/01/30/leetCode/17.Majority_Element/</url>
      <content type="html"><![CDATA[<h2 id="Problem-17-Majority-Element"><a href="#Problem-17-Majority-Element" class="headerlink" title="Problem 17: Majority Element"></a>Problem 17: Majority Element</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears <strong>more than</strong> ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Credits:</strong><br>Special thanks to @ts for adding this problem and creating all test cases.</p>
<p><strong>solution:</strong></p>
<p>1.这里比较取巧，因为内容全部为数字，所以sort按序排序然后选择中位数即可。</p>
<pre><code>var majorityElement = function(nums) {
    nums.sort(function(a,b){return a-b;});
    return nums[Math.floor(nums.length/2)];
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 16.Best Time to Buy and Sell Stock II]]></title>
      <url>/2018/01/30/leetCode/16.Best_Time_to_Buy_and_Sell_Stock_II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-16-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Problem-16-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Problem 16: Best Time to Buy and Sell Stock II"></a>Problem 16: Best Time to Buy and Sell Stock II</h2><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p><strong>solution:</strong></p>
<p>1.题目信息请见之前的题目地址，这道题的思路比较奇特，因为可以选择多次，所以只要后一次大于前一次，即可以在总额上加上差值，因为若后面的数继续大于前面的数，累加的差值等于之后的差值。若后面的小，则可以跳过，因为前面的内容已经得到最多的利润。</p>
<pre><code>var maxProfit = function(prices) {
    var maxprofit = 0;
    for(var i = 0; i &lt; prices.length; i++) {
        if (prices[i] &gt; prices[i - 1])
            maxprofit += prices[i] - prices[i - 1];
    }
    return maxprofit;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 15.1-bit and 2-bit Characters]]></title>
      <url>/2018/01/30/leetCode/15.1_bit_and_2_bit_Characters/</url>
      <content type="html"><![CDATA[<h2 id="Problem-15-1-bit-and-2-bit-Characters"><a href="#Problem-15-1-bit-and-2-bit-Characters" class="headerlink" title="Problem 15: 1-bit and 2-bit Characters"></a>Problem 15: 1-bit and 2-bit Characters</h2><p>We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).</p>
<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>bits = [1, 0, 0]<br><strong>Output:</strong> True<br><strong>Explanation:</strong><br>The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>bits = [1, 1, 1, 0]<br><strong>Output:</strong> False<br><strong>Explanation:</strong><br>The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>1 &lt;= len(bits) &lt;= 1000.</li>
<li>bits[i] is always 0 or 1.</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.近期因为时间比较紧，所以只用一种方法解决。本题选择递归，当前元素若为1，则删掉前两个，当前元素为0，则删除一个，直到最后长度为0或时，返回false或true。</p>
<pre><code>var isOneBitCharacter = function(bits) {
    if(bits.length==0) return false; 
    else if(bits.length==1) return true;
    if(bits[0]==0)bits.splice(0,1); 
    else bits.splice(0,2);
    return isOneBitCharacter(bits)
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 14.Move Zeroes]]></title>
      <url>/2018/01/27/leetCode/14.Move_Zeroes/</url>
      <content type="html"><![CDATA[<h2 id="Problem-14-Move-Zeroes"><a href="#Problem-14-Move-Zeroes" class="headerlink" title="Problem 14: Move Zeroes"></a>Problem 14: Move Zeroes</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p><strong>Note:</strong></p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<p><strong>Credits:</strong></p>
<p>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p>
<p><strong>solution:</strong></p>
<ol>
<li>这跟之前做的题很类似，只要注意在splice之后要对i减一即可。</li>
</ol>
<pre><code>var moveZeroes = function(nums) {
    var sumZero = 0;
    for(var i = 0; i &lt; nums.length; i++) {
        if(nums[i] == 0) {
            nums.splice(i, 1);
            i--;
            sumZero++;
        }
    }
    for(var n = 0; n &lt; sumZero; n++) {
        nums.push(0);
    }
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 13.Find All Numbers Disappeared in an Array]]></title>
      <url>/2018/01/27/leetCode/13.Find_All_Numbers_Disappeared_in_an_Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-13-Find-All-Numbers-Disappeared-in-an-Array"><a href="#Problem-13-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="Problem 13: Find All Numbers Disappeared in an Array"></a>Problem 13: Find All Numbers Disappeared in an Array</h2><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<p><strong>Example:</strong></p>
<p><strong>Input:</strong><br>[4,3,2,7,8,2,3,1]</p>
<p><strong>Output:</strong><br>[5,6]</p>
<p><strong>solution:</strong></p>
<p>1.本来想最简单的方法就是先筛选出1 ≤ a[i] ≤ n 中哪个元素不再数组里，然后push到最后一位在splice之前的内容，但是要求<code>without extra space and in O(n) runtime</code>，所以选择其他的方法。这里选择先将数组排序，然后判断哪个元素不是对应位置上的数字，最后push到数组中。</p>
<pre><code>var findDisappearedNumbers = function(nums) {
     var res = [];
     for (var i = 0; i &lt; nums.length; i++) {
        if (nums[i] != nums[nums[i] - 1]) {
            var inchange = nums[nums[i] - 1];
            nums[nums[i] - 1] = nums[i];
            nums[i] = inchange;
            i--;
        }
    }
    for (var j = 0; j &lt; nums.length; j++) {
        if (nums[j] != j + 1)
            res.push(j + 1);
    }
    return res;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 12.Max Area of Island]]></title>
      <url>/2018/01/27/leetCode/12.Max_Area_of_Island/</url>
      <content type="html"><![CDATA[<h2 id="Problem-12-Max-Area-of-Island"><a href="#Problem-12-Max-Area-of-Island" class="headerlink" title="Problem 12: Max Area of Island"></a>Problem 12: Max Area of Island</h2><p>Given a non-empty 2D array <code>grid</code> of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</p>
</blockquote>
<p>Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.</p>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>[[0,0,0,0,0,0,0,0]]</p>
</blockquote>
<p>Given the above grid, return 0.</p>
<p><strong>Note:</strong> The length of each dimension in the given grid does not exceed 50.</p>
<p><strong>solution:</strong></p>
<ol>
<li>因为选取最多的相邻的1，本来打算遍历一遍，如果当前元素右边和下边为1，则对右下方元素加对应的值，但是边界条件判断比较复杂。所以，选择递归实现，虽然实现很简单，但是时间复杂度相对较高，做了比较多重复的操作。以下为对应代码：</li>
</ol>
<pre><code>var maxAreaOfIsland = function(grid) {
      var res = 0;
      for(var i = 0; i &lt; grid.length; i++){
         for(var j = 0; j &lt; grid[0].length; j++){
                if(grid[i][j] == 1) res = Math.max(res, helper(grid, i, j));
            }
        }
        return res;
};

var helper = function(grid, r, c) {
    if(r &lt; 0 || r &gt;= grid.length || c &lt; 0 || c &gt;= grid[0].length) return 0;
        var res = 0;
        if(grid[r][c] == 1){
            grid[r][c] = 0;
            res = 1 + helper(grid, r-1, c) + helper(grid, r+1, c) + helper(grid, r, c-1) + helper(grid, r, c+1);
        }
        return res;
}
</code></pre><p>复杂度分析：<br>Time Complexity：O(r X c), r为行的个数，c为列的个数。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 11.Shortest Word Distance]]></title>
      <url>/2018/01/27/leetCode/11.Shortest_Word_Distance/</url>
      <content type="html"><![CDATA[<h2 id="Problem-11-Shortest-Word-Distance"><a href="#Problem-11-Shortest-Word-Distance" class="headerlink" title="Problem 11: Shortest Word Distance"></a>Problem 11: Shortest Word Distance</h2><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>For example,<br>Assume that words = <code>[&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]</code>.</p>
<p>Given word1 = <code>&quot;coding&quot;</code>, word2 = <code>&quot;practice&quot;</code>, return 3.<br>Given word1 = <code>&quot;makes&quot;</code>, word2 = <code>&quot;coding&quot;</code>, return 1.</p>
<p><strong>Note:</strong></p>
<p>You may assume that word1 <strong>does not equal to</strong> word2, and word1 and word2 are both in the list.</p>
<p><strong>solution:</strong></p>
<ol>
<li>根据题意，选出最近的两个对应的单词的间距，因为所选单词最短的间距即相邻间距，所以最小的匹配值间距的绝对值即是所求答案。</li>
</ol>
<pre><code>var shortestDistance = function(words, word1, word2) {
    var index1 = -1, index2 = -1;
    var minDistance = words.length;
    var currentDistance;
    for (var i = 0; i &lt; words.length; i++) {
        if (words[i] == word1) {
            index1 = i;
        } else if (words[i] == word2) {
            index2 = i;
        }

        if (index1 != -1 &amp;&amp; index2 != -1) {
            minDistance = Math.min(minDistance, Math.abs(index1 - index2));
        }
    }
    return minDistance;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组的长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 10.Max Consecutive Ones]]></title>
      <url>/2018/01/26/leetCode/10.Max_Consecutive_Ones/</url>
      <content type="html"><![CDATA[<h2 id="Problem-10-Max-Consecutive-Ones"><a href="#Problem-10-Max-Consecutive-Ones" class="headerlink" title="Problem 10: Max Consecutive Ones"></a>Problem 10: Max Consecutive Ones</h2><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,1,0,1,1,1]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The first two digits or the last three digits are consecutive 1s.<br>    The maximum number of consecutive 1s is 3.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The input array will only contain 0 and 1.</li>
<li>The length of input array is a positive integer and will not exceed 10,000</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.这道题算是福利题了，只要确定最长的1的长度就行了，所以直接判断即可：</p>
<pre><code>var findMaxConsecutiveOnes = function(nums) {
    var res = 0;
    var cnt = 0;
    for (var i = 0; i&lt; nums.length; i++) {
        cnt = (nums[i] == 0) ? 0 : cnt + 1;
        res = Math.max(res, cnt);
    }
    return res;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n),n为nums的长度；</p>
<p>2.除此之外还看到一个人的另一种比较有趣的方法，因为是01串，那么连续1的和跟个数相等，所以我们可以计算和，通过加上num，再乘以num来计算，如果当前数字是0，那么sum就被重置为0，还是要更新结果res。</p>
<pre><code>var findMaxConsecutiveOnes = function(nums) {
    var res = 0;
    var cnt = 0;
    for (var i = 0; i&lt; nums.length; i++) {
        cnt = (cnt + nums[i]) * nums[i];
        res = Math.max(res, cnt);
    }
    return res;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n),n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 9.Reshape the Matrix]]></title>
      <url>/2018/01/26/leetCode/9.Reshape_the_Matrix/</url>
      <content type="html"><![CDATA[<h2 id="Problem-9-Reshape-the-Matrix"><a href="#Problem-9-Reshape-the-Matrix" class="headerlink" title="Problem 9:Reshape the Matrix"></a>Problem 9:Reshape the Matrix</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p>
<p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and column number of the wanted reshaped matrix, respectively.</p>
<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p>
<p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>nums =<br>[[1,2],<br> [3,4]]<br>r = 1, c = 4<br><strong>Output:</strong><br>[[1,2,3,4]]<br><strong>Explanation:</strong><br>The <strong>row-traversing</strong> of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>nums =<br>[[1,2],<br> [3,4]]<br>r = 2, c = 4<br><strong>Output:</strong><br>[[1,2],<br> [3,4]]<br><strong>Explanation:</strong><br>There is no way to reshape a 2 X 2 matrix to a 2 X 4 matrix. So output the original matrix.</p>
</blockquote>
<p><strong>Note:</strong><br>The height and width of the given matrix is in range [1, 100].<br>The given r and c are all positive.</p>
<p><strong>solution:</strong></p>
<ol>
<li>做这道题时主要的问题在于如何创建一个二维数组，因为js创建二维数组时出现问题，所以选择设两个一维数组，先判断是否符合要求，不符合返回原数组，然后将元素通过concat添加到一个一维数组中，然后根据所给的r,c一一赋值即可。这道题主要纠结在如何设置一个空的二维数组以及如何对二维数组进行赋值。最后回避了这个问题。</li>
</ol>
<pre><code>var matrixReshape = function(nums, r, c) {
    var result_storage = [];
    var result = []; 
    if(nums.length * nums[0].length != r * c) {
        return nums;
    }    
    for(var i=0; i &lt; nums.length; i++) {  
            result_storage = result_storage.concat(nums[i]);  
    }
    for(var i = 0; i &lt; r; i++) {  
        result.push([]);  
        for(var j = 0; j &lt; c ; j++){  
                result[i][j] = result_storage[i * c + j];  
            }  
    } 
    return result;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(r X c), r为矩阵的横向长度，c为矩阵的纵向长度。</p>
<p>2.经过查询过后，发现二维数组不是通过创建`var result = new Array[][]这样的形式创建，而是通过先创建一个一维数组，再对其中的元素设置为数组的形式创建多维数组。接下来就对数组中的内容进行判断，若没有到下一行，则继续对下一位内容赋值，若倒下一行，则换行输入。</p>
<pre><code>var matrixReshape = function(nums, r, c) {
    var result =  new Array(r);  
    for(var n = 0; n &lt; result.length; n++){  
        result[n] = new Array(c);   
    }  
    var rows = 0; 
    var cols = 0;
    var count = 0;
    if(nums.length == 0 || nums.length * nums[0].length != r * c) 
        return nums;   
    for (var i = 0; i &lt; nums.length; i ++) {
        for (var j = 0; j &lt; nums[0].length; j++) {
            result[rows][cols] = nums[i][j];
            cols++;
            if (cols == c) {
                rows++;
                cols = 0;
            }
        }
    }
    return result;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(num.length X num[0].length), 与上述方法的复杂度类似，不过更直观一些。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 8.Toeplitz Matrix]]></title>
      <url>/2018/01/26/leetCode/8.Toeplitz_Matrix/</url>
      <content type="html"><![CDATA[<h2 id="Problem-8-Toeplitz-Matrix"><a href="#Problem-8-Toeplitz-Matrix" class="headerlink" title="Problem 8: Toeplitz Matrix"></a>Problem 8: Toeplitz Matrix</h2><p>A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.</p>
<p>Now given an <code>M x N</code> matrix, return <code>True</code> if and only if the matrix is Toeplitz.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]<br><strong>Output:</strong> True<br><strong>Explanation:</strong><br>1234<br>5123<br>9512</p>
</blockquote>
<p>In the above grid, the diagonals are “[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”, and in each diagonal all elements are the same, so the answer is True.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> matrix = [[1,2],[2,2]]<br><strong>Output:</strong> False<br><strong>Explanation:</strong><br>The diagonal “[1, 2]” has different elements.</p>
<p><strong>Note:</strong></p>
<ol>
<li>matrix will be a 2D array of integers.</li>
<li>matrix will have a number of rows and columns in range [1, 20].</li>
<li>matrix[i][j] will be integers in range [0, 99].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.通过画图可得，从左上角的元素开始，如果每行（最后一行除外）元素可以与右下方（每行最后一个元素除外）的元素相等，既符合要求，所以可以选择遍历得到答案。</p>
<p>目前就只有这一种比较好的解法，所以就先写一个算法了。</p>
<pre><code>var isToeplitzMatrix = function(matrix) {
    for(var r = 0; r &lt; matrix.length - 1; r++) {
        for(var c = 0; c &lt; matrix[0].length - 1; c++) {
            if(matrix[r][c] != matrix[r+1][c+1]) {
                return false;
            }
        }
    }
    return true;
};
</code></pre><p>复杂度分析：<br>Time Complexity: O(m X n), m为矩阵的横向长度，n为矩阵的纵向长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 7.Array Partition I]]></title>
      <url>/2018/01/26/leetCode/7.array_partition_I/</url>
      <content type="html"><![CDATA[<h2 id="Problem-7-Array-Partition-I"><a href="#Problem-7-Array-Partition-I" class="headerlink" title="Problem 7:Array Partition I"></a>Problem 7:Array Partition I</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,4,3,2]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li>
<li>All the integers in the array will be in the range of [-10000, 10000].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.这道题比较简单的做法是对数组排序，然后隔一个数字取一个，就可以保证数组中所有的每两个数字的最小值的总和是最小值。</p>
<p>目前也没有找到比这个更简单的算法，所以就先写一个算法了。</p>
<pre><code>var arrayPairSum = function(nums) {
    var sum = 0;
    var i = 0;
    nums.sort(function(a, b){return a-b;});
    for(var i = 0; i&lt; nums.length; i+=2) {
        sum+=nums[i];
    }
    return sum;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1.22~1.26所遇问题]]></title>
      <url>/2018/01/25/blog/1.22~1.16_questions/</url>
      <content type="html"><![CDATA[<h2 id="1-22-1-26所遇问题"><a href="#1-22-1-26所遇问题" class="headerlink" title="1.22~1.26所遇问题"></a>1.22~1.26所遇问题</h2><h3 id="1-导入css文件时，import和link的区别"><a href="#1-导入css文件时，import和link的区别" class="headerlink" title="1.导入css文件时，import和link的区别"></a>1.导入css文件时，import和link的区别</h3><ol>
<li><code>&lt;link&gt;</code>标签是html标签，除了可以引入CSS之外还可以定义RSS，定义rel属性等，而@import只能引入CSS样式；</li>
<li><code>&lt;link&gt;</code>标签引用的CSS文件会在页面加载时与html同时加载，而@import引入的CSS文件会等页面全部加载完以后再加载；</li>
<li>@import标签必须放在页面样式表的顶部，而<code>&lt;link&gt;</code>不必；</li>
</ol>
<p>那为什么会有很多人建议使用link标签，而非import呢？在Steve Souders（编写过《高性能网站建设指南》等书）的博客中通过一些实例来说明<strong>don’t use @import</strong>。<br>以下节选部分内容并进行翻译：</p>
<p>原文链接<a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/" target="_blank" rel="noopener">http://www.stevesouders.com/blog/2009/04/09/dont-use-import/</a><br>——————————————————————————————————————<br><strong>LINK vs. @import</strong></p>
<p>There are two ways to include a stylesheet in your web page. You can use the LINK tag:</p>
<p>以下有两种将样式表引入到您的网页中的方式。您可以使用LINK标签：</p>
<pre><code>&lt;link rel=&#39;stylesheet&#39; href=&#39;a.css&#39;&gt;
</code></pre><p>Or you can use the @import rule:</p>
<p>或者您可以使用@import规则：</p>
<pre><code>&lt;style&gt;
@import url(&#39;a.css&#39;);
&lt;/style&gt;
</code></pre><p>I prefer using LINK for simplicity—you have to remember to put @import at the top of the style block or else it won’t work. It turns out that avoiding @import is better for performance, too.</p>
<p>为了简单起见，我更倾向于使用LINK。如果您使用@import的话，您必须将它放在样式内容的顶部，否则它将无法显示。事实证明，处于性能来说，避免使用@import也是一个更好的选择。</p>
<p><strong>@import @import</strong></p>
<p>I’m going to walk through the different ways LINK and @import can be used. In these examples, there are two stylesheets: a.css and b.css. Each stylesheet is configured to take two seconds to download to make it easier to see the performance impact. The first example uses @import to pull in these two stylesheets. In this example, called @import @import, the HTML document contains the following style block:</p>
<p>我将在不同的情况下使用LINK和@import。在这些例子中，有两个样式表：a.css和b.css。每个样式表都需要花费两秒钟的时间下载，以便更容易地观测性能。第一个示例中，我们使用@import来下载这两个样式表。我们叫这个例子为<code>@import @import</code>在这个示例中，HTML文档包含以下样式块：</p>
<pre><code>&lt;style&gt;
@import url(&#39;a.css&#39;);
@import url(&#39;b.css&#39;);
&lt;/style&gt;
</code></pre><p>If you always use @import in this way, there are no performance problems, although we’ll see below it could result in JavaScript errors due to race conditions. The two stylesheets are downloaded in parallel, as shown in Figure 1. (The first tiny request is the HTML document.) The problems arise when @import is embedded in other stylesheets or is used in combination with LINK.</p>
<p>如果您总是使用@import的方式，不会有什么性能方面的问题，尽管可能由于竞争的原因导致JavaScript报错。如图1所示，这两个样式表是并行下载的。（第一个请求时HTML文档），但是，当@import与LINK结合使用引入其他样式表时，问题就出现了。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/import-import.gif" alt="只使用@import"><br>    <figcaption><br>        只使用@import<br>    </figcaption><br></figure>

<p>由此可见，只使用@import是没有问题的。</p>
<p><strong>LINK @import</strong></p>
<p>The LINK @import example uses LINK for a.css, and @import for b.css:</p>
<p>LINK @import示例中使用LINK标签引入a.css，使用@import引入b.css：</p>
<pre><code>&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
&lt;style&gt;
@import url(&#39;b.css&#39;);
&lt;/style&gt;
</code></pre><p>In IE (tested on 6, 7, and 8), this causes the stylesheets to be downloaded sequentially, as shown in Figure 2. Downloading resources in parallel is key to a faster page. As shown here, this behavior in IE causes the page to take a longer time to finish.</p>
<p>在IE（在IE6， 7， 8下测试）中，如下图所示，这将导致样式表按顺序下载，而并行下载资源是让页面加载更快的关键。如图所示，在IE中的这会导致页面花费较长的时间完成渲染。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-import.gif" alt="混合使用@import和link标签"><br>    <figcaption><br>        混合使用@import和link标签<br>    </figcaption><br></figure>

<p><strong>LINK with @import</strong></p>
<p>In the LINK with @import example, a.css is inserted using LINK, and a.css has an @import rule to pull in b.css:</p>
<p>在使用LINK中使用@import的示例中，a.css使用LINK嵌入在DOM中，而a.css中则通过@import导入b.css：</p>
<pre><code>in the HTML document:
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
in a.css:
@import url(&#39;b.css&#39;);
</code></pre><p>This pattern also prevents the stylesheets from loading in parallel, but this time it happens on all browsers. When we stop and think about it, we shouldn’t be too surprised. The browser has to download a.css and parse it. At that point, the browser sees the @import rule and starts to fetch b.css.</p>
<p>这种方式也可以防止样式表的并行加载，但是这次它发生在所有的浏览器上。其实仔细想一想，我们都不应该感到惊讶。浏览器必须先下载a.css并解析它，只有解析它后，浏览器才会看到@import规则并开始加载b.css。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-with-import.gif" alt="在link标签引入@import"><br>    <figcaption><br>       在link标签引入@import<br>    </figcaption><br></figure>

<p><strong>LINK blocks @import</strong></p>
<p>A slight variation on the previous example with surprising results in IE: LINK is used for a.css and for a new stylesheet called proxy.css. proxy.css is configured to return immediately; it contains an @import rule for b.css.</p>
<p>在IE中与上述结果有些许不同：对a.css和名为proxy.css的样式表使用LINK引入。而proxy.css会立即执行并渲染; 注意，它包含一个b.css的@import规则</p>
<pre><code>in the HTML document:
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;proxy.css&#39;&gt;
in proxy.css:
@import url(&#39;b.css&#39;);
</code></pre><p>The results of this example in IE, LINK blocks @import, are shown in Figure 4. The first request is the HTML document. The second request is a.css (two seconds). The third (tiny) request is proxy.css. The fourth request is b.css (two seconds). Surprisingly, IE won’t start downloading b.css until a.css finishes. In all other browsers, this blocking issue doesn’t occur, resulting in a faster page as shown in Figure 5.</p>
<p>在IE中的LINK bock @import例子里，第一个请求时HTML文件，第二个请求是a.css（花费了两秒），第三个请求（很短）是proxy.css。第四个请求时b.css（花费了两秒）。令人惊奇的是，IE不会等到a.css结束后再开始下载b.css。在所有其他的浏览器里，这种加速渲染页面的情况不会发生。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-blocks-import.gif" alt="LINK blocks @import embedded in other stylesheets in IE"><br>     <figcaption><br>        LINK blocks @import embedded in other stylesheets in IE<br>     </figcaption><br></figure>

<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-blocks-import-not-ie.gif" alt=" LINK doesn't block @import embedded stylesheets in browsers other than IE"><br>     <figcaption><br>         LINK doesn’t block @import embedded stylesheets in browsers other than IE<br>     </figcaption><br></figure>

<p><strong>many @imports</strong></p>
<p>The many @imports example shows that using @import in IE causes resources to be downloaded in a different order than specified. This example has six stylesheets (each takes two seconds to download) followed by a script (a four second download).</p>
<p>在many @imports例子中显示了在IE中使用@import会导致不同于指定的顺序下载资源。这个例子有六个样式表（每个需要两秒钟下载），后面是一个脚本（四秒钟的下载）</p>
<pre><code>&lt;style&gt;
@import url(&#39;a.css&#39;);
@import url(&#39;b.css&#39;);
@import url(&#39;c.css&#39;);
@import url(&#39;d.css&#39;);
@import url(&#39;e.css&#39;);
@import url(&#39;f.css&#39;);
&lt;/style&gt;
&lt;script src=&#39;one.js&#39; type=&#39;text/javascript&#39;&gt;&lt;/script&gt;
</code></pre><p>Looking at Figure 6, the longest bar is the four second script. Even though it was listed last, it gets downloaded first in IE. If the script contains code that depends on the styles applied from the stylesheets (a la getElementsByClassName, etc.), then unexpected results may occur because the script is loaded before the stylesheets, despite the developer listing it last.</p>
<p>看下图，最长的一条是一个四秒的脚本。尽管它位于最后，但是它在IE中是最早下载下来的。如果脚本包括依赖于样式表中的样式，会有未知的结果发生，因为脚本不是按照预期的顺序在样式之后加载的。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/many-imports.gif" alt="多个import"><br>     <figcaption><br>        多个import<br>     </figcaption><br></figure>

<p><strong>LINK LINK</strong></p>
<p>It’s simpler and safer to use LINK to pull in stylesheets:</p>
<p>使用LINK加载样式更快捷也更安全：</p>
<pre><code>&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;b.css&#39;&gt;
</code></pre><p>Using LINK ensures that stylesheets will be downloaded in parallel across all browsers. The LINK LINK example demonstrates this, as shown in Figure 7. Using LINK also guarantees resources are downloaded in the order specified by the developer.</p>
<p>使用LINK会确保样式表会在所有的浏览器中都并行下载。这个LINK LINK的例子证明了这点，使用LINk也保证资源会按开发者的顺序加载。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/import-import.gif" alt="使用link加载样式表"><br>     <figcaption><br>        使用link加载样式表<br>     </figcaption><br></figure>

<p>These issues need to be addressed in IE. It’s especially bad that resources can end up getting downloaded in a different order. All browsers should implement a small lookahead when downloading stylesheets to extract any @import rules and start those downloads immediately. Until browsers make these changes, I recommend avoiding @import and instead using LINK for inserting stylesheets.</p>
<p>这些问题在IE中都需要解决。尤其是资源会以不同的顺序下载的问题尤为糟糕。所有的浏览器都应该在下载样式表的时候就提取任何@import规则并立即开始下载。在浏览器进行这些更改之前，我建议避免使用@import，而应使用LINK来引入样式表。</p>
<p>The load times of these resources are exaggerated to make it easy to see what’s happening. But for people with slow connections, especially those in some of the world’s emerging markets, these response times may not be that far from reality. The takeaways are:</p>
<ol>
<li>Using @import within a stylesheet adds one more roundtrip to the overall download time of the page.</li>
<li>Using @import in IE causes the download order to be altered. This may cause stylesheets to take longer to download, which hinders progress rendering making the page feel slower.</li>
</ol>
<p>因为这些资源的加载时间被夸大，所有我们很容易看到发生了什么事情。但是对于那些网速慢的人来说，网络的响应时间也许并不那么块。 原因是：</p>
<ol>
<li>在样式表中使用@import会使得页面的整体下载时间再增加一倍。</li>
<li>在IE中使用@import会导致资源的下载顺序发生改变。这可能会导致样式表花费更长的时间来下载，因此会阻碍渲染，使页面加载的更慢。</li>
</ol>
<h3 id="2-微格式"><a href="#2-微格式" class="headerlink" title="2.微格式"></a>2.微格式</h3><p>对应官网为：<a href="http://microformats.org/" target="_blank" rel="noopener">http://microformats.org/</a></p>
<h4 id="微格式产生背景："><a href="#微格式产生背景：" class="headerlink" title="微格式产生背景："></a>微格式产生背景：</h4><p>由于早期HTML中缺少相应的元素，很难突出显示人、地点或日期等类型的信息。为了解决这个问题，有一组开发人员决定开发一套标准的命名约定盒标记模式来表示这些数据。这些命名约定基于vCard（电子名片）和iCalendar（日历数据交换）等现有的数据格式，现在称为微格式（microformat)。</p>
<h4 id="微格式定义："><a href="#微格式定义：" class="headerlink" title="微格式定义："></a>微格式定义：</h4><p>建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式（microformats.org官方定义）。是把语义嵌入到HTML以便有助于分离式开发而制定的一些简单约定，是兼顾人机可读性设计的数据表达方式，对Web网页进行语义注解的方法。</p>
<h4 id="微格式意义："><a href="#微格式意义：" class="headerlink" title="微格式意义："></a>微格式意义：</h4><p>微格式按照某种已有的被广泛应用的标准，通过对内容块的语义标记，可以让外部应用程序、聚合程序和搜索引擎能够做以下事情：</p>
<ol>
<li>在捉取Web内容时，能够更为准确地识别内容块的语义；</li>
<li>对内容进行操作，包括提供访问、校对，还可以将其转化成其他的相关格式，提供给外部程序和Web服务使用。</li>
</ol>
<p>因此，微格式实际上就是为现有的HTML元素添加元数据和其他属性以增强语义化。</p>
<p>常见的微格式是hCard</p>
<p>hCard是一种微格式，用来发布个人，公司，组织，地点等详细的联系信息。它可以包含在(X)HTML，Atom，RSS等可扩展置标语言中。hCard使用vCard（RFC 2426）的属性和值来实现这些功能。</p>
<p>它可以使分析器（比如其他网站，Firefox的Operator插件）获得详细的信息，并通过别的网站或者地图工具进行显示，或者载入到地址簿等其他程序。</p>
<p>example：</p>
<pre><code>&lt;div&gt;
     &lt;div&gt;Joe Doe&lt;/div&gt;
     &lt;div&gt;The Example Company&lt;/div&gt;
     &lt;div&gt;604-555-1234&lt;/div&gt;
     &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
 &lt;/div&gt;
</code></pre><p> 如下代码添加了微格式后，成为:</p>
<pre><code> &lt;div class=&quot;vcard&quot;&gt;
     &lt;div class=&quot;fn&quot;&gt;Joe Doe&lt;/div&gt;
     &lt;div class=&quot;org&quot;&gt;The Example Company&lt;/div&gt;
     &lt;div class=&quot;tel&quot;&gt;604-555-1234&lt;/div&gt;
     &lt;a class=&quot;url&quot; href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
 &lt;/div&gt;
</code></pre><p> 这里，正式名称（class=”fn”），组织（class=”org”），电话号码（class=”tel”）和url（class=”url”）分别用相应的class标示；同时，所有内容都包含在class=”vcard”里。</p>
<p> 以上就是微格式的大体内容。</p>
<h3 id="外边距叠加"><a href="#外边距叠加" class="headerlink" title="外边距叠加"></a>外边距叠加</h3><p>首先，先说明是什么导致的外边距叠加。</p>
<p>首先，外边距叠加是因为<strong>外边距塌陷(margin collapse)</strong>导致的。实际它也是由于一个缺省值的设定而导致的。在Chrome浏览器里，这个缺省值就是由-webkit-margin-collapse规定的。-webkit-margin-collapse的缺省值就是collapse，所以导致塌陷。这个属性还有另外2个取值：一个是discard，一个是separate。下面我们来具体看一下它们的不同表现形式。</p>
<h4 id="webkit-margin-collapse-collapse"><a href="#webkit-margin-collapse-collapse" class="headerlink" title="-webkit-margin-collapse: collapse"></a>-webkit-margin-collapse: collapse</h4><p>我们先从简单的看起。假定我们有这样一个<code>&lt;div&gt;</code>，这个<code>&lt;div&gt;</code>里面有3个<code>&lt;p&gt;</code>，如果我们什么也不设，它就是这个样子：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/157/537/1575372319-5a5eabae0c326_articlex" alt="未设置-webkit-margin-collapse"></p>
<p>会看到每一个<code>&lt;p&gt;</code>下面都有一个下边距。现在我们加上<code>margin: 20px 0;</code>表示为每一个<code>&lt;p&gt;</code>增加一个20px的上边距和一个20px的下边距，现在再看一下效果：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/537/919/537919608-5a5eac73b8e6c_articlex" alt="-webkit-margin-collapse: collapse"></p>
<p>这时我们看到虽然第一个<code>&lt;p&gt;</code>有20px的上边距，但第2个<code>&lt;p&gt;</code>的20px上边距已经被第一个<code>&lt;p&gt;</code>的下边距『吃掉』了，这就是我们大家所熟知的外边距塌陷。</p>
<h4 id="webkit-margin-collapse-separate"><a href="#webkit-margin-collapse-separate" class="headerlink" title="-webkit-margin-collapse: separate"></a>-webkit-margin-collapse: separate</h4><p>现在我们来看一下第2种情况，如果我们设定<code>-webkit-margin-collapse: separate</code>之后会怎么样：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/164/511/1645114860-5a5eb3d394158_articlex" alt="-webkit-margin-collapse: separate"></p>
<p>现在我们看到塌陷的外边距回来了。</p>
<h4 id="webkit-margin-collapse-discard"><a href="#webkit-margin-collapse-discard" class="headerlink" title="-webkit-margin-collapse: discard"></a>-webkit-margin-collapse: discard</h4><p>那么第3种取值<code>discard</code>是什么作用呢？</p>
<p><img src="https://sfault-image.b0.upaiyun.com/318/356/3183561786-5a5eb42f8c31d_articlex" alt="-webkit-margin-collapse: discard"></p>
<p>外边距完全没有了。</p>
<p>所以，如果我们想强制所有元素边距都不塌陷，那么该怎么办呢？</p>
<p>我们不能再简单地同时设置上下边距为<code>margin: 20px 0;</code>而应该更精确控制，给<code>&lt;p&gt;</code>只设置下边距为20px就可以了，这样我们就实现了在强制不塌陷的情况下依然保持了行与行之间的距离。</p>
<p>Tips:<br>『外边距塌陷』其实是W3C早期标准为了一时方便而引入的一个过度设计，它的设计初衷是为了简化，但结果在CSS高度发展的情况下反倒造成了更大的混乱，使得前端工程师无法一目了然地知道自己的代码结果，不明白自己明明已经设置好的<code>margin-top: 20px;</code>怎么就会没有了？结果被人告知还要学习外边距塌陷这样的知识。这样的错误责任不在于工程师没有好好学习，而根本原因在于CSS本身设计的缺陷，才导致了工程师学习成本的增加，并且还增加了浏览器开发者的工作量，需要特意为外边距塌陷开发额外的代码。无论如何，这是一件各方成本都增加的双输设计。</p>
<p>至于水平方向上为什么没有外边距叠加，我也不知道呀，也许当时就是为了解决垂直方向上外边距累加的问题吧，定义上就是这么定义的。</p>
<p>最后总结一下W3C中外边距叠加的内容</p>
<blockquote>
<p>In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin.</p>
</blockquote>
<p>在CSS中，两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。</p>
<p>我们可以注意定义中的几个关键字：毗邻、两个或多个、垂直方向和普通流。</p>
<h4 id="毗邻"><a href="#毗邻" class="headerlink" title="毗邻"></a>毗邻</h4><p>毗邻说明了他们的位置关系，没有被 padding、border、clear 和 line box 分隔开。</p>
<h4 id="两个或多个"><a href="#两个或多个" class="headerlink" title="两个或多个"></a>两个或多个</h4><p>两个或多个盒子是指元素之间的相互影响，单个元素不会存在外边距叠加的情况。</p>
<h4 id="垂直方向"><a href="#垂直方向" class="headerlink" title="垂直方向"></a>垂直方向</h4><blockquote>
<p>Horizontal margins never collapse.</p>
</blockquote>
<p>只有垂直方向的外边距会发生外边距叠加。水平方向的外边距不存在叠加的情况。</p>
<h4 id="普通流-in-flow"><a href="#普通流-in-flow" class="headerlink" title="普通流(in flow)"></a>普通流(in flow)</h4><p>什么是普通流？W3C 只对 out of flow 作了定义：</p>
<blockquote>
<p>An element is called out of flow if it is floated, absolutely positioned, or is the root element.An element is called in-flow if it is not out-of-flow.</p>
</blockquote>
<p>从定义中我们可以知道只要不是 float、absolutely positioned 和 root element 时就是 in flow。</p>
<h4 id="什么时候会发生外边距叠加"><a href="#什么时候会发生外边距叠加" class="headerlink" title="什么时候会发生外边距叠加"></a>什么时候会发生外边距叠加</h4><p>外边距叠加存在两种情况：一是父子外边距叠加；二是兄弟外边距叠加。</p>
<p>W3C 对于什么是毗邻的外边距也有定义：</p>
<blockquote>
<p>Two margins are adjoining if and only if: - both belong to in-flow block-level boxes that participate in the same block formatting context - no line boxes, no clearance, no padding and no border separate them - both belong to vertically-adjacent box edges, i.e. form one of the following pairs:</p>
<ul>
<li>top margin of a box and top margin of its first in-flow child</li>
<li>bottom margin of box and top margin of its next in-flow following sibling</li>
<li>bottom margin of a last in-flow child and bottom margin of its parent if the &gt; parent has “auto” computed height</li>
<li>top and bottom margins of a box that does not establish a new block formatting context and that has zero computed “min-height”, zero or “auto” computed “height”, and no in-flow children</li>
</ul>
</blockquote>
<p>从定义中我们可以很清楚的知道要符合哪些情况才会发生外边距折叠：</p>
<ul>
<li>都属于普通流的块级盒子且参与到相同的块级格式上下文中</li>
<li>没有被padding、border、clear和line box分隔开</li>
<li>都属于垂直毗邻盒子边缘：<ul>
<li>盒子的top margin和它第一个普通流子元素的top margin</li>
<li>盒子的bottom margin和它下一个普通流兄弟的top margin</li>
<li>盒子的bottom margin和它父元素的bottom margin</li>
<li>盒子的top margin和bottom margin，且没有创建一个新的块级格式上下文，且有被计算为0的min-height，被计算为0或auto的height，且没有普通流子元素</li>
</ul>
</li>
</ul>
<h4 id="如何避免外边距叠加"><a href="#如何避免外边距叠加" class="headerlink" title="如何避免外边距叠加"></a>如何避免外边距叠加</h4><p>上面讲了外边距的叠加，那如何避免呢，其实只要破坏上面讲到的四个条件中的任何一个即可：毗邻、两个或多个、普通流和垂直方向。</p>
<p>W3C也对此做了总结：</p>
<blockquote>
<ul>
<li>Margins between a floated box and any other box do not collapse (not even between a float and its in-flow children).</li>
<li>Margins of elements that establish new block formatting contexts (such as floats and elements with “overflow” other than “visible”) do not collapse with their in-flow children.</li>
<li>Margins of absolutely positioned boxes do not collapse (not even with their in-flow children).</li>
<li>Margins of inline-block boxes do not collapse (not even with their in-flow children).</li>
<li>The bottom margin of an in-flow block-level element always collapses with the top margin of its next in-flow block-level sibling, unless that sibling has clearance.</li>
<li>The top margin of an in-flow block element collapses with its first in-flow block-level child”s top margin if the element has no top border, no top padding, and the child has no clearance.</li>
<li>The bottom margin of an in-flow block box with a “height” of “auto” and a “min-height” of zero collapses with its last in-flow block-level child”s bottom margin if the box has no bottom padding and no bottom border and the child”s bottom margin does not collapse with a top margin that has clearance.</li>
<li>A box”s own margins collapse if the “min-height” property is zero, and it has neither top or bottom borders nor top or bottom padding, and it has a “height” of either 0 or “auto”, and it does not contain a line box, and all of its in-flow children”s margins (if any) collapse.</li>
</ul>
</blockquote>
<ul>
<li>浮动元素不会与任何元素发生叠加，也包括它的子元素</li>
<li>创建了 BFC 的元素不会和它的子元素发生外边距叠加</li>
<li>绝对定位元素和其他任何元素之间不发生外边距叠加，也包括它的子元素</li>
<li>inline-block 元素和其他任何元素之间不发生外边距叠加，也包括它的子元素</li>
<li>普通流中的块级元素的 margin-bottom 永远和它相邻的下一个块级元素的 margin-top 叠加，除非相邻的兄弟元素 clear</li>
<li>普通流中的块级元素（没有 border-top、没有 padding-top）的 margin-top 和它的第一个普通流中的子元素（没有clear）发生 margin-top 叠加</li>
<li>普通流中的块级元素（height为 auto、min-height为0、没有 border-bottom、没有 padding-bottom）和它的最后一个普通流中的子元素（没有自身发生margin叠加或clear）发生 margin-bottom叠加</li>
<li>如果一个元素的 min-height 为0、没有 border、没有padding、高度为0或者auto、不包含子元素，那么它自身的外边距会发生叠加</li>
</ul>
<p>以上就是外边距叠加的主要内容。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array --6.Min Cost Climbing Stairs]]></title>
      <url>/2018/01/25/leetCode/6.Min_Cost_Climbing_Stairs/</url>
      <content type="html"><![CDATA[<h2 id="Problem-six-Min-Cost-Climbing-Stairs"><a href="#Problem-six-Min-Cost-Climbing-Stairs" class="headerlink" title="Problem six: Min Cost Climbing Stairs"></a>Problem six: Min Cost Climbing Stairs</h2><p>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).</p>
<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> cost = [10, 15, 20]<br>  <strong>Output:</strong> 15<br>  <strong>Explanation:</strong> Cheapest is start on cost[1], pay that cost and go to the top.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>  <strong>Output:</strong> 6<br>  <strong>Explanation:</strong> Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>cost will have a length in the range [2, 1000].</li>
<li>Every cost[i] will be an integer in the range [0, 999].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.第一眼看这道题，显然是一道递归题，照着这个思路做很容易就做出来了。</p>
<pre><code>var minCostClimbingStairs = function(cost) {
    for(var i=2;i&lt;=cost.length-1;i++){
        cost[i]=cost[i]+Math.min(cost[i-1],cost[i-2]);
    }

    return Math.min(cost[cost.length-1],cost[cost.length-2]);

};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<ol>
<li>同理，也有一种类似的解法，三个元素三个元素的比较，最后一个元素的最小值就是前两个元素的最小值加上对应的值。<pre><code>var minCostClimbingStairs = function(cost) {
 var firstElement = 0, secondElement = 0, thirdElement = 0;
  for(var i=2;i &lt;= cost.length;i++){
      thirdElement = Math.min(secondElement + cost[i-1], firstElement + cost[i-2]);
      firstElement = secondElement;
      secondElement = thirdElement;
  }
  return thirdElement;
};
</code></pre>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</li>
</ol>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 5.Largest Number At Least Twice of Others]]></title>
      <url>/2018/01/25/leetCode/5.Largest_Number_At_Least_Twice_of_Others/</url>
      <content type="html"><![CDATA[<h2 id="Problem-five-Largest-Number-At-Least-Twice-of-Others"><a href="#Problem-five-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="Problem five: Largest Number At Least Twice of Others"></a>Problem five: Largest Number At Least Twice of Others</h2><p>In a given integer array nums, there is always exactly one largest element.</p>
<p>Find whether the largest element in the array is at least twice as much as every other number in the array.</p>
<p>If it is, return the index of the largest element, otherwise return -1.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [3, 6, 1, 0]<br>  <strong>Output:</strong> 1<br>  <strong>Explanation:</strong> 6 is the largest integer, and for every other number in the array x,<br>    6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [1, 2, 3, 4]<br>  <strong>Output:</strong> -1<br>  <strong>Explanation:</strong> 4 isn’t at least as big as twice the value of 3, so we return -1.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>nums will have a length in the range [1, 50].</li>
<li>Every nums[i] will be an integer in the range [0, 99].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.最开始想到的是用sort()函数来解决这个问题，但是需要注意两点：在sort函数中添加判断数字大小的函数，否则会将数字视为字符串，用最开始的数字进行排序；再一个就是在复制数组时，不能直接使用‘=’进行复制操作，因为这样其实传递的是数组地址，如果这样赋值，在对原先数组进行操作时，其实会对新建的数组进行修改。</p>
<pre><code>function sequence(a,b){
         if (a&gt;b) {
             return 1;
         }else if(a&lt;b){
              return -1
         }else{
             return 0;
        }
};
var dominantIndex = function(nums) {
    var nums_copy;
    nums_copy = [];
    for(var m = 0; m &lt; nums.length; m++) {
        nums_copy[m] = nums[m];
    }
    nums.sort(sequence);
    if(nums.length == 1)
        return 0;
    if(nums[nums.length - 2] &gt; 0) {
        if(nums[nums.length - 1]/nums[nums.length - 2] &gt;= 2) {
            for(var i = 0; i &lt; nums_copy.length; i++) {
                if(nums_copy[i] == nums[nums.length -1])
                    return i;
            }
        } else
            return -1;
    } else {
        for(var n = 0; n &lt; nums_copy.length; n++) {
            if(nums_copy[n] == nums[nums.length -1])
                return n;
        }
    }
};
</code></pre><p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度；</p>
<p>2.一开始以为上述方法比较简单，但实际写下来还有需要细节要注意，因此，先选出数组中的最大值，在与数组中的所有元素进行对比，当有元素大于nums[maxIndex]的1/2时，返回-1，否则返回该最大值下标。</p>
<pre><code>var dominantIndex = function(nums) {
    var maxIndex = 0;
        for (var i = 0; i &lt; nums.length; ++i) {
            if (nums[i] &gt; nums[maxIndex])
                maxIndex = i;
        }
        for (var i = 0; i &lt; nums.length; ++i) {
            if (maxIndex != i &amp;&amp; nums[maxIndex] &lt; 2 * nums[i])
                return -1;
        }
        return maxIndex;
};
</code></pre><p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度;</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 4.longest continuous increasing subsequence]]></title>
      <url>/2018/01/25/leetCode/4.longest_continuous_increasing_subsequence/</url>
      <content type="html"><![CDATA[<h2 id="Problem-four-longest-continuous-increasing-subsequence"><a href="#Problem-four-longest-continuous-increasing-subsequence" class="headerlink" title="Problem four: longest continuous increasing subsequence"></a>Problem four: longest continuous increasing subsequence</h2><p>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,3,5,4,7]<br>  <strong>Output:</strong> 3<br>  <strong>Explanation:</strong> The longest continuous increasing subsequence is [1,3,5], its length is 3.<br>  Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4. </p>
</blockquote>
<p>  <strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [2,2,2,2,2]<br>  <strong>Output:</strong> 1<br>  <strong>Explanation:</strong> The longest continuous increasing subsequence is [2], its length is 1.</p>
</blockquote>
<p><strong>Note:</strong> Length of the array will not exceed 10,000.</p>
<p><strong>solution:</strong></p>
<p>1.直观的想法是遍历数组时，当数字持续增加时用一个数字存储累加的总和，在减少时与另一个初始为0的数字对比，如果大于这个存放之前的最长长度的数字，则替换该值，并重置计数的大小。最后，比较最后一次累加数值的大小，返回最大值。</p>
<pre><code>var findLengthOfLCIS = function(nums) {
    var num = 1;
    var maxLength = 0;
    if(nums.length == 0)
        return 0;
    for(var i = 1; i &lt; nums.length;  i++) {
        if(nums[i] &gt; nums[i-1]) {
            num++;
        } else {
            if(num &gt; maxLength) {
                maxLength = num;
            }
            num = 1;
        }
    }
    if(num &gt; maxLength) 
        return num;
    else
        return maxLength;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.因为累加的子串是在nums[i-1] &gt;= nums[i]时发生变化的，也就是说我们将变化的元素下标记录下来，当前一个元素大于后一个元素时，将当前元素下标赋值给anchor，在累加的过程中，ans会用之前的最长串与现在的累加的串的长度作对比，保留最长串。</p>
<pre><code>var findLengthOfLCIS = function(nums) {
    var ans = 0;
    var anchor = 0;
        for (var i = 0; i &lt; nums.length; ++i) {
            if (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i])
                anchor = i;
            ans = Math.max(ans, i - anchor + 1);
        }
        return ans;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Array -- 3.Best Time to Buy and Sell Stock]]></title>
      <url>/2018/01/23/leetCode/3.Best_Time_to_Buy_and_sell_stock/</url>
      <content type="html"><![CDATA[<h2 id="Problem-three-Best-Time-to-Buy-and-Sell-Stock"><a href="#Problem-three-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Problem three: Best Time to Buy and Sell Stock"></a>Problem three: Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [7, 1, 5, 3, 6, 4]<br><strong>Output:</strong> 5<br>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [7, 6, 4, 3, 1]<br><strong>Output:</strong> 0<br>In this case, no transaction is done, i.e. max profit = 0.</p>
</blockquote>
<p><strong>solution:</strong></p>
<p>1.这道题主要考察的是边界条件的判断，首先，将第二个元素与第一个元素进行对比，如果第二个元素大，则设置maxProfit，minPrice和maxPrice，如果第一个元素大，设置maxPrice，minPrice。若不为前两个元素，需要考虑下一个元素与之前最小的元素比较是否会大于之前的maxProfit，若大于，则设置maxProfit和maxPrice，否则设置minPrice。以此类推，最后返回maxProfit。</p>
<pre><code>var maxProfit = function(prices) {
    var maxProfit = 0;
    var maxPrice = 0;
    var minPrice = 0;
    for(var i = 1; i &lt; prices.length; i++) {
        if(i == 1) {
            if((prices[i] - prices[i-1]) &gt; maxProfit) {
                maxProfit = prices[i] - prices[i-1];
                minPrice = prices[i - 1];
                maxPrice = prices[i];
            } 
            else {
                minPrice = prices[i];
                maxPrice = prices[i-1];
            }
        }else {
            if((prices[i] - minPrice) &gt; maxProfit) {
                maxProfit = prices[i] - minPrice;
                maxPrice = prices[i];
            }
            else{
                if(minPrice &gt; prices[i]) {
                    minPrice = prices[i];  
                }
            }
        }
    }
    return maxProfit;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.接下来换一种思想比较简单的方法，现在需要找到最大的差值，且大的数在后面，小的数在前面，所以，可以两层嵌套，比较元素后面的值并选出最大的值。</p>
<pre><code>var maxProfit = function(prices) {
     var maxprofit = 0;
        for (var i = 0; i &lt; prices.length - 1; i++) {
            for (var j = i + 1; j &lt; prices.length; j++) {
                var profit = prices[j] - prices[i];
                if (profit &gt; maxprofit)
                    maxprofit = profit;
            }
        }
        return maxprofit;
  };
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), 循环n(n-1)/2遍，效果很差。</p>
<p>3.接下来的方法和第一种类似，先去一个特别大的最小值和特别大的最大值，然后进行遍历，若当前元素小于最小值，则替换最小值，否则就与最小值比较，若大于最大差值，则替换最大差值。这个方法与第一种比不需要保存最大值。</p>
<pre><code>var maxProfit = function(prices) {
     var minprice = 9999999;
     var maxprofit = 0;
        for (var i = 0; i &lt; prices.length; i++) {
            if (prices[i] &lt; minprice)
                minprice = prices[i];
            else if (prices[i] - minprice &gt; maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
  };
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Array -- 2.Remove Element]]></title>
      <url>/2018/01/23/leetCode/2.remove_element/</url>
      <content type="html"><![CDATA[<h2 id="Problem-two-Remove-Element"><a href="#Problem-two-Remove-Element" class="headerlink" title="Problem two: Remove Element"></a>Problem two: Remove Element</h2><p>Given an array and a value, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example:</strong></p>
<blockquote>
<p>Given <strong>nums</strong> = [3,2,2,3], val = 3,</p>
</blockquote>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p><strong>solution:</strong></p>
<p>1.最直接的方法是使用数组自带的splice方法，需要注意的是当remove掉相符合的元素后，要将下标减一，不然会造成数组减少一个元素后，原元素后面的元素序号会提前一个，会忽略掉下一个元素。</p>
<pre><code>var removeElement = function(nums, val) {
    for(var i = 0; i&lt; nums.length; i++) {
        if(nums[i] == val) {
            nums.splice(i, 1);
            i -= 1;
        } 
    } 
    return nums.length;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.另一种方法是在遍历数组过程中，如果元素的值等于对应的value，则将当前元素与最后一个元素交换位置，然后将数组长度减1，变相的去除数组的重复项，可惜的是，这种方法和splice()消耗的时间几近相同。</p>
<pre><code>var removeElement = function(nums, val) {
    var i = 0;
    var num = nums.length;
    while (i &lt; num) {
        if (nums[i] == val) {
            nums[i] = nums[num - 1];
            num--;
        } else {
            i++;
        }
    }
    return num;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 1.Find Pivot Index]]></title>
      <url>/2018/01/23/leetCode/1.find_pivot_index/</url>
      <content type="html"><![CDATA[<h2 id="Problem-one-Find-Pivot-Index"><a href="#Problem-one-Find-Pivot-Index" class="headerlink" title="Problem one: Find Pivot Index"></a>Problem one: Find Pivot Index</h2><p>Given an array of integers nums, write a method that returns the “pivot” index of this array.</p>
<p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p>
<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br><strong>nums</strong> = [1, 7, 3, 6, 5, 6]<br><strong>Output</strong>: 3<br><strong>Explanation</strong>:<br>The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.<br>Also, 3 is the first index where this occurs.</p>
</blockquote>
<p><strong>Example</strong> 2:</p>
<blockquote>
<p><strong>Input:</strong><br><strong>nums</strong> = [1, 2, 3]<br><strong>Output</strong>: -1<br><strong>Explanation</strong>:<br>There is no index that satisfies the conditions in the problem statement.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The length of nums will be in the range [0, 10000].</li>
<li>Each element nums[i] will be an integer in the range [-1000, 1000].</li>
</ul>
<p><strong>solution:</strong></p>
<ol>
<li><p>直接想到的是遍历数组，将每个元素左侧的元素和与右侧元素和比较，相同则返回对应元素下标。（若第一个元素右侧和为0，则返回第一个元素下标）。否则返回-1；</p>
<pre><code>var pivotIndex = function(nums) {
 var leftSum = 0;
 var rightSum = 0;
 for(var i = 0; i &lt; nums.length; i++) {
     if(i == 0) {
         leftSum =0;
     }else{
         leftSum += nums[i-1];
     }
     for(var n = i+1; n &lt; nums.length; n++) {
         rightSum += nums[n];    
     }
     if(leftSum == rightSum) 
         return i;
     rightSum = 0;
 }
 return -1;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为nums的长度；</p>
</li>
<li><p>上一种方法的问题在于要用两遍for循环，时间复杂度过高，所以尽量减少嵌套：</p>
<pre><code class="javascript">var pivotIndex = function(nums) {
 var leftSum =0;
 var sum = 0;
 for(var i = 0; i&lt; nums.length; i++) 
     sum += nums[i];
  for (var n = 0; n &lt; nums.length; n++) {
     if (leftSum == (sum - leftSum - nums[n])) 
         return n;
     leftSum += nums[n];
 }
 return -1;
}
</code></pre>
<p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度；</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建github博客]]></title>
      <url>/2018/01/12/blog/%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="搭建github博客-amp-使用hexo博客框架-amp-使用material主题"><a href="#搭建github博客-amp-使用hexo博客框架-amp-使用material主题" class="headerlink" title="搭建github博客&amp;使用hexo博客框架&amp;使用material主题"></a>搭建github博客&amp;使用hexo博客框架&amp;使用material主题</h2><p>因为原先在CSDN上有各种各样的限制和难言之隐，所以在生庆哥的帮助和怂恿下，选择使用github搭建博客并个性化设置，主要说一下大体过程和期间的问题。主要的内容可以分为以下三类：</p>
<ul>
<li>搭建github博客</li>
<li>使用hexo框架</li>
<li>使用material主题</li>
</ul>
<h3 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h3><p>其实之前在学校的时候一直知道github看可以搭建博客，还可以直接使用对应的域名，但是出于各种原因一直没有自己搭建一个博客尝试尝试，终于，现在正好有时间和精力可以试试。<br>在个人github首页上，创建一个github.io的框架，即个人账户+仓库名，如：lpldplws.github.io。因为此仓库就是用来放博客的，所以在master分支上开发，然后在setting页面中选择launch automatic page generator生成博客项目。然后将该项目clone到本地，最初的博客就搭建成了~</p>
<p>个人博客地址是<a href="https://github.com/lpldplws/lpldplws.github.io" target="_blank" rel="noopener">lpldplws.github.io</a>。<br>接下来要做的就是redirect到自己的域名，在阿里上买了一个29一年的域名，名字是<a href="http://www.lpldplws.cn">lpldplws.cn</a>,需要做的是在clone下的项目的根目录下建立好映射，创建一个”CNAME”（没有后缀名）的文件，之后访问lpldplws.github.io就会redirect到此域名，或者您在对应的域名服务商上面修改CNAME到对应的github仓库地址也是可以的。<br>注意：此处因为是直接在master分支上创建的，之后也是在master分支上使用的框架和主题，导致最后hexo generate的内容保存到了github.io中，这部分是接下来一周需要解决的问题之一。</p>
<h3 id="使用hexo框架"><a href="#使用hexo框架" class="headerlink" title="使用hexo框架"></a>使用hexo框架</h3><p>之所以知道这个框架是因为咱们的FE团队的翻译框架就是这个，所以此处借鉴了以下，嘿嘿。<br>在<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>上,介绍了这是一个简单高效的博客框架，在github.io仓库中，使用npm安装即可。虽然可以支持markdown的格式，但是其自带的tag也是非常方便的，我看还可以使用youtube视频，厉害了，这理所当然的成为下周需要学习的内容之一了。<br>还有一个比较深的体会是使用hexo的感觉就像开发机一样，通过hexo server相当于在开发机上查看效果，使用hexo generate和hexo deploy相当于部署在线上环境，就是少了review的部分，不过对于一个个人博客来说还是比较完善的了。</p>
<h3 id="使用material主题"><a href="#使用material主题" class="headerlink" title="使用material主题"></a>使用material主题</h3><p>使用hexo默认界面当然不能满足自己的审美了，在一番选择（选择恐惧症）后，终于选(sui)择(ji)了一个比较好看的theme，这就是<a href="https://material.viosey.com/" target="_blank" rel="noopener">material</a>，这个主题比较素雅，正好很吸引我~以下主要说明material主题配置中遇到的问题。其中主要的配置文件在<code>config.template.yaml</code>中，不过需要先将其改名为<code>config.yaml</code>。在页面配置中，按照流程可以选择对应的插件和效果，比较吸引人的是它的背景可以从必应上选择，后来因为颜色不匹配主题就去掉了，个人打算通过对选项加一个filter或者下到对应文件随机加载是个不错的选择，所以下周又新加了一项任务。还有一点就是评论系统和统计系统，个人选择的是<code>Valine</code>，因为考虑到可以使用对应后台查看信息，不过缺点就是有点丑。。。后来生庆哥说Google的后台数据处理用的人很多，所以打算抛弃当前评论系统，投入其他评论系统的怀抱。<br>对于独立页面部分还没有怎么看，下周来吧，除此之外，除了在mobile上效果还行，pc上两端有点空，所以想加一个音乐播放器，这部分打算选择网易云的api，实现一个音乐播放的效果。其他的内容就慢慢补全吧，这周过的虽然很累但还是很充实，个人也应该静下心来，虽然很多不会，但是相信通过付出比别人更多的努力，一定快速达到可以帮助到胡老师和FE团队的地步，fighting！</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
  
</search>
