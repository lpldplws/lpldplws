<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[leetCode String -- 11.Rotated Digits]]></title>
    <url>%2F2018%2F08%2F02%2FleetCode%2Fstring%2F11.rotated_digits%2F</url>
    <content type="text"><![CDATA[Rotated DigitsX is a good number if after rotating each digit individually by 180 degrees, we get a valid number that is different from X. Each digit must be rotated - we cannot choose to leave it alone. A number is valid if each digit remains a digit after rotation. 0, 1, and 8 rotate to themselves; 2 and 5 rotate to each other; 6 and 9 rotate to each other, and the rest of the numbers do not rotate to any other number and become invalid. Now given a positive number N, how many numbers X from 1 to N are good? Example:Input: 10Output: 4Explanation:There are four good numbers in the range [1, 10] : 2, 5, 6, 9.Note that 1 and 10 are not good numbers, since they remain unchanged after rotating. Note: N will be in range [1, 10000]. solutions: 1.本来以为是整个word rotate的，其实是单词的rotate。。那就简单很多了： 123456789101112/** * @param &#123;number&#125; N * @return &#123;number&#125; */var rotatedDigits = function(N) &#123; let count = 0; for(let i=1; i&lt;=N; i++)&#123; let tmp = i+''; if(!/[347]/g.test(tmp) &amp;&amp; /[2569]/g.test(tmp)) count++; &#125; return count;&#125;;]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode String -- 10.Count Binary Substrings]]></title>
    <url>%2F2018%2F08%2F02%2FleetCode%2Fstring%2F10.count_binary_substrings%2F</url>
    <content type="text"><![CDATA[Count Binary SubstringsGive a string s, count the number of non-empty (contiguous) substrings that have the same number of 0’s and 1’s, and all the 0’s and all the 1’s in these substrings are grouped consecutively. Substrings that occur multiple times are counted the number of times they occur. Example 1:Input: “00110011”Output: 6Explanation: There are 6 substrings that have equal number of consecutive 1’s and 0’s: “0011”, “01”, “1100”, “10”, “0011”, and “01”. Notice that some of these substrings repeat and are counted the number of times they occur. Also, “00110011” is not a valid substring because all the 0’s (and 1’s) are not grouped together. Example 2:Input: “10101”Output: 4Explanation: There are 4 substrings: “10”, “01”, “10”, “01” that have equal number of consecutive 1’s and 0’s. Note: s.length will be between 1 and 50,000. s will only consist of “0” or “1” characters. solutions: 选择变化的元素，开始左右扩展，如果都与对应的下标保持一致，则继续扩展: 1234567891011121314151617181920/** * @param &#123;string&#125; s * @return &#123;number&#125; */var countBinarySubstrings = function(s) &#123; s = s.split(''); count = 0, step = 1; s.map((letter, index) =&gt; &#123; if(s[index + 1] &amp;&amp; s[index] !== s[index + 1]) &#123; count++; while(s[index - step] &amp;&amp; s[index + 1 + step] &amp;&amp; s[index - step] === s[index] &amp;&amp; s[index + 1 + step] === s[index + 1]) &#123; count++; step++; &#125; step = 1; &#125; &#125;); return count;&#125;; 2.使用正则也是一个不错的方法： 1234567/** * @param &#123;string&#125; s * @return &#123;number&#125; */var countBinarySubstrings = (s) =&gt; s.replace(/01/g, '0,1').replace(/10/g, '1,0').split(',') .reduce((res, a, i, arr) =&gt; i ? res + Math.min(a.length, arr[--i].length) : 0, 0);]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode String -- 9.Detect Capital]]></title>
    <url>%2F2018%2F08%2F02%2FleetCode%2Fstring%2F09.detect_capital%2F</url>
    <content type="text"><![CDATA[Detect CapitalGiven a word, you need to judge whether the usage of capitals in it is right or not. We define the usage of capitals in a word to be right when one of the following cases holds: All letters in this word are capitals, like “USA”. All letters in this word are not capitals, like “leetcode”. Only the first letter in this word is capital if it has more than one letter, like “Google”. Otherwise, we define that this word doesn’t use capitals in a right way. Example 1:Input: “USA”Output: True Example 2:Input: “FlaG”Output: False Note: The input will be a non-empty word consisting of uppercase and lowercase latin letters. solutions: 1.先判断首字母的大小写，然后可以使用正则表达式，如果在首字母大写时，除去首字母有大小写不一样的情况，return false，在首字母小写的情况下，其余字母均为小写： 12345678910111213141516/** * @param &#123;string&#125; word * @return &#123;boolean&#125; */var detectCapitalUse = function(word) &#123; let capital = true; if(word[0] &gt; 'a' &amp;&amp; word[0] &lt; 'z') &#123; word.slice(1).split('').forEach((letter) =&gt; &#123; if(letter &lt;= 'Z') capital = false; &#125;); &#125; else &#123; if(!/^[A-Z]*$/.test(word.slice(1)) &amp;&amp; !/^[a-z]*$/.test(word.slice(1))) capital = false; &#125; return capital;&#125;; 记录大小写的所有值，根据word中含有的大小写的数量返回： 12345678910111213141516/** * @param &#123;string&#125; word * @return &#123;boolean&#125; */var detectCapitalUse = function(word) &#123; let capitalCounter = 0; let smallCounter = 0; for(let i =0; i&lt;word.length;i++) &#123; if (word[i] &gt;= 'A' &amp;&amp; word[i] &lt;= 'Z') capitalCounter ++ else smallCounter++ &#125; if(capitalCounter == word.length || smallCounter == word.length) return true; else if (word[0] &gt;= 'A' &amp;&amp; word[0] &lt;= 'Z' &amp;&amp; capitalCounter == 1) return true; return false&#125;;]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[14.weakmap]]></title>
    <url>%2F2018%2F08%2F01%2FpureMaterial%2F14.weakMaps%2F</url>
    <content type="text"><![CDATA[weakmapES6 WeakMapsYou can think of WeakMap as a subset of Map. There are a few limitations on WeakMap that we didn’t find in Map. The biggest limitation is that WeakMap is not iterable, as opposed to Map – that means there is no iterable protocol, no .entries(), no .keys(), no .values(), no .forEach() and no .clear(). Another “limitation” found in WeakMap as opposed to Map is that every key must be an object, and value types are not admitted as keys. Note that Symbol is a value type as well, and they’re not allowed either. 12345var map = new WeakMap()map.set(1, 2)// TypeError: 1 is not an object!map.set(Symbol(), 2)// TypeError: Invalid value used as weak map key This is more of a feature than an issue, though, as it enables map keys to be garbage collected when they’re only being referenced as WeakMap keys. Usually you want this behavior when storing metadata related to something like a DOM node, and now you can keep that metadata in a WeakMap. If you want all of those you could always use a regular Map as we explored earlier. You are still able to pass an iterable to populate a WeakMap through its constructor. 1var map = new WeakMap([[new Date(), 'foo'], [() =&gt; 'bar', 'baz']]) Just like with Map, you can use .has, .get, and .delete too. 123456789var date = new Date()var map = new WeakMap([[date, 'foo'], [() =&gt; 'bar', 'baz']])console.log(map.has(date))// &lt;- trueconsole.log(map.get(date))// &lt;- 'foo'map.delete(date)console.log(map.has(date))// &lt;- false Is This a Strictly Worse Map?I know! You must be wondering – why the hell would I use WeakMap when it has so many limitations when compared to Map? The difference that may make WeakMap worth it is in its name. WeakMap holds references to its keys weakly, meaning that if there are no other references to one of its keys, the object is subject to garbage collection. Use cases for WeakMap generally revolve around the need to specify metadata or extend an object while still being able to garbage collect it if nobody else cares about it. A perfect example might be the underlying implementation for process.on(&#39;unhandledRejection&#39;) which uses a WeakMap to keep track of promises that were rejected but no error handlers dealt with the rejection within a tick. Keeping data about DOM elements that should be released from memory when they’re no longer of interest is another very important use case, and in this regard using WeakMap is probably an even better solution to the DOM-related API caching solution we wrote about earlier using Map. In so many words then, no. WeakMap is not strictly worse than Map – they just cater to different use cases. ES6 SetsSets are yet another collection type in ES6. Sets are very similar to Map. To wit: Set is also iterable Set constructor also accepts an iterable Set also has a .size property Keys can also be arbitrary values Keys must be unique NaN equals NaN when it comes to Set too All of .keys, .values, .entries, .forEach, .get, .set, .has, .delete, and .clear However, there’s a few differences as well! Sets only have values No set.get – but why would you want get(value) =&gt; value? Having set.set would be weird, so we have set.add instead set[Symbol.iterator] !== set.entries set[Symbol.iterator] === set.values set.keys === set.values set.entries() returns an iterator on a sequence of items like [value, value] In the example below you can note how it takes an iterable with duplicate values, it can be spread over an Array using the spread operator, and how the duplicate value has been ignored. 123var set = new Set([1, 2, 3, 4, 4])console.log([...set])// &lt;- [1, 2, 3, 4] Sets may be a great alternative to work with DOM elements. The following piece of code creates a Set with all the &lt;div&gt; elements on a page and then prints how many it found. Then, we query the DOM again and call set.add again for every DOM element. Since they’re all already in the set, the .size property won’t change, meaning the set remains the same. 12345678910function divs () &#123; return [...document.querySelectorAll('div')]&#125;var set = new Set(divs())console.log(set.size)// &lt;- 56divs().forEach(div =&gt; set.add(div))console.log(set.size)// &lt;- 56// &lt;- look at that, no duplicates! ES6 WeakSetsMuch like with WeakMap and Map, WeakSet is Set plus weakness minus the iterability – I just made that term up, didn’t I? That means you can’t iterate over WeakSet. Its values must be unique object references. If nothing else is referencing a value found in a WeakSet, it’ll be subject to garbage collection. Much like in WeakMap, you can only .add, .has, and .delete values from a WeakSet. And just like in Set, there’s no .get. 123var set = new WeakSet()set.add(&#123;&#125;)set.add(new Date()) As we know, we can’t use primitive values. 123var set = new WeakSet()set.add(Symbol())// TypeError: invalid value used in weak set Just like with WeakMap, passing iterators to the constructor is still allowed even though a WeakSet instance is not iterable itself. 1var set = new WeakSet([new Date(), &#123;&#125;, () =&gt; &#123;&#125;, [1]]) Use cases for WeakSet vary, and here’s one from a thread on es-discuss – the mailing list for the ECMAScript-262 specification of JavaScript. 1234567891011const foos = new WeakSet()class Foo &#123; constructor() &#123; foos.add(this) &#125; method () &#123; if (!foos.has(this)) &#123; throw new TypeError('Foo.prototype.method called on incompatible object!') &#125; &#125;&#125; As a general rule of thumb, you can also try and figure out whether a WeakSet will do when you’re considering to use a WeakMap as some use cases may overlap. Particularly, if all you need to check for is whether a reference value is in the WeakSet or not. Next week we’ll be having Proxy for brunch :)]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode String -- 8. Goat Latin]]></title>
    <url>%2F2018%2F08%2F01%2FleetCode%2Fstring%2F08.goat_latin%2F</url>
    <content type="text"><![CDATA[Goat LatinA sentence S is given, composed of words separated by spaces. Each word consists of lowercase and uppercase letters only. We would like to convert the sentence to “Goat Latin” (a made-up language similar to Pig Latin.) The rules of Goat Latin are as follows: If a word begins with a vowel (a, e, i, o, or u), append “ma” to the end of the word.For example, the word ‘apple’ becomes ‘applema’. If a word begins with a consonant (i.e. not a vowel), remove the first letter and append it to the end, then add “ma”.For example, the word “goat” becomes “oatgma”. Add one letter ‘a’ to the end of each word per its word index in the sentence, starting with 1.For example, the first word gets “a” added to the end, the second word gets “aa” added to the end and so on.Return the final sentence representing the conversion from S to Goat Latin. Example 1:Input: “I speak Goat Latin”Output: “Imaa peaksmaaa oatGmaaaa atinLmaaaaa” Example 2:Input: “The quick brown fox jumped over the lazy dog”Output: “heTmaa uickqmaaa rownbmaaaa oxfmaaaaa umpedjmaaaaaa overmaaaaaaa hetmaaaaaaaa azylmaaaaaaaaa ogdmaaaaaaaaaa” Notes: S contains only uppercase, lowercase and spaces. Exactly one space between each word. 1 &lt;= S.length &lt;= 150. solutions: 1.]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[13.map]]></title>
    <url>%2F2018%2F08%2F01%2FpureMaterial%2F13.map%2F</url>
    <content type="text"><![CDATA[mapBefore ES6, There Were Hash-MapsA very common _ab_use case of JavaScript objects is hash-maps, where we map string keys to arbitrary values. For example, one might use an object to map npm package names to their metadata, like so: 12345678910var registry = &#123;&#125;function add (name, meta) &#123; registry[name] = meta&#125;function get (name) &#123; return registry[name]&#125;add('contra', &#123; description: 'Asynchronous flow control' &#125;)add('dragula', &#123; description: 'Drag and drop' &#125;)add('woofmark', &#123; description: 'Markdown and WYSIWYG editor' &#125;) There’s several issues with this approach, to wit: Security issues where user-provided keys like __proto__, toString, or anything in Object.prototype break expectations and make interaction with these kinds of hash-map data structures more cumbersome Iteration over list items is verbose with Object.keys(registry).forEach or implementing the iterable protocol on the registry Keys are limited to strings, making it hard to create hash-maps where you’d like to index values by DOM elements or other non-string references The first problem could be fixed using a prefix, and being careful to always get or set values in the hash-map through methods. It would be even better to use ES6 proxies, but we won’t be covering those until tomorrow! 12345678910var registry = &#123;&#125;function add (name, meta) &#123; registry['map:' + name] = meta&#125;function get (name) &#123; return registry['map:' + name]&#125;add('contra', &#123; description: 'Asynchronous flow control' &#125;)add('dragula', &#123; description: 'Drag and drop' &#125;)add('woofmark', &#123; description: 'Markdown and WYSIWYG editor' &#125;) Luckily for us, though, ES6 maps provide us with an even better solution to the key-naming security issue. At the same time they facilitate collection behaviors out the box that may also come in handy. Let’s plunge into their practical usage and inner workings. ES6 MapsMap is a key/value data structure in ES6. It provides a better data structure to be used for hash-maps. Here’s how what we had earlier looks like with ES6 maps. 1234var map = new Map()map.set('contra', &#123; description: 'Asynchronous flow control' &#125;)map.set('dragula', &#123; description: 'Drag and drop' &#125;)map.set('woofmark', &#123; description: 'Markdown and WYSIWYG editor' &#125;) One of the important differences is also that you’re able to use anything for the keys. You’re not just limited to primitive values like symbols, numbers, or strings, but you can even use functions, objects and dates – too. Keys won’t be casted to strings like with regular objects, either. 1234var map = new Map()map.set(new Date(), function today () &#123;&#125;)map.set(() =&gt; 'key', &#123; pony: 'foo' &#125;)map.set(Symbol('items'), [1, 2]) You can also provide Map objects with any object that follows the iterable protocol and produces a collection such as [[&#39;key&#39;, &#39;value&#39;], [&#39;key&#39;, &#39;value&#39;]]. 12345var map = new Map([ [new Date(), function today () &#123;&#125;], [() =&gt; 'key', &#123; pony: 'foo' &#125;], [Symbol('items'), [1, 2]]]) The above would be effectively the same as the following. Note how we’re using destructuring in the parameters of items.forEach to effortlessly pull the key and value out of the two-dimensional item. 1234567var items = [ [new Date(), function today () &#123;&#125;], [() =&gt; 'key', &#123; pony: 'foo' &#125;], [Symbol('items'), [1, 2]]]var map = new Map()items.forEach(([key, value]) =&gt; map.set(key, value)) Of course, it’s kind of silly to go through the trouble of adding items one by one when you can just feed an iterable to your Map. Speaking of iterables – Map adheres to the iterable protocol. It’s very easy to pull a key-value pair collection much like the ones you can feed to the Map constructor. Naturally, we can use the spread operator to this effect. 1234567var map = new Map()map.set('p', 'o')map.set('n', 'y')map.set('f', 'o')map.set('o', '!')console.log([...map])// &lt;- [['p', 'o'], ['n', 'y'], ['f', 'o'], ['o', '!']] You could also use a for..of loop, and we could combine that with destructuring to make it seriously terse. Also, remember template literals? 123456789101112var map = new Map()map.set('p', 'o')map.set('n', 'y')map.set('f', 'o')map.set('o', '!')for (let [key, value] of map) &#123; console.log(`$&#123;key&#125;: $&#123;value&#125;`) // &lt;- 'p: o' // &lt;- 'n: y' // &lt;- 'f: o' // &lt;- 'o: !'&#125; Even though maps have a programmatic API to add items, keys are unique, just like with hash-maps. Setting a key over and over again will only overwrite its value. 123456var map = new Map()map.set('a', 'a')map.set('a', 'b')map.set('a', 'c')console.log([...map])// &lt;- [['a', 'c']] In ES6 Map, NaN becomes a “corner-case” that gets treated as a value that’s equal to itself even though the following expression actually evaluates to true – NaN !== NaN. 1234567console.log(NaN === NaN)// &lt;- falsevar map = new Map()map.set(NaN, 'foo')map.set(NaN, 'bar')console.log([...map])// &lt;- [[NaN, 'bar']] Hash-Maps and the DOMIn ES5, whenever we had a DOM element we wanted to associate with an API object for some library, we had to follow a verbose and slow pattern like the one below. The following piece of code just returns an API object with a bunch of methods for a given DOM element, allowing us to put and remove DOM elements from the cache, and also allowing us to retrieve the API object for a DOM element – if one already exists. 123456789101112131415161718192021222324252627282930313233var cache = []function put (el, api) &#123; cache.push(&#123; el: el, api: api &#125;)&#125;function find (el) &#123; for (i = 0; i &lt; cache.length; i++) &#123; if (cache[i].el === el) &#123; return cache[i].api &#125; &#125;&#125;function destroy (el) &#123; for (i = 0; i &lt; cache.length; i++) &#123; if (cache[i].el === el) &#123; cache.splice(i, 1) return &#125; &#125;&#125;function thing (el) &#123; var api = find(el) if (api) &#123; return api &#125; api = &#123; method: method, method2: method2, method3: method3, destroy: destroy.bind(null, el) &#125; put(el, api) return api&#125; One of the coolest aspects of Map, as I’ve previously mentioned, is the ability to index by DOM elements. The fact that Map also has collection manipulation abilities also greatly simplifies things. 123456789101112131415161718192021222324var cache = new Map()function put (el, api) &#123; cache.set(el, api)&#125;function find (el) &#123; return cache.get(el)&#125;function destroy (el) &#123; cache.delete(el)&#125;function thing (el) &#123; var api = find(el) if (api) &#123; return api &#125; api = &#123; method: method, method2: method2, method3: method3, destroy: destroy.bind(null, el) &#125; put(el, api) return api&#125; The fact that these methods have now become one liners means we can just inline them, as readability is no longer an issue. We just went from ~30 LOC to half that amount. Needless to say, at some point in the future this will also perform much faster than the haystack alternative. 123456789101112131415var cache = new Map()function thing (el) &#123; var api = cache.get(el) if (api) &#123; return api &#125; api = &#123; method: method, method2: method2, method3: method3, destroy: () =&gt; cache.delete(el) &#125; cache.set(el, api) return api&#125; The simplicity of Map is amazing. If you ask me, we desperately needed this feature in JavaScript. Being to index a collection by arbitrary objects is super important. What else can we do with Map? Collection Methods in MapMaps make it very easy to probe the collection and figure out whether a key is defined in the Map. As we noted earlier, NaN equals NaN as far as Map is concerned. However, Symbol values are always different, so you’ll have to use them by value! 123456789var map = new Map([[NaN, 1], [Symbol(), 2], ['foo', 'bar']])console.log(map.has(NaN))// &lt;- trueconsole.log(map.has(Symbol()))// &lt;- falseconsole.log(map.has('foo'))// &lt;- trueconsole.log(map.has('bar'))// &lt;- false As long as you keep a Symbol reference around, you’ll be okay. Keep your references close, and your Symbols closer? 1234var sym = Symbol()var map = new Map([[NaN, 1], [sym, 2], ['foo', 'bar']])console.log(map.has(sym))// &lt;- true Also, remember the no key-casting thing? Beware! We are so used to objects casting keys to strings that this may bite you if you’re not careful. 12345var map = new Map([[1, 'a']])console.log(map.has(1))// &lt;- trueconsole.log(map.has('1'))// &lt;- false You can also clear a Map entirely of entries without losing a reference to it. This can be very handy sometimes. 123456var map = new Map([[1, 2], [3, 4], [5, 6]])map.clear()console.log(map.has(1))// &lt;- falseconsole.log([...map])// &lt;- [] When you use Map as an iterable, you are actually looping over its .entries(). That means that you don’t need to explicitly iterate over .entries(). It’ll be done on your behalf anyways. You do remember Symbol.iterator, right? 12console.log(map[Symbol.iterator] === map.entries)// &lt;- true Just like .entries(), Map has two other iterators you can leverage. These are .keys() and .values(). I’m sure you guessed what sequences of values they yield, but here’s a code snippet anyways. 12345var map = new Map([[1, 2], [3, 4], [5, 6]])console.log([...map.keys()])// &lt;- [1, 3, 5]console.log([...map.values()])// &lt;- [2, 4, 6] Maps also come with a read-only .size property that behaves sort of like Array.prototype.length – at any point in time it gives you the current amount of entries in the map. 123456789var map = new Map([[1, 2], [3, 4], [5, 6]])console.log(map.size)// &lt;- 3map.delete(3)console.log(map.size)// &lt;- 2map.clear()console.log(map.size)// &lt;- 0 One more aspect of Map that’s worth mentioning is that their entries are always iterated in insertion order. This is in contrast with Object.keys loops which follow an arbitrary order. The for..in statement iterates over the enumerable properties of an object, in arbitrary order. Maps also have a .forEach method that’s identical in behavior to that in ES5 Array objects. Once again, keys do not get casted into strings here. 12345var map = new Map([[NaN, 1], [Symbol(), 2], ['foo', 'bar']])map.forEach((value, key) =&gt; console.log(key, value))// &lt;- NaN 1// &lt;- Symbol() 2// &lt;- 'foo' 'bar' Get up early tomorrow morning, we’ll be having WeakMap, Set, and WeakSet for breakfast :)]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode String -- 7.Longest Uncommon Subsequence I]]></title>
    <url>%2F2018%2F08%2F01%2FleetCode%2Fstring%2F07.longest_uncommon_subsequence_I%2F</url>
    <content type="text"><![CDATA[Longest Uncommon Subsequence IGiven a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings. A subsequence is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string. The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1. Example 1:Input: “aba”, “cdc”Output: 3Explanation: The longest uncommon subsequence is “aba” (or “cdc”),because “aba” is a subsequence of “aba”,but not a subsequence of any other strings in the group of two strings. Note: Both strings’ lengths will not exceed 100. Only letters from a ~ z will appear in input strings. solutions: 这就是个文字游戏。。。取两个字符串之间的最大值即可,毕竟是最长的非公共子串： 123456789/** * @param &#123;string&#125; a * @param &#123;string&#125; b * @return &#123;number&#125; */var findLUSlength = function(a, b) &#123; if (a === b) return -1; else return Math.max(a.length, b.length);&#125;;]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode String -- 6.flip game]]></title>
    <url>%2F2018%2F08%2F01%2FleetCode%2Fstring%2F06.flip_game%2F</url>
    <content type="text"><![CDATA[You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip twoconsecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner. Write a function to compute all possible states of the string after one valid move. For example, given s = “++++”, after one move, it may become one of the following states: 12345[ "--++", "+--+", "++--"] If there is no valid move, return an empty list []. solution： 感觉没有特别好的办法，只能遍历，当下一个元素跟上一个元素相等时，可以输出一个表达式： 1234567891011121314/*** @param &#123;string&#125; s* @return &#123;string&#125;**/var generatePossibleNextMoves = function(s) &#123; let b = [], c = s.split(''); for(let i = 1; i&lt; c.length; i++) &#123; if(c[i] === '+' &amp;&amp; c[i - 1] === '+') &#123; b.push(s.substr(0,i-1) + '--' + s.substr(i+1)); &#125; &#125; return b;&#125;;]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[12.promises]]></title>
    <url>%2F2018%2F08%2F01%2FpureMaterial%2F12.promises%2F</url>
    <content type="text"><![CDATA[promises Promises are a very involved paradigm, so we’ll take it slow. Here’s a table of contents with the topics we’ll cover in this article. Feel free to skip topics you’re comfortable about. What is a Promise? – we define Promise and look at a simple example in JavaScript Callbacks and Events – alternative ways to handle asynchronous code flows Gist of a Promise – a first glimpse at how promises work Promises in Time – a brief history of promises Then, Again – an analysis of .then and .catch Creating a Promise From Scratch Settling a Promise – discusses states of a Promise Paying a Promise with another Promise – explains promise chaining Transforming Values in Promises – shows how to turn a result into something else in the context of promises Leveraging Promise.all and Promise.race Shall we? What is a Promise?Promises are usually vaguely defined as “a proxy for a value that will eventually become available”. They can be used for both synchronous and asynchronous code flows, although they make asynchronous flows easier to reason about – once you’ve mastered promises, that is. Consider as an example the upcoming fetch API. This API is a simplification of XMLHttpRequest. It aims to be super simple to use for the most basic use cases: making a GET request against a resource relative to the current page over http(s) – it also provides a comprehensive API that caters to advanced use cases as well, but that’s not our focus for now. In it’s most basic incarnation, you can make a request for GET foo like so. 1fetch('foo') The fetch(&#39;foo&#39;) statement doesn’t seem all that exciting. It makes a “fire-and-forget” GET request against foo relative to the resource we’re currently on. The fetch method returns a Promise. You can chain a .then callback that will be executed once the foo resource finishes loading. 1fetch('foo').then(response =&gt; /* do something */) Promises offer an alternative to callbacks and events. Callbacks and EventsIf the fetch API used callbacks, you’d get one last parameter that then gets executed whenever fetching ends. Typical asynchronous code flow conventions dictate that we allocate the first parameter for errors (that may or may not occur) during the fetching process. The rest of the parameters can be used to pass in resulting data. Often, a single parameter is used. 123456fetch('foo', (err, res) =&gt; &#123; if (err) &#123; // handle error &#125; // handle response&#125;) The callback wouldn’t be invoked until the foo resource has been fetched, so its execution remains asynchronous and non-blocking. Note that in this model you could only specify a single callback, and that callback would be responsible for all functionality derived from the response. Another option might have been to use an event-driven API model. In this model the object returned by fetch would be able to listen .on events, binding as many event handlers as needed for any events. Typically there’s an error event for when things go awry and a data event that’s called when the operation completes successfully. 1234567fetch('foo') .on('error', err =&gt; &#123; // handle error &#125;) .on('data', res =&gt; &#123; // handle response &#125;) In this case, errors usually end up in hard exceptions if no event listener is attached – but that depends on what event emitter implementation is used. Promises are a bit different. Gist of a PromiseInstead of binding event listeners through .on, promises offer a slightly different API. The snippet of code shown below displays the actual API of the fetch method, which returns a Promise object. Much like with events, you can bind as many listeners as you’d like with both .catch and .then. Note how there’s no need for an event type anymore with the declarative methods used by promises. 1234567var p = fetch('foo')p.then(res =&gt; &#123; // handle response&#125;)p.catch(error =&gt; &#123; // handle error&#125;) See [this example][(http://buff.ly/1KtWGUD)] on Promisees Also note that .then is able to register a reaction to rejections as its second argument. The above could be expressed as the following piece of code. 123456789fetch('foo') .then( res =&gt; &#123; // handle response &#125;, err =&gt; &#123; // handle error &#125; ) See [this example][(http://buff.ly/1V8xpHI)] on Promisees Just like you can omit the error reaction in .then(fulfillment), you can also omit the reaction to fulfillment. Using .then(null, rejection) is equivalent to .catch(rejection). Note that .then and .catch return a new promise every time. That’s important because chaining can have wildly different results depending on where you append a .then or a .catch call onto. See the following example to understand the difference. We’ll get more in depth into these two methods in a bit. Let’s look at a brief history of promises before doing that. Promises in TimePromises aren’t all that new. Like most things in computer science, the earliest mention of Promises can be traced all the way back to the late seventies. According to the Internet, they made their first appearance in JavaScript in 2007 – in a library called MochiKit. Then Dojo adopted it, and jQuery followed shortly after that. Then the Promises/A+ specification came out from the CommonJS group (now famous for their CommonJS module specification). In its earliest incarnations, Node.js shipped with promises. Some time later, they were removed from core and everyone switched over to callbacks. Now, promises ship with the ES6 standard and V8 has already implemented them a while back. The ES6 standard implements Promises/A+ natively. In the latest versions of Node.js you can use promises without any libraries. They’re also available on Chrome 32+, Firefox 29+, and Safari 7.1+. Shall we go back to the Promise API? Then, AgainGoing back to our example – here’s some of the code we had. In the simplest use case, this is all we wanted. 123fetch('foo').then(res =&gt; &#123; // handle response&#125;) What if an error happens in one of the reactions passed to .then? You can catch those with .catch. The example in the snippet below logs the error caught when trying to access prop from the undefined a property in res. 1234fetch('foo') .then(res =&gt; res.a.prop.that.does.not.exist) .catch(err =&gt; console.error(err.message))// &lt;- 'Cannot read property "prop" of undefined' Note that where you tack your reactions onto matters. The following example won’t print the err.message twice – only once. That’s because no errors happened in the first .catch, so the rejection branch for that promise wasn’t executed. Check out the Promisee for a visual explanation of the code below. 12345fetch('foo') .then(res =&gt; res.a.prop.that.does.not.exist) .catch(err =&gt; console.error(err.message)) .catch(err =&gt; console.error(err.message))// &lt;- 'Cannot read property "prop" of undefined' In contrast, the snippet found below will print the err.message twice. It works by saving a reference to the promise returned by .then, and then tacking two .catch reactions onto it. The second .catch in the previous example was capturing errors produced in the promise returned from the first .catch, while in this case both .catch branch off of p. 12345var p = fetch('foo').then(res =&gt; res.a.prop.that.does.not.exist)p.catch(err =&gt; console.error(err.message))p.catch(err =&gt; console.error(err.message))// &lt;- 'Cannot read property "prop" of undefined'// &lt;- 'Cannot read property "prop" of undefined' Here’s another example that puts that difference the spotlight. The second catch is triggered this time because it’s bound to the rejection branch on the first .catch. 12345fetch('foo') .then(res =&gt; res.a.prop.that.does.not.exist) .catch(err =&gt; &#123; throw new Error(err.message) &#125;) .catch(err =&gt; console.error(err.message))// &lt;- 'Cannot read property "prop" of undefined' If the first .catch call didn’t return anything, then nothing would be printed. 12345fetch('foo') .then(res =&gt; res.a.prop.that.does.not.exist) .catch(err =&gt; &#123;&#125;) .catch(err =&gt; console.error(err.message))// nothing happens We should observe, then, that promises can be chained “arbitrarily”, that is to say: as we just saw, you can save a reference to any point in the promise chain and then tack more promises on top of it. This is one of the fundamental points to understanding promises. You can save a reference to any point in the promise chain. In fact, the last example can be represented as shown below. This snippet makes it much easier to understand what we’ve discussed so far. Glance over it and then I’ll give you some bullet points. 1234var p1 = fetch('foo')var p2 = p1.then(res =&gt; res.a.prop.that.does.not.exist)var p3 = p2.catch(err =&gt; &#123;&#125;)var p4 = p3.catch(err =&gt; console.error(err.message)) Good boy! Have some bullet points. Or you could just look at the Promisees visualization. fetch returns a brand new p1 promise p1.then returns a brand new p2 promise p2.catch returns a brand new p3 promise p3.catch returns a brand new p4 promise When p1 is settled (fulfilled), the p1.then reaction is executed After that p2, which is awaiting the pending result of p1.then is settled Since p2 was rejected, p2.catch reactions are executed (instead of the p2.then branch) The p3 promise from p2.catch is fulfilled, even though it doesn’t produce any value nor an error Because p3 succeeded, p3.catch is never executed – the p3.then branch would’ve been used instead You should think of promises as a tree structure. It all starts with a single promise, which we’ll later see how to construct. You then add a branch with .then or .catch. You can tack as many .then or .catch calls as you want onto each branch, creating new branches, and so on. Creating a Promise From ScratchYou should now understand how promises work like a tree where you can add branches where you need them, as you need them. But how do you create a promise from scratch? Writing these kinds of Promise tutorials is hard because its a chicken and egg situation. People hardly have a need to create a promise from scratch, since libraries usually take care of that. In this article, for instance, I purposely started explaining things using fetch, which internally creates a new promise object. Then, each call to .then or .catch on the promise created by fetch also creates a promise internally, and those promises depend on their parent when it comes to deciding whether the fulfillment branch or the rejection branch should be executed. Promises can be created from scratch by using new Promise(resolver). The resolver parameter is a method that will be used to resolve the promise. It takes two arguments, a resolve method and a reject method. These promises are fulfilled and rejected, respectively, on the next tick – as seen on Promisees. 12new Promise(resolve =&gt; resolve()) // promise is fulfillednew Promise((resolve, reject) =&gt; reject()) // promise is rejected Resolving and rejecting promises without a value isn’t that useful, though. Usually promises will resolve to some result, like the response from an AJAX call as we saw with fetch. Similarly, you’ll probably want to state the reason for your rejections – typically using an Error object. The code below codifies what you’ve just read (see the visualization, too). 12345678new Promise(resolve =&gt; resolve(&#123; foo: 'bar' &#125;)) .then(result =&gt; console.log(result)) // &lt;- &#123; foo: 'bar' &#125;new Promise((resolve, reject) =&gt; reject(new Error('failed to deliver on my promise to you'))) .catch(reason =&gt; console.log(reason)) // &lt;- Error: failed to deliver on my promise to you As you may have guessed, there’s nothing inherently synchronous about promises. Fulfillment and rejection can both be completely asynchronous. That’s the whole point of promises! The promise below is fulfilled after two seconds elapse. 1new Promise(resolve =&gt; setTimeout(resolve, 2000)) It’s important to note that only the first call made to either of these methods will have an impact – once a promise is settled, it’s result can’t change. The example below creates a promise that’s fulfilled in the alloted time or rejected after a generous timeout (visualization). 12345678function resolveUnderThreeSeconds (delay) &#123; return new Promise(function (resolve, reject) &#123; setTimeout(resolve, delay) setTimeout(reject, 3000) &#125;)&#125;resolveUnderThreeSeconds(2000) // resolves!resolveUnderThreeSeconds(7000) // fulfillment took so long, it was rejected. Besides returning resolution values, you could also resolve with another promise. What happens in those cases? In the following snippet we create a promise p that will be rejected in three seconds. We also create a promise p2 that will be resolved with p in a second. Since p is still two seconds out, resolving p2 won’t have an immediate effect. Two seconds later, when p is rejected, p2 will be rejected as well, with the same rejection reason that was provided to p. 123456789var p = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('fail')), 3000)&#125;)var p2 = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(p), 1000)&#125;)p2.then(result =&gt; console.log(result))p2.catch(error =&gt; console.log(error))// &lt;- Error: fail In the animation shown below we can observe how p2 becomes blocked – marked in yellow – waiting for a settlement in p. Note that this behavior is only possible for fulfillment branches using resolve. If you try to replicate the same behavior with reject you’ll find that the p2 promise is just rejected with the p promise as the rejection reason. Using Promise.resolve and Promise.rejectSometimes you want to create a Promise but you don’t want to go through the trouble of using the constructor. The following statement creates a promise that’s fulfilled with a result of &#39;foo&#39;. 1new Promise(resolve =&gt; resolve('foo')) If you already know the value a promise should be fulfilled with, you can use Promise.resolve instead. The following statement is equivalent to the previous one. 1Promise.resolve('foo') Similarly, if you already know the rejection reason, you can use Promise.reject. The next statement creates a promise that’s going to settle into a rejection, with reason. 1Promise.reject(reason) What else should we know about settling a promise? Settling a PromisePromises can exist in three states: pending, fulfilled, and rejected. Pending is the default state. From there, a promise can be “settled” into either fulfillment or rejection. Once a promise is settled, all reactions that are waiting on it are evaluated. Those on the correct branch – .then for fulfillment and .catch for rejections – are executed. From this point on, the promise is settled. If at a later point in time another reaction is chained onto the settled promise, the appropriate branch for that reaction is executed in the next tick of the program. In the example below, p is resolved with a value of 100 after two seconds. Then, 100 is printed onto the screen. Two seconds later, another .then branch is added onto p, but since p has already fulfilled, the new branch gets executed right away. 12345678var p = new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; resolve(100), 2000)&#125;)p.then(result =&gt; console.log(result))// &lt;- 100setTimeout(() =&gt; p.then(result =&gt; console.log(result * 20)), 4000)// &lt;- 2000 A promise can return another promise – this is what enables and powers most of their asynchronous behavior. In the previous section, when creating a promise from scratch, we saw that we can resolve with another promise. We can also return promises when calling .then. Paying a Promise with another PromiseThe example below shows how we use a promise and .then another promise that will only be settled once the returned promise also settles. Once that happens, we get back the response from the wrapped promise, and we use the res.url to figure out what random article we were graced with. 1234fetch('foo') .then(response =&gt; fetch('/articles/random')) .then(response =&gt; console.log(response.url))// &lt;- 'http://ponyfoo.com/articles/es6-symbols-in-depth' Obviously, in the real world, your second fetch would probably depend on the response from the first one. Here’s another example of returning a promise, where we randomly fulfill or reject after a second. 1234567var p = Promise.resolve() .then(data =&gt; new Promise(function (resolve, reject) &#123; setTimeout(Math.random() &gt; 0.5 ? resolve : reject, 1000) &#125;))p.then(data =&gt; console.log('okay!'))p.catch(data =&gt; console.log('boo!')) The animation for this one is super fun! Okay it’s not that fun. I did have fun making the Promisees tool itself! Transforming Values in PromisesYou’re not just limited to returning other promises from your .then and .catch callbacks. You could also return values, transforming what you had. The example below first creates a promise fulfilled with [1, 2, 3] and then has a fulfillment branch on top of that which maps thoes values into [2, 4, 6]. Calling .then on that branch of the promise will produce the doubled values. 1234Promise.resolve([1, 2, 3]) .then(values =&gt; values.map(value =&gt; value * 2)) .then(values =&gt; console.log(values)) // &lt;- [2, 4, 6] Note that you can do the same thing in rejection branches. An interesting fact that may catch your eye is that if a .catch branch goes smoothly without errors, then it will be fulfilled with the returned value. That means that if you still want to have an error for that branch, you should throw again. The following piece of code takes an internal error and masks it behind a generic “Internal Server Error” message as to not leak off potentially dangerous information to its clients (visualization). 1234Promise.reject(new Error('Database ds.214.53.4.12 connection timeout!')) .catch(error =&gt; &#123; throw new Error('Internal Server Error') &#125;) .catch(error =&gt; console.info(error)) // &lt;- Error: Internal Server Error Mapping promise results is particularly useful when dealing with multiple concurrent promises. Let’s see how that looks like. Leveraging Promise.all and Promise.raceA tremendously common scenario – even more so for those used to Node.js – is to have a dependency on things A and B before being able to do thing C. I’ll proceed that lousy description of the scenario with multiple code snippets. Suppose you wanted to pull the homepage for both Google and Twitter, and then print out the length of each of their responses. Here’s how that looks in the most näive approach possible, with a hypothetical request(url, done) method. 12345request('https://google.com', function (err, goog) &#123; request('https://twitter.com', function (err, twit) &#123; console.log(goog.length, twit.length) &#125;)&#125;) Of course, that’s going to run in series you say! Why would we wait on Google’s response before pulling Twitter’s? The following piece fixes the problem. It’s also ridiculously long, though, right? 123456789101112131415var results = &#123;&#125;request('https://google.com', function (err, goog) &#123; results.goog = goog done()&#125;)request('https://twitter.com', function (err, twit) &#123; results.twit = twit done()&#125;)function done () &#123; if (Object.keys(results).length &lt; 2) &#123; return &#125; console.log(results.goog.length, results.twit.length)&#125; Since nobody wants to be writing code like that, utility libraries like async and contra make this much shorter for you. You can use contra.concurrent to run these methods at the same time and execute a callback once they all ended. Here’s how that’d look like. 12345678910contra.concurrent(&#123; goog: function (next) &#123; request('https://google.com', next) &#125; twit: function (next) &#123; request('https://twitter.com', next) &#125;&#125;, function (err, results) &#123; console.log(results.goog.length, results.twit.length)&#125;) For the very common “I just want a method that appends that magical next parameter at the end” use case, there’s also contra.curry (equivalent of async.apply) to make the code even shorter. 123456contra.concurrent(&#123; goog: contra.curry(request, 'https://google.com'), twit: contra.curry(request, 'https://twitter.com')&#125;, function (err, results) &#123; console.log(results.goog.length, results.twit.length)&#125;) Promises already make the “run this after this other thing in series” use case very easy, using .then as we saw in several examples earlier. For the “run these things concurrently” use case, we can use Promise.all (visualization here). 1234567Promise.all([ fetch('/'), fetch('foo')]) .then(responses =&gt; responses.map(response =&gt; response.statusText)) .then(status =&gt; console.log(status.join(', '))) // &lt;- 'OK, Not Found' Note that even if a single dependency is rejected, the Promise.all method will be rejected entirely as well. 12345678Promise.all([ Promise.reject(), fetch('/'), fetch('foo')]) .then(responses =&gt; responses.map(response =&gt; response.statusText)) .then(status =&gt; console.log(status.join(', '))) // nothing happens In summary, Promise.all has two possible outcomes. Settle with a single rejection reason as soon as one of its dependencies is rejected Settle with all fulfillment results as soon as all of its dependencies are fulfilled Then there’s Promise.race. This is a similar method to Promise.all, except the first promise to settle will “win” the race, and its value will be passed along to branches of the race. If you run the visualization for the following piece of code a few times, you’ll notice that this race doesn’t have a clear winner. It depends on the server and the network! 123456Promise.race([ fetch('/'), fetch('foo')]) .then(response =&gt; console.log(response.statusText)) // &lt;- 'OK', or maybe 'Not Found'. Rejections will also finish the race, and the race promise will be rejected. As a closing note we may indicate that this could be useful for scenarios where we want to time out a promise we otherwise have no control over. For instance, the following race does make sense. 12345678var p = Promise.race([ fetch('/resource-that-may-take-a-while'), new Promise(function (resolve, reject) &#123; setTimeout(() =&gt; reject(new Error('request timeout')), 5000) &#125;)])p.then(response =&gt; console.log(response))p.catch(error =&gt; console.log(error)) To close this article, I’ll leave you with a visualization. It shows the race between a resource and a timeout as shown in the code above. Race between a resource and a timeout Here’s hoping I didn’t make promises even harder to understand for you!]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode String -- 5.Reverse Words in a String III]]></title>
    <url>%2F2018%2F08%2F01%2FleetCode%2Fstring%2F05.reverse_words_in_a_string_III%2F</url>
    <content type="text"><![CDATA[Reverse Words in a String IIIGiven a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order. Example 1:Input: “Let’s take LeetCode contest”Output: “s’teL ekat edoCteeL tsetnoc” Note: In the string, each word is separated by single space and there will not be any extra space in the string. solution： 1.与上题类似，使用对应方法即可： 1234567/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseWords = function(s) &#123; return s.split(' ').map((value) =&gt; value.split('').reverse().join('')).join(' ');&#125;;]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[11.generators]]></title>
    <url>%2F2018%2F08%2F01%2FpureMaterial%2F11.generators%2F</url>
    <content type="text"><![CDATA[generatorsGenerator Functions and Generator ObjectsGenerators are a new feature in ES6. You declare a generator function which returns generator objects g that can then be iterated using any of Array.from(g), [...g], or for value of g loops. Generator functions allow you to declare a special kind of iterator. These iterators can suspend execution while retaining their context. We already examined iterators in the previous article and how their .next() method is called once at a time to pull values from a sequence. Here is an example generator function. Note the * after function. That’s not a typo, that’s how you mark a generator function as a generator. 12345function* generator () &#123; yield 'f' yield 'o' yield 'o'&#125; Generator objects conform to both the iterable protocol and the iterator protocol. This means… 123456789101112var g = generator()// a generator object g is built using the generator functiontypeof g[Symbol.iterator] === 'function'// it's an iterable because it has an @@iteratortypeof g.next === 'function'// it's also an iterator because it has a .next methodg[Symbol.iterator]() === g// the iterator for a generator object is the generator object itselfconsole.log([...g])// &lt;- ['f', 'o', 'o']console.log(Array.from(g))// &lt;- ['f', 'o', 'o'] (This article is starting to sound an awful lot like a Math course…) When you create a generator object (I’ll just call them “generator” from here on out), you’ll get an iterator that uses the generator to produce its sequence. Whenever a yield expression is reached, that value is emitted by the iterator and function execution is suspended. Let’s use a different example, this time with some other statements mixed in between yield expressions. This is a simple generator but it behaves in an interesting enough way for our purposes here. 12345678910function* generator () &#123; yield 'p' console.log('o') yield 'n' console.log('y') yield 'f' console.log('o') yield 'o' console.log('!')&#125; If we use a for..of loop, this will print ponyfoo! one character at a time, as expected. 123456789101112var foo = generator()for (let pony of foo) &#123; console.log(pony) // &lt;- 'p' // &lt;- 'o' // &lt;- 'n' // &lt;- 'y' // &lt;- 'f' // &lt;- 'o' // &lt;- 'o' // &lt;- '!'&#125; What about using the spread [...foo] syntax? Things turn out a little different here. This might be a little unexpected, but that’s how generators work, everything that’s not yielded ends up becoming a side effect. As the sequence is being constructed, the console.log statements in between yield calls are executed, and they print characters to the console before foo is spread over an array. The previous example worked because we were printing characters as soon as they were pulled from the sequence, instead of waiting to construct a range for the entire sequence first. 1234567var foo = generator()console.log([...foo])// &lt;- 'o'// &lt;- 'y'// &lt;- 'o'// &lt;- '!'// &lt;- ['p', 'n', 'f', 'o'] A neat aspect of generator functions is that you can also use yield* to delegate to another generator function. Want a very contrived way to split &#39;ponyfoo&#39; into individual characters? Since strings in ES6 adhere to the iterable protocol, you could do the following. 12345function* generator () &#123; yield* 'ponyfoo'&#125;console.log([...generator()])// &lt;- ['p', 'o', 'n', 'y', 'f', 'o', 'o'] Of course, in the real world you could just do [...&#39;ponyfoo&#39;], since spread supports iterables just fine. Just like you could yield* a string, you can yield* anything that adheres to the iterable protocol. That includes other generators, arrays, and come ES6 – just about anything. 1234567891011121314151617181920212223242526var foo = &#123; [Symbol.iterator]: () =&gt; (&#123; items: ['p', 'o', 'n', 'y', 'f', 'o', 'o'], next: function next () &#123; return &#123; done: this.items.length === 0, value: this.items.shift() &#125; &#125; &#125;)&#125;function* multiplier (value) &#123; yield value * 2 yield value * 3 yield value * 4 yield value * 5&#125;function* trailmix () &#123; yield 0 yield* [1, 2] yield* [...multiplier(2)] yield* multiplier(3) yield* foo&#125;console.log([...trailmix()])// &lt;- [0, 1, 2, 4, 6, 8, 10, 6, 9, 12, 15, 'p', 'o', 'n', 'y', 'f', 'o', 'o'] You could also iterate the sequence by hand, calling .next(). This approach gives you the most control over the iteration, but it’s also the most involved. There’s a few features you can leverage here that give you even more control over the iteration. Iterating Over Generators by HandBesides iterating over trailmix as we’ve already covered, using [...trailmix()], for value of trailmix(), and Array.from(trailmix()), we could use the generator returned by trailmix() directly, and iterate over that. But trailmix was an overcomplicated showcase of yield*, let’s go back to the side-effects generator for this one. 123456789101112131415161718function* generator () &#123; yield 'p' console.log('o') yield 'n' console.log('y') yield 'f' console.log('o') yield 'o' console.log('!')&#125;var g = generator()while (true) &#123; let item = g.next() if (item.done) &#123; break &#125; console.log(item.value)&#125; Just like we learned yesterday, any items returned by an iterator will have a done property that indicates whether the sequence has reached its end, and a value indicating the current value in the sequence. If you’re confused as to why the &#39;!&#39; is printed even though there are no more yield expressions after it, that’s because g.next() doesn’t know that. The way it works is that each time its called, it executes the method until a yield expression is reached, emits its value and suspends execution. The next time g.next() is called, _execution is resumed _from where it left off (the last yield expression), until the next yield expression is reached. When no yield expression is reached, the generator returns { done: true }, signaling that the sequence has ended. At this point, the console.log(&#39;!&#39;) statement has been already executed, though. It’s also worth noting that context is preserved across suspensions and resumptions. That means generators can be stateful. Generators are, in fact, the underlying implementation for async/await semantics coming in ES7. Whenever .next() is called on a generator, there’s four “events” that will suspend execution in the generator, returning an IteratorResult to the caller of .next(). A yield expression returning the next value in the sequence A return statement returning the last value in the sequence A throw statement halts execution in the generator entirely Reaching the end of the generator function signals { done: true } Once the g generator ended iterating over a sequence, subsequent calls to g.next() will have no effect and just return { done: true }. 12345678910function* generator () &#123; yield 'only'&#125;var g = generator()console.log(g.next())// &lt;- &#123; done: false, value: 'only' &#125;console.log(g.next())// &lt;- &#123; done: true &#125;console.log(g.next())// &lt;- &#123; done: true &#125; Generators: The Weird Awesome PartsGenerator objects come with a couple more methods besides .next. These are .return and .throw. We’ve already covered .next extensively, but not quite. You could also use .next(value) to send values into the generator. Let’s make a magic 8-ball generator. First off, you’ll need some answers. Wikipedia obliges, yielding 20 possible answers for our magic 8-ball. 123456789101112var answers = [ `It is certain`, `It is decidedly so`, `Without a doubt`, `Yes definitely`, `You may rely on it`, `As I see it, yes`, `Most likely`, `Outlook good`, `Yes`, `Signs point to yes`, `Reply hazy try again`, `Ask again later`, `Better not tell you now`, `Cannot predict now`, `Concentrate and ask again`, `Don't count on it`, `My reply is no`, `My sources say no`, `Outlook not so good`, `Very doubtful`]function answer () &#123; return answers[Math.floor(Math.random() * answers.length)]&#125; The following generator function can act as a “genie” that answers any questions you might have for them. Note how we discard the first result from g.next(). That’s because the first call to .next enters the generator and there’s no yield expression waiting to capture the value from g.next(value). 1234567891011121314function* chat () &#123; while (true) &#123; let question = yield '[Genie] ' + answer() console.log(question) &#125;&#125;var g = chat()g.next()console.log(g.next('[Me] Will ES6 die a painful death?').value)// &lt;- '[Me] Will ES6 die a painful death?'// &lt;- '[Genie] My sources say no'console.log(g.next('[Me] How youuu doing?').value)// &lt;- '[Me] How youuu doing?'// &lt;- '[Genie] Concentrate and ask again' Randomly dropping g.next() feels like a very dirty coding practice, though. What else could we do? We could flip responsibilities around. Inversion of ControlWe could have the Genie be in control, and have the generator ask the questions. How would that look like? At first, you might think that the code below is unconventional, but in fact, most libraries built around generators work by inverting responsibility. 1234567891011121314151617function* chat () &#123; yield '[Me] Will ES6 die a painful death?' yield '[Me] How youuu doing?'&#125;var g = chat()while (true) &#123; let question = g.next() if (question.done) &#123; break &#125; console.log(question.value) console.log('[Genie] ' + answer()) // &lt;- '[Me] Will ES6 die a painful death?' // &lt;- '[Genie] Very doubtful' // &lt;- '[Me] How youuu doing?' // &lt;- '[Genie] My reply is no'&#125; You would expect the generator to do the heavy lifting of an iteration, but in fact generators make it easy to iterate over things by suspending execution of themselves – and deferring the heavy lifting. That’s one of the most powerful aspects of generators. Suppose now that the iterator is a genie method in a library, like so: 1234567891011function genie (questions) &#123; var g = questions() while (true) &#123; let question = g.next() if (question.done) &#123; break &#125; console.log(question.value) console.log('[Genie] ' + answer()) &#125;&#125; To use it, all you’d have to do is pass in a simple generator like the one we just made. 1234genie(function* questions () &#123; yield '[Me] Will ES6 die a painful death?' yield '[Me] How youuu doing?'&#125;) Compare that to the generator we had before, where questions were sent to the generator instead of the other way around. See how much more complicated the logic would have to be to achieve the same goal? Letting the library deal with the flow control means you can just worry about the thing you want to iterate over, and you can delegate how to iterate over it. But yes, it does mean your code now has an asterisk in it. Weird. Dealing with asynchronous flowsImagine now that the genie library gets its magic 8-ball answers from an API. How does that look then? Probably something like the snippet below. Assume the xhr pseudocode call always yields JSON responses like { answer: &#39;No&#39; }. Keep in mind this is a simple example that just processes each question in series. You could put together different and more complex flow control algorithms depending on what you’re looking for. This is just a demonstration of the sheer power of generators. 12345678910111213141516171819202122function genie (questions) &#123; var g = questions() pull() function pull () &#123; let question = g.next() if (question.done) &#123; return &#125; ask(question.value, pull) &#125; function ask (q, next) &#123; xhr('https://computer.genie/?q=' + encodeURIComponent(q), got) function got (err, res, body) &#123; if (err) &#123; // todo &#125; console.log(q) console.log('[Genie] ' + body.answer) next() &#125; &#125;&#125; See this link for a live demo on the Babel REPL Even though we’ve just made our genie method asynchronous and are now using an API to fetch responses to the user’s questions, the way the consumer uses the genie library by passing a questions generator function remains unchanged! That’s awesome. We haven’t handled the case for an err coming out of the API. That’s inconvenient. What can we do about that one? Throwing at a GeneratorNow that we’ve figured out that the most important aspect of generators is actually the control flow code that decides when to call g.next(), we can look at the other two methods and actually understand their purpose. Before shifting our thinking into “the generator defines what to iterate over, not the how”, we would’ve been hard pressed to find a user case for g.throw. Now however it seems immediately obvious. The flow control that leverages a generator needs to be able to tell the generator that’s yielding the sequence to be iterated when something goes wrong processing an item in the sequence. In the case of our genie flow, that is now using xhr, we may experience network issues and be unable to continue processing items, or we may want to warn the user about unexpected errors. Here’s how, we simply add g.throw(error) in our control flow code. 12345678910111213141516171819202122function genie (questions) &#123; var g = questions() pull() function pull () &#123; let question = g.next() if (question.done) &#123; return &#125; ask(question.value, pull) &#125; function ask (q, next) &#123; xhr('https://computer.genie/?q=' + encodeURIComponent(q), got) function got (err, res, body) &#123; if (err) &#123; g.throw(err) &#125; console.log(q) console.log('[Genie] ' + body.answer) next() &#125; &#125;&#125; The user code is still unchanged, though. In between yield statements it may throw errors now. You could use try/catch blocks to address those issues. If you do this, execution will be able to resume. The good thing is that this is up to the user, it’s still perfectly sequential on their end, and they can leverage try/catch semantics just like in high-school. 123456789101112genie(function* questions () &#123; try &#123; yield '[Me] Will ES6 die a painful death?' &#125; catch (e) &#123; console.error('Error', e.message) &#125; try &#123; yield '[Me] How youuu doing?' &#125; catch (e) &#123; console.error('Error', e.message) &#125;&#125;) Returning on Behalf of a GeneratorUsually not as interesting in asynchronous control flow mechanisms in general, the g.return() method allows you to resume execution inside a generator function, much like g.throw() did moments earlier. The key difference is that g.return() won’t result in an exception at the generator level, although it will end the sequence. 123456789101112function* numbers () &#123; yield 1 yield 2 yield 3&#125;var g = numbers()console.log(g.next())// &lt;- &#123; done: false, value: 1 &#125;console.log(g.return())// &lt;- &#123; done: true &#125;console.log(g.next())// &lt;- &#123; done: true &#125;, as we know You could also return a value using g.return(value), and the resulting IteratorResult will contain said value. This is equivalent to having return value somewhere in the generator function. You should be careful there though – as neither for..of, [...generator()], nor Array.from(generator()) include the value in the IteratorResult that signals { done: true }. 123456789101112131415161718192021222324function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;console.log([...numbers()])// &lt;- [1, 2]console.log(Array.from(numbers()))// &lt;- [1, 2]for (let n of numbers()) &#123; console.log(n) // &lt;- 1 // &lt;- 2&#125;var g = numbers()console.log(g.next())// &lt;- &#123; done: false, value: 1 &#125;console.log(g.next())// &lt;- &#123; done: false, value: 2 &#125;console.log(g.next())// &lt;- &#123; done: true, value: 3 &#125;console.log(g.next())// &lt;- &#123; done: true &#125; Using g.return is no different in this regard, think of it as the programmatic equivalent of what we just did. 12345678910111213function* numbers () &#123; yield 1 yield 2 return 3 yield 4&#125;var g = numbers()console.log(g.next())// &lt;- &#123; done: false, value: 1 &#125;console.log(g.return(5))// &lt;- &#123; done: true, value: 5 &#125;console.log(g.next())// &lt;- &#123; done: true &#125; You can avoid the impending sequence termination, as Axel points out, if the code in the generator function when g.return() got called is wrapped in try/finally. Once the yield expressions in the finally block are over, the sequence will end with the value passed to g.return(value) 123456789101112131415161718192021function* numbers () &#123; yield 1 try &#123; yield 2 &#125; finally &#123; yield 3 yield 4 &#125; yield 5&#125;var g = numbers()console.log(g.next())// &lt;- &#123; done: false, value: 1 &#125;console.log(g.next())// &lt;- &#123; done: false, value: 2 &#125;console.log(g.return(6))// &lt;- &#123; done: false, value: 3 &#125;console.log(g.next())// &lt;- &#123; done: false, value: 4 &#125;console.log(g.next())// &lt;- &#123; done: true, value: 6 &#125; That’s all there is to know when it comes to generators in terms of functionality. Use Cases for ES6 GeneratorsAt this point in the article you should feel comfortable with the concepts of iterators, iterables, and generators in ES6. If you feel like reading more on the subject, I highly recommend you go over Axel’s article on generators, as he put together an amazing write-up on use cases for generators just a few months ago.]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode String -- 4.Reverse String]]></title>
    <url>%2F2018%2F08%2F01%2FleetCode%2Fstring%2F04.reverse_string%2F</url>
    <content type="text"><![CDATA[Reverse StringWrite a function that takes a string as input and returns the string reversed Example:Given s = “hello”, return “olleh”. solution： 1.使用string的方法，拆分字符串，反序然后拼接： 1234567/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseString = function(s) &#123; return s.split('').reverse().join('');&#125;; 2.使用es6的用法，可以减少split(‘’)来拆分： 1234567/** * @param &#123;string&#125; s * @return &#123;string&#125; */var reverseString = function(s) &#123; return [...s].reverse().join('');&#125;;]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[10.iterators]]></title>
    <url>%2F2018%2F08%2F01%2FpureMaterial%2F10.iterators%2F</url>
    <content type="text"><![CDATA[iteratorsIterator Protocol and Iterable Protocol There’s a lot of new, intertwined terminology here. Please bear with me as I get some of these explanations out of the way! JavaScript gets two new protocols in ES6, Iterators and Iterables. In plain terms, you can think of protocols as conventions. As long as you follow a determined convention in the language, you get a side-effect. The iterable protocol allows you to define the behavior when JavaScript objects are being iterated. Under the hood, deep in the world of JavaScript interpreters and language specification keyboard-smashers, we have the @@iterator method. This method underlies the iterable protocol and, in the real world, you can assign to it using something called “the “well-known” Symbol.iterator Symbol”. We’ll get back to what Symbols are later in the series. Before losing focus, you should know that the @@iterator method is called once, whenever an object needs to be iterated. For example, at the beginning of a for..of loop (which we’ll also get back to in a few minutes), the @@iterator will be asked for an iterator. The returned iterator will be used to obtain values out of the object. Let’s use the snippet of code found below as a crutch to understand the concepts behind iteration. The first thing you’ll notice is that I’m making my object an iterable by assigning to it’s mystical @@iterator property through the Symbol.iterator property. I can’t use the symbol as a property name directly. Instead, I have to wrap in square brackets, meaning it’s a computed property name that evaluates to the Symbol.iterator expression – as you might recall from the article on object literals. The object returned by the method assigned to the [Symbol.iterator] property must adhere to the iterator protocol. The iterator protocol defines how to get values out of an object, and we must return an @@iterator that adheres to iterator protocol. The protocol indicates we must have an object with a next method. The next method takes no arguments and it should return an object with these two properties. done signals that the sequence has ended when true, and false means there may be more values value is the current item in the sequence In my example, the iterator method returns an object that has a finite list of items and which emits those items until there aren’t any more left. The code below is an iterable object in ES6. 1234567891011var foo = &#123; [Symbol.iterator]: () =&gt; (&#123; items: ['p', 'o', 'n', 'y', 'f', 'o', 'o'], next: function next () &#123; return &#123; done: this.items.length === 0, value: this.items.shift() &#125; &#125; &#125;)&#125; To actually iterate over the object, we could use for..of. How would that look like? See below. The for..of iteration method is also new in ES6, and it settles the everlasting war against looping over JavaScript collections and randomly finding things that didn’t belong in the result-set you were expecting. 12345678910for (let pony of foo) &#123; console.log(pony) // &lt;- 'p' // &lt;- 'o' // &lt;- 'n' // &lt;- 'y' // &lt;- 'f' // &lt;- 'o' // &lt;- 'o'&#125; You can use for..of to iterate over any object that adheres to the iterable protocol. In ES6, that includes arrays, any objects with an user-defined [Symbol.iterator] method, generators, DOM node collections from .querySelectorAll and friends, etc. If you just want to “cast” any iterable into an array, a couple of terse alternatives would be using the spread operator and Array.from. 1234console.log([...foo])// &lt;- ['p', 'o', 'n', 'y', 'f', 'o', 'o']console.log(Array.from(foo))// &lt;- ['p', 'o', 'n', 'y', 'f', 'o', 'o'] To recap, our foo object adheres to the iterable protocol by assigning a method to [Symbol.iterator] – anywhere in the prototype chain for foo would work. This means that the object is iterable: it can be iterated. Said method returns an object that adheres to the iterator protocol. The iterator method is called once whenever we want to start iterating over the object, and the returned iterator is used to pull values out of foo. To iterate over iterables, we can use for..of, the spread operator, or Array.from. What Does This All Mean?In essence, the selling point about iteration protocols, for..of, Array.from, and the spread operator is that they provide expressive ways to effortlessly iterate over collections and array-likes (such as arguments). Having the ability to define how any object may be iterated is huge, because it enables any libraries like lo-dash to converge under a protocol the language natively understands – iterables. This is huge. Just to give you another example, remember how I always complain about jQuery wrapper objects not being true arrays, or how document.querySelectorAll doesn’t return a true array either? If jQuery implemented the iterator protocol on their collection’s prototype, then you could do something like below. 1234for (let item of $('li')) &#123; console.log(item) // &lt;- the &lt;li&gt; wrapped in a jQuery object&#125; Why wrapped? Because it’s more expressive. You could easily iterate as deep as you need to. 123456for (let list of $('ul')) &#123; for (let item of list.find('li')) &#123; console.log(item) // &lt;- the &lt;li&gt; wrapped in a jQuery object &#125;&#125; This brings me to an important aspect of iterables and iterators. Lazy in NatureIterators are lazy in nature. This is fancy-speak for saying that the sequence is accessed one item at a time. It can even be an infinite sequence – a legitimate scenario with many use cases. Given that iterators are lazy, having jQuery wrap every result in the sequence with their wrapper object wouldn’t have a big upfront cost. Instead, a wrapper is created each time a value is pulled from the iterator. How would an infinite iterator look? The example below shows an iterator with a 1..Infinity range. Note how it will never yields done: true, signaling that the sequence is over. Attempting to cast the iterable foo object into an array using either Array.from(foo) or [...foo] would crash our program, since the sequence never ends. We must be very careful with these types of sequences as they can crash and burn our Node process, or the human’s browser tab. 123456var foo = &#123; [Symbol.iterator]: () =&gt; &#123; var i = 0 return &#123; next: () =&gt; (&#123; value: ++i &#125;) &#125; &#125;&#125; The correct way of working with such an iterator is with an escape condition that prevents the loop from going infinite. The example below loops over our infinite sequence using for..of, but it breaks the loop as soon as the value goes over 10. 123456for (let pony of foo) &#123; if (pony &gt; 10) &#123; break &#125; console.log(pony)&#125; The iterator doesn’t really know that the sequence is infinite. In that regard, this is similar to the halting problem – there is no way of knowing whether the sequence is infinite or not in code. We usually have a good idea about whether a sequence is finite or infinite, since we construct those sequences. Whenever we have an infinite sequence it’s up to us to add an escape condition that ensures our program won’t crash in an attempt to loop over every single value in the sequence. Come back tomorrow for a discussion about generators!]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[09.Symbols]]></title>
    <url>%2F2018%2F08%2F01%2FpureMaterial%2F09.symbol%2F</url>
    <content type="text"><![CDATA[symbolsWhat are Symbols?Symbols are a new primitive type in ES6. If you ask me, they’re an awful lot like strings. Just like with numbers and strings, symbols also come with their accompanying Symbol wrapper object. We can create our own Symbols. 1var mystery = Symbol() Note that there was no new. The new operator even throws a TypeError when we try it on Symbol. 12var oops = new Symbol()// &lt;- TypeError For debugging purposes, you can describe symbols. 1var mystery = Symbol('this is a descriptive description') Symbols are immutable. Just like numbers or strings. Note however that symbols are unique, unlike primitive numbers and strings. 1234console.log(Symbol() === Symbol())// &lt;- falseconsole.log(Symbol('foo') === Symbol('foo'))// &lt;- false Symbols are symbols. 1234console.log(typeof Symbol())// &lt;- 'symbol'console.log(typeof Symbol('foo'))// &lt;- 'symbol' There are three different flavors of symbols – each flavor is accessed in a different way. We’ll explore each of these and slowly figure out what all of this means. You can access local symbols by obtaining a reference to them directly You can place symbols on the global registry and access them across realms “Well-known” symbols exist across realms – but you can’t create them and they’re not on the global registry What the heck is a realm, you say? A realm is spec-speak for any execution context, such as the page your application is running in, or an &lt;iframe&gt; within your page. The “Runtime-Wide” Symbol RegistryThere’s two methods you can use to add symbols to the runtime-wide symbol registry: Symbol.for(key) and Symbol.keyFor(symbol). What do these do? Symbol.for(key)This method looks up key in the runtime-wide symbol registry. If a symbol with that key exists in the global registry, that symbol is returned. If no symbol with that key is found in the registry, one is created. That’s to say, Symbol.for(key) is idempotent. In the snippet below, the first call to Symbol.for(&#39;foo&#39;) creates a symbol, adds it to the registry, and returns it. The second call returns that same symbol because the key is already in the registry by then – and associated to the symbol returned by the first call. 12Symbol.for('foo') === Symbol.for('foo')// &lt;- true That is in contrast to what we knew about symbols being unique. The global symbol registry however keeps track of symbols by a key. Note that your key will also be used as a description when the symbols that go into the registry are created. Also note that these symbols are as global as globals get in JavaScript, so play nice and use a prefix and don’t just name your symbols &#39;user&#39; or some generic name like that. Symbol.keyFor(symbol)Given a symbol symbol, Symbol.keyFor(symbol) returns the key that was associated with symbol when the symbol was added to the global registry. 123var symbol = Symbol.for('foo')console.log(Symbol.keyFor(symbol))// &lt;- 'foo' How Wide is Runtime-Wide?Runtime-wide means the symbols in the global registry are accessible across code realms. I’ll probably have more success explaining this with a piece of code. It just means the registry is shared across realms. 1234var frame = document.createElement('iframe')document.body.appendChild(frame)console.log(Symbol.for('foo') === frame.contentWindow.Symbol.for('foo'))// &lt;- true The “Well-Known” SymbolsLet me put you at ease: these aren’t actually well-known at all. Far from it. I didn’t have any idea these things existed until a few months ago. Why are they “well-known”, then? That’s because they are JavaScript built-ins, and they are used to control parts of the language. They weren’t exposed to user code before ES6, but now you can fiddle with them. A great example of a “well-known” symbol is something we’ve already been playing with on Pony Foo: the Symbol.iterator well-known symbol. We used that symbol to define the @@iterator method on objects that adhere to the iterator protocol. There’s a list of well-known symbols on MDN, but few of them are documented at the time of this writing. One of the well-known symbols that is documented at this time is Symbol.match. According to MDN, you can set the Symbol.match property on regular expressions to false and have them behave as string literals when matching _(instead of regular expressions, which don’t play nice with .startsWith, .endsWith, or .includes)_. This part of the spec hasn’t been implemented in Babel yet, – I assume that’s just because it’s not worth the trouble – but supposedly it goes like this. 12345var text = '/foo/'var literal = /foo/literal[Symbol.match] = falseconsole.log(text.startsWith(literal))// &lt;- true Why you’d want to do that instead of just casting literal to a string is beyond me. 1234var text = '/foo/'var casted = /foo/.toString()console.log(text.startsWith(casted))// &lt;- true I suspect the language has legitimate performance reasons that warrant the existence of this symbol, but I don’t think it’ll become a front-end development staple anytime soon. Regardless, Symbol.iterator is actually very useful, and I’m sure other well-known symbols are useful as well. Note that well-known symbols are unique, but shared across realms, even when they’re not accessible through the global registry. 1234var frame = document.createElement('iframe')document.body.appendChild(frame)console.log(Symbol.iterator === frame.contentWindow.Symbol.iterator)// &lt;- true Not accessible through the global registry? Nope! 12console.log(Symbol.keyFor(Symbol.iterator))// &lt;- undefined Accessing them statically from anywhere should be more than enough, though. Symbols and IterationAny consumer of the iterable protocol obviously ignores symbols other than the well-known Symbol.iterator that would define how to iterate and help identify the object as an iterable. 12345678var foo = &#123; [Symbol()]: 'foo', [Symbol('foo')]: 'bar', [Symbol.for('bar')]: 'baz', what: 'ever'&#125;console.log([...foo])// &lt;- [] The ES5 Object.keys method ignores symbols. 12console.log(Object.keys(foo))// &lt;- ['what'] Same goes for JSON.stringify. 12console.log(JSON.stringify(foo))// &lt;- &#123;"what":"ever"&#125; So, for..in then? Nope. 1234for (let key in foo) &#123; console.log(key) // &lt;- 'what'&#125; I know, Object.getOwnPropertyNames. Nah! – but close. 12console.log(Object.getOwnPropertyNames(foo))// &lt;- ['what'] You need to be explicitly looking for symbols to stumble upon them. They’re like JavaScript neutrinos. You can use Object.getOwnPropertySymbols to detect them. 12console.log(Object.getOwnPropertySymbols(foo))// &lt;- [Symbol(), Symbol('foo'), Symbol.for('bar')] The magical drapes of symbols drop, and you can now iterate over the symbols with a for..of loop to finally figure out the treasures they were guarding. Hopefully, they won’t be as disappointing as the flukes in the snippet below. 123456for (let symbol of Object.getOwnPropertySymbols(foo)) &#123; console.log(foo[symbol]) // &lt;- 'foo' // &lt;- 'bar' // &lt;- 'baz'&#125; Why Would I Want Symbols?There’s a few different uses for symbols. Name ClashesYou can use symbols to avoid name clashes in property keys. This is important when following the “objects as hash maps” pattern, which regularly ends up failing miserably as native methods and properties are overridden unintentionally (or maliciously). “Privacy”?Symbols are invisible to all “reflection” methods before ES6. This can be useful in some scenarios, but they’re not private by any stretch of imagination, as we’ve just demonstrated with the Object.getOwnPropertySymbols API. That being said, the fact that you have to actively look for symbols to find them means they’re useful in situations where you want to define metadata that shouldn’t be part of iterable sequences for arrays or any iterable objects. Defining ProtocolsI think the biggest use case for symbols is exactly what the ES6 implementers use them for: defining protocols – just like there’s Symbol.iterator which allows you to define how an object can be iterated. Imagine for instance a library like dragula defining a protocol through Symbol.for(&#39;dragula.moves&#39;), where you could add a method on that Symbol to any DOM elements. If a DOM element follows the protocol, then dragula could call the el[Symbol.for(&#39;dragula.moves&#39;)]() user-defined method to assert whether the element can be moved. This way, the logic about elements being draggable by dragula is shifted from a single place for the entire drake (the options for an instance of dragula), to each individual DOM element. That’d make it easier to deal with complex interactions in larger implementations, as the logic would be delegated to individual DOM nodes instead of being centralized in a single options.moves method.]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[08.Let, Const and the “Temporal Dead Zone” (TDZ)]]></title>
    <url>%2F2018%2F08%2F01%2FpureMaterial%2F08.let_const_temporal_dead_zone%2F</url>
    <content type="text"><![CDATA[Let, Const and the “Temporal Dead Zone” (TDZ)Let StatementThe let statement is one of the most well-known features in ES6, which is partly why I grouped it together with a few other new features. It works like a var statement, but it has different scoping rules. JavaScript has always had a complicated ruleset when it came to scoping, driving many programmers crazy when they were first trying to figure out how variables work in JavaScript. Eventually, you discover this thing called hoisting, and things start making a bit more sense to you. Hoisting means that variables get pulled from anywhere they were declared in user code to the top of their scope. For example, see the code below. 12345678910function areTheyAwesome (name) &#123; if (name === 'nico') &#123; var awesome = true &#125; return awesome&#125;areTheyAwesome('nico')// &lt;- trueareTheyAwesome('christian heilmann')// &lt;- undefined The reason why this doesn’t implode into oblivion is, as we know, that var is function-scoped. That coupled with hoisting means that what we’re really expressing is something like the piece of code below. 1234567function areTheyAwesome (name) &#123; var awesome if (name === 'nico') &#123; awesome = true &#125; return awesome&#125; Whether we like it or not (or we’re just used to it – I know I am), this is plainly more confusing than having block-scoped variables would be. Block scoping works on the bracket level, rather than the function level. Instead of having to declare a new function if we want a deeper scoping level, block scoping allows you to just leverage existing code branches like those in if, for, or while statements; you could also create new {} blocks arbitrarily. As you may or may not know, the JavaScript language allows us to create an indiscriminate number of blocks, just because we want to. 123&#123;&#123;&#123;&#123;&#123;var insane = 'yes, you are'&#125;&#125;&#125;&#125;&#125;console.log(insane)// &lt;- 'yes, you are' With var, though, one could still access the variable from outside those many, many, many blocks, and not get an error. Sometimes it can be very useful to get errors in these situations. Particularly if one or more of these is true. Accessing the inner variable breaks some sort of encapsulation principle in our code The inner variable doesn’t belong in the outer scope at all The block in question has many siblings that would also want to use the same variable name One of the parent blocks already has a variable with the name we need, but it’s still appropriate to use in the inner block So how does this let thing work? The let statement is an alternative to var. It follows block scoping rules instead of the default function scoping rules. This means you don’t need entire functions to get a new scope – a simple {} block will do! 12345678910let outer = 'I am so eccentric!'&#123; let inner = 'I play with neighbors in my block and the sewers' &#123; let innermost = 'I only play with neighbors in my block' &#125; // accessing innermost here would throw&#125;// accessing inner here would throw// accessing innermost here would throw Here is where things got interesting. As I wrote this example I thought “well, but if we now declare a function inside a block and access it from outside that block, things will surely go awry”. Based on my existing knowledge of ES5 I fully expected the following snippet of code to work, and it does in fact work in ES5 but it’s broken in ES6. That would’ve been a problem because it’d make super easy to expose block-scoped properties through functions that become hoisted outside of the block. I didn’t expect this to throw. 12345678&#123; let _nested = 'secret' function nested () &#123; return _nested &#125;&#125;console.log(nested())// nested is not defined As it turns out, this wasn’t a bug in Babel, but in fact a (much welcome) change in ES6 language semantics. Note that you can still expose nested let things to outer scopes simply by assigning them to a variable that has more access. I wouldn’t recommend you do this however, as there probably are cleaner ways to write code in these situations – such as not using let when you don’t want block scoping. 123456789var nested&#123; let _nested = 'secret' nested = function () &#123; return _nested &#125;&#125;console.log(nested())// &lt;- 'secret' In conclusion, block scoping can be quite useful in new codebases. Some people will tell you to drop var forever and just use let everywhere. Some will tell you to never use let because that’s not the One True Way of JavaScript. My position might change over time, but this is it – for the time being: I plan on using var most of the time, and let in those situations where I would’ve otherwise hoisted a variable to the top of the scope for no reason, when they actually belonged inside a conditional or iterator code branch. 25 Nov 2016: after working with ES6 for over a year, I’ve completely changed my mind on how to declare variables in ES6. Prefer const where possible, let anywhere else! The Temporal Dead Zone and the Deathly HallowsOne last thing of note about let is a mystical concept called the “Temporal Dead Zone” (TDZ) – ooh… so scary, I know. In so many words: if you have code such as the following, it’ll throw. 123there = 'far away'// &lt;- ReferenceError: there is not definedlet there = 'dragons' If your code tries to access there in any way before the let there statement is reached, the program will throw. Declaring a method that references there before it’s defined is okay, as long as the method doesn’t get executed while there is in the TDZ, and there will be in the TDZ for as long as the let there statement isn’t reached (while the scope has been entered). This snippet won’t throw because return there isn’t executed until after there leaves the TDZ. 123456function readThere () &#123; return there&#125;let there = 'dragons'console.log(readThere())// &lt;- 'dragons' But this snippet will, because access to there occurs before leaving the TDZ for there. 123456function readThere () &#123; return there&#125;console.log(readThere())// ReferenceError: there is not definedlet there = 'dragons' Note that the semantics for these examples doesn’t change when there isn’t actually assigned a value when initially declared. The snippet below still throws, as it still tries to access there before leaving the TDZ. 123456function readThere () &#123; return there&#125;console.log(readThere())// ReferenceError: there is not definedlet there This snippet still works because it still leaves the TDZ before accessing there in any way. 123456function readThere () &#123; return there&#125;let thereconsole.log(readThere())// &lt;- undefined The only tricky part is to remember that (when it comes to the TDZ) functions work sort of like blackboxes until they’re actually executed for the first time, so it’s okay to place there inside functions that don’t get executed until we leave the TDZ. The whole point of the TDZ is to make it easier to catch errors where accessing a variable before it’s declared in user code leads to unexpected behavior. This happened a lot with ES5 due both to hoisting and poor coding conventions. In ES6 it’s easier to avoid. Keep in mind that hoisting still applies for let as well – this just means that the variables will be created when we enter the scope, and the TDZ will be born, but they will be inaccessible until code execution hits the place where the variable was actually declared, at which point we leave the TDZ and are cleared to use the variable. Const StatementPhew. I wrote more than I ever wanted to write about let. Fortunately for both of us, const is quite similar to let. const is also block-scoped const also enjoys the marvels of TDZ semantics There’s also a couple of major differences. const variables must be declared using an initializer const variables can only be assigned to once, in said initializer const variables don’t make the assigned value immutable Assigning to const will fail silently Redeclaration of a variable by the same name will throw Let’s go to some examples. First, this snippet shows how it follows block-scoping rules just like let. 12345678const cool = 'ponyfoo'&#123; const cool = 'dragons' console.log(cool) // &lt;- 'dragons'&#125;console.log(cool)// &lt;- 'ponyfoo' Once a const is declared, you can’t change the reference or literal that’s assigned to it. 123const cool = &#123; people: ['you', 'me', 'tesla', 'musk'] &#125;cool = &#123;&#125;// &lt;- "cool" is read-only You can however, change the reference itself. It does not become immutable. You’d have to use Object.freeze to make the value itself immutable. 1234const cool = &#123; people: ['you', 'me', 'tesla', 'musk'] &#125;cool.people.push('berners-lee')console.log(cool)// &lt;- &#123; people: ['you', 'me', 'tesla', 'musk', 'berners-lee'] &#125; You can also make other references to the const that can, in fact, change. 12345const cool = &#123; people: ['you', 'me', 'tesla', 'musk'] &#125;var uncool = cooluncool = &#123; people: ['edison'] &#125; // so uncool he's all aloneconsole.log(uncool)// &lt;- &#123; people: ['edison'] &#125; I think const is great because it allows us to mark things that we really need to preserve as such. Imagine the following piece of code, which does come up in some situations – sorry about the extremely contrived example. 12345678910111213function code (groceries) &#123; return &#123;eat&#125; function eat () &#123; if (groceries.length === 0) &#123; throw new Error('All out. Please buy more groceries to feed the code.') &#125; return groceries.shift() &#125;&#125;var groceries = ['carrot', 'lemon', 'potato', 'turducken']var eater = code(groceries)console.log(eater.eat())// &lt;- 'carrot' I sometimes come across code where someone is trying to add more groceries to the list, and they figure that doing the following would just work. In many cases this does work. However, if we’re passing a reference to groceries to something else, the re-assignment wouldn’t be carried away to that other place, and hard to debug issues would ensue. 12// a few hundred lines of code later...groceries = ['heart of palm', 'tomato', 'corned beef'] If groceries were a constant in the piece of code above, this re-assignment would’ve been far easier to detect. Yay, ES6! I can definitely see myself using const a lot in the future, but I haven’t quite internalized it yet. I guess more coding is in order!]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode String -- 3.Judge Route Circle]]></title>
    <url>%2F2018%2F07%2F31%2FleetCode%2Fstring%2F03.judge_route_circle%2F</url>
    <content type="text"><![CDATA[Judge Route CircleInitially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place. The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle. Example 1:Input: “UD”Output: true Example 2:input: “LL”Output: false solution： 1.定义一个对象，保存四个方向的值，只要左右，上下对应相等即可： 123456789101112131415161718/** * @param &#123;string&#125; moves * @return &#123;boolean&#125; */var judgeCircle = function(moves) &#123; let storage = &#123; R: 0, L: 0, U: 0, D: 0 &#125; for (var i in moves) &#123; storage[moves[i]] += 1; &#125; return (storage['R'] == storage['L'] &amp;&amp; storage['U'] === storage['D'])&#125;; 2.这道题的思想大体类似，选择switch进行判断： 1234567891011121314151617181920212223242526var judgeCircle = function(moves) &#123; let start = [0, 0] for (let i = 0; i &lt; moves.length; i++) &#123; switch (moves[i]) &#123; case 'U': start = [start[0], start[1] + 1] break case 'D': start = [start[0], start[1] - 1] break case 'L': start = [start[0] - 1, start[1]] break case 'R': start = [start[0] + 1, start[1]] break &#125; &#125; if (start.join('') === '00') &#123; return true &#125; else &#123; return false &#125;&#125;;]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode String -- 2.Unique Morse Code Words]]></title>
    <url>%2F2018%2F07%2F31%2FleetCode%2Fstring%2F02.unique_morse_code_words%2F</url>
    <content type="text"><![CDATA[Unique Morse Code WordsInternational Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on. For convenience, the full table for the 26 letters of the English alphabet is given below: 1[".-","-...","-.-.","-..",".","..-.","--.","....","..",".---","-.-",".-..","--","-.","---",".--.","--.-",".-.","...","-","..-","...-",".--","-..-","-.--","--.."] Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word. Return the number of different transformations among all words we have. Example:Input: words = [“gin”, “zen”, “gig”, “msg”]Output: 2Explanation:The transformation of each word is:“gin” -&gt; “–…-.”“zen” -&gt; “–…-.”“gig” -&gt; “–…–.”“msg” -&gt; “–…–.” There are 2 different transformations, “–…-.” and “–…–.”. Note:The length of words will be at most 100.Each words[i] will have length in range [1, 12].words[i] will only consist of lowercase letters. solution： 1.使用map 和set一一对应，代码如下： 12345678910111213141516/*** @param &#123;string[]&#125; words* @return &#123;number&#125;*/const letters = 'abcdefghijklmnopqrstuvwxyz';const morseCode = ['.-','-...','-.-.','-..','.','..-.','--.','....','..','.---','-.-','.-..','--','-.','---','.--.','--.-','.-.','...','-','..-','...-','.--','-..-','-.--','--..'];const mapMorse = new Map(morseCode.map((code, index) =&gt; [letters[index], code]));var uniqueMorseRepresentations = function(words) &#123; const transformations = new Set(); words.forEach((w) =&gt; &#123; transformations.add(w.split('').map( l =&gt; mapMorse.get(l)).join('')); &#125;); return transformations.size;&#125;; 2.在学习其他人的代码时，看到了一个比较厉害的例子，一行搞定： 12345678/** * @param &#123;string[]&#125; words * @return &#123;number&#125; */var uniqueMorseRepresentations = function(words) &#123; return new Set(words.map(word =&gt; [...word].map(val =&gt; [".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."].slice(val.charCodeAt(0) - 'a'.charCodeAt(0), val.charCodeAt(0) - 'a'.charCodeAt(0) + 1)).join(''))).size&#125;; 也就是： 1234let uniqueMorseRepresentations = function (words) &#123; let code = [".-", "-...", "-.-.", "-..", ".", "..-.", "--.", "....", "..", ".---", "-.-", ".-..", "--", "-.", "---", ".--.", "--.-", ".-.", "...", "-", "..-", "...-", ".--", "-..-", "-.--", "--.."]; return new Set(words.map(word =&gt; [...word].map(val =&gt; code[val.charCodeAt(0) - 'a'.charCodeAt(0)]).join(''))).size&#125;; mark一下。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode String -- 1.To Lower Case]]></title>
    <url>%2F2018%2F07%2F31%2FleetCode%2Fstring%2F01.to_lower_case%2F</url>
    <content type="text"><![CDATA[To Lower CaseImplement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase. Example 1: Input: “Hello”Output: “hello” Example 2: Input: “here”Output: “here” Example 3: Input: “LOVELY”Output: “lovely” solution： 直接想到的办法就是使用js的toLowerCase()： 1234567/** * @param &#123;string&#125; str * @return &#123;string&#125; */var toLowerCase = function(str) &#123; return str.toLowerCase();&#125;; 第二种是拆分当前字符串，根据ASCII码判断是否是大写字母，是的话转为小写： 12345678910/** * @param &#123;string&#125; str * @return &#123;string&#125; */var toLowerCase = function(str) &#123; return str.split("").map((code) =&gt; &#123; const unicode = code.charCodeAt(0); return unicode &gt;= 65 &amp;&amp; unicode &lt;= 90 ? String.fromCharCode(unicode + 32) : code &#125;).join("")&#125;;]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[07.classes]]></title>
    <url>%2F2018%2F07%2F31%2FpureMaterial%2F07.classes%2F</url>
    <content type="text"><![CDATA[What do you mean; classes in JavaScript?JavaScript is a prototype-based language, so what are ES6 classes really? They’re syntactic sugar on top of prototypical inheritance – a device to make the language more inviting to programmers coming from other paradigms who might not be all that familiar with prototype chains. Many features in ES6 (such as destructuring) are, in fact, syntactic sugar – and classes are no exception. I like to clarify this because it makes it much easier to understand the underlying technology behind ES6 classes. There is no huge restructuring of the language, they just made it easier for people used to classes to leverage prototypal inheritance. While I may dislike the term “classes” for this particular feature, I have to say that the syntax is in fact much easier to work with than regular prototypal inheritance syntax in ES5, and that’s a win for everyone – regardless of them being called classes or not. Now that that’s out of the way, I’ll assume you understand prototypal inheritance – just because you’re reading a blog about JavaScript. Here’s how you would describe a Car that can be instantiated, fueled up, and move. 12345678910111213141516171819function Car () &#123; this.fuel = 0; this.distance = 0;&#125;Car.prototype.move = function () &#123; if (this.fuel &lt; 1) &#123; throw new RangeError('Fuel tank is depleted') &#125; this.fuel-- this.distance += 2&#125;Car.prototype.addFuel = function () &#123; if (this.fuel &gt;= 60) &#123; throw new RangeError('Fuel tank is full') &#125; this.fuel++&#125; To move the car, you could use the following piece of code. 12345var car = new Car()car.addFuel()car.move()car.move()// &lt;- RangeError: 'Fuel tank is depleted' Neat. What about with ES6 classes? The syntax is very similar to declaring an object, except we precede it with class Name, where Name is the name for our class. Here we are leveraging the method signature notation we covered yesterday to declare the methods using a shorter syntax. The constructor is just like the constructor method in ES5, so you can use that to initialize any variables your instances may have. 12345678910111213141516171819class Car &#123; constructor () &#123; this.fuel = 0 this.distance = 0 &#125; move () &#123; if (this.fuel &lt; 1) &#123; throw new RangeError('Fuel tank is depleted') &#125; this.fuel-- this.distance += 2 &#125; addFuel () &#123; if (this.fuel &gt;= 60) &#123; throw new RangeError('Fuel tank is full') &#125; this.fuel++ &#125;&#125; In case you haven’t noticed, and for some obscure reason that escapes me, commas are invalid in-between properties or methods in a class, as opposed to object literals where commas are (still) mandatory. That discrepancy is bound to cause headaches to people trying to decide whether they want a plain object literal or a class instead, but the code does look sort of cleaner without the commas here. Many times “classes” have static methods. Think of your friend the Array for example. Arrays have instance methods like .filter, .reduce, and .map. The Array “class” itself has static methods as well, like Array.isArray. In ES5 code, it’s pretty easy to add these kind of methods to our Car “class”. 123456function Car () &#123; this.topSpeed = Math.random()&#125;Car.isFaster = function (left, right) &#123; return left.topSpeed &gt; right.topSpeed&#125; In ES6 class notation, we can use precede our method with static, following a similar syntax as that of get and set. Again, just sugar on top of ES5, as it’s quite trivial to transpile this down into ES5 notation. 12345678class Car &#123; constructor () &#123; this.topSpeed = Math.random() &#125; static isFaster (left, right) &#123; return left.topSpeed &gt; right.topSpeed &#125;&#125; One sweet aspect of ES6 class sugar is that you also get an extends keyword that enables you to easily “inherit” from other “classes”. We all know Tesla cars move further while using the same amount of fuel, thus the code below shows how Tesla extends Car and “overrides” (a concept you might be familiar with if you’ve ever played around with C#.aspx)) the move method to cover a larger distance. 123456class Tesla extends Car &#123; move () &#123; super.move() this.distance += 4 &#125;&#125; The special super keyword identifies the Car class we’ve inherited from – and since we’re speaking about C#, it’s akin to base. It’s raison d’être is that most of the time we override a method by re-implementing it in the inheriting class, – Tesla in our example – we’re supposed to call the method on the base class as well. This way we don’t have to copy logic over to the inheriting class whenever we re-implement a method. That’d be particularly lousy since whenever a base class changes we’d have to paste their logic into every inheriting class, turning our codebase into a maintainability nightmare. If you now did the following, you’ll notice the Tesla car moves two places because of base.move(), which is what every regular car does as well, and it moves an additional four places because Tesla is just that good. 12345var car = new Tesla()car.addFuel()car.move()console.log(car.distance)// &lt;- 6 The most common thing you’ll have to override is the constructor method. Here you can just call super(), passing any arguments that the base class needs. Tesla cars are twice as fast, so we just call the base Car constructor with twice the advertised speed. 12345678910class Car &#123; constructor (speed) &#123; this.speed = speed &#125;&#125;class Tesla extends Car &#123; constructor (speed) &#123; super(speed * 2) &#125;&#125;]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[06.Object Literals]]></title>
    <url>%2F2018%2F07%2F31%2FpureMaterial%2F06.object_literals%2F</url>
    <content type="text"><![CDATA[Object LiteralProperty Value ShorthandsWhenever you find yourself assigning a property value that matches a property name, you can omit the property value, it’s implicit in ES6. 1234var foo = 'bar'var baz = &#123; foo &#125;console.log(baz.foo)// &lt;- 'bar' In the snippet shown below I re-implemented part of localStorage in memory as a polyfill. It displays a pattern that I’ve followed countless times in my code. 12345678910111213141516171819var ms = &#123;&#125;function getItem (key) &#123; return key in ms ? ms[key] : null&#125;function setItem (key, value) &#123; ms[key] = value&#125;function clear () &#123; ms = &#123;&#125;&#125;module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125; The reasons why – most often – I don’t place functions directly on an object definition are several. Less indentation needed Public API stands out Harder to tightly couple methods Easier to reason about With ES6, we can throw another bullet into that list, and that’s that the export can be even easier using property value shorthands. You can omit the property value if it matches the property name. The module.exports from the code above thus becomes: 1module.exports = &#123; getItem, setItem, clear &#125; So good! Computed Property NamesWe already covered computed property names briefly in the destructuring article. This was a very common thing to do for me: 12345var foo = 'bar'var baz = &#123;&#125;baz[foo] = 'ponyfoo'console.log(baz)// &lt;- &#123; bar: 'ponyfoo' &#125; Computed property names allow you to write an expression wrapped in square brackets instead of the regular property name. Whatever the expression evaluates to will become the property name. 1234var foo = 'bar'var baz = &#123; [foo]: 'ponyfoo' &#125;console.log(baz)// &lt;- &#123; bar: 'ponyfoo' &#125; One limitation of computed property names is that you won’t be able to use the shorthand expression with it. I presume this is because shorthand expression is meant to be simple, compile-time sugar. 12345var foo = 'bar'var bar = 'ponyfoo'var baz = &#123; [foo] &#125;console.log(baz)// &lt;- SyntaxError That being said, I believe this to be the most common use case. Here our code is simpler because we don’t have to spend three steps in allocating a foo variable, assigning to foo[type], and returning foo. Instead we can do all three in a single statement. 12345678function getModel (type) &#123; return &#123; [type]: &#123; message: 'hello, this is doge', date: new Date() &#125; &#125;&#125; Neat. What else? Method DefinitionsTypically in ES5 you declare methods on an object like so: 1234var foo = &#123; bar: function (baz) &#123; &#125;&#125; While getters and setters have a syntax like this, where there’s no need for the function keyword. It’s just inferred from context. 123456789101112var cart = &#123; _wheels: 4, get wheels () &#123; return this._wheels &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error('hey, come back here!') &#125; this._wheels = value &#125;&#125; Starting in ES6, you can declare regular methods with a similar syntax, only difference is it’s not prefixed by get or set. 12345678910111213141516var cart = &#123; _wheels: 4, get wheels () &#123; return this._wheels &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error('hey, come back here!') &#125; this._wheels = value &#125;, dismantle () &#123; this._wheels = 0 console.warn(`you're all going to pay for this!`) &#125;&#125; I think it’s nice that methods converged together with getters and setter. I for one don’t use this syntax a lot because I like to name my functions and decouple them from their host objects as I explained in the shorthand section. However, it’s still useful in some situations and definitely useful when declaring “classes” – if you’re into that sort of thing.]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[extra --- 01.Fun with Native Arrays]]></title>
    <url>%2F2018%2F07%2F31%2FpureMaterial%2Fextra.01.fun_with_native_arrays%2F</url>
    <content type="text"><![CDATA[Fun with Native ArraysIn JavaScript, arrays can be created with the Array constructor, or using the [] convenience shortcut, which is also the preferred approach. Arrays inherit from the Object prototype and they haven’t a special value for typeof, they return &#39;object&#39; too. Using [] instanceof Array, however, returns true. That being said, there are also Array-like objects which complicate matters, such as strings, or the arguments object. The arguments object is not an instance of Array, but it still has a length property, and its values are indexed, so it can be looped like any Array. In this article I’ll go over a few of the methods on the Array prototype, and explore the possibilities each of these methods unveil. Looping with .forEach Asserting with .some and .every Subtleties in .join and .concat Stacks and queues with .pop, .push, .shift, and .unshift Model mapping with .map Querying with .filter Ordering with .sort Computing with .reduce, .reduceRight Copying a .slice The power of .splice Lookups with .indexOf The in operator Going in .reverse You can copy and paste any of the examples in your browser’s console, I sure did! Looping with .forEachThis is one of the simplest methods in a native JavaScript Array. Unsurprisingly unsupport in IE7 and IE8. forEach takes a callback which is invoked once for each element in the array, and gets passed three arguments. value containing the current array element index is the element’s position in the array array is a reference to the array Furthermore, we could pass an optional second argument which will become the context (this) for each function call. 123456['_', 't', 'a', 'n', 'i', 'f', ']'].forEach(function (value, index, array) &#123; this.push(String.fromCharCode(value.charCodeAt() + index + 2))&#125;, out = [])out.join('')// &lt;- 'awesome' I cheated with .join which we didn’t cover yet, but we’ll look at it soon. In this case, it joins together the different elements in the array, effectively doing something like out[0] + &#39;&#39; + out[1] + &#39;&#39; + out[2] + &#39;&#39; + out[n]. We can’t break forEach loops, and throwing exceptions wouldn’t be very sensible. Luckily, we have other options available to us in those cases where we might want to short-circuit a loop. Asserting with .some and .everyIf you’ve ever worked with .NET’s enumerables, these methods are the poorly named cousins of .Any(x =&gt; x.IsAwesome).aspx) and .All(x =&gt; x.IsAwesome).aspx). These methods are similar to .forEach in that they also take a callback with value, index, and array, which can be context-bound passing a second argument. The MDN docs describe .some: some executes the callback function once for each element present in the array until it finds one where callback returns a true value. If such an element is found, some immediately returns true. Otherwise, some returns false. callback is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values. 1234567891011max = -Infinitysatisfied = [10, 12, 10, 8, 5, 23].some(function (value, index, array) &#123; if (value &gt; max) max = value return value &lt; 10&#125;)console.log(max)// &lt;- 12satisfied// &lt;- true Note that the function stopped looping after it hit the first item which satisfied the callback’s condition value &lt; 10. .every works in the same way, but short-circuits happen when your callback returns false, rather than true. Subtleties in .join and .concatThe .join method is often confused with .concat. .join(separator) creates a string, resulting of taking every element in the array and separating them by separator. If no separator is provided, it’ll default to a comma &#39;,&#39;. .concat works by creating new arrays which are shallow copies of the source arrays. .concat has the signature: array.concat(val, val2, val3, valn) .concat returns a new array array.concat() with no arguments returns a shallow copy of the array Shallow copy means that the copy will hold the same object references as the source array, which is generally a good thing. For example: 123456789var a = &#123; foo: 'bar' &#125;var b = [1, 2, 3, a]var c = b.concat()console.log(b === c)// &lt;- falseb[3] === a &amp;&amp; c[3] === a// &lt;- true Stacks and queues with .pop, .push, .shift, and .unshiftNowadays, everyone knows that adding elements to the end of an array is done using .push. Did you know that you can push many elements at once using [].push(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;z&#39;)? The .pop method is the counterpart of the most common use for .push. It’ll return the last element in the array, and remove it from the array at the same time. If the array is empty, void 0 (undefined) is returned. Using .push and .pop we could easily create a LIFO (last in first out)) stack. 1234567891011121314151617function Stack () &#123; this._stack = []&#125;Stack.prototype.next = function () &#123; return this._stack.pop()&#125;Stack.prototype.add = function () &#123; return this._stack.push.apply(this._stack, arguments)&#125;stack = new Stack()stack.add(1,2,3)stack.next()// &lt;- 3 Inversely, we could create a FIFO (first in first out) queue using .unshift and .shift. 1234567891011121314151617function Queue () &#123; this._queue = []&#125;Queue.prototype.next = function () &#123; return this._queue.shift()&#125;Queue.prototype.add = function () &#123; return this._queue.unshift.apply(this._queue, arguments)&#125;queue = new Queue()queue.add(1,2,3)queue.next()// &lt;- 1 Using .shift (or .pop) is an easy way to loop through a set of array elements, while draining the array in the process. 12345678list = [1,2,3,4,5,6,7,8,9,10]while (item = list.shift()) &#123; console.log(item)&#125;list// &lt;- [] Model mapping with .map map calls a provided callback function once for each element in an array, in order, and constructs a new array from the results. callback is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values. The Array.prototype.map method has the same signature we’ve seen in .forEach, .some, and .every: .map(fn(value, index, array), thisArgument). 12345678values = [void 0, null, false, '']values[7] = void 0result = values.map(function(value, index, array)&#123; console.log(value) return value&#125;)// &lt;- [undefined, null, false, '', undefined × 3, undefined] The undefined × 3 values explain that while .map won’t run for deleted or unassigned array elements, they’ll be still included in the resulting array. Mapping is very useful for casting or transforming arrays. 12345678910111213141516// casting[1, '2', '30', '9'].map(function (value) &#123; return parseInt(value, 10)&#125;)// 1, 2, 30, 9[97, 119, 101, 115, 111, 109, 101].map(String.fromCharCode).join('')// &lt;- 'awesome'// a commonly used pattern is mapping to new objectsitems.map(function (item) &#123; return &#123; id: item.id, name: computeName(item) &#125;&#125;) Querying with .filter filter calls a provided callback function once for each element in an array, and constructs a new array of all the values for which callback returns a true value. callback is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values. Array elements which do not pass the callback test are simply skipped, and are not included in the new array. Same as usual: .filter(fn(value, index, array), thisArgument). Think of it as the .Where(x =&gt; x.IsAwesome) LINQ expression (if you’re into C#), or the WHERE SQL clause. Considering .filter only returns elements which pass the callback test with a truthy value, there are some interesting use cases. 123456789[void 0, null, false, '', 1].filter(function (value) &#123; return value&#125;)// &lt;- [1][void 0, null, false, '', 1].filter(function (value) &#123; return !value&#125;)// &lt;- [void 0, null, false, ''] Ordering with .sort(compareFunction) If compareFunction is not supplied, elements are sorted by converting them to strings and comparing strings in lexicographic (“dictionary” or “telephone book,” not numerical) order. For example, “80” comes before “9” in lexicographic order, but in a numeric sort 9 comes before 80. Like most sorting functions, Array.prototype.sort(fn(a,b)) takes a callback which tests two elements, and should produce one of three return values: return value &lt; 0 if a comes before b return value === 0 if both a and b are considered equivalent return value &gt; 0 if a comes after b 1234567[9,80,3,10,5,6].sort()// &lt;- [10, 3, 5, 6, 80, 9][9,80,3,10,5,6].sort(function (a, b) &#123; return a - b&#125;)// &lt;- [3, 5, 6, 9, 10, 80] Computing with .reduce, .reduceRightReduce functions are, at first, hard to wrap our heads around. These functions loop through the array, from left-to-right (.reduce) or right-to-left (.reduceRight), each invocation receives the partial result so far, and the operation results in a single aggregated return value. Both methods have the following signature: .reduce(callback(previousValue, currentValue, index, array), initialValue). The previousValue will be the value returned in the last callback invocation, or initialValue the first time around. currentValue contains the current element, while index indicates the array position for the element. array is simply a reference to the array .reduce was called on. One of the typical use cases for .reduce is the sum function. 12345678Array.prototype.sum = function () &#123; return this.reduce(function (partial, value) &#123; return partial + value &#125;, 0)&#125;;[3,4,5,6,10].sum()// &lt;- 28 Say we wanted to join a few strings together. We could use .join to that purpose. In the case of objects, though, .join wouldn’t work as we expected, unless the objects had a reasonable valueOf or toString representation. However, we might use .reduce as a string builder for those objects. 123456789101112131415function concat (input) &#123; return input.reduce(function (partial, value) &#123; if (partial) &#123; partial += ', ' &#125; return partial + value.name &#125;, '')&#125;concat([ &#123; name: 'George' &#125;, &#123; name: 'Sam' &#125;, &#123; name: 'Pear' &#125;])// &lt;- 'George, Sam, Pear' Copying a .sliceSimilarly to .concat, calls to .slice without any arguments produce a shallow copy of the source array. Slice takes two arguments, a begin and an end position. Array.prototype.slice can be used to convert array-like objects into real arrays. 12Array.prototype.slice.call(&#123; 0: 'a', 1: 'b', length: 2 &#125;)// &lt;- ['a', 'b'] This won’t work with .concat, because it’ll wrap the array-like object in a real array, instead. 12Array.prototype.concat.call(&#123; 0: 'a', 1: 'b', length: 2 &#125;)// &lt;- [&#123; 0: 'a', 1: 'b', length: 2 &#125;] Other than that, another common use for .slice is removing the first few elements from a list of arguments (an array-like object, which we could cast to a real array). 123456789101112131415function format (text, bold) &#123; if (bold) &#123; text = '&lt;b&gt;' + text + '&lt;/b&gt;' &#125; var values = Array.prototype.slice.call(arguments, 2) values.forEach(function (value) &#123; text = text.replace('%s', value) &#125;) return text&#125;format('some%sthing%s %s', true, 'some', 'other', 'things')// &lt;- &lt;b&gt;somesomethingother things&lt;/b&gt; The power of .splice.splice is one of my favorite native array functions. It allows you to remove elements, insert new ones, and to do both in the same position, using just one function call. Note that this function alters the source array, unlike .concat or .slice. 12345678var source = [1,2,3,8,8,8,8,8,9,10,11,12,13]var spliced = source.splice(3, 4, 4, 5, 6, 7)console.log(source)// &lt;- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ,13]spliced// &lt;- [8, 8, 8, 8] As you might’ve noted, it also returns the removed elements. This might come in handy if you want to loop a section of the array and then forget about it. 12345678910111213var source = [1,2,3,8,8,8,8,8,9,10,11,12,13]var spliced = source.splice(9)spliced.forEach(function (value) &#123; console.log('removed', value)&#125;)// &lt;- removed 10// &lt;- removed 11// &lt;- removed 12// &lt;- removed 13console.log(source)// &lt;- [1, 2, 3, 8, 8, 8, 8, 8, 9] Lookups with .indexOfWith .indexOf, we can look up array element positions. If it can’t find a match, -1 is returned. A pattern I find myself using a lot, is when I have comparisons such as a === &#39;a&#39; || a === &#39;b&#39; || a === &#39;c&#39;, or even with just two comparsions. You could just use .indexOf, like so: [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].indexOf(a) !== -1. Note that objects will be found only if the same reference is provided. A second argument can provide the start index at which to begin searching. 1234567891011121314151617var a = &#123; foo: 'bar' &#125;var b = [a, 2]console.log(b.indexOf(1))// &lt;- -1console.log(b.indexOf(&#123; foo: 'bar' &#125;))// &lt;- -1console.log(b.indexOf(a))// &lt;- 0console.log(b.indexOf(a, 1))// &lt;- -1b.indexOf(2, 1)// &lt;- 1 If you want to go in the reverse direction, .lastIndexOf will do the trick. The in operatorA common rookie mistake during interviews is to confuse .indexOf with the in operator, and hand-scribbling things such as: 1234567var a = [1, 2, 5]1 in a// &lt;- true, but because of the 2!5 in a// &lt;- false The problem here was that the in operator checks the object key for a value, rather than searching for values. This is, of course, much faster than using .indexOf. 1234var a = [3, 7, 6]1 in a === !!a[1]// &lt;- true The in operator is similar to casting the value at the provided key to a boolean value. The !! expression is used by some developers to negate a value, and then negate it again. Effectively casting to boolean any truthy value to true, and any falsy value to false. Going in .reverseThis method will take the elements in an array and reverse them in place. 1234var a = [1, 1, 7, 8]a.reverse()// [8, 7, 1, 1] Rather than a copy, the array itself is modified. In a future article we’ll expand on these concepts to see how we could create an _-like library, such as Underscore or Lo-Dash.]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[05.Template Literals]]></title>
    <url>%2F2018%2F07%2F31%2FpureMaterial%2F05.template_literals%2F</url>
    <content type="text"><![CDATA[Template LiteralsTemplate literals are a new feature in ES6 to make working with strings and string templates easier. You wrap your text in `backticks` and you’ll get the features described below. You can interpolate variables in them You can actually interpolate using any kind of expression, not just variables They can be multi-line. Finally! You can construct raw templates that don’t interpret backslashes In addition, you can also define a method that will decide what to make of the template, instead of using the default templating behavior. There are some interesting use cases for this one. Let’s dig into template literals and see what we can come up with. Using Template LiteralsWe’ve already covered the basic `I&#39;m just a string`. One aspect of template literals that may be worth mentioning is that you’re now able to declare strings with both &#39; and &quot; quotation marks in them without having to escape anything. 1var text = `I'm "amazed" that we have so many quotation marks to choose from!` That was neat, but surely there’s more useful stuff we can apply template literals to. How about some actual interpolation? You can use the ${expression} notation for that. 1234var host = 'ponyfoo.com'var text = `this blog lives at $&#123;host&#125;`console.log(text)// &lt;- 'this blog lives at ponyfoo.com' I’ve already mentioned you can have any kind of expressions you want in there. Think of whatever expressions you put in there as defining a variable before the template runs, and then concatenating that value with the rest of the string. That means that variables you use, methods you call, and so on, should all be available to the current scope. The following expressions would all work just as well. It’ll be up to us to decide how much logic we cram into the interpolation expressions. 123var text = `this blog lives at $&#123;'ponyfoo.com'&#125;`console.log(text)// &lt;- 'this blog lives at ponyfoo.com' 1234var today = new Date()var text = `the time and date is $&#123;today.toLocaleString()&#125;`console.log(text)// &lt;- 'the time and date is 8/26/2015, 3:15:20 PM' 12345import moment from 'moment'var today = new Date()var text = `today is the $&#123;moment(today).format('Do [of] MMMM')&#125;`console.log(text)// &lt;- 'today is the 26th of August' 123var text = `such $&#123;Infinity/0&#125;, very uncertain`console.log(text)// &lt;- 'such Infinity, very uncertain' Multi-line strings mean that you no longer have to use methods like these anymore. 12345var text = ( 'foo\n' + 'bar\n' + 'baz') 12345var text = [ 'foo', 'bar', 'baz'].join('\n') Instead, you can now just use backticks! Note that spacing matters, so you might still want to use parenthesis in order to keep the first line of text away from the variable declaration. 1234var text = (`foobarbaz`) Multi-line strings really shine when you have, for instance, a chunk of HTML you want to interpolate some variables to. Much like with JSX, you’re perfectly able to use an expression to iterate over a collection and return yet another template literal to declare list items. This makes it a breeze to declare sub-components in your templates. Note also how I’m using destructuring to avoid having to prefix every expression of mine with article., I like to think of it as “a with block, but not as insane”. 123456789101112131415161718192021var article = &#123; title: 'Hello Template Literals', teaser: 'String interpolation is awesome. Here are some features', body: 'Lots and lots of sanitized HTML', tags: ['es6', 'template-literals', 'es6-in-depth']&#125;var &#123;title,teaser,body,tags&#125; = articlevar html = `&lt;article&gt; &lt;header&gt; &lt;h1&gt;$&#123;title&#125;&lt;/h1&gt; &lt;/header&gt; &lt;section&gt; &lt;div&gt;$&#123;teaser&#125;&lt;/div&gt; &lt;div&gt;$&#123;body&#125;&lt;/div&gt; &lt;/section&gt; &lt;footer&gt; &lt;ul&gt; $&#123;tags.map(tag =&gt; `&lt;li&gt;$&#123;tag&#125;&lt;/li&gt;`).join('\n ')&#125; &lt;/ul&gt; &lt;/footer&gt;&lt;/article&gt;` The above will produce output as shown below. Note how the spacing trick was enough to properly indent the &lt;li&gt; tags. 12345678910111213141516&lt;article&gt; &lt;header&gt; &lt;h1&gt;Hello Template Literals&lt;/h1&gt; &lt;/header&gt; &lt;section&gt; &lt;div&gt;String interpolation is awesome. Here are some features&lt;/div&gt; &lt;div&gt;Lots and lots of sanitized HTML&lt;/div&gt; &lt;/section&gt; &lt;footer&gt; &lt;ul&gt; &lt;li&gt;es6&lt;/li&gt; &lt;li&gt;template-literals&lt;/li&gt; &lt;li&gt;es6-in-depth&lt;/li&gt; &lt;/ul&gt; &lt;/footer&gt;&lt;/article&gt; Raw templates are the same in essence, you just have to prepend your template literal with String.raw. This can be very convenient in some use cases. 12345var text = String.raw`The "\n" newline won't result in a new line.It'll be escaped.`console.log(text)// The "\n" newline won't result in a new line.// It'll be escaped. You might’ve noticed that String.raw seems to be a special part of the template literal syntax, and you’d be right! The method you choose will be used to parse the template. Template literal methods – called “tagged templates” – receive an array containing a list of the static parts of the template, as well as each expression on their own variables. For instance a template literal like `hello ${name}. I am ${emotion}!` will pass arguments to the “tagged template” in a function call like the one below. 1fn(['hello ', '. I am', '!'], 'nico', 'confused') You might be confused by the seeming oddity in which the arguments are laid out, but they start to make sense when you think of it this way: for every item in the template array, there’s an expression result after it. Demystifying Tagged TemplatesI wrote an example normal method below, and it works exactly like the default behavior. This might help you better understand what happens under the hood for template literals. If you don’t know what .reduce does, refer to MDN or my “Fun with Native Arrays” article. Reduce is always useful when you’re trying to map a collection of values into a single value that can be computed from the collection. In this case we can reduce the template starting from template[0] and then reducing all other parts by adding the preceding expression and the subsequent part. 12345function normal (template, ...expressions) &#123; return template.reduce((accumulator, part, i) =&gt; &#123; return accumulator + expressions[i - 1] + part &#125;)&#125; The ...expressions syntax is new in ES6 as well. It’s called the “rest parameters syntax”, and it’ll basically place all the arguments passed to normal that come after template into a single array. You can try the tagged template as seen below, and you’ll notice you get the same output as if you omitted normal. 12345var name = 'nico'var outfit = 'leather jacket'var text = normal`hello $&#123;name&#125;, you look lovely today in that $&#123;outfit&#125;`console.log(text)// &lt;- 'hello nico, you look lovely today in that leather jacket' Now that we’ve figured out how tagged templates work, what can we do with them? Well, whatever we want. One possible use case might be to make user input uppercase, turning our greeting into something that sounds more satirical – I read the result out loud in my head with Gob’s voice from Arrested Development, now I’m laughing alone. I’ve made a huge mistake. 12345678910function upperExpr (template, ...expressions) &#123; return template.reduce((accumulator, part, i) =&gt; &#123; return accumulator + expressions[i - 1].toUpperCase() + part &#125;)&#125;var name = 'nico'var outfit = 'leather jacket'var text = upperExpr`hello $&#123;name&#125;, you look lovely today in that $&#123;outfit&#125;`console.log(text)// &lt;- 'hello NICO, you look lovely today in that LEATHER JACKET' There’s obviously much more useful use cases for tagged templates than laughing at yourself. In fact, you could go crazy with tagged templates. A decidedly useful use case would be to sanitize user input in your templates automatically. Given a template where all expressions are considered user-input, we could use insane to sanitize them out of HTML tags we dislike. 12345678910import insane from 'insane'function sanitize (template, ...expressions) &#123; return template.reduce((accumulator, part, i) =&gt; &#123; return accumulator + insane(expressions[i - 1]) + part &#125;)&#125;var comment = 'haha xss is so easy &lt;iframe src="http://evil.corp"&gt;&lt;/iframe&gt;'var html = sanitize`&lt;div&gt;$&#123;comment&#125;&lt;/div&gt;`console.log(html)// &lt;- '&lt;div&gt;haha xss is so easy &lt;/div&gt;' Not so easy now! I can definitely see a future where the only strings I use in JavaScript begin and finish with a backtick.]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[04.Arrow Functions]]></title>
    <url>%2F2018%2F07%2F31%2FpureMaterial%2F04.arrow_functions%2F</url>
    <content type="text"><![CDATA[Arrow FunctionsUsing Arrow Functions in JavaScriptArrow functions are available to many other modern languages and was one of the features I sorely missed a few years ago when I moved from C# to JavaScript. Fortunately, they’re now part of ES6 and thus available to us in JavaScript. The syntax is quite expressive. We already had anonymous functions, but sometimes it’s nice to have a terse alternative. Here’s how the syntax looks like if we have a single argument and just want to return the results for an expression. 12[1, 2, 3].map(num =&gt; num * 2)// &lt;- [2, 4, 6] The ES5 equivalent would be as below. 12[1, 2, 3].map(function (num) &#123; return num * 2 &#125;)// &lt;- [2, 4, 6] If we need to declare more arguments (or no arguments), we’ll have to use parenthesis. 12[1, 2, 3, 4].map((num, index) =&gt; num * 2 + index)// &lt;- [2, 5, 8, 11] You might want to have some other statements and not just an expression to return. In this case you’ll have to use bracket notation. 12345[1, 2, 3, 4].map(num =&gt; &#123; var multiplier = 2 + num return num * multiplier&#125;)// &lt;- [3, 8, 15, 24] You could also add more arguments with the parenthesis syntax here. 12345[1, 2, 3, 4].map((num, index) =&gt; &#123; var multiplier = 2 + index return num * multiplier&#125;)// &lt;- [2, 6, 12, 20] At that point, however, chances are you’d be better off using a named function declaration for a number of reasons. (num, index) =&gt; is only marginally shorter than function (num, index) The function form allows you to name the method, improving code quality When a function has multiple arguments and multiple statements, I’d say it’s improbable that six extra characters will make a difference However, naming the method might add just enough context into the equation that those six extra characters (plus method name) become really worthwhile Moving on, if we need to return an object literal, we’ll have to wrap the expression in parenthesis. That way the object literal won’t be interpreted as a statement block (which would result in a silent error or worse, a syntax error because number: n isn’t a valid expression in the example below. The first example interprets number as a label and then figures out we have an n expression. Since we’re in a block and not returning anything, the mapped values will be undefined. In the second case, after the label and the n expression, , something: &#39;else&#39; makes no sense to the compiler, and a SyntaxError is thrown. 12345678910111213[1, 2, 3].map(n =&gt; &#123; number: n &#125;)// [undefined, undefined, undefined][1, 2, 3].map(n =&gt; &#123; number: n, something: 'else' &#125;)// &lt;- SyntaxError[1, 2, 3].map(n =&gt; (&#123; number: n &#125;))// &lt;- [&#123; number: 1 &#125;, &#123; number: 2 &#125;, &#123; number: 3 &#125;][1, 2, 3].map(n =&gt; (&#123; number: n, something: 'else' &#125;))/* &lt;- [ &#123; number: 1, something: 'else' &#125;, &#123; number: 2, something: 'else' &#125;, &#123; number: 3, something: 'else' &#125;]*/ A cool aspect of arrow functions in ES6 is that they’re bound to their lexical scope. That means that you can say goodbye to var self = this and similar hacks – such as using .bind(this) – to preserve the context from within deeply nested methods. 1234567function Timer () &#123; this.seconds = 0 setInterval(() =&gt; this.seconds++, 1000)&#125;var timer = new Timer()setTimeout(() =&gt; console.log(timer.seconds), 3100)// &lt;- 3 Keep in mind that the lexical this binding in ES6 arrow functions means that .call and .apply won’t be able to change the context. Usually however, that’s more of a feature than a bug. ConclusionsArrow functions are neat when it comes to defining anonymous functions that should probably be lexically bound anyways, and they can definitely make your code more terse in some situations. There’s no reason why you should be turning all of your function declarations into arrow functions unless their arguments and expression body are descriptive enough. I’m a big proponent of named function declarations, because they improve readability of the codebase without the need for comments – which means I’ll have “a hard time” adopting arrow functions in most situations. That being said, I think arrow functions are particularly useful in most functional programming situations such as when using .map, .filter, or .reduce on collections. Similarly, arrow functions will be really useful in asynchronous flows since those typically have a bunch of callbacks that just do argument balancing, a situation where arrow functions really shine.]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.Spread Operator and Rest Parameters]]></title>
    <url>%2F2018%2F07%2F31%2FpureMaterial%2F03.spread_operator_and_rest_parameters%2F</url>
    <content type="text"><![CDATA[Spread Operator and Rest ParametersRest parametersYou know how sometimes there’s a ton of arguments and you end up having to use the arguments magic variable to work with them? Consider the following method that joins any arguments passed to it as a string. 123456function concat () &#123; return Array.prototype.slice.call(arguments).join(' ')&#125;var result = concat('this', 'was', 'no', 'fun')console.log(result)// &lt;- 'this was no fun' The rest parameters syntax enables you to pull a real Array out of the function‘s arguments by adding a parameter name prefixed by .... Definitely simpler, the fact that it’s a real Array is also very convenient, and I for one am glad not to have to resort to arguments anymore. 123456function concat (...words) &#123; return words.join(' ')&#125;var result = concat('this', 'is', 'okay')console.log(result)// &lt;- 'this is okay' When you have more parameters in your function it works slightly different. Whenever I declare a method that has a rest parameter, I like to think of its behavior as follows. Rest parameter gets all the arguments passed to the function call Each time a parameter is added on the left, it’s as if its value is assigned by calling rest.shift() Note that you can’t actually place parameters to the right: rest parameters can only be the last argument It’s easier to visualize how that would behave than try to put it into words, so let’s do that. The method below computes the sum for all arguments except the first one, which is then used as a multiplier for the sum. In case you don’t recall, .shift() returns the first value in an array, and also removes it from the collection, which makes it a useful mnemonic device in my opinion. 12345678910function sum () &#123; var numbers = Array.prototype.slice.call(arguments) // numbers gets all arguments var multiplier = numbers.shift() var base = numbers.shift() var sum = numbers.reduce((accumulator, num) =&gt; accumulator + num, base) return multiplier * sum&#125;var total = sum(2, 6, 10, 8, 9)console.log(total)// &lt;- 66 Here’s how that method would look if we were to use the rest parameter to pluck the numbers. Note how we don’t need to use arguments nor do any shifting anymore. This is great because it vastly reduces the complexity in our method – which now can focus on its functionality itself and not so much on rebalancing arguments. 1234567function sum (multiplier, base, ...numbers) &#123; var sum = numbers.reduce((accumulator, num) =&gt; accumulator + num, base) return multiplier * sum&#125;var total = sum(2, 6, 10, 8, 9)console.log(total)// &lt;- 66 Spread OperatorTypically you invoke a function by passing arguments into it. 12console.log(1, 2, 3)// &lt;- '1 2 3' Sometimes however you have those arguments in a list and just don’t want to access every index just for a method call – or you just can’t because the array is formed dynamically – so you use .apply. This feels kind of awkward because .apply also takes a context for this, which feels out of place when it’s not relevant and you have to reiterate the host object (or use null). 12console.log.apply(console, [1, 2, 3])// &lt;- '1 2 3' The spread operator can be used as a butter knife alternative over using .apply. There is no need for a context either. You just append three dots ... to the array, just like with the rest parameter. 12console.log(...[1, 2, 3])// &lt;- '1 2 3' As we’ll investigate more in-depth next monday, in the article about iterators in ES6, a nice perk of the spread operator is that it can be used on anything that’s an iterable. This encompasses even things like the results of document.querySelectorAll(&#39;div&#39;). 12[...document.querySelectorAll('div')]// &lt;- [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] Another nice aspect of the butter knife operator is that you can mix and match regular arguments with it, and they’ll be spread over the function call exactly how you’d expect them to. This, too, can be very very useful when you have a lot of argument rebalancing going on in your ES5 code. 12console.log(1, ...[2, 3, 4], 5) // becomes `console.log(1, 2, 3, 4, 5)`// &lt;- '1 2 3 4 5' Time for a real-world example. I sometimes use the method below in Express applications to allow morgan (the request logger in Express) stream its messages through winston, a general purpose multi-transport logger. I remove the trailing line breaks from the message because winston already takes care of those. I also place some metadata about the currently executing process like the host and the process pid into the arguments list, and then I .apply everything on the winston logging mechanism. If you take a close look at the code, the only line of code that’s actually doing anything is the one I’ve highlighted in yellow, the rest is just playing around with arguments. 1234567891011121314function createWriteStream (level) &#123; return &#123; write: function () &#123; var bits = Array.prototype.slice.call(arguments) var message = bits.shift().replace(/\n+$/, '') // remove trailing breaks bits.unshift(message) bits.push(&#123; hostname: os.hostname(), pid: process.pid &#125;) winston[level].apply(winston, bits) &#125; &#125;&#125;app.use(morgan(':status :method :url', &#123; stream: createWriteStream('debug')&#125;)) We can thoroughly simplify the solution with ES6. First, we can use the rest parameter instead of relying on arguments. The rest parameter already gives us a true array, so there’s no casting involved either. We can grab the message directly as the first parameter, and we can then apply everything on winston[level] directly by combining normal arguments with the rest of the ...bits and pieces. The code below is in much better shape, as now every piece of it is actually relevant to what we’re trying to accomplish, which is call winston[level] with a few modified arguments. The piece of code we had earlier, in contrast, spent most time manipulating the arguments, and the focus quickly dissipated into a battle of wits against JavaScript itself – the method stopped being about the code we were trying to write. 123456789function createWriteStream (level) &#123; return &#123; write: function (message, ...bits) &#123; winston[level](message.replace(/\n+$/, ''), ...bits, &#123; hostname: os.hostname(), pid: process.pid &#125;) &#125; &#125;&#125; We could further simplify the method by pulling the process metadata out, since that won’t change for the lifespan of the process. We could’ve done that in the ES5 code too, though. 12345678var proc = &#123; hostname: os.hostname(), pid: process.pid &#125;function createWriteStream (level) &#123; return &#123; write: function (message, ...bits) &#123; winston[level](message.replace(/\n+$/, ''), ...bits, proc) &#125; &#125;&#125; Another thing we could do to shorten that piece of code might be to use an arrow function. In this case however, it would only complicate matters. You’d have to shorten message to msg so that it fits in a single line, and the call to winston[level] with the rest and spread operators in there makes it an incredibly complicated sight to anyone who hasn’t spent the last 15 minutes thinking about the method – be it a team mate or yourself the week after you wrote this function. 123456var proc = &#123; hostname: os.hostname(), pid: process.pid &#125;function createWriteStream (level) &#123; return &#123; write: (msg, ...bits) =&gt; winston[level](msg.replace(/\n+$/, ''), ...bits, proc) &#125;&#125; It would be wiser to just keep our earlier version. While it’s quite self-evident in this case that an arrow function only piles onto the complexity, in other cases it might not be so. It’s up to you to decide, and you need to be able to distinguish between using ES6 features because they genuinely improve your codebase and its maintainability, or whether you’re actually decreasing maintainability by translating things into ES6 just for the sake of doing so. Some other useful uses are detailed below. You can obviously use the spread operator when creating a new array, but you can also use while destructuring, in which case it works sort of like ...rest did, and a use case that’s not going to come up often but is still worth mentioning is that you can use spread to pseudo-.apply when using the new operator as well. Use Case ES5 ES6 Concatenation [1, 2].concat(more) [1, 2, ...more] Push onto list list.push.apply(list, [3, 4]) list.push(...[3, 4]) Destructuring a = list[0], rest = list.slice(1) [a, ...rest] = list new + apply new (Date.bind.apply(Date, [null,2015,8,1])) new Date(...[2015,8,1]) Default OperatorThe default operator is something we’ve covered in the destructuring article, but only tangentially. Just like you can use default values during destructuring, you can define a default value for any parameter in a function, as shown below. 123456789function sum (left=1, right=2) &#123; return left + right&#125;console.log(sum())// &lt;- 3console.log(sum(2))// &lt;- 4console.log(sum(1, 0))// &lt;- 1 Consider the code that initializes options in dragula. 12345678910111213function dragula (options) &#123; var o = options || &#123;&#125;; if (o.moves === void 0) &#123; o.moves = always; &#125; if (o.accepts === void 0) &#123; o.accepts = always; &#125; if (o.invalid === void 0) &#123; o.invalid = invalidTarget; &#125; if (o.containers === void 0) &#123; o.containers = initialContainers || []; &#125; if (o.isContainer === void 0) &#123; o.isContainer = never; &#125; if (o.copy === void 0) &#123; o.copy = false; &#125; if (o.revertOnSpill === void 0) &#123; o.revertOnSpill = false; &#125; if (o.removeOnSpill === void 0) &#123; o.removeOnSpill = false; &#125; if (o.direction === void 0) &#123; o.direction = 'vertical'; &#125; if (o.mirrorContainer === void 0) &#123; o.mirrorContainer = body; &#125;&#125;]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.Assignment Destructuring]]></title>
    <url>%2F2018%2F07%2F31%2FpureMaterial%2F02.Assignment_destructuring%2F</url>
    <content type="text"><![CDATA[DestructuringThis is easily one of the features I’ve been using the most. It’s also one of the simplest. It binds properties to as many variables as you need and it works with both Arrays and Objects.123456var foo = &#123; bar: 'pony', baz: 3 &#125;var &#123;bar, baz&#125; = fooconsole.log(bar)// &lt;- 'pony'console.log(baz)// &lt;- 3 It makes it very quick to pull out a specific property from an object. You’re also allowed to map properties into aliases as well. 123456var foo = &#123; bar: 'pony', baz: 3 &#125;var &#123;bar: a, baz: b&#125; = fooconsole.log(a)// &lt;- 'pony'console.log(b)// &lt;- 3 You can also pull properties as deep as you want, and you could also alias those deep bindings. 123456var foo = &#123; bar: &#123; deep: 'pony', dangerouslySetInnerHTML: 'lol' &#125; &#125;var &#123;bar: &#123; deep, dangerouslySetInnerHTML: sure &#125;&#125; = fooconsole.log(deep)// &lt;- 'pony'console.log(sure)// &lt;- 'lol' By default, properties that aren’t found will be undefined, just like when accessing properties on an object with the dot or bracket notation. 123var &#123;foo&#125; = &#123;bar: 'baz'&#125;console.log(foo)// &lt;- undefined If you’re trying to access a deeply nested property of a parent that doesn’t exist, then you’ll get an exception, though. 12var &#123;foo:&#123;bar&#125;&#125; = &#123;baz: 'ouch'&#125;// &lt;- Exception That makes a lot of sense, if you think of destructuring as sugar for ES5 like the code below. 123var _temp = &#123; baz: 'ouch' &#125;var bar = _temp.foo.bar// &lt;- Exception A cool property of destructuring is that it allows you to swap variables without the need for the infamous aux variable. 12345678910111213141516171819function es5 () &#123; var left = 10 var right = 20 var aux if (right &gt; left) &#123; aux = right right = left left = aux &#125;&#125;function es6 () &#123; var left = 10 var right = 20 if (right &gt; left) &#123; [left, right] = [right, left] &#125;&#125; Another convenient aspect of destructuring is the ability to pull keys using computed property names. 1234var key = 'such_dynamic'var &#123; [key]: foo &#125; = &#123; such_dynamic: 'bar' &#125;console.log(foo)// &lt;- 'bar' In ES5, that’d take an extra statement and variable allocation on your behalf. 1234var key = 'such_dynamic'var baz = &#123; such_dynamic: 'bar' &#125;var foo = baz[key]console.log(foo) You can also define default values, for the case where the pulled property evaluates to undefined. 123456789var &#123;foo=3&#125; = &#123; foo: 2 &#125;console.log(foo)// &lt;- 2var &#123;foo=3&#125; = &#123; foo: undefined &#125;console.log(foo)// &lt;- 3var &#123;foo=3&#125; = &#123; bar: 2 &#125;console.log(foo)// &lt;- 3 Destructuring works for Arrays as well, as we mentioned earlier. Note how I’m using square brackets in the destructuring side of the declaration now. 123var [a] = [10]console.log(a)// &lt;- 10 Here, again, we can use the default values and follow the same rules. 123456789var [a] = []console.log(a)// &lt;- undefinedvar [b=10] = [undefined]console.log(b)// &lt;- 10var [c=10] = []console.log(c)// &lt;- 10 When it comes to Arrays you can conveniently skip over elements that you don’t care about. 12345var [,,a,b] = [1,2,3,4,5]console.log(a)// &lt;- 3console.log(b)// &lt;- 4 You can also use destructuring in a function‘s parameter list. 1234567function greet (&#123; age, name:greeting='she' &#125;) &#123; console.log(`$&#123;greeting&#125; is $&#123;age&#125; years old.`)&#125;greet(&#123; name: 'nico', age: 27 &#125;)// &lt;- 'nico is 27 years old'greet(&#123; age: 24 &#125;)// &lt;- 'she is 24 years old' That’s roughly how you can use destructuring. What is destructuring good for? Use Cases for DestructuringThere are many situations where destructuring comes in handy. Here’s some of the most common ones. Whenever you have a method that returns an object, destructuring makes it much terser to interact with. 1234567891011function getCoords () &#123; return &#123; x: 10, y: 22 &#125;&#125;var &#123;x, y&#125; = getCoords()console.log(x)// &lt;- 10console.log(y)// &lt;- 22 A similar use case but in the opposite direction is being able to define default options when you have a method with a bunch of options that need default values. This is particularly interesting as an alternative to named parameters in other languages like Python and C#. 1234567function random (&#123; min=1, max=300 &#125;) &#123; return Math.floor(Math.random() * (max - min)) + min&#125;console.log(random(&#123;&#125;))// &lt;- 174console.log(random(&#123;max: 24&#125;))// &lt;- 18 If you wanted to make the options object entirely optional you could change the syntax to the following. 12345function random (&#123; min=1, max=300 &#125; = &#123;&#125;) &#123; return Math.floor(Math.random() * (max - min)) + min&#125;console.log(random())// &lt;- 133 A great fit for destructuring are things like regular expressions, where you would just love to name parameters without having to resort to index numbers. Here’s an example parsing a URL with a random RegExp I got on StackOverflow. 1234567891011121314function getUrlParts (url) &#123; var magic = /^(https?):\/\/(ponyfoo\.com)(\/articles\/([a-z0-9-]+))$/ return magic.exec(url)&#125;var parts = getUrlParts('http://ponyfoo.com/articles/es6-destructuring-in-depth')var [,protocol,host,pathname,slug] = partsconsole.log(protocol)// &lt;- 'http'console.log(host)// &lt;- 'ponyfoo.com'console.log(pathname)// &lt;- '/articles/es6-destructuring-in-depth'console.log(slug)// &lt;- 'es6-destructuring-in-depth' Special Case: import StatementsEven though import statements don’t follow destructuring rules, they behave a bit similarly. This is probably the “destructuring-like” use case I find myself using the most, even though it’s not actually destructuring. Whenever you’re writing module import statements, you can pull just what you need from a module’s public API. An example using contra: 1234import &#123;series, concurrent, map &#125; from 'contra'series(tasks, done)concurrent(tasks, done)map(items, mapper, done) Note that, however, import statements have a different syntax. When compared against destructuring, none of the following import statements will work. Use defaults values such as import {series = noop} from &#39;contra&#39; “Deep” destructuring style like import {map: { series }} from &#39;contra&#39; Aliasing syntax import {map: mapAsync} from &#39;contra&#39; The main reason for these limitations is that the import statement brings in a binding, and not a reference or a value. This is an important differentiation that we’ll explore more in depth in a future article about ES6 modules.]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.An introduction to how JavaScript package managers work]]></title>
    <url>%2F2018%2F07%2F30%2FpureMaterial%2F01.package_managers%2F</url>
    <content type="text"><![CDATA[An introduction to how JavaScript package managers workA few days ago, ashley williams, one of the leaders of the Node.js community, tweeted this: lockfiles = awesome for apps, bad for libs this is not a new thought, i’m confused why’s everyone mad about this I didn’t really understand what she meant, so I decided to dig in deeper and read about how package managers work. This was right when the newest kid on the JavaScript package manager block — Yarn — had just arrived and was generating a lot of buzz. So I used this opportunity to also understand how and why Yarn does things differently from npm. I had so much fun researching this. I wish I’d done so a long time ago. So I wrote this simple introduction to npm and Yarn to share what I’ve learned. Let’s start with some definitions: What is a package?A package is a reusable piece of software which can be downloaded from a global registry into a developer’s local environment. Each package may or may not depend on other packages. What is a Package Manager?Simply put — a package manager is a piece of software that lets you manage the dependencies (external code written by you or someone else) that your project needs to work correctly. Most package managers juggle the following pieces of your project: Project CodeThis is the code of your project for which you need to manage various dependencies. Typically, all of this code is checked into a version control system like Git. Manifest fileThis is a file that keeps track of all your dependencies (the packages to be managed). It also contains other metadata about your project. In the JavaScript world, this file is your package.json Dependency codeThis code constitutes your dependencies. It shouldn’t be mutated during the lifetime of your application, and should be accessible by your project code in memory when it’s needed. Lock fileThis file is written automatically by the package manager itself. It contains all the information needed to reproduce the full dependency source tree. It contains information about each of your project’s dependencies, along with their respective versions. It’s worth pointing out at this point that Yarn uses a lockfile, while npm doesn’t. We’ll talk about the consequences of this distinction in a bit. Now that I’ve introduced you to the parts of a package manager, let’s discuss dependencies themselves. Flat versus Nested DependenciesTo understand the difference between the Flat versus Nested dependency schemes, let’s try visualizing a dependency graph of dependencies in your project. It’s important to keep in mind that the dependencies your project depends on might have dependencies of their own. And these dependencies may in turn have some dependencies in common. To make this clear, let’s say our application depends on dependencies A, B and C, and C depends on A. Flat Dependencies Dependency graph in case of flat dependencies As shown in the image, both the app and C have A as their dependency. For dependency resolution in a flat dependency scheme, there is only one layer of dependencies that your package manager needs to traverse. Long story short — you can have only one version of a particular package in your source tree, as there is one common namespace for all your dependencies. Suppose that package A is upgraded to version 2.0. If your app is compatible with version 2.0, but package C isn’t, then we need two versions of package A in order to make our app work correctly. This is known an Dependency Hell. Nested Dependencies Dependency graph in case of nested dependencies One simple solution to deal with the problem of Dependency Hell is to have two different versions of package A — version 1.0 and version 2.0. This is where nested dependencies come into play. In case of nested dependencies, every dependency can isolate its own dependencies from other dependencies, in a different namespace. The package manager needs to traverse multiple levels for dependency resolution. We can have several copies of a single dependency in such a scheme. But as you might have guessed, this leads to a few problems too. What if we add another package — package D — and it also depends on version 1.0 of package A? So with this scheme, we can end up with duplication of version 1.0 of package A. This can cause confusion, and takes up unnecessary disk space. One solution to the above problem is to have two versions of package A, v1.0 and v2.0, but only one copy of v1.0 in order to avoid unnecessary duplication. This is the approach taken by npm v3, which reduces the time taken to traverse the dependency tree considerably. As ashley williams explains, npm v2 installs dependencies in a nested manner. That’s why npm v3 is considerably faster by comparison. Determinism vs Non-determinismAnother important concept in package managers is that of determinism. In the context of the JavaScript ecosystem, determinism means that all computers with a given package.json file will all have the exact same source tree of dependencies installed on them in their node_modules folder. But with a non-deterministic package manager, this isn’t guaranteed. Even if you have the exact same package.json on two different computers, the layout of your node_modules may differ between them. Determinism is desirable. It helps you avoid “worked on my machine but it broke when we deployed it” issues, which arise when you have different node_modules on different computers. This popular developer meme illustrates the problems with non-determinism. npm v3, by default has non-deterministic installs and offers a shrinkwrap feature to make installs deterministic. This writes all the packages on the disk to a lockfile, along with their respective versions. Yarn offers deterministic installs because it uses a lockfile to lockdown all the dependencies recursively at the application level. So if package A depends on v1.0 of package C, and package B depends on v2.0 of package A, both of them will be written to the lockfile separately. When you know the exact versions of the dependencies you’re working with, you can easily reproduce builds, then track down and isolate bugs. “To make it more clear, your package.json states “what I want” for the project whereas your lockfile says “what I had” in terms of dependencies. — Dan Abramov So now we can return to the original question that started me on this learning spree in the first place: Why is it considered a good practice to have lockfiles for applications, but not for libraries? The main reason is that you actually deploy applications. So you need to have deterministic dependencies that lead to reproducible builds in different environments — testing, staging, and production. But the same isn’t true for libraries. Libraries aren’t deployed. They’re used to build other libraries, or in application themselves. Libraries need to be flexible so that they can maximize compatibility. If we had a lockfile for each dependency (library) that we used in an application, and the application was forced to respect these lockfiles, it would be impossible to get anywhere close to a flat dependency structure we talked about earlier, with the semantic versioning flexibility, which is the best case scenario for dependency resolution. Here’s why: if your application has to recursively honor the lockfiles of all your dependencies, there would be version conflicts all over the place — even in relatively small projects. This would cause a large amount of unavoidable duplication due to semantic versioning. This is not to say that libraries can’t have lockfiles. They certainly can. But the main takeaway is that package managers like Yarn and npm — which consume these libraries — will not respect those lockfiles.]]></content>
      <categories>
        <category>pure material</category>
      </categories>
      <tags>
        <tag>pure material</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[CSS--flex]]></title>
    <url>%2F2018%2F07%2F23%2Fcss%2Fflex%2F</url>
    <content type="text"><![CDATA[CSS – flexBackgroundThe Flexbox Layout (Flexible Box) module (currently a W3C Last Call Working Draft) aims at providing a more efficient way to lay out, align and distribute space among items in a container, even when their size is unknown and/or dynamic (thus the word “flex”). The main idea behind the flex layout is to give the container the ability to alter its items’ width/height (and order) to best fill the available space (mostly to accommodate to all kind of display devices and screen sizes). A flex container expands items to fill available free space, or shrinks them to prevent overflow. Most importantly, the flexbox layout is direction-agnostic as opposed to the regular layouts (block which is vertically-based and inline which is horizontally-based). While those work well for pages, they lack flexibility (no pun intended) to support large or complex applications (especially when it comes to orientation changing, resizing, stretching, shrinking, etc.). Most importantly, the flexbox layout is direction-agnostic as opposed to the regular layouts (block which is vertically-based and inline which is horizontally-based). While those work well for pages, they lack flexibility (no pun intended) to support large or complex applications (especially when it comes to orientation changing, resizing, stretching, shrinking, etc.). Note: Flexbox layout is most appropriate to the components of an application, and small-scale layouts, while the Grid layout is intended for larger scale layouts. Basics &amp; TerminologySince flexbox is a whole module and not a single property, it involves a lot of things including its whole set of properties. Some of them are meant to be set on the container (parent element, known as “flex container”) whereas the others are meant to be set on the children (said “flex items”). If regular layout is based on both block and inline flow directions, the flex layout is based on “flex-flow directions”. Please have a look at this figure from the specification, explaining the main idea behind the flex layout. Basically, items will be laid out following either the main axis (from main-start to main-end) or the cross axis (from cross-start to cross-end). main axis - The main axis of a flex container is the primary axis along which flex items are laid out. Beware, it is not necessarily horizontal; it depends on the flex-direction property (see below). main-start | main-end - The flex items are placed within the container starting from main-start and going to main-end. main size - A flex item’s width or height, whichever is in the main dimension, is the item’s main size. The flex item’s main size property is either the ‘width’ or ‘height’ property, whichever is in the main dimension. cross axis - The axis perpendicular to the main axis is called the cross axis. Its direction depends on the main axis direction. cross-start | cross-end - Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side. cross size - The width or height of a flex item, whichever is in the cross dimension, is the item’s cross size. The cross size property is whichever of ‘width’ or ‘height’ that is in the cross dimension. Properties for the ParentdisplayThis defines a flex container; inline or block depending on the given value. It enables a flex context for all its direct children. 123.container &#123; display: flex; /* or inline-flex */&#125; Note that CSS columns have no effect on a flex container. flex-direction This establishes the main-axis, thus defining the direction flex items are placed in the flex container. Flexbox is (aside from optional wrapping) a single-direction layout concept. Think of flex items as primarily laying out either in horizontal rows or vertical columns. 123.container &#123; flex-direction: row | row-reverse | column | column-reverse;&#125; row (default): left to right in ltr; right to left in rtl row-reverse: right to left in ltr; left to right in rtl column: same as row but top to bottom column-reverse: same as row-reverse but bottom to top flex-wrap By default, flex items will all try to fit onto one line. You can change that and allow the items to wrap as needed with this property nowrap (default): all flex items will be on one line wrap: flex items will wrap onto multiple lines, from top to bottom. wrap-reverse: flex items will wrap onto multiple lines from bottom to top. flex-flow (Applies to: parent flex container element)This is a shorthand flex-direction and flex-wrap properties, which together define the flex container’s main and cross axes. Default is row nowrap. 1flex-flow: &lt;‘flex-direction’&gt; || &lt;‘flex-wrap’&gt; justify-content This defines the alignment along the main axis. It helps distribute extra free space left over when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line. 123.container &#123; justify-content: flex-start | flex-end | center | space-between | space-around | space-evenly;&#125; flex-start (default): items are packed toward the start line flex-end: items are packed toward to end line center: items are centered along the line space-between: items are evenly distributed in the line; first item is on the start line, last item on the end line space-around: items are evenly distributed in the line with equal space around them. Note that visually the spaces aren’t equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies. space-evenly: items are distributed so that the spacing between any two items (and the space to the edges) is equal. align-items This defines the default behaviour for how flex items are laid out along the cross axis on the current line. Think of it as the justify-content version for the cross-axis (perpendicular to the main-axis). 123.container &#123; align-items: flex-start | flex-end | center | baseline | stretch;&#125; flex-start: cross-start margin edge of the items is placed on the cross-start line flex-end: cross-end margin edge of the items is placed on the cross-end line center: items are centered in the cross-axis baseline: items are aligned such as their baselines align stretch (default): stretch to fill the container (still respect min-width/max-width) align-content This aligns a flex container’s lines within when there is extra space in the cross-axis, similar to how justify-content aligns individual items within the main-axis. Note: this property has no effect when there is only one line of flex items. 123.container &#123; align-content: flex-start | flex-end | center | space-between | space-around | stretch;&#125; flex-start: lines packed to the start of the container flex-end: lines packed to the end of the container center: lines packed to the center of the container space-between: lines evenly distributed; the first line is at the start of the container while the last one is at the end space-around: lines evenly distributed with equal space around each line stretch (default): lines stretch to take up the remaining space Properties for the Children(flex items)order By default, flex items are laid out in the source order. However, the order property controls the order in which they appear in the flex container. 123.item &#123; order: &lt;integer&gt;; /* default is 0 */&#125; flex-grow This defines the ability for a flex item to grow if necessary. It accepts a unitless value that serves as a proportion. It dictates what amount of the available space inside the flex container the item should take up. If all items have flex-grow set to 1, the remaining space in the container will be distributed equally to all children. If one of the children has a value of 2, the remaining space would take up twice as much space as the others (or it will try to, at least). 123.item &#123; flex-grow: &lt;number&gt;; /* default 0 */&#125; Negative numbers are invalid. flex-shrinkThis defines the ability for a flex item to shrink if necessary. 123.item &#123; flex-shrink: &lt;number&gt;; /* default 1 */&#125; flex-basisThis defines the default size of an element before the remaining space is distributed. It can be a length (e.g. 20%, 5rem, etc.) or a keyword. The auto keyword means “look at my width or height property” (which was temporarily done by the main-size keyword until deprecated). The content keyword means “size it based on the item’s content” - this keyword isn’t well supported yet, so it’s hard to test and harder to know what its brethren max-content, min-content, and fit-content do. 123.item &#123; flex-basis: &lt;length&gt; | auto; /* default auto */&#125; flexThis is the shorthand for flex-grow, flex-shrink and flex-basis combined. The second and third parameters (flex-shrink and flex-basis) are optional. Default is 0 1 auto. 123.item &#123; flex: none | [ &lt;'flex-grow'&gt; &lt;'flex-shrink'&gt;? || &lt;'flex-basis'&gt; ]&#125; It is recommended that you use this shorthand property rather than set the individual properties. The short hand sets the other values intelligently. align-self This allows the default alignment (or the one specified by align-items) to be overridden for individual flex items. Please see the align-items explanation to understand the available values. 123.item &#123; align-self: auto | flex-start | flex-end | center | baseline | stretch;&#125; Note that float, clear and vertical-align have no effect on a flex item. ExamplesLet’s start with a very very simple example, solving an almost daily problem: perfect centering. It couldn’t be any simpler if you use flexbox. 12345678910.parent &#123; display: flex; height: 300px; /* Or whatever */&#125;.child &#123; width: 100px; /* Or whatever */ height: 100px; /* Or whatever */ margin: auto; /* Magic! */&#125; This relies on the fact a margin set to auto in a flex container absorb extra space. So setting a vertical margin of auto will make the item perfectly centered in both axis. Now let’s use some more properties. Consider a list of 6 items, all with a fixed dimensions in a matter of aesthetics but they could be auto-sized. We want them to be evenly and nicely distributed on the horizontal axis so that when we resize the browser, everything is fine (without media queries!). 123456789101112131415.flex-container &#123; /* We first create a flex layout context */ display: flex; /* Then we define the flow direction and if we allow the items to wrap * Remember this is the same as: * flex-direction: row; * flex-wrap: wrap; */ flex-flow: row wrap; /* Then we define how is distributed the remaining space */ justify-content: space-around;&#125; Let’s try something else. Imagine we have a right-aligned navigation on the very top of our website, but we want it to be centered on medium-sized screens and single-columned on small devices. Easy enough. 1234567891011121314151617181920212223/* Large */.navigation &#123; display: flex; flex-flow: row wrap; /* This aligns items to the end line on main-axis */ justify-content: flex-end;&#125;/* Medium screens */@media all and (max-width: 800px) &#123; .navigation &#123; /* When on medium sized screens, we center it by evenly distributing empty space around items */ justify-content: space-around; &#125;&#125;/* Small screens */@media all and (max-width: 500px) &#123; .navigation &#123; /* On small screens, we are no longer using row direction but column */ flex-direction: column; &#125;&#125; Let’s try something even better by playing with flex items flexibility! What about a mobile-first 3-columns layout with full-width header and footer. And independent from source order. 123456789101112131415161718192021222324252627282930313233343536.wrapper &#123; display: flex; flex-flow: row wrap;&#125;/* We tell all items to be 100% width, via flex-basis */.wrapper &gt; * &#123; flex: 1 100%;&#125;/* We rely on source order for mobile-first approach * in this case: * 1. header * 2. article * 3. aside 1 * 4. aside 2 * 5. footer *//* Medium screens */@media all and (min-width: 600px) &#123; /* We tell both sidebars to share a row */ .aside &#123; flex: 1 auto; &#125;&#125;/* Large screens */@media all and (min-width: 800px) &#123; /* We invert order of first sidebar and main * And tell the main element to take twice as much width as the other two sidebars */ .main &#123; flex: 2 0px; &#125; .aside-1 &#123; order: 1; &#125; .main &#123; order: 2; &#125; .aside-2 &#123; order: 3; &#125; .footer &#123; order: 4; &#125;&#125;]]></content>
      <categories>
        <category>css</category>
      </categories>
      <tags>
        <tag>css</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.Advanced Guides -- 04.Error Boundaries]]></title>
    <url>%2F2018%2F07%2F05%2Freact%2F03.Advanced_Guides%2F04.Error_Boundaries%2F</url>
    <content type="text"><![CDATA[Error Boundaries(错误边界)In the past, JavaScript errors inside components used to corrupt React’s internal state and cause it to emit cryptic errors on next renders. These errors were always caused by an earlier error in the application code, but React did not provide a way to handle them gracefully in components, and could not recover from them. 过去，组件内部的JavaScript错误会导致React的内部状态产生问题并可能导致在下一次渲染时产生不可预知的错误。这些错误总是由应用程序代码中的早期错误引起，但React没有提供在组件中优雅地处理它们的方法，并且无法从这些旧的错误中恢复回来。 Introducing Error Boundaries(介绍错误边界)A JavaScript error in a part of the UI shouldn’t break the whole app. To solve this problem for React users, React 16 introduces a new concept of an “error boundary”. JavaScript中UI部分的错误不应该阻断整个应用程序的运行。为了解决React用户的这个问题，React 16引入了一个新的“错误边界”的概念。 Error boundaries are React components that catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them. 错误边界属于React组件，它们可以在其子组件树中的任何位置捕获JavaScript错误，并会记录这些错误，以UI的形式返回而不是阻断的的组件树。错误边界是在渲染期间，生命周期方法以及它们下面的整个树的构造函数中捕获错误的。 NoteError boundaries do not catch errors for: Event handlers (learn more) Asynchronous code (e.g. setTimeout or requestAnimationFrame callbacks) Server side rendering Errors thrown in the error boundary itself (rather than its children) 注意错误边界不会获取以下错误： 事件处理器（关于更多） 异步代码（例如setTimeout或requestAnimationFrame回调函数） 服务器端的渲染 在错误边界内部抛出的错误(而不是它的子组件中) A class component becomes an error boundary if it defines a new lifecycle method called componentDidCatch(error, info): 当类组件被定义为一个名为componentDidCatch(error, info)的新的生命周期函数时，它会变为一个错误边界： 123456789101112131415161718192021class ErrorBoundary extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; hasError: false &#125;; &#125; componentDidCatch(error, info) &#123; // Display fallback UI this.setState(&#123; hasError: true &#125;); // You can also log the error to an error reporting service logErrorToMyService(error, info); &#125; render() &#123; if (this.state.hasError) &#123; // You can render any custom fallback UI return &lt;h1&gt;Something went wrong.&lt;/h1&gt;; &#125; return this.props.children; &#125;&#125; Then you can use it as a regular component: 然后您可以将它作为常规组件使用： 123&lt;ErrorBoundary&gt; &lt;MyWidget /&gt;&lt;/ErrorBoundary&gt; The componentDidCatch() method works like a JavaScript catch {} block, but for components. Only class components can be error boundaries. In practice, most of the time you’ll want to declare an error boundary component once and use it throughout your application. componentDidCatch（）方法的工作方式类似于JavaScript catch {}，但对于组件而言。只有类组件可以被定义为错误边界。实际上，大多数情况下，您需要声明一次错误边界组件并在整个应用程序中使用它。 Note that error boundaries only catch errors in the components below them in the tree. An error boundary can’t catch an error within itself. If an error boundary fails trying to render the error message, the error will propagate to the closest error boundary above it. This, too, is similar to how catch {} block works in JavaScript. 请注意，错误边界仅捕获它们的子组件中的错误。 一个错误边界无法捕获自身的错误。如果错误边界要呈现错误信息时，错误将传到到其上方最接近的错误边界组件上呈现。这也类似于JavaScript中catch的工作方式。 componentDidCatch Parameters（componentDidCatch参数）error is an error that has been thrown. error是一个被抛出的错误。 info is an object with componentStack key. The property has information about component stack during thrown error. info是componentStack键的对象。该属性包含有关抛出错误期间组件堆栈的信息。 12345678910111213//...componentDidCatch(error, info) &#123; /* Example stack information: in ComponentThatThrows (created by App) in ErrorBoundary (created by App) in div (created by App) in App */ logComponentStackToMyService(info.componentStack);&#125;//... Live Demo(实例)Check out this example of declaring and using an error boundary with React 16. 请看在React 16声明和使用一个错误边界的例子 Where to Place Error Boundaries(在哪个放置错误边界)The granularity of error boundaries is up to you. You may wrap top-level route components to display a “Something went wrong” message to the user, just like server-side frameworks often handle crashes. You may also wrap individual widgets in an error boundary to protect them from crashing the rest of the application. 错误边界的位置取决于您。您可以将顶层路由组件包装为向用户显示“Something going wrong”消息，就像服务器端框架经常处理崩溃一样。您还可以将各个小组件包装在错误边界中，以防止它们阻碍应用程序的其余部分。 New Behavior for Uncaught Errors(未捕获错误的新行为)This change has an important implication. As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree. 这种变化具有重要的意义。从React 16开始，未被任何错误边界捕获的错误将导致卸载整个React组件树。 We debated this decision, but in our experience it is worse to leave corrupted UI in place than to completely remove it. For example, in a product like Messenger leaving the broken UI visible could lead to somebody sending a message to the wrong person. Similarly, it is worse for a payments app to display a wrong amount than to render nothing. 我们讨论过这个决定，但根据我们的经验，将错误的UI显示出来比完全删除它更糟糕。例如，在像Messenger这样的产品中，对用户可见的错误UI可能会导致某人向他人误发消息。同样，支付应用程序显示错误的金额比提供任何其他内容更糟糕。 This change means that as you migrate to React 16, you will likely uncover existing crashes in your application that have been unnoticed before. Adding error boundaries lets you provide better user experience when something goes wrong. 此更改意味着在迁移到React 16后，您可能会发现应用程序中以前未被注意到的bug导致整个应用程序的崩溃。添加错误边界可让您在出现问题时提供更好的用户体验。 For example, Facebook Messenger wraps content of the sidebar, the info panel, the conversation log, and the message input into separate error boundaries. If some component in one of these UI areas crashes, the rest of them remain interactive. 例如，Facebook Messenger将侧边栏，信息面板，对话日志和消息输入的内容包装到单独的错误边界中。 如果其中一个UI区域中的某个组件崩溃，则其余组件还可以保持正常的交互状态。 We also encourage you to use JS error reporting services (or build your own) so that you can learn about unhandled exceptions as they happen in production, and fix them. 我们还鼓励您使用JS错误报告服务（或构建您自己的错误报告），以便让您可以了解生产中发生的未处理的异常并去修复它们。 Component Stack Traces(组件堆栈的跟踪)React 16 prints all errors that occurred during rendering to the console in development, even if the application accidentally swallows them. In addition to the error message and the JavaScript stack, it also provides component stack traces. Now you can see where exactly in the component tree the failure has happened: React 16将在渲染过程中发生的所有错误打印到开发工具中的控制台，即使应用程序意外未显示它们也是如此。除了错误消息和JavaScript堆栈之外，它还提供了组件堆栈的跟踪。现在，您可以看到故障发生在组件树中的确切位置： You can also see the filenames and line numbers in the component stack trace. This works by default in Create React App projects: 您还可以在组件堆栈跟踪中查看文件名和行号。默认情况下，这会在Create React App项目下显示： If you don’t use Create React App, you can add this plugin manually to your Babel configuration. Note that it’s intended only for development and must be disabled in production. 如果您不使用Create React App，则可以将此插件手动添加到Babel的配置中。请注意，此插件仅用于开发环境，在生产环境中必须禁用。 NoteComponent names displayed in the stack traces depend on the Function.name property. If you support older browsers and devices which may not yet provide this natively (e.g. IE 11), consider including a Function.name polyfill in your bundled application, such as function.name-polyfill. Alternatively, you may explicitly set the displayName property on all your components. 注意堆栈跟踪中显示的组件名称取决于Function.name属性。 如果您支持旧版本的浏览器和设备（例如IE 11），请考虑在捆绑应用程序中包含polyfill的Function.name，例如function.name-polyfill。 或者，您可以在所有组件上显式设置displayName属性。 How About try/catch?(关于try / catch如何？)try / catch is great but it only works for imperative code: try / catch不错，但它只适用于命令式代码： 12345try &#123; showButton();&#125; catch (error) &#123; // ...&#125; However, React components are declarative and specify what should be rendered: 然而，React组件是声明式的，并指定应该如何渲染： 1&lt;Button /&gt; Error boundaries preserve the declarative nature of React, and behave as you would expect. For example, even if an error occurs in a componentDidUpdate hook caused by a setState somewhere deep in the tree, it will still correctly propagate to the closest error boundary. 错误边界保留了React的声明式的本质，并且表现的和您期待的一样。例如，即使在由组件树中深处的某个setState引起的componentDidUpdate钩子上发生错误，它仍会正确地传播到最接近的错误边界。 How About Event Handlers?(事件处理器如何？)Error boundaries do not catch errors inside event handlers. 错误边界不会捕获在事件处理器中的错误。 React doesn’t need error boundaries to recover from errors in event handlers. Unlike the render method and lifecycle hooks, the event handlers don’t happen during rendering. So if they throw, React still knows what to display on the screen. React不需要错误边界从事件处理程序中的错误中恢复。与render方法和生命周期钩子不同，事件处理器在渲染过程中不会发生。因此，如果它们抛出错误，React仍然知道在屏幕上如何显示。 If you need to catch an error inside event handler, use the regular JavaScript try / catch statement: 如果您需要在事件处理器中捕获问题，请使用常规的JavaScript的try / catch语法： 123456789101112131415161718192021class MyComponent extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; error: null &#125;; &#125; handleClick = () =&gt; &#123; try &#123; // Do something that could throw &#125; catch (error) &#123; this.setState(&#123; error &#125;); &#125; &#125; render() &#123; if (this.state.error) &#123; return &lt;h1&gt;Caught an error.&lt;/h1&gt; &#125; return &lt;div onClick=&#123;this.handleClick&#125;&gt;Click Me&lt;/div&gt; &#125;&#125; Note that the above example is demonstrating regular JavaScript behavior and doesn’t use error boundaries. 注意上面的例子只用了常规的JavaScript语法，并没有使用错误边界。 Naming Changes from React 15（与React 15相比的命名改变）React 15 included a very limited support for error boundaries under a different method name: unstable_handleError. This method no longer works, and you will need to change it to componentDidCatch in your code starting from the first 16 beta release. React 15对不同方法名称下的错误边界的支持非常有限：比如unstable_handleError。 此方法不再有效，您需要在第一个16 beta版本中将代码其更改为`componentDidCatch·。 For this change, we’ve provided a codemod to automatically migrate your code. 对于此更改，我们提供了一个自动迁移代码的codemod。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.Advanced Guides -- 03.Context]]></title>
    <url>%2F2018%2F07%2F02%2Freact%2F03.Advanced_Guides%2F03.Context%2F</url>
    <content type="text"><![CDATA[Context(上下文) Context provides a way to pass data through the component tree without having to pass props down manually at every level.Context提供了一种通过组件树传递数据的方法，而无需在每层组件之间手动传递props。 In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree. 在一个典型的React应用中，数据是从顶向下（从父元素向子元素）提供props传递的，但是这对于某些特定类型的props（例如本地配置的首选项，UI主题）来说，在一个应用的多个组件之间传递实在太过笨重。Context提供了一种在组件之间共享这些值，且不需要显示地在每层组件之间传递props的方法。 When to Use Context(什么时候使用Context) [API] React.createContext Provider Consumer Examples Dynamic Context（动态上下文） Updating Context from a Nested Component（从一个嵌套的组件里更新上下文） Consuming Multiple Contexts（使用多个上下文） Accessing Context in Lifecycle Methods（在生命周期方法中访问上下文） Consuming Context with a HOC（提供HOC使用上下文） Forwarding Refs to Context Consumers（通过Refs传给上下文使用者） Caveats（注意事项） Legacy API（遗留的API） When to Use Context(什么时候使用上下文)Context is designed to share data that can be considered “global” for a tree of React components, such as the current authenticated user, theme, or preferred language. For example, in the code below we manually thread through a “theme” prop in order to style the Button component: 上下文旨在共享可被视为React组件树中的“全局”数据，例如当前经过身份验证的用户，主题或首选语言。例如，在下面的代码中，我们手动穿过“theme”参数以设置Button组件的样式： 12345678910111213141516171819class App extends React.Component &#123; render() &#123; return &lt;Toolbar theme="dark" /&gt;; &#125;&#125;function Toolbar(props) &#123; // The Toolbar component must take an extra "theme" prop // and pass it to the ThemedButton. This can become painful // if every single button in the app needs to know the theme // because it would have to be passed through all components. return ( &lt;div&gt; &lt;ThemedButton theme=&#123;props.theme&#125; /&gt; &lt;/div&gt; );&#125;function ThemedButton(props) &#123; return &lt;Button theme=&#123;props.theme&#125; /&gt;;&#125; Using context, we can avoid passing props through intermediate elements: 使用context，我们可以变通过中间元素传参。 1234567891011121314151617181920212223242526272829303132333435363738// Context lets us pass a value deep into the component tree// without explicitly threading it through every component.// Create a context for the current theme (with "light" as the default).const ThemeContext = React.createContext('light');class App extends React.Component &#123; render() &#123; // Use a Provider to pass the current theme to the tree below. // Any component can read it, no matter how deep it is. // In this example, we're passing "dark" as the current value. return ( &lt;ThemeContext.Provider value="dark"&gt; &lt;Toolbar /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;// A component in the middle doesn't have to// pass the theme down explicitly anymore.function Toolbar(props) &#123; return ( &lt;div&gt; &lt;ThemedButton /&gt; &lt;/div&gt; );&#125;function ThemedButton(props) &#123; // Use a Consumer to read the current theme context. // React will find the closest theme Provider above and use its value. // In this example, the current theme is "dark". return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt; );&#125; NoteDon’t use context just to avoid passing props a few levels down. Stick to cases where the same data needs to be accessed in many components at multiple levels. 注意：不要仅仅为了避免向下几层组件传参就使用context。尤其是在多个层次的组件中访问相同数据的情况。 APIReact.createContext1const &#123;Provider, Consumer&#125; = React.createContext(defaultValue); Creates a { Provider, Consumer } pair. When React renders a context Consumer, it will read the current context value from the closest matching Provider above it in the tree. 创造一对{ Provider, Consumer }。当React渲染上下文Consumer时，它会从react树中与它最接近的Provider上读取当前context值。 The defaultValue argument is only used by a Consumer when it does not have a matching Provider above it in the tree. This can be helpful for testing components in isolation without wrapping them. Note: passing undefined as a Provider value does not cause Consumers to use defaultValue. defaultValue参数仅在使用者在树中没有与之匹配的Provider时使用。这有助于在不没有对应的provider包围它们的情况下单独测试组件。注意：将undefined作为Provider值传递不会导致使用者使用defaultValue。 Provider1&lt;Provider value=&#123;/* some value */&#125;&gt; A React component that allows Consumers to subscribe to context changes. 一个可以让使用者获取context改变的react组件。 Accepts a value prop to be passed to Consumers that are descendants of this Provider. One Provider can be connected to many Consumers. Providers can be nested to override values deeper within the tree. 接受作为此Provider的后代使用者的值prop。一个Provider可以连接到许多使用者者。可以通过嵌套来覆盖树中更深层的值。 Consumer123&lt;Consumer&gt; &#123;value =&gt; /* render something based on the context value */&#125;&lt;/Consumer&gt; A React component that subscribes to context changes. 一个接受context变化的React组件。 Requires a function as a child. The function receives the current context value and returns a React node. The value argument passed to the function will be equal to the value prop of the closest Provider for this context above in the tree. If there is no Provider for this context above, the value argument will be equal to the defaultValue that was passed to createContext(). 需要一个作为子元素的函数。该函数接收当前context值并返回React节点。传递给函数的value参数将等于React组件树中与此context最近的Provider的prop值。如果父组件没有此context的Provider，则value参数将等于传递给createContext（）的defaultValue。 NoteFor more information about the ‘function as a child’ pattern, see render props. 注意想查看更多有关于‘将函数作为一个子元素’的信息，请看渲染参数 All Consumers that are descendants of a Provider will re-render whenever the Provider’s value prop changes. The propagation from Provider to its descendant Consumers is not subject to the shouldComponentUpdate method, so the Consumer is updated even when an ancestor component bails out of the update. 作为Provider后代的所有使用者将在Provider的value发生变化时重新呈现。从Provider到其后代的使用者的传递不受shouldComponentUpdate方法的限制，因此即使祖先组件退出更新，使用者也会更新。 Changes are determined by comparing the new and old values using the same algorithm as Object.is. 改变是通过Object.is相同的算法比较新旧值来确定更改。 NoteThe way changes are determined can cause some issues when passing objects as value: see Caveats. 注意：确定更改的方式可能会在将对象作为值传递时导致一些问题：请参阅警告。 ExamplesDynamic Context（动态上下文）A more complex example with dynamic values for the theme: 一个将theme作为动态值的更为复杂的例子： theme-context.js1234567891011121314export const themes = &#123; light: &#123; foreground: '#000000', background: '#eeeeee', &#125;, dark: &#123; foreground: '#ffffff', background: '#222222', &#125;,&#125;;export const ThemeContext = React.createContext( themes.dark // default value); themed-button.js12345678910111213141516import &#123;ThemeContext&#125; from './theme-context';function ThemedButton(props) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;button &#123;...props&#125; style=&#123;&#123;backgroundColor: theme.background&#125;&#125; /&gt; )&#125; &lt;/ThemeContext.Consumer&gt; );&#125;export default ThemedButton; app.js1234567891011121314151617181920212223242526272829303132333435363738394041424344454647import &#123;ThemeContext, themes&#125; from './theme-context';import ThemedButton from './themed-button';// An intermediate component that uses the ThemedButtonfunction Toolbar(props) &#123; return ( &lt;ThemedButton onClick=&#123;props.changeTheme&#125;&gt; Change Theme &lt;/ThemedButton&gt; );&#125;class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; theme: themes.light, &#125;; this.toggleTheme = () =&gt; &#123; this.setState(state =&gt; (&#123; theme: state.theme === themes.dark ? themes.light : themes.dark, &#125;)); &#125;; &#125; render() &#123; // The ThemedButton button inside the ThemeProvider // uses the theme from state while the one outside uses // the default dark theme return ( &lt;Page&gt; &lt;ThemeContext.Provider value=&#123;this.state.theme&#125;&gt; &lt;Toolbar changeTheme=&#123;this.toggleTheme&#125; /&gt; &lt;/ThemeContext.Provider&gt; &lt;Section&gt; &lt;ThemedButton /&gt; &lt;/Section&gt; &lt;/Page&gt; ); &#125;&#125;ReactDOM.render(&lt;App /&gt;, document.root); Updating Context from a Nested Component（从一个嵌套的组件里更新上下文）It is often necessary to update the context from a component that is nested somewhere deeply in the component tree. In this case you can pass a function down through the context to allow consumers to update the context: 通常需要从组件树上嵌套层数较深的组件中更新context。在这种情况下，您可以在context中向下传递一个函数，以允许使用者更新context： theme-context.js123456// Make sure the shape of the default value passed to// createContext matches the shape that the consumers expect!export const ThemeContext = React.createContext(&#123; theme: themes.dark, toggleTheme: () =&gt; &#123;&#125;,&#125;); theme-toggler-button.js12345678910111213141516171819import &#123;ThemeContext&#125; from './theme-context';function ThemeTogglerButton() &#123; // The Theme Toggler Button receives not only the theme // but also a toggleTheme function from the context return ( &lt;ThemeContext.Consumer&gt; &#123;(&#123;theme, toggleTheme&#125;) =&gt; ( &lt;button onClick=&#123;toggleTheme&#125; style=&#123;&#123;backgroundColor: theme.background&#125;&#125;&gt; Toggle Theme &lt;/button&gt; )&#125; &lt;/ThemeContext.Consumer&gt; );&#125;export default ThemeTogglerButton; app.js12345678910111213141516171819202122232425262728293031323334353637383940414243import &#123;ThemeContext, themes&#125; from './theme-context';import ThemeTogglerButton from './theme-toggler-button';class App extends React.Component &#123; constructor(props) &#123; super(props); this.toggleTheme = () =&gt; &#123; this.setState(state =&gt; (&#123; theme: state.theme === themes.dark ? themes.light : themes.dark, &#125;)); &#125;; // State also contains the updater function so it will // be passed down into the context provider this.state = &#123; theme: themes.light, toggleTheme: this.toggleTheme, &#125;; &#125; render() &#123; // The entire state is passed to the provider return ( &lt;ThemeContext.Provider value=&#123;this.state&#125;&gt; &lt;Content /&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;function Content() &#123; return ( &lt;div&gt; &lt;ThemeTogglerButton /&gt; &lt;/div&gt; );&#125;ReactDOM.render(&lt;App /&gt;, document.root); Consuming Multiple ContextsTo keep context re-rendering fast, React needs to make each context consumer a separate node in the tree. 为了保证context重新渲染的速度更快，React需要让每个context使用者在react组件树中都作为一个独立的子节点。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546// Theme context, default to light themeconst ThemeContext = React.createContext('light');// Signed-in user contextconst UserContext = React.createContext(&#123; name: 'Guest',&#125;);class App extends React.Component &#123; render() &#123; const &#123;signedInUser, theme&#125; = this.props; // App component that provides initial context values return ( &lt;ThemeContext.Provider value=&#123;theme&#125;&gt; &lt;UserContext.Provider value=&#123;signedInUser&#125;&gt; &lt;Layout /&gt; &lt;/UserContext.Provider&gt; &lt;/ThemeContext.Provider&gt; ); &#125;&#125;function Layout() &#123; return ( &lt;div&gt; &lt;Sidebar /&gt; &lt;Content /&gt; &lt;/div&gt; );&#125;// A component may consume multiple contextsfunction Content() &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;UserContext.Consumer&gt; &#123;user =&gt; ( &lt;ProfilePage user=&#123;user&#125; theme=&#123;theme&#125; /&gt; )&#125; &lt;/UserContext.Consumer&gt; )&#125; &lt;/ThemeContext.Consumer&gt; );&#125; If two or more context values are often used together, you might want to consider creating your own render prop component that provides both. 如果两个或更多的context值经常一起使用，您可能需要考虑创建您自己的渲染参数的组件来一起提供它们。 Accessing Context in Lifecycle MethodsAccessing values from context in lifecycle methods is a relatively common use case. Instead of adding context to every lifecycle method, you just need to pass it as a prop, and then work with it just like you’d normally work with a prop. 在生命周期方法中从context访问值是一种相对常见的用例。您只需要将其作为prop传递，而不是向每个生命周期方法添加context，然后使用它就像您通常使用prop一样。 12345678910111213141516171819202122232425class Button extends React.Component &#123; componentDidMount() &#123; // ThemeContext value is this.props.theme &#125; componentDidUpdate(prevProps, prevState) &#123; // Previous ThemeContext value is prevProps.theme // New ThemeContext value is this.props.theme &#125; render() &#123; const &#123;theme, children&#125; = this.props; return ( &lt;button className=&#123;theme ? 'dark' : 'light'&#125;&gt; &#123;children&#125; &lt;/button&gt; ); &#125;&#125;export default props =&gt; ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt;); Consuming Context with a HOCSome types of contexts are consumed by many components (e.g. theme or localization). It can be tedious to explicitly wrap each dependency with a &lt;Context.Consumer&gt; element. A higher-order component can help with this. 一些类型的context会被许多组件（例如主题或本地化）使用。使用&lt;Context.Consumer&gt;元素显式地包装每个依赖项可能会很繁琐。这时候更高阶的组件可以帮助解决这个问题。 For example, a button component might consume a theme context like so: 例如，一个button组件可能会这样使用主题context： 123456789const ThemeContext = React.createContext('light');function ThemedButton(props) &#123; return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;button className=&#123;theme&#125; &#123;...props&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt; );&#125; That’s alright for a few components, but what if we wanted to use the theme context in a lot of places? 这对于几个组件来说是够用了，但是如果我们想在许多地方用主题的context呢？ We could create a higher-order component called withTheme: 我们可以创建一个更高级别的组件，叫做withTheme： 123456789101112131415const ThemeContext = React.createContext('light');// This function takes a component...export function withTheme(Component) &#123; // ...and returns another component... return function ThemedComponent(props) &#123; // ... and renders the wrapped component with the context theme! // Notice that we pass through any additional props as well return ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; &lt;Component &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125; &lt;/ThemeContext.Consumer&gt; ); &#125;;&#125; Now any component that depends on the theme context can easily subscribe to it using the withTheme function we’ve created: 现在任何依赖于主题context的组件都通过我们创建的withTheme函数可以轻松的使用它。 12345function Button(&#123;theme, ...rest&#125;) &#123; return &lt;button className=&#123;theme&#125; &#123;...rest&#125; /&gt;;&#125;const ThemedButton = withTheme(Button); Forwarding Refs to Context ConsumersOne issue with the render prop API is that refs don’t automatically get passed to wrapped elements. To get around this, use React.forwardRef: render prop API的一个问题是refs不会自动传递给子元素。要解决此问题，请使用React.forwardRef： fancy-button.js1234567891011121314151617class FancyButton extends React.Component &#123; focus() &#123; // ... &#125; // ...&#125;// Use context to pass the current "theme" to FancyButton.// Use forwardRef to pass refs to FancyButton as well.export default React.forwardRef((props, ref) =&gt; ( &lt;ThemeContext.Consumer&gt; &#123;theme =&gt; ( &lt;FancyButton &#123;...props&#125; theme=&#123;theme&#125; ref=&#123;ref&#125; /&gt; )&#125; &lt;/ThemeContext.Consumer&gt;)); app.js12345678910import FancyButton from './fancy-button';const ref = React.createRef();// Our ref will point to the FancyButton component,// And not the ThemeContext.Consumer that wraps it.// This means we can call FancyButton methods like ref.current.focus()&lt;FancyButton ref=&#123;ref&#125; onClick=&#123;handleClick&#125;&gt; Click me!&lt;/FancyButton&gt;; CaveatsBecause context uses reference identity to determine when to re-render, there are some gotchas that could trigger unintentional renders in consumers when a provider’s parent re-renders. For example, the code below will re-render all consumers every time the Provider re-renders because a new object is always created for value: 因为上下文使用引用参考标识符来确定何时重新渲染，所以当Provider的父级重新渲染时，使用者可能会触发一些无意的渲染。例如，下面的代码将在每次Provider重新渲染时重新呈现所有使用者，因为始终会为value创建新对象： 123456789class App extends React.Component &#123; render() &#123; return ( &lt;Provider value=&#123;&#123;something: 'something'&#125;&#125;&gt; &lt;Toolbar /&gt; &lt;/Provider&gt; ); &#125;&#125; To get around this, lift the value into the parent’s state: 为了解决此问题，将value放在父组件的state中： 12345678910111213141516class App extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123; value: &#123;something: 'something'&#125;, &#125;; &#125; render() &#123; return ( &lt;Provider value=&#123;this.state.value&#125;&gt; &lt;Toolbar /&gt; &lt;/Provider&gt; ); &#125;&#125; ###Legacy API NoteReact previously shipped with an experimental context API. The old API will be supported in all 16.x releases, but applications using it should migrate to the new version. The legacy API will be removed in a future major React version. Read the legacy context docs here. 注意：之前版本的React附带有实验context的API。所有16.x版本都支持旧的API，但应用程序应当使用新版本的API。 遗留API将在未来的主版本的React中删除。您可以在[此处阅读旧版context文档。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.Advanced Guides -- 02.Code-Splitting]]></title>
    <url>%2F2018%2F06%2F30%2Freact%2F03.Advanced_Guides%2F02.Code_Spliting%2F</url>
    <content type="text"><![CDATA[Code-Splitting(代码拆分)Bundling(打包)Most React apps will have their files “bundled” using tools like Webpack or Browserify. Bundling is the process of following imported files and merging them into a single file: a “bundle”. This bundle can then be included on a webpage to load an entire app at once. 大多数React应用程序都有它们自己的“打包”工具，例如Webpack 或者Browserify。打包是指跟踪导入的文件并将它们合并到单个文件–“bundle”中的过程。然后，可以将打包后的文件加载到网页上，以立即加载整个应用。 Example(举例) App:1234// app.jsimport &#123; add &#125; from './math.js';console.log(add(16, 26)); // 42 1234// math.jsexport function add(a, b) &#123; return a + b;&#125; Bundle:12345function add(a, b) &#123; return a + b;&#125;console.log(add(16, 26)); // 42 Note(注意):Your bundles will end up looking a lot different than this.您打包后的文件可能跟上述代码有所不同。 If you’re using Create React App, Next.js, Gatsby, or a similar tool, you will have a Webpack setup out of the box to bundle your app. 如果您正在使用Create React App, Next.js, Gatsby或者其他相似的工具，您可以使用开箱即用的Webpack设置来捆绑您的应用。 If you aren’t, you’ll need to setup bundling yourself. For example, see the Installation and Getting Started guides on the Webpack docs. 如果您不是什么样的上述工具，您就得自己安装打包工具了。例如，请看webpack文档的安装和开始目录。 Code Splitting(代码拆分)Bundling is great, but as your app grows, your bundle will grow too. Especially if you are including large third-party libraries. You need to keep an eye on the code you are including in your bundle so that you don’t accidentally make it so large that your app takes a long time to load. 打包工具虽然很棒，但随着您的应用程序的扩展，您捆绑的包也会随之增长。特别是如果您包含第三方大型的库。您需要密切关注打完的包中的代码，这样您就不会将其编写的过大，以至于您的应用需要很长时间才能加载完成。 To avoid winding up with a large bundle, it’s good to get ahead of the problem and start “splitting” your bundle. Code-Splitting is a feature supported by bundlers like Webpack and Browserify (via factor-bundle) which can create multiple bundles that can be dynamically loaded at runtime. 为了避免大量捆绑的发生，最好从最开始就解决问题，并开始“拆分”打过的包。Code-Splitting是Webpack和Browserify等打包软件支持的一项功能，（通过factor-bundle）可以创建多个可在运行时动态加载的bundle。 Code-splitting your app can help you “lazy-load” just the things that are currently needed by the user, which can dramatically improve the performance of your app. While you haven’t reduced the overall amount of code in your app, you’ve avoided loading code that the user may never need, and reduced the amount of code needed during the initial load. 拆分您应用程序的代码可以帮助您在当前用户需要的时候实现“懒加载”，这样可以提高您应用程序的性能。当您没有减少您应用程序整体代码量的时候，您可以避免加载用户可能从来不需要的代码，并且减少在初次加载时的代码量。 import()The best way to introduce code-splitting into your app is through the dynamic import() syntax. 在您的应用程序中介绍分隔代码最好的方式就是动态的使用import()语法。 Before(之前): 123import &#123; add &#125; from './math';console.log(add(16, 26)); After(之后): 123import("./math").then(math =&gt; &#123; console.log(math.add(16, 26));&#125;); Note(注意):The dynamic import() syntax is a ECMAScript (JavaScript) proposal not currently part of the language standard. It is expected to be accepted in the near future.动态的import()语法只是ECMAScript (JavaScript)的一个建议，并非语法标准。它也许会在以后的版本中被接受。 When Webpack comes across this syntax, it automatically starts code-splitting your app. If you’re using Create React App, this is already configured for you and you can start using it immediately. It’s also supported out of the box in Next.js. 当Webpack遇到这种语法时，它会自动启动拆分代码的部分来拆分您的应用程序。如果您正在使用Create React App，那么您已经配置好了这个并可以立即开始使用它。在Next.js中也支持开箱即用。 If you’re setting up Webpack yourself, you’ll probably want to read Webpack’s guide on code splitting. Your Webpack config should look vaguely like this. 如何您自己正在设置Webpack，您可能需要阅读Webpack的拆分代码指南。您的Webpack配置大体看上去应该像这样。 When using Babel, you’ll need to make sure that Babel can parse the dynamic import syntax but is not transforming it. For that you will need babel-plugin-syntax-dynamic-import. 当使用Babel，您需要确保Babel能够解析动态导入的语法，但不会对其进行转换。为此，您需要使用babel-plugin-syntax-dynamic-import。 Libraries(库)ReactLoadable(React的可加载性)React Loadable wraps dynamic imports in a nice, React-friendly API for introducing code splitting into your app at a given component. React Loadable包装在一个良好的，对React友好的API中，这个API用于拆分的代码引入到给定组件的应用程序中。 Before(之前): 12345import OtherComponent from './OtherComponent';const MyComponent = () =&gt; ( &lt;OtherComponent/&gt;); After: 12345678910import Loadable from 'react-loadable';const LoadableOtherComponent = Loadable(&#123; loader: () =&gt; import('./OtherComponent'), loading: () =&gt; &lt;div&gt;Loading...&lt;/div&gt;,&#125;);const MyComponent = () =&gt; ( &lt;LoadableOtherComponent/&gt;); React Loadable helps you create loading states, error states, timeouts, preloading, and more. It can even help you server-side render an app with lots of code-splitting. React Loadable可帮助您创建加载状态，错误状态，超时，预加载等。 它甚至可以帮助您在服务器端渲染具有大量代码拆分的应用程序。 Route-based code splitting(基于路由的代码拆分)Deciding where in your app to introduce code splitting can be a bit tricky. You want to make sure you choose places that will split bundles evenly, but won’t disrupt the user experience. 在你的应用中选择哪里引入代码拆分的位置可能有点棘手。引入代码拆分的位置要确保位于拆分合理的地方，并且不会破坏用户体验。 A good place to start is with routes. Most people on the web are used to page transitions taking some amount of time to load. You also tend to be re-rendering the entire page at once so your users are unlikely to be interacting with other elements on the page at the same time. 引用代码拆分的一个好的位置是路由。大多数人在网页上都习惯于页面切换，这需要花费一些时间来加载。您还可以重新渲染整个页面，这样您的用户就不可能同时与页面上的其他元素进行交互。 Here’s an example of how to setup route-based code splitting into your app using libraries like React Router and React Loadable. 以下是如何使用React Router和React Loadable等库将基于路由的代码拆分到应用程序的示例。 1234567891011121314151617181920212223import &#123; BrowserRouter as Router, Route, Switch &#125; from 'react-router-dom';import Loadable from 'react-loadable';const Loading = () =&gt; &lt;div&gt;Loading...&lt;/div&gt;;const Home = Loadable(&#123; loader: () =&gt; import('./routes/Home'), loading: Loading,&#125;);const About = Loadable(&#123; loader: () =&gt; import('./routes/About'), loading: Loading,&#125;);const App = () =&gt; ( &lt;Router&gt; &lt;Switch&gt; &lt;Route exact path="/" component=&#123;Home&#125;/&gt; &lt;Route path="/about" component=&#123;About&#125;/&gt; &lt;/Switch&gt; &lt;/Router&gt;);]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[03.Advanced Guides -- 01.Accessibility]]></title>
    <url>%2F2018%2F06%2F29%2Freact%2F03.Advanced_Guides%2F01.Accessibility%2F</url>
    <content type="text"><![CDATA[Accessibility(可访问性)Why Accessibility?(为什么要考虑可访问性？)Web accessibility (also referred to as a11y) is the design and creation of websites that can be used by everyone. Accessibility support is necessary to allow assistive technology to interpret web pages. Web可访问性（也称为a11y）是指如何设计和创建可供任何人都可以使用的网站。可访问性的支持是必须的，因为它们可以才协助辅助性技术渲染网页。 React fully supports building accessible websites, often by using standard HTML techniques. React可以通过使用标准的HTML技术来完全支持构建可访问性的网站。 Standards and Guidelines（标准和指南）WCAGThe Web Content Accessibility Guidelines provides guidelines for creating accessible web sites. 网站内容可访问性指南为创建可访问网站的提供了指导指南。 The following WCAG checklists provide an overview: 以下为WCAG清单提供了一个概述： WCAG checklist from Wuhcag WCAG checklist from WebAIM Checklist from The A11Y Project 关于WCAG的Wuhcag概述 关于WCAG的WebAIM概述 来自A11Y项目的概述 WAI-ARIAThe Web Accessibility Initiative - Accessible Rich Internet Applications document contains techniques for building fully accessible JavaScript widgets. 网页可访问性倡议 - 充分可访问性的互联网应用程序文章中包含了对于构建充分可访问的JavaScript部件的技术。 Note that all aria-* HTML attributes are fully supported in JSX. Whereas most DOM properties and attributes in React are camelCased, these attributes should be lowercased: 注意，JSX完全支持所有aria- * HTML属性。尽管React中的大多数DOM属性和特性都是camelCased的，但aria-*属性应该是小写的： 12345678&lt;input type="text" aria-label=&#123;labelText&#125; aria-required="true" onChange=&#123;onchangeHandler&#125; value=&#123;inputValue&#125; name="name"/&gt; Semantic HTML(语义化的HTML)Semantic HTML is the foundation of accessibility in a web application. Using the various HTML elements to reinforce the meaning of information in our websites will often give us accessibility for free. 语义化的HTML是一个web应用可访问性的基础。我们可以通过在网站中使用不同的HTML元素来加强想表达的信息的含义，这可以让我们的应用更具有可访问性。 MDN HTML elements reference(MDN HTML元素的参阅) Sometimes we break HTML semantics when we add elements to our JSX to make our React code work, especially when working with lists (, and ) and the HTML . In these cases we should rather use React Fragments to group together multiple elements. 有时，当我们将&lt;div&gt;元素添加到JSX中以使我们的React代码工作时，我们会破坏HTML语义，尤其是在使用列表（&lt;ol&gt;，&lt;ul&gt;和&lt;dl&gt;）和HTML &lt;table&gt;时。 在这些情况下，我们应该使用React Fragments将多个元素组合在一起。 Use &lt;Fragment&gt; when a key prop is required: 在key的属性是必须时使用&lt;Fragment&gt; 123456789101112131415import React, &#123; Fragment &#125; from 'react';function Glossary(props) &#123; return ( &lt;dl&gt; &#123;props.items.map(item =&gt; ( // Without the `key`, React will fire a key warning &lt;Fragment key=&#123;item.id&#125;&gt; &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt; &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt; &lt;/Fragment&gt; ))&#125; &lt;/dl&gt; );&#125; Use &lt;&gt;&lt;/&gt; syntax everywhere else: 在任何地方使用&lt;&gt;&lt;/&gt;语法 12345678function ListItem(&#123; item &#125;) &#123; return ( &lt;&gt; &lt;dt&gt;&#123;item.term&#125;&lt;/dt&gt; &lt;dd&gt;&#123;item.description&#125;&lt;/dd&gt; &lt;/&gt; );&#125; 即为了不破坏HTML结构的完整性和统一性，可以将React Fragment或者&lt;&gt;&lt;/&gt;添加到React组件返回的内容上以此来保持返回元素的可访问性。 Accessible Forms(可访问性的表单)Labeling(标签)Every HTML form control, such as &lt;input&gt; and &lt;textarea&gt;, needs to be labeled accessibly. We need to provide descriptive labels that are also exposed to screen readers. 每个HTML表单中的控制元件，例如&lt;input&gt;和&lt;textarea&gt;都需要有可访问性的标签。我们也需要也向屏幕阅读器提供公开的描述性标签。 The following resources show us how to do this: 下列资源告诉我们如何做到这些： The W3C shows us how to label elements WebAIM shows us how to label elements The Paciello Group explains accessible names W3C 告诉我们如何标记元素 WebAIM告诉我们如何标记元素 Paciello项目组介绍了如何让名称具有可访问性 Although these standard HTML practices can be directly used in React, note that the for attribute is written as htmlFor in JSX: 尽管这些标准的HTML元素可以直接在React中使用，但还要注意for属性在JSX中应当写成’htmlFor’: 12&lt;label htmlFor="namedInput"&gt;Name:&lt;/label&gt;&lt;input id="namedInput" type="text" name="name"/&gt; Notifying the user of errors(通知用户错误信息)Error situations need to be understood by all users. The following link shows us how to expose error texts to screen readers as well: 所有用户都需要能够读懂错误信息。以下链接向我们展示了如何将错误文本展示给屏幕阅读器： The W3C demonstrates user notifications WebAIM looks at form validation W3C演示用户通知示例 WebAIM演示表单验证 Focus Control(焦点控制)Ensure that your web application can be fully operated with the keyboard only: 确保您的web应用只可以通过键盘进行操作： WebAIM talks about keyboard accessibility WebAIM讨论键盘的可访问性 Keyboard focus and focus outline(键盘聚焦和轮廓聚焦)Keyboard focus refers to the current element in the DOM that is selected to accept input from the keyboard. We see it everywhere as a focus outline similar to that shown in the following image: 键盘聚焦是指选用DOM中的当前元素作为键盘中的输入。这种表现非常常见，与下图所示类似的焦点轮廓类似： Only ever use CSS that removes this outline, for example by setting outline: 0, if you are replacing it with another focus outline implementation. 只可以通过CSS来删除外边框，如果您用另一种聚焦外边框来替换它，可以通过设置outline: 0来实现。 Mechanisms to skip to desired content(跳转到期待的内容的机制)Provide a mechanism to allow users to skip past navigation sections in your application as this assists and speeds up keyboard navigation. 我们提供了一种机制，允许用户在您的应用中跳过导航部分，因为这有助于通过键盘导航。 Skiplinks or Skip Navigation Links are hidden navigation links that only become visible when keyboard users interact with the page. They are very easy to implement with internal page anchors and some styling: 跳转链接或跳转导航链接通常是隐藏的，只有当用户通过键盘与页面进行交互时才会显示。通过内部页面锚点和一些样式，我们非常容易实现这种功能： WebAIM - Skip Navigation Links WebAIM - 跳转导航链接 Programmatically managing focus(用编程化的方式来管理焦点)Our React applications continuously modify the HTML DOM during runtime, sometimes leading to keyboard focus being lost or set to an unexpected element. In order to repair this, we need to programmatically nudge the keyboard focus in the right direction. For example, by resetting keyboard focus to a button that opened a modal window after that modal window is closed. 我们的React项目会在运行时持续的调整HTML节点，有时会导致键盘丢失焦点或设置到意想不到的元素上。为了修复这个问题，我们需要以正确的方向以编程方式来设置键盘焦点。例如，在一个模式窗口关闭后通过重置键盘焦点到一个按钮上来打开一个模式窗口。 MDN Web Docs takes a look at this and describes how we can build keyboard-navigable JavaScript widgets. MDN Web文档考虑到了这方面的问题并向我们介绍了如何搭建键盘导航的JavaScript组件 To set focus in React, we can use Refs to DOM elements. 为了设置React焦点，我们可以使用DOM元素的Refs Using this, we first create a ref to an element in the JSX of a component class: 为了介绍Refs，我们首先在组件类的JSX中创建一个元素的ref： 1234567891011121314151617class CustomTextInput extends React.Component &#123; constructor(props) &#123; super(props); // Create a ref to store the textInput DOM element this.textInput = React.createRef(); &#125; render() &#123; // Use the `ref` callback to store a reference to the text input DOM // element in an instance field (for example, this.textInput). return ( &lt;input type="text" ref=&#123;this.textInput&#125; /&gt; ); &#125;&#125; Then we can focus it elsewhere in our component when needed: 然后当我们需要时，我们可以在组件的任何地方调用focus函数了： 12345focus() &#123; // Explicitly focus the text input using the raw DOM API // Note: we're accessing "current" to get the DOM node this.textInput.current.focus();&#125; Sometimes a parent component needs to set focus to an element in a child component. We can do this by exposing DOM refs to parent components through a special prop on the child component that forwards the parent’s ref to the child’s DOM node. 有些时候父组件需要将焦点设置在子组件的一个元素上。我们可以根据向父组件传递DOM refs通过在子组件上设置一个特殊的属性,然后父组件通过ref指向子组件的DOM节点。 1234567891011121314151617181920212223function CustomTextInput(props) &#123; return ( &lt;div&gt; &lt;input ref=&#123;props.inputRef&#125; /&gt; &lt;/div&gt; );&#125;class Parent extends React.Component &#123; constructor(props) &#123; super(props); this.inputElement = React.createRef(); &#125; render() &#123; return ( &lt;CustomTextInput inputRef=&#123;this.inputElement&#125; /&gt; ); &#125;&#125;/&gt;// Now you can set focus when required.this.inputElement.current.focus(); When using a HOC to extend components, it is recommended to forward the ref to the wrapped component using the forwardRef function of React. If a third party HOC does not implement ref forwarding, the above pattern can still be used as a fallback. 当使用HOC扩展组件时，建议使用React的forwardRef函数将ref传到到包装好的组件。如果第三方库HOC没有使用向下传递ref，上述模式仍然可以用作备用方案。 A great focus management example is the react-aria-modal. This is a relatively rare example of a fully accessible modal window. Not only does it set initial focus on the cancel button (preventing the keyboard user from accidentally activating the success action) and trap keyboard focus inside the modal, it also resets focus back to the element that initially triggered the modal. 一个很好的焦点管理的例子就是react-aria-modal。 这是一个相当罕见的完全无障碍的窗口模式的例子。它不仅将初始焦点设置在取消按钮上以避免键盘焦点陷入该模式中（防止键盘用户意外激活成功操作）还将焦点重置回最初触发模式的元素。 Note:While this is a very important accessibility feature, it is also a technique that should be used judiciously. Use it to repair the keyboard focus flow when it is disturbed, not to try and anticipate how users want to use applications. 提示：虽然这是可访问性非常重要的一个特点，但它也是一种应该谨慎使用的技术。用它修复键盘焦点流时，不要试图预测用户是如何使用应用程序的。 More Complex Widgets(更复杂的组件)A more complex user experience should not mean a less accessible one. Whereas accessibility is most easily achieved by coding as close to HTML as possible, even the most complex widget can be coded accessibly. 更复杂的用户体验不应该意味着可访问性更差。尽管通过类似HTML编码最容易实现可访问性，但即使是最复杂的小部件也可以有良好的访问性。 Here we require knowledge of ARIA Roles as well as ARIA States and Properties. These are toolboxes filled with HTML attributes that are fully supported in JSX and enable us to construct fully accessible, highly functional React components. 在这里，我们需要知道ARIA角色以及ARIA的状态和属性。 这些工具箱包含了JSX完全支持的HTML属性，使我们能够构建可访问性良好，功能强大的React组件。 Each type of widget has a specific design pattern and is expected to function in a certain way by users and user agents alike: 每个类型的组件都有一个特定的设计模式，并且预计会以某种方式由用户和用户代理运行： WAI-ARIA Authoring Practices - Design Patterns and Widgets Heydon Pickering - ARIA Examples Inclusive Components WAI-ARIA创作实践 - 设计模式和小工具 Heydon Pickering - ARIA示例 包容性组件 Other Points for Consideration(其他需要考虑的点)Setting the language(设置语言)Indicate the human language of page texts as screen reader software uses this to select the correct voice settings: 当屏幕阅读器软件选择语音设置时，请指明页面上对应的语言： WebAIM - Document Language WebAIM - 文本语言 Setting the document title(设置文本标题)Set the document &lt;title&gt; to correctly describe the current page content as this ensures that the user remains aware of the current page context: 设置文本的&lt;title&gt;来正确的描述现在页面的内容，以此来保证用户始终正确了解页面的内容： WCAG - Understanding the Document Title Requirement WCAG - 理解文档标题的需要 We can set this in React using the React Document Title Component. 我们可以使用React文档标题组件在React中使用。 Color contrast(颜色对比)Ensure that all readable text on your website has sufficient color contrast to remain maximally readable by users with low vision: 确保您的网站页面上所有可阅读的文本度有足够的颜色对比，以便视力不便的用户也有最好的阅读体验。 WCAG - Understanding the Color Contrast Requirement Everything About Color Contrast And Why You Should Rethink It A11yProject - What is Color Contrast WCAG - 理解颜色对比的需要 有关颜色对比的所有事及为什么应该重新思考它 A11yProject - 什么是颜色对比 It can be tedious to manually calculate the proper color combinations for all cases in your website so instead, you can calculate an entire accessible color palette with Colorable. 手动计算网站中所有组件适当的颜色组合可能是非常繁琐的，因此您可以使用Colorable来计算整个可访问的调色板。 Both the aXe and WAVE tools mentioned below also include color contrast tests and will report on contrast errors. 下面提到的ax和WAVE工具都包括颜色对比测试，并会提到对比度误差。 If you want to extend your contrast testing abilities you can use these tools: 如果您想扩展您的颜色对比测试能力，您可以使用下列工具： WebAIM - Color Contrast Checker The Paciello Group - Color Contrast Analyzer WebAIM - 颜色对比度检查器 Paciello组 - 颜色对比处理器 Development and Testing Tools(开发及测试工具)There are a number of tools we can use to assist in the creation of accessible web applications. 下面是可以用来协助我们创建可访问性的网站的一系列的工具。 The keyboard(键盘)By far the easiest and also one of the most important checks is to test if your entire website can be reached and used with the keyboard alone. Do this by: 到目前为止，最简单也是最重要的检查之一是测试整个网站是否可以与键盘一起使用。通过下面几步，我们可以做到这一点： Plugging out your mouse. Using Tab and Shift+Tab to browse. Using Enter to activate elements. Where required, using your keyboard arrow keys to interact with some elements, such as menus and dropdowns. 拔下鼠标。 使用Tab和Shift + Tab浏览。 使用Enter激活元素。 根据需要，使用键盘上的箭头键与某些元素（如菜单和下拉菜单）进行交互。 Development assistance(开发者工具)We can check some accessibility features directly in our JSX code. Often intellisense checks are already provided in JSX aware IDE’s for the ARIA roles, states and properties. We also have access to the following tool: 我们可以在我们的JSX代码中直接检测一些可访问性的因素。通常IDE会扮演ARIA的角色自动进行状态和属性的检测。 我们也可以访问以下工具： eslint-plugin-jsx-a11y The eslint-plugin-jsx-a11y plugin for ESLint provides AST linting feedback regarding accessibility issues in your JSX. Many IDE’s allow you to integrate these findings directly into code analysis and source code windows. ESLint的eslint-plugin-jsx-a11y提供了JSX在AST中可访问性问题的linting反馈。许多IDE允许您将这些问题直接集成到代码分析窗口和源代码窗口中。 Create React App has this plugin with a subset of rules activated. If you want to enable even more accessibility rules, you can create an .eslintrc file in the root of your project with this content: Create React App已有这个插件并沿用其中的一些规则。如果您希望使用更多可访问性的规则，则可以使用以下指令在项目的根目录下创建.eslintrc文件： 1234&#123; "extends": ["react-app", "plugin:jsx-a11y/recommended"], "plugins": ["jsx-a11y"]&#125; Testing accessibility in the browser(在浏览器中测试可访问性)A number of tools exist that can run accessibility audits on web pages in your browser. Please use them in combination with other accessibility checks mentioned here as they can only test the technical accessibility of your HTML. 许多工具可以在浏览器的网页上测试可访问性。请将它们与其他可访问性检查结合使用，因为它们只能测试与HTML相关的可访问性。 aXe, aXe-core and react-axe Deque Systems offers aXe-core for automated and end-to-end accessibility tests of your applications. This module includes integrations for Selenium. Deque Systems为您的应用程序的自动化和端对端可访问性测试提供了ax-core。 该模块包含Selenium的集成。 The Accessibility Engine or aXe, is an accessibility inspector browser extension built on aXe-core. 可访问性的引擎或者aXe,是一个内嵌在aXe-core上的检测可访问性的浏览器插件。 You can also use the react-axe module to report these accessibility findings directly to the console while developing and debugging. 您也可以使用react-axe模块在开发和调试时直接向控制台报告这些可访问性结果。 WebAIM WAVE The Web Accessibility Evaluation Tool is another accessibility browser extension. 网络可访问性评估工具是另一个可访问性的浏览器插件。 Accessibility inspectors and the Accessibility Tree(可访问性检测器及可访问性树) The Accessibility Tree is a subset of the DOM tree that contains accessible objects for every DOM element that should be exposed to assistive technology, such as screen readers. 可访问性树是DOM树的子集，其中包含每个DOM元素的可访问对象，这些元素会暴露给可访问的设备，例如屏幕阅读器。 In some browsers we can easily view the accessibility information for each element in the accessibility tree: 在一些浏览器中，我们可以轻松地查看可访问性功能树中每个元素的可访问性信息： Activate the Accessibility Inspector in Chrome Using the Accessibility Inspector in OS X Safari 在Chrome中激活辅助功能检查器 在OS X Safari中使用辅助功能检查器 Screen readers(屏幕阅读器)Testing with a screen reader should form part of your accessibility tests. 测试屏幕阅读器应该是您可访问性测试的一部分。 Please note that browser / screen reader combinations matter. It is recommended that you test your application in the browser best suited to your screen reader of choice. 请注意，浏览器/屏幕阅读器的组合很重要。建议您在最适合的屏幕阅读器的浏览器中测试您的应用程序。 Commonly Used Screen Readers(通用的屏幕阅读器) NVDA in Firefox NonVisual Desktop Access or NVDA is an open source Windows screen reader that is widely used. 不可视的桌面访问或者NVDA时一个广泛使用的开源的Windows屏幕阅读器。 Refer to the following guides on how to best use NVDA: 您可以参考下列的目录来学习如何最好的使用NVDA： WebAIM - Using NVDA to Evaluate Web Accessibility Deque - NVDA Keyboard Shortcuts WebAIM - 使用NVDA来评估网络的可访问性 Deque - NVDA键盘的快捷键 VoiceOver in Safari VoiceOver is an integrated screen reader on Apple devices. VoiceOver是Apple设备上的集成屏幕阅读器。 Refer to the following guides on how activate and use VoiceOver: 您可以参考下列的目录来学习如何激活并使用VoiceOver： WebAIM - Using VoiceOver to Evaluate Web Accessibility Deque - VoiceOver for OS X Keyboard Shortcuts Deque - VoiceOver for iOS Shortcuts WebAIM - 使用VoiceOver来评估Web可访问性 Deque- VoiceOver在OS X的快捷键 Deque - VoiceOver在iOS上的快捷键 JAWS in Internet Explorer Job Access With Speech or JAWS, is a prolifically used screen reader on Windows. Job Access With Speech或JAWS进行工作访问是Windows上一种多用途的屏幕阅读器。 Refer to the following guides on how to best use JAWS: 参考下列目录来学习如何最好的使用JAWS： WebAIM - Using JAWS to Evaluate Web Accessibility Deque - JAWS Keyboard Shortcuts WebAIM - 使用JAWS来评估Web的可访问性 Deque - JAWS键盘快捷键 Other Screen Readers(其他的屏幕阅读器) ChromeVox in Google Chrome ChromeVox is an integrated screen reader on Chromebooks and is available as an extension for Google Chrome. ChromeVox是Chromebook上的集成屏幕阅读器，可作为Google Chrome的扩展程序。 Refer to the following guides on how best to use ChromeVox: 参考下列目录来学习如何最好的使用ChromeVox： Google Chromebook Help - Use the Built-in Screen Reader ChromeVox Classic Keyboard Shortcuts Reference Google Chromebook帮助 - 使用内建的屏幕阅读器 ChromeVox Classic传统的快捷键参阅]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[react组件之间的通信]]></title>
    <url>%2F2018%2F06%2F23%2Fblog%2Fproblem%2Freact_communication%2F</url>
    <content type="text"><![CDATA[react组件之间的通信说 React 组件间通讯之前，我们先来讨论一下 React 组件究竟有多少种层级间的关系。假设我们开发的项目是一个纯 React 的项目，那我们项目应该有如下类似的关系： 父子：Parent 与 Child_1、Child_2、Child_1_1、Child_1_2、Child_2_1 兄弟：Child_1 与 Child_2、Child_1_1 与 Child_2、etc. 针对这些关系，我们将来好好讨论一下这些关系间的通讯方式。 （在 React 中，React 组件之间的关系为从属关系，与 DOM 元素之间的父子关系有所不同，下面只是为了说明方便，将 React 组件的关系类比成父子关系进行阐述） 父组件向子组件通讯通讯是单向的，数据必须是由一方传到另一方。在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。 1234567891011121314151617181920212223class Parent extends Component&#123; state = &#123; msg: 'start' &#125;; componentDidMount() &#123; setTimeout(() =&gt; &#123; this.setState(&#123; msg: 'end' &#125;); &#125;, 1000); &#125; render() &#123; return &lt;Child_1 msg=&#123;this.state.msg&#125; /&gt;; &#125;&#125;class Child_1 extends Component&#123; render() &#123; return &lt;p&gt;&#123;this.props.msg&#125;&lt;/p&gt; &#125;&#125; 如果父组件与子组件之间不止一个层级，如 Parent 与 Child_1_1 这样的关系，可通过 … 运算符（Object 剩余和展开属性），将父组件的信息，以更简洁的方式传递给更深层级的子组件。通过这种方式，不用考虑性能的问题，通过 babel 转义后的 … 运算符 性能和原生的一致，且上级组件 props 与 state 的改变，会导致组件本身及其子组件的生命周期改变， 123456789101112131415// 通过 ... 运算符 向 Child_1_1 传递 Parent 组件的信息class Child_1 extends Component&#123; render() &#123; return &lt;div&gt; &lt;p&gt;&#123;this.props.msg&#125;&lt;/p&gt; &lt;Child_1_1 &#123;...this.props&#125;/&gt; &lt;/div&gt; &#125;&#125;class Child_1_1 extends Component&#123; render() &#123; return &lt;p&gt;&#123;this.props.msg&#125;&lt;/p&gt; &#125;&#125; 子组件向父组件通讯在上一个例子中，父组件可以通过传递 props 的方式，自顶而下向子组件进行通讯。而子组件向父组件通讯，同样也需要父组件向子组件传递 props 进行通讯，只是父组件传递的，是作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中。 1234567891011121314151617181920212223242526272829303132class Parent extends Component&#123; state = &#123; msg: 'start' &#125;; transferMsg(msg) &#123; this.setState(&#123; msg &#125;); &#125; render() &#123; return &lt;div&gt; &lt;p&gt;child msg: &#123;this.state.msg&#125;&lt;/p&gt; &lt;Child_1 transferMsg = &#123;msg =&gt; this.transferMsg(msg)&#125; /&gt; &lt;/div&gt;; &#125;&#125;class Child_1 extends Component&#123; componentDidMount() &#123; setTimeout(() =&gt; &#123; this.props.transferMsg('end') &#125;, 1000); &#125; render() &#123; return &lt;div&gt; &lt;p&gt;child_1 component&lt;/p&gt; &lt;/div&gt; &#125;&#125; 在上面的例子中，我们使用了 箭头函数，将父组件的 transferMsg 函数通过 props 传递给子组件，得益于箭头函数，保证子组件在调用 transferMsg 函数时，其内部 this 仍指向父组件。 当然，对于层级比较深的子组件与父组件之间的通讯，仍可使用 … 运算符，将父组件的调用函数传递给子组件，具体方法和上面的例子类似。 兄弟组件间通讯对于没有直接关联关系的两个节点，就如 Child_1 与 Child_2 之间的关系，他们唯一的关联点，就是拥有相同的父组件。参考之前介绍的两种关系的通讯方式，如果我们向由 Child_1 向 Child_2 进行通讯，我们可以先通过 Child_1 向 Parent 组件进行通讯，再由 Parent 向 Child_2 组件进行通讯，所以有以下代码。 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849505152535455565758596061626364656667class Parent extends Component&#123; state = &#123; msg: 'start' &#125;; transferMsg(msg) &#123; this.setState(&#123; msg &#125;); &#125; componentDidUpdate() &#123; console.log('Parent update'); &#125; render() &#123; return ( &lt;div&gt; &lt;Child_1 transferMsg = &#123;msg =&gt; this.transferMsg(msg)&#125; /&gt; &lt;Child_2 msg = &#123;this.state.msg&#125; /&gt; &lt;/div&gt; ); &#125;&#125;class Child_1 extends Component&#123; componentDidMount() &#123; setTimeout(() =&gt; &#123; this.props.transferMsg('end') &#125;, 1000); &#125; componentDidUpdate() &#123; console.log('Child_1 update'); &#125; render() &#123; return &lt;div&gt; &lt;p&gt;child_1 component&lt;/p&gt; &lt;/div&gt; &#125;&#125;class Child_2 extends Component&#123; componentDidUpdate() &#123; console.log('Child_2 update'); &#125; render() &#123; return &lt;div&gt; &lt;p&gt;child_2 component: &#123;this.props.msg&#125;&lt;/p&gt; &lt;Child_2_1 /&gt; &lt;/div&gt; &#125;&#125;class Child_2_1 extends Component&#123; componentDidUpdate() &#123; console.log('Child_2_1 update'); &#125; render() &#123; return &lt;div&gt; &lt;p&gt;child_2_1 component&lt;/p&gt; &lt;/div&gt; &#125;&#125; 然而，这个方法有一个问题，由于 Parent 的 state 发生变化，会触发 Parent 及从属于 Parent 的子组件的生命周期，所以我们在控制台中可以看到，在各个组件中的 componentDidUpdate 方法均被触发。]]></content>
      <categories>
        <category>前端常见问题</category>
      </categories>
      <tags>
        <tag>前端问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 -- 10.Symbol]]></title>
    <url>%2F2018%2F06%2F19%2FES6%2F10.symbol%2F</url>
    <content type="text"><![CDATA[Symbol概 述ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入Symbol的原因。 ES6 引入了一种新的原始数据类型Symbol，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：undefined、null、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。 Symbol 值通过Symbol函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。 1234let s = Symbol();typeof s// "symbol" 上面代码中，变量s就是一个独一无二的值。typeof运算符的结果，表明变量s是 Symbol 数据类型，而不是字符串之类的其他类型。 注意，Symbol函数前不能使用new命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。 Symbol函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。 12345678let s1 = Symbol('foo');let s2 = Symbol('bar');s1 // Symbol(foo)s2 // Symbol(bar) s1.toString() // "Symbol(foo)"s2.toString() // "Symbol(bar)" 上面代码中，s1和s2是两个 Symbol 值。如果不加参数，它们在控制台的输出都是Symbol()，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。 如果 Symbol 的参数是一个对象，就会调用该对象的toString方法，将其转为字符串，然后才生成一个 Symbol 值。 1234567const obj = &#123; toString() &#123; return 'abc'; &#125;&#125;;const sym = Symbol(obj);sym // Symbol(abc) 注意，Symbol函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的Symbol函数的返回值是不相等的。 1234567891011// 没有参数的情况let s1 = Symbol();let s2 = Symbol();s1 === s2 // false// 有参数的情况let s1 = Symbol('foo');let s2 = Symbol('foo');s1 === s2 // false 上面代码中，s1和s2都是Symbol函数的返回值，而且参数相同，但是它们是不相等的。 Symbol 值不能与其他类型的值进行运算，会报错。 123456let sym = Symbol('My symbol');"your symbol is " + sym// TypeError: can't convert symbol to string`your symbol is $&#123;sym&#125;`// TypeError: can't convert symbol to string 但是，Symbol 值可以显式转为字符串。 1234let sym = Symbol('My symbol');String(sym) // 'Symbol(My symbol)'sym.toString() // 'Symbol(My symbol)' 另外，Symbol 值也可以转为布尔值，但是不能转为数值。 123456789let sym = Symbol();Boolean(sym) // true!sym // falseif (sym) &#123;&#125; Number(sym) // TypeErrorsym + 2 // TypeError 作为属性名的 Symbol由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。 1234567891011121314151617let mySymbol = Symbol();// 第一种写法let a = &#123;&#125;;a[mySymbol] = 'Hello!';// 第二种写法let a = &#123; [mySymbol]: 'Hello!'&#125;;// 第三种写法let a = &#123;&#125;;Object.defineProperty(a, mySymbol, &#123; value: 'Hello!' &#125;);// 以上写法都得到同样结果a[mySymbol] // "Hello!" 上面代码通过方括号结构和Object.defineProperty，将对象的属性名指定为一个 Symbol 值。 注意，Symbol 值作为对象属性名时，不能用点运算符。 123456const mySymbol = Symbol();const a = &#123;&#125;;a.mySymbol = 'Hello!';a[mySymbol] // undefineda['mySymbol'] // "Hello!" 上面代码中，因为点运算符后面总是字符串，所以不会读取mySymbol作为标识名所指代的那个值，导致a的属性名实际上是一个字符串，而不是一个 Symbol 值。 同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。 1234567let s = Symbol();let obj = &#123; [s]: function (arg) &#123; ... &#125;&#125;;obj[s](123); 上面代码中，如果s不放在方括号中，该属性的键名就是字符串s，而不是s所代表的那个 Symbol 值。 采用增强的对象写法，上面代码的obj对象可以写得更简洁一些。 123let obj = &#123; [s](arg) &#123; ... &#125;&#125;; Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。 123456789const log = &#123;&#125;;log.levels = &#123; DEBUG: Symbol('debug'), INFO: Symbol('info'), WARN: Symbol('warn')&#125;;console.log(log.levels.DEBUG, 'debug message');console.log(log.levels.INFO, 'info message'); 下面是另外一个例子。 12345678910111213const COLOR_RED = Symbol();const COLOR_GREEN = Symbol();function getComplement(color) &#123; switch (color) &#123; case COLOR_RED: return COLOR_GREEN; case COLOR_GREEN: return COLOR_RED; default: throw new Error('Undefined color'); &#125;&#125; 常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的switch语句会按设计的方式工作。 还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。 实例：消除魔术字符串 魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。 1234567891011121314function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case 'Triangle': // 魔术字符串 area = .5 * options.width * options.height; break; /* ... more code ... */ &#125; return area;&#125;getArea('Triangle', &#123; width: 100, height: 100 &#125;); // 魔术字符串 上面代码中，字符串Triangle就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。 常用的消除魔术字符串的方法，就是把它写成一个变量。 123456789101112131415const shapeType = &#123; triangle: 'Triangle'&#125;;function getArea(shape, options) &#123; let area = 0; switch (shape) &#123; case shapeType.triangle: area = .5 * options.width * options.height; break; &#125; return area;&#125;getArea(shapeType.triangle, &#123; width: 100, height: 100 &#125;); 上面代码中，我们把Triangle写成shapeType对象的triangle属性，这样就消除了强耦合。 如果仔细分析，可以发现shapeType.triangle等于哪个值并不重要，只要确保不会跟其他shapeType属性的值冲突即可。因此，这里就很适合改用 Symbol 值。 123const shapeType = &#123; triangle: Symbol()&#125;; 上面代码中，除了将shapeType.triangle的值设为一个 Symbol，其他地方都不用修改。 属性名的遍历Symbol 作为属性名，该属性不会出现在for...in、for...of循环中，也不会被Object.keys()、Object.getOwnPropertyNames()、JSON.stringify()返回。但是，它也不是私有属性，有一个Object.getOwnPropertySymbols方法，可以获取指定对象的所有 Symbol 属性名。 Object.getOwnPropertySymbols方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。 1234567891011const obj = &#123;&#125;;let a = Symbol('a');let b = Symbol('b'); obj[a] = 'Hello';obj[b] = 'World';const objectSymbols = Object.getOwnPropertySymbols(obj);objectSymbols// [Symbol(a), Symbol(b)] 下面是另一个例子，Object.getOwnPropertySymbols方法与for...in循环、Object.getOwnPropertyNames方法进行对比的例子。 1234567891011121314151617const obj = &#123;&#125;;let foo = Symbol("foo");Object.defineProperty(obj, foo, &#123; value: "foobar",&#125;); for (let i in obj) &#123; console.log(i); // 无输出&#125;Object.getOwnPropertyNames(obj)// []Object.getOwnPropertySymbols(obj)// [Symbol(foo)] 上面代码中，使用Object.getOwnPropertyNames方法得不到Symbol属性名，需要使用Object.getOwnPropertySymbols方法。 另一个新的 API，Reflect.ownKeys方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。 12345678let obj = &#123; [Symbol('my_key')]: 1, enum: 2, nonEnum: 3&#125;;Reflect.ownKeys(obj)// ["enum", "nonEnum", Symbol(my_key)] 由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。 1234567891011121314151617181920212223242526let size = Symbol('size');class Collection &#123; constructor() &#123; this[size] = 0; &#125; add(item) &#123; this[this[size]] = item; this[size]++; &#125; static sizeOf(instance) &#123; return instance[size]; &#125;&#125;let x = new Collection();Collection.sizeOf(x) // 0x.add('foo');Collection.sizeOf(x) // 1Object.keys(x) // ['0']Object.getOwnPropertyNames(x) // ['0']Object.getOwnPropertySymbols(x) // [Symbol(size)] 上面代码中，对象x的size属性是一个 Symbol 值，所以Object.keys(x)、Object.getOwnPropertyNames(x)都无法获取它。这就造成了一种非私有的内部方法的效果。 Symbol.for()，Symbol.keyFor()有时，我们希望重新使用同一个 Symbol 值，Symbol.for方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。 1234let s1 = Symbol.for('foo');let s2 = Symbol.for('foo');s1 === s2 // true 上面代码中，s1和s2都是 Symbol 值，但是它们都是同样参数的Symbol.for方法生成的，所以实际上是同一个值。 Symbol.for()与Symbol()这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。Symbol.for()不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的key是否已经存在，如果不存在才会新建一个值。比如，如果你调用Symbol.for(&quot;cat&quot;)30 次，每次都会返回同一个 Symbol 值，但是调用Symbol(&quot;cat&quot;)30 次，会返回 30 个不同的 Symbol 值。 12345Symbol.for("bar") === Symbol.for("bar")// trueSymbol("bar") === Symbol("bar")// false 上面代码中，由于Symbol()写法没有登记机制，所以每次调用都会返回一个不同的值。 Symbol.keyFor方法返回一个已登记的 Symbol 类型值的key。 12345let s1 = Symbol.for("foo");Symbol.keyFor(s1) // "foo"let s2 = Symbol("foo");Symbol.keyFor(s2) // undefined 上面代码中，变量s2属于未登记的 Symbol 值，所以返回undefined。 需要注意的是，Symbol.for为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。 123456iframe = document.createElement('iframe');iframe.src = String(window.location);document.body.appendChild(iframe);iframe.contentWindow.Symbol.for('foo') === Symbol.for('foo')// true 上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。 实例：模块的 Singleton 模式Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。 对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？ 很容易想到，可以把实例放到顶层对象global。 12345678910// mod.jsfunction A() &#123; this.foo = 'hello';&#125;if (!global._foo) &#123; global._foo = new A();&#125;module.exports = global._foo; 然后，加载上面的mod.js。 12const a = require('./mod.js');console.log(a.foo); 上面代码中，变量a任何时候加载的都是A的同一个实例。 但是，这里有一个问题，全局变量global._foo是可写的，任何文件都可以修改。 1234global._foo = &#123; foo: 'world' &#125;;const a = require('./mod.js');console.log(a.foo); 上面的代码，会使得加载mod.js的脚本都失真。 为了防止这种情况出现，我们就可以使用 Symbol。 123456789101112// mod.jsconst FOO_KEY = Symbol.for('foo');function A() &#123; this.foo = 'hello';&#125;if (!global[FOO_KEY]) &#123; global[FOO_KEY] = new A();&#125;module.exports = global[FOO_KEY]; 上面代码中，可以保证global[FOO_KEY]不会被无意间覆盖，但还是可以被改写。 123global[Symbol.for('foo')] = &#123; foo: 'world' &#125;;const a = require('./mod.js'); 如果键名使用Symbol方法生成，那么外部将无法引用这个值，当然也就无法改写。 1234// mod.jsconst FOO_KEY = Symbol('foo');// 后面代码相同 …… 上面代码将导致其他脚本都无法引用FOO_KEY。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的FOO_KEY都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。 内置的 Symbol 值除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。 Symbol.hasInstance对象的Symbol.hasInstance属性，指向一个内部方法。当其他对象使用instanceof运算符，判断是否为该对象的实例时，会调用这个方法。比如，foo instanceof Foo在语言内部，实际调用的是Foo[Symbol.hasInstance](foo)。 1234567class MyClass &#123; [Symbol.hasInstance](foo) &#123; return foo instanceof Array; &#125;&#125;[1, 2, 3] instanceof new MyClass() // true 上面代码中，MyClass是一个类，new MyClass()会返回一个实例。该实例的Symbol.hasInstance方法，会在进行instanceof运算时自动调用，判断左侧的运算子是否为Array的实例。 下面是另一个例子。 12345678910111213141516class Even &#123; static [Symbol.hasInstance](obj) &#123; return Number(obj) % 2 === 0; &#125;&#125; // 等同于const Even = &#123; [Symbol.hasInstance](obj) &#123; return Number(obj) % 2 === 0; &#125;&#125;;1 instanceof Even // false2 instanceof Even // true12345 instanceof Even // false Symbol.isConcatSpreadable对象的Symbol.isConcatSpreadable属性等于一个布尔值，表示该对象用于Array.prototype.concat()时，是否可以展开。 1234567let arr1 = ['c', 'd'];['a', 'b'].concat(arr1, 'e') // ['a', 'b', 'c', 'd', 'e']arr1[Symbol.isConcatSpreadable] // undefined let arr2 = ['c', 'd'];arr2[Symbol.isConcatSpreadable] = false;['a', 'b'].concat(arr2, 'e') // ['a', 'b', ['c','d'], 'e'] 上面代码说明，数组的默认行为是可以展开，Symbol.isConcatSpreadable默认等于undefined。该属性等于true时，也有展开的效果。 类似数组的对象正好相反，默认不展开。它的Symbol.isConcatSpreadable属性设为true，才可以展开。 12345let obj = &#123;length: 2, 0: 'c', 1: 'd'&#125;;['a', 'b'].concat(obj, 'e') // ['a', 'b', obj, 'e']obj[Symbol.isConcatSpreadable] = true;['a', 'b'].concat(obj, 'e') // ['a', 'b', 'c', 'd', 'e'] Symbol.isConcatSpreadable属性也可以定义在类里面。 12345678910111213141516171819202122class A1 extends Array &#123; constructor(args) &#123; super(args); this[Symbol.isConcatSpreadable] = true; &#125;&#125;class A2 extends Array &#123; constructor(args) &#123; super(args); &#125; get [Symbol.isConcatSpreadable] () &#123; return false; &#125;&#125;let a1 = new A1();a1[0] = 3;a1[1] = 4;let a2 = new A2();a2[0] = 5;a2[1] = 6;[1, 2].concat(a1).concat(a2)// [1, 2, 3, 4, [5, 6]] 上面代码中，类A1是可展开的，类A2是不可展开的，所以使用concat时有不一样的结果。 注意，Symbol.isConcatSpreadable的位置差异，A1是定义在实例上，A2是定义在类本身，效果相同。 Symbol.species对象的Symbol.species属性，指向一个构造函数。创建衍生对象时，会使用该属性。 123456789class MyArray extends Array &#123;&#125;const a = new MyArray(1, 2, 3);const b = a.map(x =&gt; x);const c = a.filter(x =&gt; x &gt; 1);b instanceof MyArray // truec instanceof MyArray // true 上面代码中，子类MyArray继承了父类Array，a是MyArray的实例，b和c是a的衍生对象。你可能会认为，b和c都是调用数组方法生成的，所以应该是数组（Array的实例），但实际上它们也是MyArray的实例。 Symbol.species属性就是为了解决这个问题而提供的。现在，我们可以为MyArray设置Symbol.species属性。 123class MyArray extends Array &#123; static get [Symbol.species]() &#123; return Array; &#125;&#125; 上面代码中，由于定义了Symbol.species属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义Symbol.species属性要采用get取值器。默认的Symbol.species属性等同于下面的写法。 123static get [Symbol.species]() &#123; return this;&#125; 现在，再来看前面的例子。 123456789class MyArray extends Array &#123; static get [Symbol.species]() &#123; return Array; &#125;&#125; const a = new MyArray();const b = a.map(x =&gt; x);b instanceof MyArray // falseb instanceof Array // true 上面代码中，a.map(x =&gt; x)生成的衍生对象，就不是MyArray的实例，而直接就是Array的实例。 再看一个例子。1234567891011class T1 extends Promise &#123;&#125;class T2 extends Promise &#123; static get [Symbol.species]() &#123; return Promise; &#125;&#125;new T1(r =&gt; r()).then(v =&gt; v) instanceof T1 // truenew T2(r =&gt; r()).then(v =&gt; v) instanceof T2 // false 上面代码中，T2定义了Symbol.species属性，T1没有。结果就导致了创建衍生对象时（then方法），T1调用的是自身的构造方法，而T2调用的是Promise的构造方法。 总之，Symbol.species的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。 Symbol.match对象的Symbol.match属性，指向一个函数。当执行str.match(myObject)时，如果该属性存在，会调用它，返回该方法的返回值。 1234567891011String.prototype.match(regexp)// 等同于regexp[Symbol.match](this)class MyMatcher &#123; [Symbol.match](string) &#123; return 'hello world'.indexOf(string); &#125;&#125; 'e'.match(new MyMatcher()) // 1 Symbol.replace对象的Symbol.replace属性，指向一个方法，当该对象被String.prototype.replace方法调用时，会返回该方法的返回值。 123String.prototype.replace(searchValue, replaceValue)// 等同于searchValue[Symbol.replace](this, replaceValue) 下面是一个例子。 1234const x = &#123;&#125;;x[Symbol.replace] = (...s) =&gt; console.log(s);'Hello'.replace(x, 'World') // ["Hello", "World"] Symbol.replace方法会收到两个参数，第一个参数是replace方法正在作用的对象，上面例子是Hello，第二个参数是替换后的值，上面例子是World。 Symbol.search对象的Symbol.search属性，指向一个方法，当该对象被String.prototype.search方法调用时，会返回该方法的返回值。 12345678910111213String.prototype.search(regexp)// 等同于regexp[Symbol.search](this)class MySearch &#123; constructor(value) &#123; this.value = value; &#125; [Symbol.search](string) &#123; return string.indexOf(this.value); &#125;&#125;'foobar'.search(new MySearch('foo')) // 0 Symbol.split对象的Symbol.split属性，指向一个方法，当该对象被String.prototype.split方法调用时，会返回该方法的返回值。 123String.prototype.split(separator, limit)// 等同于separator[Symbol.split](this, limit) 下面是一个例子。 123456789101112131415161718192021222324class MySplitter &#123; constructor(value) &#123; this.value = value; &#125; [Symbol.split](string) &#123; let index = string.indexOf(this.value); if (index === -1) &#123; return string; &#125; return [ string.substr(0, index), string.substr(index + this.value.length) ]; &#125;&#125; 'foobar'.split(new MySplitter('foo'))// ['', 'bar']'foobar'.split(new MySplitter('bar'))// ['foo', '']'foobar'.split(new MySplitter('baz'))// 'foobar' 上面方法使用Symbol.split方法，重新定义了字符串对象的split方法的行为， Symbol.iterator对象的Symbol.iterator属性，指向该对象的默认遍历器方法。 12345678const myIterable = &#123;&#125;;myIterable[Symbol.iterator] = function* () &#123; yield 1; yield 2; yield 3;&#125;;[...myIterable] // [1, 2, 3] 对象进行for...of循环时，会调用Symbol.iterator方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。 123456789101112131415161718class Collection &#123; *[Symbol.iterator]() &#123; let i = 0; while(this[i] !== undefined) &#123; yield this[i]; ++i; &#125; &#125;&#125;let myCollection = new Collection();myCollection[0] = 1;myCollection[1] = 2; for(let value of myCollection) &#123; console.log(value);&#125;// 1// 2 Symbol.toPrimitive对象的Symbol.toPrimitive属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。 Symbol.toPrimitive被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。 Number：该场合需要转成数值 String：该场合需要转成字符串 Default：该场合可以转成数值，也可以转成字符串 12345678910111213141516171819let obj = &#123; [Symbol.toPrimitive](hint) &#123; switch (hint) &#123; case 'number': return 123; case 'string': return 'str'; case 'default': return 'default'; default: throw new Error(); &#125; &#125;&#125;; 2 * obj // 2463 + obj // '3default'obj == 'default' // trueString(obj) // 'str' Symbol.toStringTag对象的Symbol.toStringTag属性，指向一个方法。在该对象上面调用Object.prototype.toString方法时，如果这个属性存在，它的返回值会出现在toString方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制[object Object]或[object Array]中object后面的那个字符串。 123456789101112// 例一(&#123;[Symbol.toStringTag]: 'Foo'&#125;.toString())// "[object Foo]"// 例二class Collection &#123; get [Symbol.toStringTag]() &#123; return 'xxx'; &#125;&#125;let x = new Collection();Object.prototype.toString.call(x) // "[object xxx]" ES6 新增内置对象的Symbol.toStringTag属性值如下。 JSON[Symbol.toStringTag]：’JSON’ Math[Symbol.toStringTag]：’Math’ Module 对象M[Symbol.toStringTag]：’Module’ ArrayBuffer.prototype[Symbol.toStringTag]：’ArrayBuffer’ DataView.prototype[Symbol.toStringTag]：’DataView’ Map.prototype[Symbol.toStringTag]：’Map’ Promise.prototype[Symbol.toStringTag]：’Promise’ Set.prototype[Symbol.toStringTag]：’Set’ %TypedArray%.prototype[Symbol.toStringTag]：’Uint8Array’等 WeakMap.prototype[Symbol.toStringTag]：’WeakMap’ WeakSet.prototype[Symbol.toStringTag]：’WeakSet’ %MapIteratorPrototype%[Symbol.toStringTag]：’Map Iterator’ %SetIteratorPrototype%[Symbol.toStringTag]：’Set Iterator’ %StringIteratorPrototype%[Symbol.toStringTag]：’String Iterator’ Symbol.prototype[Symbol.toStringTag]：’Symbol’ Generator.prototype[Symbol.toStringTag]：’Generator’ GeneratorFunction.prototype[Symbol.toStringTag]：’GeneratorFunction’ Symbol.unscopables对象的Symbol.unscopables属性，指向一个对象。该对象指定了使用with关键字时，哪些属性会被with环境排除。 12345678910111213Array.prototype[Symbol.unscopables]// &#123;// copyWithin: true,// entries: true,// fill: true,// find: true,// findIndex: true,// includes: true,// keys: true// &#125; Object.keys(Array.prototype[Symbol.unscopables])// ['copyWithin', 'entries', 'fill', 'find', 'findIndex', 'includes', 'keys'] 上面代码说明，数组有 7 个属性，会被with命令排除。 123456789101112131415161718192021222324// 没有 unscopables 时class MyClass &#123; foo() &#123; return 1; &#125;&#125; var foo = function () &#123; return 2; &#125;; with (MyClass.prototype) &#123; foo(); // 1&#125; // 有 unscopables 时class MyClass &#123; foo() &#123; return 1; &#125; get [Symbol.unscopables]() &#123; return &#123; foo: true &#125;; &#125;&#125;var foo = function () &#123; return 2; &#125;;with (MyClass.prototype) &#123; foo(); // 2&#125; 上面代码通过指定Symbol.unscopables属性，使得with语法块不会在当前作用域寻找foo属性，即foo将指向外层作用域的变量。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 -- 09.对象的扩展]]></title>
    <url>%2F2018%2F06%2F19%2FES6%2F09.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[对象的扩展1.属性的简洁表示法 ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。 123456const foo = 'bar';const baz = &#123;foo&#125;;baz // &#123;foo: "bar"&#125;// 等同于const baz = &#123;foo: foo&#125;; 上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。 1234567891011function f(x, y) &#123; return &#123;x, y&#125;;&#125;// 等同于function f(x, y) &#123; return &#123;x: x, y: y&#125;;&#125;f(1, 2) // Object &#123;x: 1, y: 2&#125; 除了属性简写，方法也可以简写。 12345678910111213const o = &#123; method() &#123; return "Hello!"; &#125; &#125;; // 等同于 const o = &#123; method: function() &#123; return "Hello!"; &#125; &#125;; 下面是一个实际的例子。12345678910111213let birth = '2000/01/01'; const Person = &#123; name: '张三', //等同于birth: birth birth, // 等同于hello: function ()... hello() &#123; console.log('我的名字是', this.name); &#125;&#125;; 这种写法用于函数的返回值，将会非常方便。 12345678function getPoint() &#123; const x = 1; const y = 10; return &#123;x, y&#125;;&#125;getPoint()// &#123;x:1, y:10&#125; CommonJS 模块输出一组变量，就非常合适使用简洁写法。123456789101112131415161718192021let ms = &#123;&#125;;function getItem (key) &#123; return key in ms ? ms[key] : null;&#125;function setItem (key, value) &#123; ms[key] = value;&#125;function clear () &#123; ms = &#123;&#125;;&#125;module.exports = &#123; getItem, setItem, clear &#125;;// 等同于module.exports = &#123; getItem: getItem, setItem: setItem, clear: clear&#125;; 属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。1234567891011121314const cart = &#123; _wheels: 4, get wheels () &#123; return this._wheels; &#125;, set wheels (value) &#123; if (value &lt; this._wheels) &#123; throw new Error('数值太小了！'); &#125; this._wheels = value; &#125;&#125; 注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。 123456789const obj = &#123; class () &#123;&#125;&#125;;// 等同于 var obj = &#123; 'class': function() &#123;&#125;&#125;; 上面代码中，class是字符串，所以不会因为它属于关键字，而导致语法解析报错。 如果某个方法的值是一个 Generator 函数，前面需要加上星号。 12345const obj = &#123; * m() &#123; yield 'hello world'; &#125;&#125;; 属性名表达式JavaScript 定义对象的属性，有两种方法。 12345// 方法一obj.foo = true;// 方法二obj['a' + 'bc'] = 123; 上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。 但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。 1234var obj = &#123; foo: true, abc: 123&#125;; ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。 123456let propKey = 'foo';let obj = &#123; [propKey]: true, ['a' + 'bc']: 123&#125;; 下面是另一个例子。 12345678910let lastWord = 'last word';const a = &#123; 'first word': 'hello', [lastWord]: 'world'&#125;; a['first word'] // "hello"a[lastWord] // "world"a['last word'] // "world" 表达式还可以用于定义方法名。 1234567let obj = &#123; ['h' + 'ello']() &#123; return 'hi'; &#125;&#125;;obj.hello() // hi 注意，属性名表达式与简洁表示法，不能同时使用，会报错。 12345678// 报错const foo = 'bar';const bar = 'abc';const baz = &#123; [foo] &#125;;// 正确const foo = 'bar';const baz = &#123; [foo]: 'abc'&#125;; 注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串[object Object]，这一点要特别小心。 123456789const keyA = &#123;a: 1&#125;;const keyB = &#123;b: 2&#125;;const myObject = &#123; [keyA]: 'valueA', [keyB]: 'valueB'&#125;;myObject // Object &#123;[object Object]: "valueB"&#125; 上面代码中，[keyA]和[keyB]得到的都是[object Object]，所以[keyB]会把[keyA]覆盖掉，而myObject最后只有一个[object Object]属性。 方法的 name 属性函数的name属性，返回函数名。对象方法也是函数，因此也有name属性。 1234567const person = &#123; sayName() &#123; console.log('hello!'); &#125;,&#125;; person.sayName.name // "sayName" 上面代码中，方法的name属性返回函数名（即方法名）。 如果对象的方法使用了取值函数（getter）和存值函数（setter），则name属性不是在该方法上面，而是该方法的属性的描述对象的get和set属性上面，返回值是方法名前加上get和set。 123456789101112const obj = &#123; get foo() &#123;&#125;, set foo(x) &#123;&#125;&#125;;obj.foo.name// TypeError: Cannot read property 'name' of undefinedconst descriptor = Object.getOwnPropertyDescriptor(obj, 'foo');descriptor.get.name // "get foo"descriptor.set.name // "set foo" 有两种特殊情况：bind方法创造的函数，name属性返回bound加上原函数的名字；Function构造函数创造的函数，name属性返回anonymous。 123456(new Function()).name // "anonymous"var doSomething = function() &#123; // ...&#125;;doSomething.bind().name // "bound doSomething" 如果对象的方法是一个 Symbol 值，那么name属性返回的是这个 Symbol 值的描述。 12345678const key1 = Symbol('description');const key2 = Symbol();let obj = &#123; [key1]() &#123;&#125;, [key2]() &#123;&#125;,&#125;;obj[key1].name // "[description]"obj[key2].name // "" 上面代码中，key1对应的 Symbol 值有描述，key2没有。 Object.is()ES5 比较两个值是否相等，只有两个运算符：相等运算符（==）和严格相等运算符（===）。它们都有缺点，前者会自动转换数据类型，后者的NaN不等于自身，以及+0等于-0。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。 ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。Object.is就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。 1234Object.is('foo', 'foo')// trueObject.is(&#123;&#125;, &#123;&#125;)// false 不同之处只有两个：一是+0不等于-0，二是NaN等于自身。 12345+0 === -0 //trueNaN === NaN // falseObject.is(+0, -0) // falseObject.is(NaN, NaN) // true ES5 可以通过下面的代码，部署Object.is。12345678910111213Object.defineProperty(Object, 'is', &#123; value: function(x, y) &#123; if (x === y) &#123; // 针对+0 不等于 -0的情况 return x !== 0 || 1 / x === 1 / y; &#125; // 针对NaN的情况 return x !== x &amp;&amp; y !== y; &#125;, configurable: true, enumerable: false, writable: true&#125;); Object.assign()基本用法Object.assign方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。 1234567const target = &#123; a: 1 &#125;;const source1 = &#123; b: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; Object.assign方法的第一个参数是目标对象，后面的参数都是源对象。 注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。1234567const target = &#123; a: 1, b: 1 &#125;;const source1 = &#123; b: 2, c: 2 &#125;;const source2 = &#123; c: 3 &#125;;Object.assign(target, source1, source2);target // &#123;a:1, b:2, c:3&#125; 如果只有一个参数，Object.assign会直接返回该参数。12const obj = &#123;a: 1&#125;;Object.assign(obj) === obj // true 如果该参数不是对象，则会先转成对象，然后返回。1typeof Object.assign(2) // "object" 由于undefined和null无法转成对象，所以如果它们作为参数，就会报错。12Object.assign(undefined) // 报错Object.assign(null) // 报错 如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果undefined和null不在首参数，就不会报错。123let obj = &#123;a: 1&#125;;Object.assign(obj, undefined) === obj // trueObject.assign(obj, null) === obj // true 其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。123456const v1 = 'abc';const v2 = true;const v3 = 10;const obj = Object.assign(&#123;&#125;, v1, v2, v3);console.log(obj); // &#123; "0": "a", "1": "b", "2": "c" &#125; 上面代码中，v1、v2、v3分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。 123Object(true) // &#123;[[PrimitiveValue]]: true&#125;Object(10) // &#123;[[PrimitiveValue]]: 10&#125;Object('abc') // &#123;0: "a", 1: "b", 2: "c", length: 3, [[PrimitiveValue]]: "abc"&#125; 上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性[[PrimitiveValue]]上面，这个属性是不会被Object.assign拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。 Object.assign拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（enumerable: false）。 1234567Object.assign(&#123;b: 'c'&#125;, Object.defineProperty(&#123;&#125;, 'invisible', &#123; enumerable: false, value: 'hello' &#125;))// &#123; b: 'c' &#125; 上面代码中，Object.assign要拷贝的对象只有一个不可枚举属性invisible，这个属性并没有被拷贝进去。 属性名为 Symbol 值的属性，也会被Object.assign拷贝。 12Object.assign(&#123; a: 'b' &#125;, &#123; [Symbol('c')]: 'd' &#125;)// &#123; a: 'b', Symbol(c): 'd' &#125; 注意点（1）浅拷贝 Object.assign方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。12345const obj1 = &#123;a: &#123;b: 1&#125;&#125;;const obj2 = Object.assign(&#123;&#125;, obj1);obj1.a.b = 2;obj2.a.b // 2 上面代码中，源对象obj1的a属性的值是一个对象，Object.assign拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。 （2）同名属性的替换 对于这种嵌套的对象，一旦遇到同名属性，Object.assign的处理方法是替换，而不是添加。1234const target = &#123; a: &#123; b: 'c', d: 'e' &#125; &#125;const source = &#123; a: &#123; b: 'hello' &#125; &#125;Object.assign(target, source)// &#123; a: &#123; b: 'hello' &#125; &#125; 上面代码中，target对象的a属性被source对象的a属性整个替换掉了，而不会得到{ a: { b: &#39;hello&#39;, d: &#39;e&#39; } }的结果。这通常不是开发者想要的，需要特别小心。 一些函数库提供Object.assign的定制版本（比如 Lodash 的_.defaultsDeep方法），可以得到深拷贝的合并。 （3）数组的处理 Object.assign可以用来处理数组，但是会把数组视为对象。 12Object.assign([1, 2, 3], [4, 5])// [4, 5, 3] 上面代码中，Object.assign把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性4覆盖了目标数组的 0 号属性1。 （4）取值函数的处理 Object.assign只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。1234567const source = &#123; get foo() &#123; return 1 &#125;&#125;;const target = &#123;&#125;;Object.assign(target, source)// &#123; foo: 1 &#125; 上面代码中，source对象的foo属性是一个取值函数，Object.assign不会复制这个取值函数，只会拿到值以后，将这个值复制过去。 常见用途Object.assign方法有很多用处。 （1）为对象添加属性12345class Point &#123; constructor(x, y) &#123; Object.assign(this, &#123;x, y&#125;); &#125;&#125; 上面方法通过Object.assign方法，将x属性和y属性添加到Point类的对象实例。 （2）为对象添加方法12345678910111213141516Object.assign(SomeClass.prototype, &#123; someMethod(arg1, arg2) &#123; ··· &#125;, anotherMethod() &#123; ··· &#125;&#125;);// 等同于下面的写法SomeClass.prototype.someMethod = function (arg1, arg2) &#123; ···&#125;;SomeClass.prototype.anotherMethod = function () &#123; ···&#125;; 上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用assign方法添加到SomeClass.prototype之中。 （3）克隆对象123function clone(origin) &#123; return Object.assign(&#123;&#125;, origin);&#125; 上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。 不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。1234function clone(origin) &#123; let originProto = Object.getPrototypeOf(origin); return Object.assign(Object.create(originProto), origin);&#125; （4）合并多个对象 将多个对象合并到某个对象。12const merge = (target, ...sources) =&gt; Object.assign(target, ...sources); 如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。12const merge = (...sources) =&gt; Object.assign(&#123;&#125;, ...sources); （5）为属性指定默认值12345678910const DEFAULTS = &#123; logLevel: 0, outputFormat: 'html'&#125;;function processContent(options) &#123; options = Object.assign(&#123;&#125;, DEFAULTS, options); console.log(options); // ...&#125; 上面代码中，DEFAULTS对象是默认值，options对象是用户提供的参数。Object.assign方法将DEFAULTS和options合并成一个新对象，如果两者有同名属性，则option的属性值会覆盖DEFAULTS的属性值。 注意，由于存在浅拷贝的问题，DEFAULTS对象和options对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，DEFAULTS对象的该属性很可能不起作用。1234567891011const DEFAULTS = &#123; url: &#123; host: 'example.com', port: 7070 &#125;,&#125;;processContent(&#123; url: &#123;port: 8000&#125; &#125;)// &#123;// url: &#123;port: 8000&#125;// &#125; 上面代码的原意是将url.port改成 8000，url.host不变。实际结果却是options.url覆盖掉DEFAULTS.url，所以url.host就不存在了。 属性的可枚举性和遍历可枚举性对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。Object.getOwnPropertyDescriptor方法可以获取该属性的描述对象。12345678let obj = &#123; foo: 123 &#125;;Object.getOwnPropertyDescriptor(obj, 'foo')// &#123;// value: 123,// writable: true,// enumerable: true,// configurable: true// &#125; 描述对象的enumerable属性，称为”可枚举性“，如果该属性为false，就表示某些操作会忽略当前属性。 目前，有四个操作会忽略enumerable为false的属性。 for...in循环：只遍历对象自身的和继承的可枚举的属性。 Object.keys()：返回对象自身的所有可枚举的属性的键名。 JSON.stringify()：只串行化对象自身的可枚举的属性。 Object.assign()： 忽略enumerable为false的属性，只拷贝对象自身的可枚举的属性。 这四个操作之中，前三个是 ES5 就有的，最后一个Object.assign()是 ES6 新增的。其中，只有for...in会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（enumerable）这个概念的最初目的，就是让某些属性可以规避掉for...in操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的toString方法，以及数组的length属性，就通过“可枚举性”，从而避免被for...in遍历到。12345Object.getOwnPropertyDescriptor(Object.prototype, 'toString').enumerable// falseObject.getOwnPropertyDescriptor([], 'length').enumerable// false 上面代码中，toString和length属性的enumerable都是false，因此for...in不会遍历到这两个继承自原型的属性。 另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。12Object.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;.prototype, 'foo').enumerable// false 总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用for...in循环，而用Object.keys()代替。 属性的遍历ES6 一共有 5 种方法可以遍历对象的属性。 （1）for…in for...in循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。 （2）Object.keys(obj) Object.keys返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。 （3）Object.getOwnPropertyNames(obj) Object.getOwnPropertyNames返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。 （4）Object.getOwnPropertySymbols(obj) Object.getOwnPropertySymbols返回一个数组，包含对象自身的所有 Symbol 属性的键名。 （5）Reflect.ownKeys(obj) Reflect.ownKeys返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。 以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。 首先遍历所有数值键，按照数值升序排列。 其次遍历所有字符串键，按照加入时间升序排列。 最后遍历所有 Symbol 键，按照加入时间升序排列。12Reflect.ownKeys(&#123; [Symbol()]:0, b:0, 10:0, 2:0, a:0 &#125;)// ['2', '10', 'b', 'a', Symbol()] 上面代码中，Reflect.ownKeys方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性2和10，其次是字符串属性b和a，最后是 Symbol 属性。 Object.getOwnPropertyDescriptors()前面说过，Object.getOwnPropertyDescriptor方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了Object.getOwnPropertyDescriptors方法，返回指定对象所有自身属性（非继承属性）的描述对象。12345678910111213141516const obj = &#123; foo: 123, get bar() &#123; return 'abc' &#125;&#125;;Object.getOwnPropertyDescriptors(obj)// &#123; foo:// &#123; value: 123,// writable: true,// enumerable: true,// configurable: true &#125;,// bar:// &#123; get: [Function: get bar],// set: undefined,// enumerable: true,// configurable: true &#125; &#125; 上面代码中，Object.getOwnPropertyDescriptors方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。 该方法的实现非常容易。1234567function getOwnPropertyDescriptors(obj) &#123; const result = &#123;&#125;; for (let key of Reflect.ownKeys(obj)) &#123; result[key] = Object.getOwnPropertyDescriptor(obj, key); &#125; return result;&#125; 该方法的引入目的，主要是为了解决Object.assign()无法正确拷贝get属性和set属性的问题。1234567891011121314const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target1 = &#123;&#125;;Object.assign(target1, source);Object.getOwnPropertyDescriptor(target1, 'foo')// &#123; value: undefined,// writable: true,// enumerable: true,// configurable: true &#125; 上面代码中，source对象的foo属性的值是一个赋值函数，Object.assign方法将这个属性拷贝给target1对象，结果该属性的值变成了undefined。这是因为Object.assign方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。 这时，Object.getOwnPropertyDescriptors方法配合Object.defineProperties方法，就可以实现正确拷贝。12345678910111213const source = &#123; set foo(value) &#123; console.log(value); &#125;&#125;;const target2 = &#123;&#125;;Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));Object.getOwnPropertyDescriptor(target2, 'foo')// &#123; get: undefined,// set: [Function: set foo],// enumerable: true,// configurable: true &#125; 上面代码中，两个对象合并的逻辑可以写成一个函数。1234const shallowMerge = (target, source) =&gt; Object.defineProperties( target, Object.getOwnPropertyDescriptors(source)); Object.getOwnPropertyDescriptors方法的另一个用处，是配合Object.create方法，将对象属性克隆到一个新对象。这属于浅拷贝。123456789const clone = Object.create(Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj));// 或者const shallowClone = (obj) =&gt; Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)); 上面代码会克隆对象obj。 另外，Object.getOwnPropertyDescriptors方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。1234const obj = &#123; __proto__: prot, foo: 123,&#125;; ES6 规定__proto__只有浏览器要部署，其他环境不用部署。如果去除__proto__，上面代码就要改成下面这样。1234567891011const obj = Object.create(prot);obj.foo = 123;// 或者const obj = Object.assign( Object.create(prot), &#123; foo: 123, &#125;); 有了Object.getOwnPropertyDescriptors，我们就有了另一种写法。123456const obj = Object.create( prot, Object.getOwnPropertyDescriptors(&#123; foo: 123, &#125;)); Object.getOwnPropertyDescriptors也可以用来实现 Mixin（混入）模式。12345678910111213141516let mix = (object) =&gt; (&#123; with: (...mixins) =&gt; mixins.reduce( (c, mixin) =&gt; Object.create( c, Object.getOwnPropertyDescriptors(mixin) ), object)&#125;);// multiple mixins examplelet a = &#123;a: 'a'&#125;;let b = &#123;b: 'b'&#125;;let c = &#123;c: 'c'&#125;;let d = mix(c).with(a, b);d.c // "c"d.b // "b"d.a // "a" 上面代码返回一个新的对象d，代表了对象a和b被混入了对象c的操作。 出于完整性的考虑，Object.getOwnPropertyDescriptors进入标准以后，以后还会新增Reflect.getOwnPropertyDescriptors方法。 __proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。 __proto__属性__proto__属性（前后各两个下划线），用来读取或设置当前对象的prototype对象。目前，所有浏览器（包括 IE11）都部署了这个属性。123456789// es5 的写法const obj = &#123; method: function() &#123; ... &#125;&#125;;obj.__proto__ = someOtherObj;// es6 的写法var obj = Object.create(someOtherObj);obj.method = function() &#123; ... &#125;; 该属性没有写入 ES6 的正文，而是写入了附录，原因是__proto__前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的Object.setPrototypeOf()（写操作）、Object.getPrototypeOf()（读操作）、Object.create()（生成操作）代替。 实现上，__proto__调用的是Object.prototype.__proto__，具体实现如下。12345678910111213141516171819202122232425Object.defineProperty(Object.prototype, '__proto__', &#123; get() &#123; let _thisObj = Object(this); return Object.getPrototypeOf(_thisObj); &#125;, set(proto) &#123; if (this === undefined || this === null) &#123; throw new TypeError(); &#125; if (!isObject(this)) &#123; return undefined; &#125; if (!isObject(proto)) &#123; return undefined; &#125; let status = Reflect.setPrototypeOf(this, proto); if (!status) &#123; throw new TypeError(); &#125; &#125;,&#125;);function isObject(value) &#123; return Object(value) === value;&#125; 如果一个对象本身部署了__proto__属性，该属性的值就是对象的原型。12Object.getPrototypeOf(&#123; __proto__: null &#125;)// null Object.setPrototypeOf()Object.setPrototypeOf方法的作用与__proto__相同，用来设置一个对象的prototype对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。12345// 格式Object.setPrototypeOf(object, prototype)// 用法const o = Object.setPrototypeOf(&#123;&#125;, null); 该方法等同于下面的函数。1234function (obj, proto) &#123; obj.__proto__ = proto; return obj;&#125; 下面是一个例子。12345678910let proto = &#123;&#125;;let obj = &#123; x: 10 &#125;;Object.setPrototypeOf(obj, proto);proto.y = 20;proto.z = 40;obj.x // 10obj.y // 20obj.z // 40 上面代码将proto对象设为obj对象的原型，所以从obj对象可以读取proto对象的属性。 如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。123Object.setPrototypeOf(1, &#123;&#125;) === 1 // trueObject.setPrototypeOf('foo', &#123;&#125;) === 'foo' // trueObject.setPrototypeOf(true, &#123;&#125;) === true // true 由于undefined和null无法转为对象，所以如果第一个参数是undefined或null，就会报错。12345Object.setPrototypeOf(undefined, &#123;&#125;)// TypeError: Object.setPrototypeOf called on null or undefinedObject.setPrototypeOf(null, &#123;&#125;)// TypeError: Object.setPrototypeOf called on null or undefined Object.getPrototypeOf()该方法与Object.setPrototypeOf方法配套，用于读取一个对象的原型对象。1Object.getPrototypeOf(obj); 下面是一个例子。123456789101112function Rectangle() &#123; // ...&#125;const rec = new Rectangle();Object.getPrototypeOf(rec) === Rectangle.prototype// trueObject.setPrototypeOf(rec, Object.prototype);Object.getPrototypeOf(rec) === Rectangle.prototype// false 如果参数不是对象，会被自动转为对象。123456789101112131415// 等同于 Object.getPrototypeOf(Number(1))Object.getPrototypeOf(1)// Number &#123;[[PrimitiveValue]]: 0&#125;// 等同于 Object.getPrototypeOf(String('foo'))Object.getPrototypeOf('foo')// String &#123;length: 0, [[PrimitiveValue]]: ""&#125;// 等同于 Object.getPrototypeOf(Boolean(true))Object.getPrototypeOf(true)// Boolean &#123;[[PrimitiveValue]]: false&#125;Object.getPrototypeOf(1) === Number.prototype // trueObject.getPrototypeOf('foo') === String.prototype // trueObject.getPrototypeOf(true) === Boolean.prototype // true 如果参数是undefined或null，它们无法转为对象，所以会报错。12345Object.getPrototypeOf(null)// TypeError: Cannot convert undefined or null to objectObject.getPrototypeOf(undefined)// TypeError: Cannot convert undefined or null to object super 关键字我们知道，this关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字super，指向当前对象的原型对象。12345678910111213const proto = &#123; foo: 'hello'&#125;;const obj = &#123; foo: 'world', find() &#123; return super.foo; &#125;&#125;;Object.setPrototypeOf(obj, proto);obj.find() // "hello" 上面代码中，对象obj的find方法之中，通过super.foo引用了原型对象proto的foo属性。 注意，super关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。12345678910111213141516// 报错const obj = &#123; foo: super.foo&#125;// 报错const obj = &#123; foo: () =&gt; super.foo&#125;// 报错const obj = &#123; foo: function () &#123; return super.foo &#125;&#125; 上面三种super的用法都会报错，因为对于 JavaScript 引擎来说，这里的super都没有用在对象的方法之中。第一种写法是super用在属性里面，第二种和第三种写法是super用在一个函数里面，然后赋值给foo属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。 JavaScript 引擎内部，super.foo等同于Object.getPrototypeOf(this).foo（属性）或Object.getPrototypeOf(this).foo.call(this)（方法）。1234567891011121314151617const proto = &#123; x: 'hello', foo() &#123; console.log(this.x); &#125;,&#125;;const obj = &#123; x: 'world', foo() &#123; super.foo(); &#125;&#125;Object.setPrototypeOf(obj, proto);obj.foo() // "world" 上面代码中，super.foo指向原型对象proto的foo方法，但是绑定的this却还是当前对象obj，因此输出的就是world。 Object.keys()，Object.values()，Object.entries()Object.keys()ES5 引入了Object.keys方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。123var obj = &#123; foo: 'bar', baz: 42 &#125;;Object.keys(obj)// ["foo", "baz"] ES2017 引入了跟Object.keys配套的Object.values和Object.entries，作为遍历一个对象的补充手段，供for...of循环使用。1234567891011121314let &#123;keys, values, entries&#125; = Object;let obj = &#123; a: 1, b: 2, c: 3 &#125;;for (let key of keys(obj)) &#123; console.log(key); // 'a', 'b', 'c'&#125;for (let value of values(obj)) &#123; console.log(value); // 1, 2, 3&#125;for (let [key, value] of entries(obj)) &#123; console.log([key, value]); // ['a', 1], ['b', 2], ['c', 3]&#125; Object.values()Object.values方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。123const obj = &#123; foo: 'bar', baz: 42 &#125;;Object.values(obj)// ["bar", 42] 返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。123const obj = &#123; 100: 'a', 2: 'b', 7: 'c' &#125;;Object.values(obj)// ["b", "c", "a"] 上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是b、c、a。 Object.values只返回对象自身的可遍历属性。12const obj = Object.create(&#123;&#125;, &#123;p: &#123;value: 42&#125;&#125;);Object.values(obj) // [] 上面代码中，Object.create方法的第二个参数添加的对象属性（属性p），如果不显式声明，默认是不可遍历的，因为p的属性描述对象的enumerable默认是false，Object.values不会返回这个属性。只要把enumerable改成true，Object.values就会返回属性p的值。1234567const obj = Object.create(&#123;&#125;, &#123;p: &#123; value: 42, enumerable: true &#125;&#125;);Object.values(obj) // [42] Object.values会过滤属性名为 Symbol 值的属性。12Object.values(&#123; [Symbol()]: 123, foo: 'abc' &#125;);// ['abc'] 如果Object.values方法的参数是一个字符串，会返回各个字符组成的一个数组。12Object.values('foo')// ['f', 'o', 'o'] 上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，Object.values返回每个属性的键值，就是各个字符组成的一个数组。 如果参数不是对象，Object.values会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，Object.values会返回空数组。12Object.values(42) // []Object.values(true) // [] Object.entriesObject.entries方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。123const obj = &#123; foo: 'bar', baz: 42 &#125;;Object.entries(obj)// [ ["foo", "bar"], ["baz", 42] ] 除了返回值不一样，该方法的行为与Object.values基本一致。 如果原对象的属性名是一个 Symbol 值，该属性会被忽略。12Object.entries(&#123; [Symbol()]: 123, foo: 'abc' &#125;);// [ [ 'foo', 'abc' ] ] 上面代码中，原对象有两个属性，Object.entries只输出属性名非 Symbol 值的属性。将来可能会有Reflect.ownEntries()方法，返回对象自身的所有属性。 Object.entries的基本用途是遍历对象的属性。12345678let obj = &#123; one: 1, two: 2 &#125;;for (let [k, v] of Object.entries(obj)) &#123; console.log( `$&#123;JSON.stringify(k)&#125;: $&#123;JSON.stringify(v)&#125;` );&#125;// "one": 1// "two": 2 Object.entries方法的另一个用处是，将对象转为真正的Map结构。123const obj = &#123; foo: 'bar', baz: 42 &#125;;const map = new Map(Object.entries(obj));map // Map &#123; foo: "bar", baz: 42 &#125; 自己实现Object.entries方法，非常简单。123456789101112131415// Generator函数的版本function* entries(obj) &#123; for (let key of Object.keys(obj)) &#123; yield [key, obj[key]]; &#125;&#125;// 非Generator函数的版本function entries(obj) &#123; let arr = []; for (let key of Object.keys(obj)) &#123; arr.push([key, obj[key]]); &#125; return arr;&#125; 对象的扩展运算符《数组的扩展》一章中，已经介绍过扩展运算符（...）。123const [a, ...b] = [1, 2, 3];a // 1b // [2, 3] ES2018 将这个运算符引入了对象。 解构赋值对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。1234let &#123; x, y, ...z &#125; = &#123; x: 1, y: 2, a: 3, b: 4 &#125;;x // 1y // 2z // &#123; a: 3, b: 4 &#125; 上面代码中，变量z是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（a和b），将它们连同值一起拷贝过来。 由于解构赋值要求等号右边是一个对象，所以如果等号右边是undefined或null，就会报错，因为它们无法转为对象。12let &#123; x, y, ...z &#125; = null; // 运行时错误let &#123; x, y, ...z &#125; = undefined; // 运行时错误 解构赋值必须是最后一个参数，否则会报错。12let &#123; ...x, y, z &#125; = obj; // 句法错误let &#123; x, ...y, ...z &#125; = obj; // 句法错误 上面代码中，解构赋值不是最后一个参数，所以会报错。 注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。1234let obj = &#123; a: &#123; b: 1 &#125; &#125;;let &#123; ...x &#125; = obj;obj.a.b = 2;x.a.b // 2 上面代码中，x是解构赋值所在的对象，拷贝了对象obj的a属性。a属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。 另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。123456let o1 = &#123; a: 1 &#125;;let o2 = &#123; b: 2 &#125;;o2.__proto__ = o1;let &#123; ...o3 &#125; = o2;o3 // &#123; b: 2 &#125;o3.a // undefined 上面代码中，对象o3复制了o2，但是只复制了o2自身的属性，没有复制它的原型对象o1的属性。 下面是另一个例子。1234567const o = Object.create(&#123; x: 1, y: 2 &#125;);o.z = 3; let &#123; x, ...newObj &#125; = o;let &#123; y, z &#125; = newObj;x // 1y // undefinedz // 3 上面代码中，变量x是单纯的解构赋值，所以可以读取对象o继承的属性；变量y和z是扩展运算符的解构赋值，只能读取对象o自身的属性，所以变量z可以赋值成功，变量y取不到值。ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量newObj，如果写成下面这样会报错。12let &#123; x, ...&#123; y, z &#125; &#125; = o;// SyntaxError: ... must be followed by an identifier in declaration contexts 解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。12345678function baseFunction(&#123; a, b &#125;) &#123; // ...&#125;function wrapperFunction(&#123; x, y, ...restConfig &#125;) &#123; // 使用 x 和 y 参数进行操作 // 其余参数传给原始函数 return baseFunction(restConfig);&#125; 上面代码中，原始函数baseFunction接受a和b作为参数，函数wrapperFunction在baseFunction的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。 扩展运算符对象的扩展运算符（...）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。123let z = &#123; a: 3, b: 4 &#125;;let n = &#123; ...z &#125;;n // &#123; a: 3, b: 4 &#125; 这等同于使用Object.assign方法。123let aClone = &#123; ...a &#125;;// 等同于let aClone = Object.assign(&#123;&#125;, a); 上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。1234567891011121314151617// 写法一const clone1 = &#123; __proto__: Object.getPrototypeOf(obj), ...obj&#125;;// 写法二const clone2 = Object.assign( Object.create(Object.getPrototypeOf(obj)), obj);// 写法三const clone3 = Object.create( Object.getPrototypeOf(obj), Object.getOwnPropertyDescriptors(obj)) 上面代码中，写法一的__proto__属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。 扩展运算符可以用于合并两个对象。123let ab = &#123; ...a, ...b &#125;;// 等同于let ab = Object.assign(&#123;&#125;, a, b); 如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。1234567let aWithOverrides = &#123; ...a, x: 1, y: 2 &#125;;// 等同于let aWithOverrides = &#123; ...a, ...&#123; x: 1, y: 2 &#125; &#125;;// 等同于let x = 1, y = 2, aWithOverrides = &#123; ...a, x, y &#125;;// 等同于let aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: 1, y: 2 &#125;); 上面代码中，a对象的x属性和y属性，拷贝到新对象后会被覆盖掉。 这用来修改现有对象部分的属性就很方便了。1234let newVersion = &#123; ...previousVersion, name: 'New Name' // Override the name property&#125;; 上面代码中，newVersion对象自定义了name属性，其他属性全部复制自previousVersion对象。 如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。12345let aWithDefaults = &#123; x: 1, y: 2, ...a &#125;;// 等同于let aWithDefaults = Object.assign(&#123;&#125;, &#123; x: 1, y: 2 &#125;, a);// 等同于let aWithDefaults = Object.assign(&#123; x: 1, y: 2 &#125;, a); 与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。1234const obj = &#123; ...(x &gt; 1 ? &#123;a: 1&#125; : &#123;&#125;), b: 2,&#125;; 如果扩展运算符后面是一个空对象，则没有任何效果。12&#123;...&#123;&#125;, a: 1&#125;// &#123; a: 1 &#125; 如果扩展运算符的参数是null或undefined，这两个值会被忽略，不会报错。1let emptyObject = &#123; ...null, ...undefined &#125;; // 不报错 扩展运算符的参数对象之中，如果有取值函数get，这个函数是会执行的。1234567891011121314151617// 并不会抛出错误，因为 x 属性只是被定义，但没执行let aWithXGetter = &#123; ...a, get x() &#123; throw new Error('not throw yet'); &#125;&#125;;// 会抛出错误，因为 x 属性被执行了let runtimeError = &#123; ...a, ...&#123; get x() &#123; throw new Error('throw now'); &#125; &#125;&#125;;]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 -- 08.数组的扩展]]></title>
    <url>%2F2018%2F06%2F15%2FES6%2F08.%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[数组的扩展1.扩展运算符含义扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。 12345678console.log(...[1, 2, 3])// 1 2 3console.log(1, ...[2, 3, 4], 5)// 1 2 3 4 5[...document.querySelectorAll('div')]// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;] 该运算符主要用于函数调用。 12345678910function push(array, ...items) &#123; array.push(...items);&#125;function add(x, y) &#123; return x + y;&#125;const numbers = [4, 38];add(...numbers) // 42 上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。 扩展运算符与正常的函数参数可以结合使用，非常灵活。 123function f(v, w, x, y, z) &#123; &#125;const args = [0, 1];f(-1, ...args, 2, ...[3]); 扩展运算符后面还可以放置表达式。 1234const arr = [ ...(x &gt; 0 ? ['a'] : []), 'b',]; 如果扩展运算符后面是一个空数组，则不产生任何效果。 12[...[], 1]// [1] 替代函数的 apply 方法由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。 12345678910111213// ES5 的写法function f(x, y, z) &#123; // ...&#125;var args = [0, 1, 2];f.apply(null, args);// ES6的写法function f(x, y, z) &#123; // ...&#125;let args = [0, 1, 2];f(...args); 下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。 12345678// ES5 的写法Math.max.apply(null, [14, 3, 77])// ES6 的写法Math.max(...[14, 3, 77])// 等同于Math.max(14, 3, 77); 上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。 另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。 123456789// ES5的 写法var arr1 = [0, 1, 2];var arr2 = [3, 4, 5];Array.prototype.push.apply(arr1, arr2);// ES6 的写法let arr1 = [0, 1, 2];let arr2 = [3, 4, 5];arr1.push(...arr2); 上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。 下面是另外一个例子。 1234// ES5new (Date.bind.apply(Date, [null, 2015, 1, 1]))// ES6new Date(...[2015, 1, 1]); 扩展运算符的应用（1）复制数组 数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。 12345const a1 = [1, 2];const a2 = a1;a2[0] = 2;a1 // [2, 2] 上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。 ES5 只能用变通方法来复制数组。 12345const a1 = [1, 2];const a2 = a1.concat();a2[0] = 2;a1 // [1, 2] 上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。 扩展运算符提供了复制数组的简便写法。 12345const a1 = [1, 2];// 写法一const a2 = [...a1];// 写法二const [...a2] = a1; 上面的两种写法，a2都是a1的克隆。 （2）合并数组 扩展运算符提供了数组合并的新写法。 1234567891011const arr1 = ['a', 'b'];const arr2 = ['c'];const arr3 = ['d', 'e'];// ES5 的合并数组arr1.concat(arr2, arr3);// [ 'a', 'b', 'c', 'd', 'e' ]// ES6 的合并数组[...arr1, ...arr2, ...arr3]// [ 'a', 'b', 'c', 'd', 'e' ] 不过，这两种方法都是浅拷贝，使用的时候需要注意。 12345678const a1 = [&#123; foo: 1 &#125;];const a2 = [&#123; bar: 2 &#125;];const a3 = a1.concat(a2);const a4 = [...a1, ...a2];a3[0] === a1[0] // truea4[0] === a1[0] // true 上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。 （3）与解构赋值结合 扩展运算符可以与解构赋值结合起来，用于生成数组。 1234// ES5a = list[0], rest = list.slice(1)// ES6[a, ...rest] = list 下面是另外一些例子。 1234567891011const [first, ...rest] = [1, 2, 3, 4, 5];first // 1rest // [2, 3, 4, 5]const [first, ...rest] = [];first // undefinedrest // []const [first, ...rest] = ["foo"];first // "foo"rest // [] 如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。 12345const [...butLast, last] = [1, 2, 3, 4, 5];// 报错const [first, ...middle, last] = [1, 2, 3, 4, 5];// 报错 （4）字符串 扩展运算符还可以将字符串转为真正的数组。 12[...'hello']// [ "h", "e", "l", "l", "o" ] 上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。 12'x\uD83D\uDE80y'.length // 4[...'x\uD83D\uDE80y'].length // 3 上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。 12345function length(str) &#123; return [...str].length;&#125;length('x\uD83D\uDE80y') // 3 凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。 let str = ‘x\uD83D\uDE80y’; 12345str.split('').reverse().join('')// 'y\uDE80\uD83Dx'[...str].reverse().join('')// 'y\uD83D\uDE80x' 上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。 （5）实现了 Iterator 接口的对象 任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。 12let nodeList = document.querySelectorAll('div');let array = [...nodeList]; 上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。 对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。 123456789let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// TypeError: Cannot spread non-iterable object.let arr = [...arrayLike]; 上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。 （6）Map 和 Set 结构，Generator 函数 扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。 1234567let map = new Map([ [1, 'one'], [2, 'two'], [3, 'three'],]);let arr = [...map.keys()]; // [1, 2, 3] Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。 1234567const go = function*()&#123; yield 1; yield 2; yield 3;&#125;;[...go()] // [1, 2, 3] 上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。 如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。 12const obj = &#123;a: 1, b: 2&#125;;let arr = [...obj]; // TypeError: Cannot spread non-iterable object 2.Array.from()Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。 下面是一个类似数组的对象，Array.from将它转为真正的数组。 123456789101112let arrayLike = &#123; '0': 'a', '1': 'b', '2': 'c', length: 3&#125;;// ES5的写法var arr1 = [].slice.call(arrayLike); // ['a', 'b', 'c']// ES6的写法let arr2 = Array.from(arrayLike); // ['a', 'b', 'c'] 实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。 1234567891011// NodeList对象let ps = document.querySelectorAll('p');Array.from(ps).filter(p =&gt; &#123; return p.textContent.length &gt; 100;&#125;);// arguments对象function foo() &#123; var args = Array.from(arguments); // ...&#125; 上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用filter方法。 只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。 12345Array.from('hello')// ['h', 'e', 'l', 'l', 'o']let namesSet = new Set(['a', 'b'])Array.from(namesSet) // ['a', 'b'] 上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。 如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。 12Array.from([1, 2, 3])// [1, 2, 3] 值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。 1234567// arguments对象function foo() &#123; const args = [...arguments];&#125;// NodeList对象[...document.querySelectorAll('div')] 扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。 12Array.from(&#123; length: 3 &#125;);// [ undefined, undefined, undefined ] 上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。 对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。 123const toArray = (() =&gt; Array.from ? Array.from : obj =&gt; [].slice.call(obj))(); Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。 123456Array.from(arrayLike, x =&gt; x * x);// 等同于Array.from(arrayLike).map(x =&gt; x * x);Array.from([1, 2, 3], (x) =&gt; x * x)// [1, 4, 9] 下面的例子是取出一组 DOM 节点的文本内容。 1234567let spans = document.querySelectorAll('span.name');// map()let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);// Array.from()let names2 = Array.from(spans, s =&gt; s.textContent) 下面的例子将数组中布尔值为false的成员转为0。 12Array.from([1, , 2, , 3], (n) =&gt; n || 0)// [1, 0, 2, 0, 3] 另一个例子是返回各种数据的类型。 12345function typesOf () &#123; return Array.from(arguments, value =&gt; typeof value)&#125;typesOf(null, [], NaN)// ['object', 'object', 'number'] 如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。 Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。 12Array.from(&#123; length: 2 &#125;, () =&gt; 'jack')// ['jack', 'jack'] 上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。 Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。 123function countSymbols(string) &#123; return Array.from(string).length;&#125; 3.Array.of()Array.of方法用于将一组值，转换为数组。 123Array.of(3, 11, 8) // [3,11,8]Array.of(3) // [3]Array.of(3).length // 1 这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。 123Array() // []Array(3) // [, , ,]Array(3, 11, 8) // [3, 11, 8] 上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。 Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。 1234Array.of() // []Array.of(undefined) // [undefined]Array.of(1) // [1]Array.of(1, 2) // [1, 2] Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。 Array.of方法可以用下面的代码模拟实现。 123function ArrayOf()&#123; return [].slice.call(arguments);&#125; 4.数组实例的 copyWithin()数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。 1Array.prototype.copyWithin(target, start = 0, end = this.length) 它接受三个参数。 target（必需）：从该位置开始替换数据。如果为负值，表示倒数。 start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。 end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。这三个参数都应该是数值，如果不是，会自动转为数值。 12[1, 2, 3, 4, 5].copyWithin(0, 3)// [4, 5, 3, 4, 5] 上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。 下面是更多例子。 123456789101112131415161718192021// 将3号位复制到0号位[1, 2, 3, 4, 5].copyWithin(0, 3, 4)// [4, 2, 3, 4, 5]// -2相当于3号位，-1相当于4号位[1, 2, 3, 4, 5].copyWithin(0, -2, -1)// [4, 2, 3, 4, 5]// 将3号位复制到0号位[].copyWithin.call(&#123;length: 5, 3: 1&#125;, 0, 3)// &#123;0: 1, 3: 1, length: 5&#125;// 将2号位到数组结束，复制到0号位let i32a = new Int32Array([1, 2, 3, 4, 5]);i32a.copyWithin(0, 2);// Int32Array [3, 4, 5, 4, 5]// 对于没有部署 TypedArray 的 copyWithin 方法的平台// 需要采用下面的写法[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);// Int32Array [4, 2, 3, 4, 5] 5.数组实例的 find() 和 findIndex()数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。 12[1, 4, -5, 10].find((n) =&gt; n &lt; 0)// -5 上面代码找出数组中第一个小于 0 的成员。 123[1, 5, 10, 15].find(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 10 上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。 数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。 123[1, 5, 10, 15].findIndex(function(value, index, arr) &#123; return value &gt; 9;&#125;) // 2 这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。 12345function f(v)&#123; return v &gt; this.age;&#125;let person = &#123;name: 'John', age: 20&#125;;[10, 12, 26, 15].find(f, person); // 26 上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。 另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。 12345[NaN].indexOf(NaN)// -1[NaN].findIndex(y =&gt; Object.is(NaN, y))// 0 上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。 6.数组实例的 fill()fill方法使用给定值，填充一个数组。 12345['a', 'b', 'c'].fill(7)// [7, 7, 7]new Array(3).fill(7)// [7, 7, 7] 上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。 fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。 12['a', 'b', 'c'].fill(7, 1, 2)// ['a', 7, 'c'] 上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。 注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。 123456789let arr = new Array(3).fill(&#123;name: "Mike"&#125;);arr[0].name = "Ben";arr// [&#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;, &#123;name: "Ben"&#125;]let arr = new Array(3).fill([]);arr[0].push(5);arr// [[5], [5], [5]] 7.数组实例的 entries()，keys() 和 values()ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。 1234567891011121314151617for (let index of ['a', 'b'].keys()) &#123; console.log(index);&#125;// 0// 1for (let elem of ['a', 'b'].values()) &#123; console.log(elem);&#125;// 'a'// 'b'for (let [index, elem] of ['a', 'b'].entries()) &#123; console.log(index, elem);&#125;// 0 "a"// 1 "b" 如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。 12345let letter = ['a', 'b', 'c'];let entries = letter.entries();console.log(entries.next().value); // [0, 'a']console.log(entries.next().value); // [1, 'b']console.log(entries.next().value); // [2, 'c'] 8.数组实例的 includes()Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。 123[1, 2, 3].includes(2) // true[1, 2, 3].includes(4) // false[1, 2, NaN].includes(NaN) // true 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。 12[1, 2, 3].includes(3, 3); // false[1, 2, 3].includes(3, -1); // true 没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。 123if (arr.indexOf(el) !== -1) &#123; // ...&#125; indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。 12[NaN].indexOf(NaN)// -1 includes使用的是不一样的判断算法，就没有这个问题。 12[NaN].includes(NaN)// true 下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。 123456const contains = (() =&gt; Array.prototype.includes ? (arr, value) =&gt; arr.includes(value) : (arr, value) =&gt; arr.some(el =&gt; el === value))();contains(['foo', 'bar'], 'baz'); // =&gt; false 另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。 Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。 Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。 9.数组的空位数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。 1Array(3) // [, , ,] 上面代码中，Array(3)返回一个具有 3 个空位的数组。 注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。 120 in [undefined, undefined, undefined] // true0 in [, , ,] // false 上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。 ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。 forEach(), filter(), reduce(), every() 和some()都会跳过空位。 map()会跳过空位，但会保留这个值 join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。 1234567891011121314151617181920212223// forEach方法[,'a'].forEach((x,i) =&gt; console.log(i)); // 1// filter方法['a',,'b'].filter(x =&gt; true) // ['a','b']// every方法[,'a'].every(x =&gt; x==='a') // true// reduce方法[1,,2].reduce((x,y) =&gt; return x+y) // 3// some方法[,'a'].some(x =&gt; x !== 'a') // false// map方法[,'a'].map(x =&gt; 1) // [,1]// join方法[,'a',undefined,null].join('#') // "#a##"// toString方法[,'a',undefined,null].toString() // ",a,," ES6 则是明确将空位转为undefined。 Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。 12Array.from(['a',,'b'])// [ "a", undefined, "b" ] 扩展运算符（…）也会将空位转为undefined。 12[...['a',,'b']]// [ "a", undefined, "b" ] copyWithin()会连空位一起拷贝。 1[,'a','b',,].copyWithin(2,0) // [,"a",,"a"] fill()会将空位视为正常的数组位置。 1new Array(3).fill('a') // ["a","a","a"] for…of循环也会遍历空位。 123456let arr = [, ,];for (let i of arr) &#123; console.log(1);&#125;// 1// 1 上面代码中，数组arr有两个空位，for…of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。 entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。 1234567891011121314// entries()[...[,'a'].entries()] // [[0,undefined], [1,"a"]]// keys()[...[,'a'].keys()] // [0,1]// values()[...[,'a'].values()] // [undefined,"a"]// find()[,'a'].find(x =&gt; true) // undefined// findIndex()[,'a'].findIndex(x =&gt; true) // 0 由于空位的处理规则非常不统一，所以建议避免出现空位。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 -- 07.函数的扩展]]></title>
    <url>%2F2018%2F06%2F15%2FES6%2F07.%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[函数的扩展1.函数的扩展基本用法ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。 12345678function log(x, y) &#123; y = y || 'World'; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello World 上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。 为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。 123if (typeof y === 'undefined') &#123; y = 'World';&#125; ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。 1234567function log(x, y = 'World') &#123; console.log(x, y);&#125;log('Hello') // Hello Worldlog('Hello', 'China') // Hello Chinalog('Hello', '') // Hello 可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。 1234567function Point(x = 0, y = 0) &#123; this.x = x; this.y = y;&#125;const p = new Point();p // &#123; x: 0, y: 0 &#125; 除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。 参数变量是默认声明的，所以不能用let或const再次声明。 1234function foo(x = 5) &#123; let x = 1; // error const x = 2; // error&#125; 上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。 使用参数默认值时，函数不能有同名参数。 12345678910111213// 不报错function foo(x, x, y) &#123; // ...&#125;// 报错function foo(x, x, y = 1) &#123; // ...&#125;// SyntaxError: Duplicate parameter name not allowed in this context// 不报错function foo(x, x, y) &#123; // ...&#125; 另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。 123456789let x = 99;function foo(p = x + 1) &#123; console.log(p);&#125;foo() // 100x = 100;foo() // 101 上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。 与解构赋值默认值结合使用参数默认值可以与解构赋值的默认值，结合起来使用。 12345678function foo(&#123;x, y = 5&#125;) &#123; console.log(x, y);&#125;foo(&#123;&#125;) // undefined 5foo(&#123;x: 1&#125;) // 1 5foo(&#123;x: 1, y: 2&#125;) // 1 2foo() // TypeError: Cannot read property 'x' of undefined 上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。 12345function foo(&#123;x, y = 5&#125; = &#123;&#125;) &#123; console.log(x, y);&#125;foo() // undefined 5 上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。 下面是另一个解构赋值默认值的例子。 123456789function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125;) &#123; console.log(method);&#125;fetch('http://example.com', &#123;&#125;)// "GET"fetch('http://example.com')// 报错 上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。 123456function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125; = &#123;&#125;) &#123; console.log(method);&#125;fetch('http://example.com')// "GET" 上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。 作为练习，请问下面两种写法有什么差别？ 123456789// 写法一function m1(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;// 写法二function m2(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125; 上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。 123456789101112131415161718// 函数没有参数的情况m1() // [0, 0]m2() // [0, 0]// x 和 y 都有值的情况m1(&#123;x: 3, y: 8&#125;) // [3, 8]m2(&#123;x: 3, y: 8&#125;) // [3, 8]// x 有值，y 无值的情况m1(&#123;x: 3&#125;) // [3, 0]m2(&#123;x: 3&#125;) // [3, undefined]// x 和 y 都无值的情况m1(&#123;&#125;) // [0, 0];m2(&#123;&#125;) // [undefined, undefined]m1(&#123;z: 3&#125;) // [0, 0]m2(&#123;z: 3&#125;) // [undefined, undefined] 参数默认值的位置通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。 12345678910111213141516171819// 例一function f(x = 1, y) &#123; return [x, y];&#125;f() // [1, undefined]f(2) // [2, undefined])f(, 1) // 报错f(undefined, 1) // [1, 1]// 例二function f(x, y = 5, z) &#123; return [x, y, z];&#125;f() // [undefined, 5, undefined]f(1) // [1, 5, undefined]f(1, ,2) // 报错f(1, undefined, 2) // [1, 5, 2] 上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。 如果传入undefined，将触发该参数等于默认值，null则没有这个效果。 12345function foo(x = 5, y = 6) &#123; console.log(x, y);&#125;foo(undefined, null) 上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。 函数的 length 属性指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。 123(function (a) &#123;&#125;).length // 1(function (a = 5) &#123;&#125;).length // 0(function (a, b, c = 5) &#123;&#125;).length // 2 上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。 这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。 1(function(...args) &#123;&#125;).length // 0 如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。 12(function (a = 0, b, c) &#123;&#125;).length // 0(function (a, b = 1, c) &#123;&#125;).length // 1 作用域一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。 1234567var x = 1;function f(x, y = x) &#123; console.log(y);&#125;f(2) // 2 上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。 再看下面的例子。 12345678let x = 1;function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // 1 上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。 如果此时，全局变量x不存在，就会报错。 123456function f(y = x) &#123; let x = 2; console.log(y);&#125;f() // ReferenceError: x is not defined 下面这样写，也会报错。 1234567var x = 1;function foo(x = x) &#123; // ...&#125;foo() // ReferenceError: x is not defined 上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。 如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。 12345678let foo = 'outer';function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar(); // outer 上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。 如果写成下面这样，就会报错。 123456function bar(func = () =&gt; foo) &#123; let foo = 'inner'; console.log(func());&#125;bar() // ReferenceError: foo is not defined 上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。 下面是一个更复杂的例子。 123456789var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; var x = 3; y(); console.log(x);&#125;foo() // 3x // 1 上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。 如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。 123456789var x = 1;function foo(x, y = function() &#123; x = 2; &#125;) &#123; x = 3; y(); console.log(x);&#125;foo() // 2x // 1 应用利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。 12345678910function throwIfMissing() &#123; throw new Error('Missing parameter');&#125;function foo(mustBeProvided = throwIfMissing()) &#123; return mustBeProvided;&#125;foo()// Error: Missing parameter 上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。 从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。 另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。 1function foo(optional = undefined) &#123; ··· &#125; 2.rest 参数ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。 1234567891011function add(...values) &#123; let sum = 0; for (var val of values) &#123; sum += val; &#125; return sum;&#125;add(2, 5, 3) // 10 上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。 下面是一个 rest 参数代替arguments变量的例子。 1234567// arguments变量的写法function sortNumbers() &#123; return Array.prototype.slice.call(arguments).sort();&#125;// rest参数的写法const sortNumbers = (...numbers) =&gt; numbers.sort(); 上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。 arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。 123456789function push(array, ...items) &#123; items.forEach(function(item) &#123; array.push(item); console.log(item); &#125;);&#125;var a = [];push(a, 1, 2, 3) 注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。 1234// 报错function f(a, ...b, c) &#123; // ...&#125; 函数的length属性，不包括 rest 参数。 123(function(a) &#123;&#125;).length // 1(function(...a) &#123;&#125;).length // 0(function(a, ...b) &#123;&#125;).length // 1 3.严格模式从 ES5 开始，函数内部可以设定为严格模式。 1234function doSomething(a, b) &#123; 'use strict'; // code&#125; ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。 12345678910111213141516171819202122232425// 报错function doSomething(a, b = a) &#123; 'use strict'; // code&#125;// 报错const doSomething = function (&#123;a, b&#125;) &#123; 'use strict'; // code&#125;;// 报错const doSomething = (...a) =&gt; &#123; 'use strict'; // code&#125;;const obj = &#123; // 报错 doSomething(&#123;a, b&#125;) &#123; 'use strict'; // code &#125;&#125;; 这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。 12345// 报错function doSomething(value = 070) &#123; 'use strict'; return value;&#125; 上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。 虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。 两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。 12345'use strict';function doSomething(a, b = a) &#123; // code&#125; 第二种是把函数包在一个无参数的立即执行函数里面。 123456const doSomething = (function () &#123; 'use strict'; return function(value = 42) &#123; return value; &#125;;&#125;()); 4.name 属性函数的name属性，返回该函数的函数名。 12function foo() &#123;&#125;foo.name // "foo" 这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。 需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。 1234567var f = function () &#123;&#125;;// ES5f.name // ""// ES6f.name // "f" 上面代码中，变量f等于一个匿名函数，ES5 和 ES6 的name属性返回的值不一样。 如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。 1234567const bar = function baz() &#123;&#125;;// ES5bar.name // "baz"// ES6bar.name // "baz" Function构造函数返回的函数实例，name属性的值为anonymous。 1(new Function).name // "anonymous" bind返回的函数，name属性值会加上bound前缀。 1234function foo() &#123;&#125;;foo.bind(&#123;&#125;).name // "bound foo"(function()&#123;&#125;).bind(&#123;&#125;).name // "bound " 5.箭头函数基本用法ES6 允许使用“箭头”（=&gt;）定义函数。 123456var f = v =&gt; v;// 等同于var f = function (v) &#123; return v;&#125;; 如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。 123456789var f = () =&gt; 5;// 等同于var f = function () &#123; return 5 &#125;;var sum = (num1, num2) =&gt; num1 + num2;// 等同于var sum = function(num1, num2) &#123; return num1 + num2;&#125;; 如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。 1var sum = (num1, num2) =&gt; &#123; return num1 + num2; &#125; 由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。 12345// 报错let getTempItem = id =&gt; &#123; id: id, name: "Temp" &#125;;// 不报错let getTempItem = id =&gt; (&#123; id: id, name: "Temp" &#125;); 下面是一种特殊情况，虽然可以运行，但会得到错误的结果。 12let foo = () =&gt; &#123; a: 1 &#125;;foo() // undefined 上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。 如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。 1let fn = () =&gt; void doesNotReturn(); 箭头函数可以与变量解构结合使用。 123456const full = (&#123; first, last &#125;) =&gt; first + ' ' + last;// 等同于function full(person) &#123; return person.first + ' ' + person.last;&#125; 箭头函数使得表达更加简洁。 12const isEven = n =&gt; n % 2 == 0;const square = n =&gt; n * n; 上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。 箭头函数的一个用处是简化回调函数。 1234567// 正常函数写法[1,2,3].map(function (x) &#123; return x * x;&#125;);// 箭头函数写法[1,2,3].map(x =&gt; x * x); 另一个例子是 1234567// 正常函数写法var result = values.sort(function (a, b) &#123; return a - b;&#125;);// 箭头函数写法var result = values.sort((a, b) =&gt; a - b); 下面是 rest 参数与箭头函数结合的例子。 123456789const numbers = (...nums) =&gt; nums;numbers(1, 2, 3, 4, 5)// [1,2,3,4,5]const headAndTail = (head, ...tail) =&gt; [head, tail];headAndTail(1, 2, 3, 4, 5)// [1,[2,3,4,5]] 使用注意点箭头函数有几个使用注意点。 （1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。 （2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。 （3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。 （4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。 上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。 12345678910function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;var id = 21;foo.call(&#123; id: 42 &#125;);// id: 42 上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。 箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。 1234567891011121314151617function Timer() &#123; this.s1 = 0; this.s2 = 0; // 箭头函数 setInterval(() =&gt; this.s1++, 1000); // 普通函数 setInterval(function () &#123; this.s2++; &#125;, 1000);&#125;var timer = new Timer();setTimeout(() =&gt; console.log('s1: ', timer.s1), 3100);setTimeout(() =&gt; console.log('s2: ', timer.s2), 3100);// s1: 3// s2: 0 上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。 箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。 123456789101112var handler = &#123; id: '123456', init: function() &#123; document.addEventListener('click', event =&gt; this.doSomething(event.type), false); &#125;, doSomething: function(type) &#123; console.log('Handling ' + type + ' for ' + this.id); &#125;&#125;; 上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。 this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。 所以，箭头函数转成 ES5 的代码如下。 123456789101112131415// ES6function foo() &#123; setTimeout(() =&gt; &#123; console.log('id:', this.id); &#125;, 100);&#125;// ES5function foo() &#123; var _this = this; setTimeout(function () &#123; console.log('id:', _this.id); &#125;, 100);&#125; 上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。 请问下面的代码之中有几个this？ 123456789101112131415function foo() &#123; return () =&gt; &#123; return () =&gt; &#123; return () =&gt; &#123; console.log('id:', this.id); &#125;; &#125;; &#125;;&#125;var f = foo.call(&#123;id: 1&#125;);var t1 = f.call(&#123;id: 2&#125;)()(); // id: 1var t2 = f().call(&#123;id: 3&#125;)(); // id: 1var t3 = f()().call(&#123;id: 4&#125;); // id: 1 上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。 除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。 12345678function foo() &#123; setTimeout(() =&gt; &#123; console.log('args:', arguments); &#125;, 100);&#125;foo(2, 4, 6, 8)// args: [2, 4, 6, 8] 上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。 另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。 123456(function() &#123; return [ (() =&gt; this.x).bind(&#123; x: 'inner' &#125;)() ];&#125;).call(&#123; x: 'outer' &#125;);// ['outer'] 上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。 长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。 嵌套的箭头函数箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。 12345678910function insert(value) &#123; return &#123;into: function (array) &#123; return &#123;after: function (afterValue) &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array; &#125;&#125;; &#125;&#125;;&#125;insert(2).into([1, 3]).after(1); //[1, 2, 3] 上面这个函数，可以使用箭头函数改写。 123456let insert = (value) =&gt; (&#123;into: (array) =&gt; (&#123;after: (afterValue) =&gt; &#123; array.splice(array.indexOf(afterValue) + 1, 0, value); return array;&#125;&#125;)&#125;);insert(2).into([1, 3]).after(1); //[1, 2, 3] 下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。 123456789const pipeline = (...funcs) =&gt; val =&gt; funcs.reduce((a, b) =&gt; b(a), val);const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;const addThenMult = pipeline(plus1, mult2);addThenMult(5)// 12 如果觉得上面的写法可读性比较差，也可以采用下面的写法。 12345const plus1 = a =&gt; a + 1;const mult2 = a =&gt; a * 2;mult2(plus1(5))// 12 箭头函数还有一个功能，就是可以很方便地改写 λ 演算。 123456// λ演算的写法fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))// ES6的写法var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v))) (x =&gt; f(v =&gt; x(x)(v))); 上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。 6.双冒号运算符箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。 函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。 123456789101112foo::bar;// 等同于bar.bind(foo);foo::bar(...arguments);// 等同于bar.apply(foo, arguments);const hasOwnProperty = Object.prototype.hasOwnProperty;function hasOwn(obj, key) &#123; return obj::hasOwnProperty(key);&#125; 如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。 1234567var method = obj::obj.foo;// 等同于var method = ::obj.foo;let log = ::console.log;// 等同于var log = console.log.bind(console); 如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。 123456import &#123; map, takeWhile, forEach &#125; from "iterlib";getPlayers()::map(x =&gt; x.character())::takeWhile(x =&gt; x.strength &gt; 100)::forEach(x =&gt; console.log(x)); 7.尾调用优化什么是尾调用？尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。 123function f(x)&#123; return g(x);&#125; 上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。 以下三种情况，都不属于尾调用。 123456789101112131415// 情况一function f(x)&#123; let y = g(x); return y;&#125;// 情况二function f(x)&#123; return g(x) + 1;&#125;// 情况三function f(x)&#123; g(x);&#125; 上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。 1234function f(x)&#123; g(x); return undefined;&#125; 尾调用不一定出现在函数尾部，只要是最后一步操作即可。 123456function f(x) &#123; if (x &gt; 0) &#123; return m(x) &#125; return n(x);&#125; 上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。 尾调用优化尾调用之所以与其他调用不同，就在于它的特殊的调用位置。 我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。 尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。 123456789101112131415function f() &#123; let m = 1; let n = 2; return g(m + n);&#125;f();// 等同于function f() &#123; return g(3);&#125;f();// 等同于g(3); 上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。 这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。 注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。 1234567function addOne(a)&#123; var one = 1; function inner(b)&#123; return b + one; &#125; return inner(a);&#125; 上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。 尾递归函数调用自身，称为递归。如果尾调用自身，就称为尾递归。 递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。 123456function factorial(n) &#123; if (n === 1) return 1; return n * factorial(n - 1);&#125;factorial(5) // 120 上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。 如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。 123456function factorial(n, total) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5, 1) // 120 还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。 非尾递归的 Fibonacci 数列实现如下。 123456789function Fibonacci (n) &#123; if ( n &lt;= 1 ) &#123;return 1&#125;; return Fibonacci(n - 1) + Fibonacci(n - 2);&#125;Fibonacci(10) // 89Fibonacci(100) // 堆栈溢出Fibonacci(500) // 堆栈溢出 尾递归优化过的 Fibonacci 数列实现如下。 123456789function Fibonacci2 (n , ac1 = 1 , ac2 = 1) &#123; if( n &lt;= 1 ) &#123;return ac2&#125;; return Fibonacci2 (n - 1, ac2, ac1 + ac2);&#125;Fibonacci2(100) // 573147844013817200000Fibonacci2(1000) // 7.0330367711422765e+208Fibonacci2(10000) // Infinity 由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。 递归函数的改写尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？ 两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。 12345678910function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;function factorial(n) &#123; return tailFactorial(n, 1);&#125;factorial(5) // 120 上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。 函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。 1234567891011121314function currying(fn, n) &#123; return function (m) &#123; return fn.call(this, m, n); &#125;;&#125;function tailFactorial(n, total) &#123; if (n === 1) return total; return tailFactorial(n - 1, n * total);&#125;const factorial = currying(tailFactorial, 1);factorial(5) // 120 上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。 第二种方法就简单多了，就是采用 ES6 的函数默认值。 123456function factorial(n, total = 1) &#123; if (n === 1) return total; return factorial(n - 1, n * total);&#125;factorial(5) // 120 上面代码中，参数total有默认值1，所以调用时不用提供这个值。 总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。 严格模式ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。 这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。 func.arguments：返回调用时函数的参数。 func.caller：返回调用当前函数的那个函数。 尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。 123456function restricted() &#123; 'use strict'; restricted.caller; // 报错 restricted.arguments; // 报错&#125;restricted(); 尾递归优化的实现尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。 它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。 下面是一个正常的递归函数。 12345678910function sum(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1); &#125; else &#123; return x; &#125;&#125;sum(1, 100000)// Uncaught RangeError: Maximum call stack size exceeded(…) 上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。 蹦床函数（trampoline）可以将递归执行转为循环执行。 123456function trampoline(f) &#123; while (f &amp;&amp; f instanceof Function) &#123; f = f(); &#125; return f;&#125; 上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。 然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。 1234567function sum(x, y) &#123; if (y &gt; 0) &#123; return sum.bind(null, x + 1, y - 1); &#125; else &#123; return x; &#125;&#125; 上面代码中，sum函数的每次执行，都会返回自身的另一个版本。 现在，使用蹦床函数执行sum，就不会发生调用栈溢出。 12trampoline(sum(1, 100000))// 100001 蹦床函数并不是真正的尾递归优化，下面的实现才是。 1234567891011121314151617181920212223242526272829function tco(f) &#123; var value; var active = false; var accumulated = []; return function accumulator() &#123; accumulated.push(arguments); if (!active) &#123; active = true; while (accumulated.length) &#123; value = f.apply(this, accumulated.shift()); &#125; active = false; return value; &#125; &#125;;&#125;var sum = tco(function(x, y) &#123; if (y &gt; 0) &#123; return sum(x + 1, y - 1) &#125; else &#123; return x &#125;&#125;);sum(1, 100000)// 100001 上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。 8.函数参数的尾逗号ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。 此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。 123456789function clownsEverywhere( param1, param2) &#123; /* ... */ &#125;clownsEverywhere( 'foo', 'bar'); 上面代码中，如果在param2或bar后面加一个逗号，就会报错。 如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownsEverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。 123456789function clownsEverywhere( param1, param2,) &#123; /* ... */ &#125;clownsEverywhere( 'foo', 'bar',); 这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 -- 06.数值的扩展]]></title>
    <url>%2F2018%2F06%2F12%2FES6%2F06.%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[数值的扩展1.二进制和八进制表示法ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。 120b111110111 === 503 // true0o767 === 503 // true 从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。 12345678910// 非严格模式(function()&#123; console.log(0o11 === 011);&#125;)() // true// 严格模式(function()&#123; 'use strict'; console.log(0o11 === 011);&#125;)() // Uncaught SyntaxError: Octal literals are not allowed in strict mode. 如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。 12Number('0b111') // 7Number('0o10') // 8 2.Number.isFinite(), Number.isNaN()ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。 Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。 12345678Number.isFinite(15); // trueNumber.isFinite(0.8); // trueNumber.isFinite(NaN); // falseNumber.isFinite(Infinity); // falseNumber.isFinite(-Infinity); // falseNumber.isFinite('foo'); // falseNumber.isFinite('15'); // falseNumber.isFinite(true); // false 注意，如果参数类型不是数值，Number.isFinite一律返回false。 Number.isNaN()用来检查一个值是否为NaN。 1234567Number.isNaN(NaN) // trueNumber.isNaN(15) // falseNumber.isNaN('15') // falseNumber.isNaN(true) // falseNumber.isNaN(9/NaN) // trueNumber.isNaN('true' / 0) // trueNumber.isNaN('true' / 'true') // true 如果参数类型不是NaN，Number.isNaN一律返回false。 它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。 12345678910isFinite(25) // trueisFinite("25") // trueNumber.isFinite(25) // trueNumber.isFinite("25") // falseisNaN(NaN) // trueisNaN("NaN") // trueNumber.isNaN(NaN) // trueNumber.isNaN("NaN") // falseNumber.isNaN(1) // false 3.Number.parseInt(), Number.parseFloat()ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。 1234567// ES5的写法parseInt('12.34') // 12parseFloat('123.45#') // 123.45// ES6的写法Number.parseInt('12.34') // 12Number.parseFloat('123.45#') // 123.45 这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。 12Number.parseInt === parseInt // trueNumber.parseFloat === parseFloat // true 4.Number.isInteger()Number.isInteger()用来判断一个数值是否为整数。 12Number.isInteger(25) // trueNumber.isInteger(25.1) // false JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。 12Number.isInteger(25) // trueNumber.isInteger(25.0) // true 如果参数不是数值，Number.isInteger返回false。 1234Number.isInteger() // falseNumber.isInteger(null) // falseNumber.isInteger('15') // falseNumber.isInteger(true) // false 注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。 1Number.isInteger(3.0000000000000002) // true 上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。 类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。 12Number.isInteger(5E-324) // falseNumber.isInteger(5E-325) // true 上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。 总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。 5.Number.EPSILONES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。 对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。 123456Number.EPSILON === Math.pow(2, -52)// trueNumber.EPSILON// 2.220446049250313e-16Number.EPSILON.toFixed(20)// "0.00000000000000022204" Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。 引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。 123456780.1 + 0.2// 0.300000000000000040.1 + 0.2 - 0.3// 5.551115123125783e-175.551115123125783e-17.toFixed(20)// '0.00000000000000005551' 上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。 10.1 + 0.2 === 0.3 // false Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。 125.551115123125783e-17 &lt; Number.EPSILON * Math.pow(2, 2)// true 因此，Number.EPSILON的实质是一个可以接受的最小误差范围。 123456789function withinErrorMargin (left, right) &#123; return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);&#125;0.1 + 0.2 === 0.3 // falsewithinErrorMargin(0.1 + 0.2, 0.3) // true1.1 + 1.3 === 2.4 // falsewithinErrorMargin(1.1 + 1.3, 2.4) // true 上面的代码为浮点数运算，部署了一个误差检查函数。 6.安全整数和 Number.isSafeInteger()JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。 1234567Math.pow(2, 53) // 90071992547409929007199254740992 // 90071992547409929007199254740993 // 9007199254740992Math.pow(2, 53) === Math.pow(2, 53) + 1// true 上面代码中，超出 2 的 53 次方之后，一个数就不精确了。 ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。 123456789Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1// trueNumber.MAX_SAFE_INTEGER === 9007199254740991// trueNumber.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER// trueNumber.MIN_SAFE_INTEGER === -9007199254740991// true 上面代码中，可以看到 JavaScript 能够精确表示的极限。 Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。 123456789101112131415Number.isSafeInteger('a') // falseNumber.isSafeInteger(null) // falseNumber.isSafeInteger(NaN) // falseNumber.isSafeInteger(Infinity) // falseNumber.isSafeInteger(-Infinity) // falseNumber.isSafeInteger(3) // trueNumber.isSafeInteger(1.2) // falseNumber.isSafeInteger(9007199254740990) // trueNumber.isSafeInteger(9007199254740992) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // falseNumber.isSafeInteger(Number.MIN_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER) // trueNumber.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false 这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。 123456Number.isSafeInteger = function (n) &#123; return (typeof n === 'number' &amp;&amp; Math.round(n) === n &amp;&amp; Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp; n &lt;= Number.MAX_SAFE_INTEGER);&#125; 实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。 123456789Number.isSafeInteger(9007199254740993)// falseNumber.isSafeInteger(990)// trueNumber.isSafeInteger(9007199254740993 - 990)// true9007199254740993 - 990// 返回结果 9007199254740002// 正确答案应该是 9007199254740003 上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。 129007199254740993 === 9007199254740992// true 所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。 12345678910111213141516function trusty (left, right, result) &#123; if ( Number.isSafeInteger(left) &amp;&amp; Number.isSafeInteger(right) &amp;&amp; Number.isSafeInteger(result) ) &#123; return result; &#125; throw new RangeError('Operation cannot be trusted!');&#125;trusty(9007199254740993, 990, 9007199254740993 - 990)// RangeError: Operation cannot be trusted!trusty(1, 2, 3)// 3 7.Math 对象的扩展ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。 Math.trunc()Math.trunc方法用于去除一个数的小数部分，返回整数部分。 12345Math.trunc(4.1) // 4Math.trunc(4.9) // 4Math.trunc(-4.1) // -4Math.trunc(-4.9) // -4Math.trunc(-0.1234) // -0 对于非数值，Math.trunc内部使用Number方法将其先转为数值。 1234Math.trunc('123.456') // 123Math.trunc(true) //1Math.trunc(false) // 0Math.trunc(null) // 0 对于空值和无法截取整数的值，返回NaN。 1234Math.trunc(NaN); // NaNMath.trunc('foo'); // NaNMath.trunc(); // NaNMath.trunc(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.trunc = Math.trunc || function(x) &#123; return x &lt; 0 ? Math.ceil(x) : Math.floor(x);&#125;; Math.sign()Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。 它会返回五种值。 参数为正数，返回+1； 参数为负数，返回-1； 参数为 0，返回0； 参数为-0，返回-0; 其他值，返回NaN。 12345Math.sign(-5) // -1Math.sign(5) // +1Math.sign(0) // +0Math.sign(-0) // -0Math.sign(NaN) // NaN 如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。 12345678Math.sign('') // 0Math.sign(true) // +1Math.sign(false) // 0Math.sign(null) // 0Math.sign('9') // +1Math.sign('foo') // NaNMath.sign() // NaNMath.sign(undefined) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 1234567Math.sign = Math.sign || function(x) &#123; x = +x; // convert to a number if (x === 0 || isNaN(x)) &#123; return x; &#125; return x &gt; 0 ? 1 : -1;&#125;; Math.cbrt()Math.cbrt方法用于计算一个数的立方根。 1234Math.cbrt(-1) // -1Math.cbrt(0) // 0Math.cbrt(1) // 1Math.cbrt(2) // 1.2599210498948734 对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。 12Math.cbrt('8') // 2Math.cbrt('hello') // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 1234Math.cbrt = Math.cbrt || function(x) &#123; var y = Math.pow(Math.abs(x), 1/3); return x &lt; 0 ? -y : y;&#125;; Math.clz32()JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0。 12345Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1000) // 22Math.clz32(0b01000000000000000000000000000000) // 1Math.clz32(0b00100000000000000000000000000000) // 2 上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。 clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。 左移运算符（&lt;&lt;）与Math.clz32方法直接相关。 12345Math.clz32(0) // 32Math.clz32(1) // 31Math.clz32(1 &lt;&lt; 1) // 30Math.clz32(1 &lt;&lt; 2) // 29Math.clz32(1 &lt;&lt; 29) // 2 对于小数，Math.clz32方法只考虑整数部分。 12Math.clz32(3.2) // 30Math.clz32(3.9) // 30 对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。 12345678Math.clz32() // 32Math.clz32(NaN) // 32Math.clz32(Infinity) // 32Math.clz32(null) // 32Math.clz32('foo') // 32Math.clz32([]) // 32Math.clz32(&#123;&#125;) // 32Math.clz32(true) // 31 Math.imul()Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。 123Math.imul(2, 4) // 8Math.imul(-1, 8) // -8Math.imul(-2, -2) // 4 如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a b的结果是相同的，即该方法等同于(a b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。 1(0x7fffffff * 0x7fffffff)|0 // 0 上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。 1Math.imul(0x7fffffff, 0x7fffffff) // 1 Math.fround()Math.fround方法返回一个数的32位单精度浮点数形式。 对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。 123Math.fround(0) // 0Math.fround(1) // 1Math.fround(2 ** 24 - 1) // 16777215 如果参数的绝对值大于 224，返回的结果便开始丢失精度。 12Math.fround(2 ** 24) // 16777216Math.fround(2 ** 24 + 1) // 16777216 Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。 12345678// 未丢失有效精度Math.fround(1.125) // 1.125Math.fround(7.25) // 7.25// 丢失精度Math.fround(0.3) // 0.30000001192092896Math.fround(0.7) // 0.699999988079071Math.fround(1.0000000123) // 1 对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。 12345678Math.fround(NaN) // NaNMath.fround(Infinity) // InfinityMath.fround('5') // 5Math.fround(true) // 1Math.fround(null) // 0Math.fround([]) // 0Math.fround(&#123;&#125;) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.fround = Math.fround || function (x) &#123; return new Float32Array([x])[0];&#125;; Math.hypot()Math.hypot方法返回所有参数的平方和的平方根。 1234567Math.hypot(3, 4); // 5Math.hypot(3, 4, 5); // 7.0710678118654755Math.hypot(); // 0Math.hypot(NaN); // NaNMath.hypot(3, 4, 'foo'); // NaNMath.hypot(3, 4, '5'); // 7.0710678118654755Math.hypot(-3); // 3 上面代码中，3 的平方加上 4 的平方，等于 5 的平方。 如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。 对数方法ES6 新增了 4 个对数相关方法。 （1） Math.expm1() Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。 123Math.expm1(-1) // -0.6321205588285577Math.expm1(0) // 0Math.expm1(1) // 1.718281828459045 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.expm1 = Math.expm1 || function(x) &#123; return Math.exp(x) - 1;&#125;; （2）Math.log1p() Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。 1234Math.log1p(1) // 0.6931471805599453Math.log1p(0) // 0Math.log1p(-1) // -InfinityMath.log1p(-2) // NaN 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log1p = Math.log1p || function(x) &#123; return Math.log(1 + x);&#125;; （3）Math.log10() Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。 12345Math.log10(2) // 0.3010299956639812Math.log10(1) // 0Math.log10(0) // -InfinityMath.log10(-2) // NaNMath.log10(100000) // 5 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log10 = Math.log10 || function(x) &#123; return Math.log(x) / Math.LN10;&#125;; （4）Math.log2() Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。 1234567Math.log2(3) // 1.584962500721156Math.log2(2) // 1Math.log2(1) // 0Math.log2(0) // -InfinityMath.log2(-2) // NaNMath.log2(1024) // 10Math.log2(1 &lt;&lt; 29) // 29 对于没有部署这个方法的环境，可以用下面的代码模拟。 123Math.log2 = Math.log2 || function(x) &#123; return Math.log(x) / Math.LN2;&#125;; 双曲函数方法ES6 新增了 6 个双曲函数方法。 Math.sinh(x) 返回x的双曲正弦（hyperbolic sine） Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine） Math.tanh(x) 返回x的双曲正切（hyperbolic tangent） Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine） Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine） Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent） 8.指数运算符ES2016 新增了一个指数运算符（**）。 122 ** 2 // 42 ** 3 // 8 指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。 1234567let a = 1.5;a **= 2;// 等同于 a = a * a;let b = 4;b **= 3;// 等同于 b = b * b * b; 注意，在 V8 引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。 12345Math.pow(99, 99)// 3.697296376497263e+19799 ** 99// 3.697296376497268e+197 上面代码中，两个运算结果的最后一位有效数字是有差异的。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 -- 05.正则的扩展]]></title>
    <url>%2F2018%2F06%2F12%2FES6%2F05.%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[正则的扩展1.RegExp 构造函数在 ES5 中，RegExp构造函数的参数有两种情况。 第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。 123var regex = new RegExp('xyz', 'i');// 等价于var regex = /xyz/i; 第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。 123var regex = new RegExp(/xyz/i);// 等价于var regex = /xyz/i; 但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。 12var regex = new RegExp(/xyz/, 'i');// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。 12new RegExp(/abc/ig, 'i').flags// "i" 上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。 2.字符串的正则方法字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。 ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。 String.prototype.match 调用 RegExp.prototype[Symbol.match] String.prototype.replace 调用 RegExp.prototype[Symbol.replace] String.prototype.search 调用 RegExp.prototype[Symbol.search] String.prototype.split 调用 RegExp.prototype[Symbol.split] 3.u 修饰符ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。 12/^\uD83D/u.test('\uD83D\uDC2A') // false/^\uD83D/.test('\uD83D\uDC2A') // true 上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。 一旦加上u修饰符号，就会修改下面这些正则表达式的行为。 （1）点字符 点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。 1234var s = '𠮷';/^.$/.test(s) // false/^.$/u.test(s) // true 上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。 （2）Unicode 字符表示法 ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。 123/\u&#123;61&#125;/.test('a') // false/\u&#123;61&#125;/u.test('a') // true/\u&#123;20BB7&#125;/u.test('𠮷') // true 上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的u。 （3）量词 使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。 1234/a&#123;2&#125;/.test('aa') // true/a&#123;2&#125;/u.test('aa') // true/𠮷&#123;2&#125;/.test('𠮷𠮷') // false/𠮷&#123;2&#125;/u.test('𠮷𠮷') // true （4）预定义模式 u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。 12/^\S$/.test('𠮷') // false/^\S$/u.test('𠮷') // true 上面代码的\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。 利用这一点，可以写出一个正确返回字符串长度的函数。 123456789function codePointLength(text) &#123; var result = text.match(/[\s\S]/gu); return result ? result.length : 0;&#125;var s = '𠮷𠮷';s.length // 4codePointLength(s) // 2 （5）i 修饰符 有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。 12/[a-z]/i.test('\u212A') // false/[a-z]/iu.test('\u212A') // true 上面代码中，不加u修饰符，就无法识别非规范的K字符。 4.RegExp.prototype.unicode 属性正则实例对象新增unicode属性，表示是否设置了u修饰符。 12345const r1 = /hello/;const r2 = /hello/u;r1.unicode // falser2.unicode // true 上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。 5.y 修饰符除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。 y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。 123456789var s = 'aaa_aa_a';var r1 = /a+/g;var r2 = /a+/y;r1.exec(s) // ["aaa"]r2.exec(s) // ["aaa"]r1.exec(s) // ["aa"]r2.exec(s) // null 上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。 如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。 12345var s = 'aaa_aa_a';var r = /a+_/y;r.exec(s) // ["aaa_"]r.exec(s) // ["aa_"] 上面代码每次匹配，都是从剩余字符串的头部开始。 使用lastIndex属性，可以更好地说明y修饰符。 12345678910111213141516const REGEX = /a/g;// 指定从2号位置（y）开始匹配REGEX.lastIndex = 2;// 匹配成功const match = REGEX.exec('xaya');// 在3号位置匹配成功match.index // 3// 下一次匹配从4号位开始REGEX.lastIndex // 4// 4号位开始匹配失败REGEX.exec('xaya') // null 上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。 y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。 123456789101112131415const REGEX = /a/y;// 指定从2号位置开始匹配REGEX.lastIndex = 2;// 不是粘连，匹配失败REGEX.exec('xaya') // null// 指定从3号位置开始匹配REGEX.lastIndex = 3;// 3号位置是粘连，匹配成功const match = REGEX.exec('xaya');match.index // 3REGEX.lastIndex // 4 实际上，y修饰符号隐含了头部匹配的标志^。 12/b/y.exec('aba')// null 上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。 下面是字符串对象的replace方法的例子。 12const REGEX = /a/gy;'aaxa'.replace(REGEX, '-') // '--xa' 上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。 单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。 12'a1a2a3'.match(/a\d/y) // ["a1"]'a1a2a3'.match(/a\d/gy) // ["a1", "a2", "a3"] y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。 12345678910111213141516const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;const TOKEN_G = /\s*(\+|[0-9]+)\s*/g;tokenize(TOKEN_Y, '3 + 4')// [ '3', '+', '4' ]tokenize(TOKEN_G, '3 + 4')// [ '3', '+', '4' ]function tokenize(TOKEN_REGEX, str) &#123; let result = []; let match; while (match = TOKEN_REGEX.exec(str)) &#123; result.push(match[1]); &#125; return result;&#125; 上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。 1234tokenize(TOKEN_Y, '3x + 4')// [ '3' ]tokenize(TOKEN_G, '3x + 4')// [ '3', '+', '4' ] 上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。 6.RegExp.prototype.sticky 属性与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。 12var r = /hello\d/y;r.sticky // true 7.RegExp.prototype.flags 属性ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。 123456789// ES5 的 source 属性// 返回正则表达式的正文/abc/ig.source// "abc"// ES6 的 flags 属性// 返回正则表达式的修饰符/abc/ig.flags// 'gi' 8.s 修饰符：dotAll 模式正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。 所谓行终止符，就是该字符表示一行的终结。以下四个字符属于”行终止符“。 U+000A 换行符（\n） U+000D 回车符（\r） U+2028 行分隔符（line separator） U+2029 段分隔符（paragraph separator） 12/foo.bar/.test('foo\nbar')// false 上面代码中，因为.不匹配\n，所以正则表达式返回false。 但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。 12/foo[^]bar/.test('foo\nbar')// true 这种解决方案毕竟不太符合直觉，ES2018 引入s修饰符，使得.可以匹配任意单个字符。 1/foo.bar/s.test('foo\nbar') // true 这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。 1234567const re = /foo.bar/s;// 另一种写法// const re = new RegExp('foo.bar', 's');re.test('foo\nbar') // truere.dotAll // truere.flags // 's' /s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。 9.后行断言JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入后行断言，V8 引擎 4.9 版（Chrome 62）已经支持。 ”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。 12/\d+(?=%)/.exec('100% of US presidents have been male') // ["100"]/\d+(?!%)/.exec('that’s all 44 of them') // ["44"] 上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，”先行断言“括号之中的部分（(?=%)），是不计入返回结果的。 “后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。 12/(?=\$)\d+/.exec('Benjamin Franklin is on the $100 bill') // ["100"]/(?&lt;!\$)\d+/.exec('it’s is worth about €90') // ["90"] 上面的例子中，“后行断言”的括号之中的部分（(?&lt;=\$)），也是不计入返回结果。 下面的例子是使用后行断言进行字符串替换。 123const RE_DOLLAR_PREFIX = /(?&lt;=\$)foo/g;'$foo %foo foo'.replace(RE_DOLLAR_PREFIX, 'bar');// '$bar %foo foo' 上面代码中，只有在美元符号后面的foo才会被替换。 “后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。 首先，后行断言的组匹配，与正常情况下结果是不一样的。 12/(?&lt;=(\d+)(\d+))$/.exec('1053') // ["", "1", "053"]/^(\d+)(\d+)$/.exec('1053') // ["1053", "105", "3"] 上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。 其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。 12/(?&lt;=(o)d\1)r/.exec('hodor') // null/(?&lt;=\1d(o))r/.exec('hodor') // ["r", "o"] 上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。 10.Unicode 属性类ES2018 引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。 12const regexGreekSymbol = /\p&#123;Script=Greek&#125;/u;regexGreekSymbol.test('π') // true 上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。 Unicode 属性类要指定属性名和属性值。 1\p&#123;UnicodePropertyName=UnicodePropertyValue&#125; 对于某些属性，可以只写属性名，或者只写属性值。 12\p&#123;UnicodePropertyName&#125;\p&#123;UnicodePropertyValue&#125; \P{…}是\p{…}的反向匹配，即匹配不满足条件的字符。 注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\p和\P会报错，ECMAScript 预留了这两个类。 由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。 12const regex = /^\p&#123;Decimal_Number&#125;+$/u;regex.test('𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼') // true 上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。 \p{Number}甚至能匹配罗马数字。 12345// 匹配所有数字const regex = /^\p&#123;Number&#125;+$/u;regex.test('²³¹¼½¾') // trueregex.test('㉛㉜㉝') // trueregex.test('ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ') // true 下面是其他一些例子。 123456789101112131415// 匹配所有空格\p&#123;White_Space&#125;// 匹配各种文字的所有字母，等同于 Unicode 版的 \w[\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W[^\p&#123;Alphabetic&#125;\p&#123;Mark&#125;\p&#123;Decimal_Number&#125;\p&#123;Connector_Punctuation&#125;\p&#123;Join_Control&#125;]// 匹配 Emoji/\p&#123;Emoji_Modifier_Base&#125;\p&#123;Emoji_Modifier&#125;?|\p&#123;Emoji_Presentation&#125;|\p&#123;Emoji&#125;\uFE0F/gu// 匹配所有的箭头字符const regexArrows = /^\p&#123;Block=Arrows&#125;+$/u;regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true 11.具名组匹配简介正则表达式使用圆括号进行组匹配。 1const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/; 上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。 123456const RE_DATE = /(\d&#123;4&#125;)-(\d&#123;2&#125;)-(\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj[1]; // 1999const month = matchObj[2]; // 12const day = matchObj[3]; // 31 组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。 ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。 123456const RE_DATE = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/;const matchObj = RE_DATE.exec('1999-12-31');const year = matchObj.groups.year; // 1999const month = matchObj.groups.month; // 12const day = matchObj.groups.day; // 31 上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。 具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。 如果具名组没有匹配，那么对应的groups对象属性会是undefined。 12345const RE_OPT_A = /^(?&lt;as&gt;a+)?$/;const matchObj = RE_OPT_A.exec('');matchObj.groups.as // undefined'as' in matchObj.groups // true 上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。 解构赋值和替换有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。 123let &#123;groups: &#123;one, two&#125;&#125; = /^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec('foo:bar');one // footwo // bar 字符串替换时，使用$&lt;组名&gt;引用具名组。 1234let re = /(?&lt;year&gt;\d&#123;4&#125;)-(?&lt;month&gt;\d&#123;2&#125;)-(?&lt;day&gt;\d&#123;2&#125;)/u;'2015-01-02'.replace(re, '$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;')// '02/01/2015' 上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。 replace方法的第二个参数也可以是函数，该函数的参数序列如下。 123456789101112'2015-01-02'.replace(re, ( matched, // 整个匹配结果 2015-01-02 capture1, // 第一个组匹配 2015 capture2, // 第二个组匹配 01 capture3, // 第三个组匹配 02 position, // 匹配开始的位置 0 S, // 原字符串 2015-01-02 groups // 具名组构成的一个对象 &#123;year, month, day&#125; ) =&gt; &#123; let &#123;day, month, year&#125; = args[args.length - 1]; return `$&#123;day&#125;/$&#123;month&#125;/$&#123;year&#125;`;&#125;); 具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。 引用如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/;RE_TWICE.test('abc!abc') // trueRE_TWICE.test('abc!ab') // false 数字引用（\1）依然有效。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\1$/;RE_TWICE.test('abc!abc') // trueRE_TWICE.test('abc!ab') // false 这两种引用语法还可以同时使用。 123const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/;RE_TWICE.test('abc!abc!abc') // trueRE_TWICE.test('abc!abc!ab') // false 12.String.prototype.matchAll如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。 123456789101112131415var regex = /t(e)(st(\d?))/g;var string = 'test1test2test3';var matches = [];var match;while (match = regex.exec(string)) &#123; matches.push(match);&#125;matches// [// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"],// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"],// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"]// ] 上面代码中，while循环取出每一轮的正则匹配，一共三轮。 目前有一个提案，增加了String.prototype.matchAll方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。 1234567891011const string = 'test1test2test3';// g 修饰符加不加都可以const regex = /t(e)(st(\d?))/g;for (const match of string.matchAll(regex)) &#123; console.log(match);&#125;// ["test1", "e", "st1", "1", index: 0, input: "test1test2test3"]// ["test2", "e", "st2", "2", index: 5, input: "test1test2test3"]// ["test3", "e", "st3", "3", index: 10, input: "test1test2test3"] 上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。 遍历器转为数组是非常简单的，使用…运算符和Array.from方法就可以了。 12345// 转为数组方法一[...string.matchAll(regex)]// 转为数组方法二Array.from(string.matchAll(regex));]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 -- 04.字符串的扩展]]></title>
    <url>%2F2018%2F06%2F11%2FES6%2F04.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95%2F</url>
    <content type="text"><![CDATA[字符串的扩展ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。 1.字符的 Unicode 表示法JavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。 12"\u0061"// "a" 但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。 12345"\uD842\uDFB7"// "𠮷""\u20BB7"// " 7" 上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。 ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。 1234567891011"\u&#123;20BB7&#125;"// "𠮷""\u&#123;41&#125;\u&#123;42&#125;\u&#123;43&#125;"// "ABC"let hello = 123;hell\u&#123;6F&#125; // 123'\u&#123;1F680&#125;' === '\uD83D\uDE80'// true 上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。 有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。 12345'\z' === 'z' // true'\172' === 'z' // true'\x7A' === 'z' // true'\u007A' === 'z' // true'\u&#123;7A&#125;' === 'z' // true 2.codePointAt()JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。 1234567var s = "𠮷";s.length // 2s.charAt(0) // ''s.charAt(1) // ''s.charCodeAt(0) // 55362s.charCodeAt(1) // 57271 上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。 ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。 123456let s = '𠮷a';s.codePointAt(0) // 134071s.codePointAt(1) // 57271s.codePointAt(2) // 97 codePointAt方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。 总之，codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。 codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。 1234let s = '𠮷a';s.codePointAt(0).toString(16) // "20bb7"s.codePointAt(2).toString(16) // "61" 你可能注意到了，codePointAt方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt方法传入 2。解决这个问题的一个办法是使用for…of循环，因为它会正确识别 32 位的 UTF-16 字符。 123456let s = '𠮷a';for (let ch of s) &#123; console.log(ch.codePointAt(0).toString(16));&#125;// 20bb7// 61 codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。 123456function is32Bit(c) &#123; return c.codePointAt(0) &gt; 0xFFFF;&#125;is32Bit("𠮷") // trueis32Bit("a") // false 3.String.fromCodePoint()ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。 12String.fromCharCode(0x20BB7)// "ஷ" 上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。 ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。 1234String.fromCodePoint(0x20BB7)// "𠮷"String.fromCodePoint(0x78, 0x1f680, 0x79) === 'x\uD83D\uDE80y'// true 上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。 注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。 4.字符串的遍历器接口ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for…of循环遍历。 123456for (let codePoint of 'foo') &#123; console.log(codePoint)&#125;// "f"// "o"// "o" 除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。 123456789101112let text = String.fromCodePoint(0x20BB7);for (let i = 0; i &lt; text.length; i++) &#123; console.log(text[i]);&#125;// " "// " "for (let i of text) &#123; console.log(i);&#125;// "𠮷" 上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for…of循环会正确识别出这一个字符。 5.at()ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。 12'abc'.charAt(0) // "a"'𠮷'.charAt(0) // "\uD842" 上面代码中的第二条语句，charAt方法期望返回的是用2个字节表示的字符，但汉字“𠮷”占用了4个字节，charAt(0)表示获取这4个字节中的前2个字节，很显然，这是无法正常显示的。 目前，有一个提案，提出字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符。 12'abc'.at(0) // "a"'𠮷'.at(0) // "𠮷" 这个方法可以通过垫片库实现。 6.normalize()许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。 这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。 1234'\u01D1'==='\u004F\u030C' //false'\u01D1'.length // 1'\u004F\u030C'.length // 2 上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。 ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。 12'\u01D1'.normalize() === '\u004F\u030C'.normalize()// true normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。 NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。 NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。 NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。） NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。 12'\u004F\u030C'.normalize('NFC').length // 1'\u004F\u030C'.normalize('NFD').length // 2 上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。 不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。 7.includes(), startsWith(), endsWith()传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。 includes()：返回布尔值，表示是否找到了参数字符串。 startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。 endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。 12345let s = 'Hello world!';s.startsWith('Hello') // trues.endsWith('!') // trues.includes('o') // true 这三个方法都支持第二个参数，表示开始搜索的位置。 12345let s = 'Hello world!';s.startsWith('world', 6) // trues.endsWith('Hello', 5) // trues.includes('Hello', 6) // false 上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。 8.repeat()repeat方法返回一个新字符串，表示将原字符串重复n次。 123'x'.repeat(3) // "xxx"'hello'.repeat(2) // "hellohello"'na'.repeat(0) // "" 参数如果是小数，会被取整。 如果repeat的参数是负数或者Infinity，会报错。 1234'na'.repeat(Infinity)// RangeError'na'.repeat(-1)// RangeError 但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。 1'na'.repeat(-0.9) // "" 参数NaN等同于 0。 1'na'.repeat(NaN) // "" 如果repeat的参数是字符串，则会先转换成数字。 12'na'.repeat('na') // ""'na'.repeat('3') // "nanana" 9.padStart()，padEnd()ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。 12345'x'.padStart(5, 'ab') // 'ababx''x'.padStart(4, 'ab') // 'abax''x'.padEnd(5, 'ab') // 'xabab''x'.padEnd(4, 'ab') // 'xaba' 上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。 如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。 12'xxx'.padStart(2, 'ab') // 'xxx''xxx'.padEnd(2, 'ab') // 'xxx' 如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。 12'abc'.padStart(10, '0123456789')// '0123456abc' 如果省略第二个参数，默认使用空格补全长度。 12'x'.padStart(4) // ' x''x'.padEnd(4) // 'x ' padStart的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。 123'1'.padStart(10, '0') // "0000000001"'12'.padStart(10, '0') // "0000000012"'123456'.padStart(10, '0') // "0000123456" 另一个用途是提示字符串格式。 12'12'.padStart(10, 'YYYY-MM-DD') // "YYYY-MM-12"'09-12'.padStart(10, 'YYYY-MM-DD') // "YYYY-09-12" 10.matchAll()matchAll方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。 11.模板字符串传统的 JavaScript 语言，输出模板通常是这样写的。 123456$('#result').append( 'There are &lt;b&gt;' + basket.count + '&lt;/b&gt; ' + 'items in your basket, ' + '&lt;em&gt;' + basket.onSale + '&lt;/em&gt; are on sale!'); 上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。 12345$('#result').append(` There are &lt;b&gt;$&#123;basket.count&#125;&lt;/b&gt; items in your basket, &lt;em&gt;$&#123;basket.onSale&#125;&lt;/em&gt; are on sale!`); 模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。 12345678910111213// 普通字符串`In JavaScript '\n' is a line-feed.`// 多行字符串`In JavaScript this is not legal.`console.log(`string text line 1string text line 2`);// 字符串中嵌入变量let name = "Bob", time = "today";`Hello $&#123;name&#125;, how are you $&#123;time&#125;?` 上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。 1let greeting = `\`Yo\` World!`; 如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`); 上面代码中，所有模板字符串的空格和换行，都是被保留的，比如标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。 123456$('#list').html(`&lt;ul&gt; &lt;li&gt;first&lt;/li&gt; &lt;li&gt;second&lt;/li&gt;&lt;/ul&gt;`.trim()); 模板字符串中嵌入变量，需要将变量名写在${}之中。 123456789101112function authorize(user, action) &#123; if (!user.hasPrivilege(action)) &#123; throw new Error( // 传统写法为 // 'User ' // + user.name // + ' is not authorized to do ' // + action // + '.' `User $&#123;user.name&#125; is not authorized to do $&#123;action&#125;.`); &#125;&#125; 大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。 123456789101112let x = 1;let y = 2;`$&#123;x&#125; + $&#123;y&#125; = $&#123;x + y&#125;`// "1 + 2 = 3"`$&#123;x&#125; + $&#123;y * 2&#125; = $&#123;x + y * 2&#125;`// "1 + 4 = 5"let obj = &#123;x: 1, y: 2&#125;;`$&#123;obj.x + obj.y&#125;`// "3" 模板字符串之中还能调用函数。 123456function fn() &#123; return "Hello World";&#125;`foo $&#123;fn()&#125; bar`// foo Hello World bar 如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。 如果模板字符串中的变量没有声明，将报错。 123// 变量place没有声明let msg = `Hello, $&#123;place&#125;`;// 报错 由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。 12`Hello $&#123;'World'&#125;`// "Hello World" 模板字符串甚至还能嵌套。 12345678const tmpl = addrs =&gt; ` &lt;table&gt; $&#123;addrs.map(addr =&gt; ` &lt;tr&gt;&lt;td&gt;$&#123;addr.first&#125;&lt;/td&gt;&lt;/tr&gt; &lt;tr&gt;&lt;td&gt;$&#123;addr.last&#125;&lt;/td&gt;&lt;/tr&gt; `).join('')&#125; &lt;/table&gt;`; 上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。 123456789101112131415const data = [ &#123; first: '&lt;Jane&gt;', last: 'Bond' &#125;, &#123; first: 'Lars', last: '&lt;Croft&gt;' &#125;,];console.log(tmpl(data));// &lt;table&gt;//// &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;//// &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;// &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;//// &lt;/table&gt; 如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。 123456789// 写法一let str = 'return ' + '`Hello $&#123;name&#125;!`';let func = new Function('name', str);func('Jack') // "Hello Jack!"// 写法二let str = '(name) =&gt; `Hello $&#123;name&#125;!`';let func = eval.call(null, str);func('Jack') // "Hello Jack!" 12.实例：模板编译下面，我们来看一个通过模板字符串，生成正式模板的实例。 1234567let template = `&lt;ul&gt; &lt;% for(let i=0; i &lt; data.supplies.length; i++) &#123; %&gt; &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt; &lt;% &#125; %&gt;&lt;/ul&gt;`; 上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置 JavaScript 代码，使用&lt;%= … %&gt;输出 JavaScript 表达式。 怎么编译这个模板字符串呢？ 一种思路是将其转换为 JavaScript 表达式字符串。 1234567echo('&lt;ul&gt;');for(let i=0; i &lt; data.supplies.length; i++) &#123; echo('&lt;li&gt;'); echo(data.supplies[i]); echo('&lt;/li&gt;');&#125;;echo('&lt;/ul&gt;'); 这个转换使用正则表达式就行了。 12345678let evalExpr = /&lt;%=(.+?)%&gt;/g;let expr = /&lt;%([\s\S]+?)%&gt;/g;template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`');template = 'echo(`' + template + '`);'; 然后，将template封装在一个函数里面返回，就可以了。 1234567891011121314let script =`(function parse(data)&#123; let output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output;&#125;)`;return script; 将上面的内容拼装成一个模板编译函数compile。 12345678910111213141516171819202122232425function compile(template)&#123; const evalExpr = /&lt;%=(.+?)%&gt;/g; const expr = /&lt;%([\s\S]+?)%&gt;/g; template = template .replace(evalExpr, '`); \n echo( $1 ); \n echo(`') .replace(expr, '`); \n $1 \n echo(`'); template = 'echo(`' + template + '`);'; let script = `(function parse(data)&#123; let output = ""; function echo(html)&#123; output += html; &#125; $&#123; template &#125; return output; &#125;)`; return script;&#125; compile函数的用法如下。 1234567let parse = eval(compile(template));div.innerHTML = parse(&#123; supplies: [ "broom", "mop", "cleaner" ] &#125;);// &lt;ul&gt;// &lt;li&gt;broom&lt;/li&gt;// &lt;li&gt;mop&lt;/li&gt;// &lt;li&gt;cleaner&lt;/li&gt;// &lt;/ul&gt; 13.标签模板模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。 123alert`123`// 等同于alert(123) 标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。 但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。 123456let a = 5;let b = 10;tag`Hello $&#123; a + b &#125; world $&#123; a * b &#125;`;// 等同于tag(['Hello ', ' world ', ''], 15, 50); 上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。 函数tag依次会接收到多个参数。 123456789function tag(stringArr, value1, value2)&#123; // ...&#125;// 等同于function tag(stringArr, ...values)&#123; // ...&#125; tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。 tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。 tag函数所有参数的实际值如下。 第一个参数：[‘Hello ‘, ‘ world ‘, ‘’] 第二个参数: 15 第三个参数：50 也就是说，tag函数实际上以下面的形式调用。 1tag(['Hello ', ' world ', ''], 15, 50) 我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。 1234567891011121314151617181920let a = 5;let b = 10;function tag(s, v1, v2) &#123; console.log(s[0]); console.log(s[1]); console.log(s[2]); console.log(v1); console.log(v2); return "OK";&#125;tag`Hello $&#123; a + b &#125; world $&#123; a * b&#125;`;// "Hello "// " world "// ""// 15// 50// "OK" 下面是一个更复杂的例子。 123456789101112131415161718let total = 30;let msg = passthru`The total is $&#123;total&#125; ($&#123;total*1.05&#125; with tax)`;function passthru(literals) &#123; let result = ''; let i = 0; while (i &lt; literals.length) &#123; result += literals[i++]; if (i &lt; arguments.length) &#123; result += arguments[i]; &#125; &#125; return result;&#125;msg // "The total is 30 (31.5 with tax)" 上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。 passthru函数采用 rest 参数的写法如下。 12345678910function passthru(literals, ...values) &#123; let output = ""; let index; for (index = 0; index &lt; values.length; index++) &#123; output += literals[index] + values[index]; &#125; output += literals[index] return output;&#125; “标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。 123456789101112131415161718let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;function SaferHTML(templateData) &#123; let s = templateData[0]; for (let i = 1; i &lt; arguments.length; i++) &#123; let arg = String(arguments[i]); // Escape special characters in the substitution. s += arg.replace(/&amp;/g, "&amp;amp;") .replace(/&lt;/g, "&amp;lt;") .replace(/&gt;/g, "&amp;gt;"); // Don't escape special characters in the template. s += templateData[i]; &#125; return s;&#125; 上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。 12345let sender = '&lt;script&gt;alert("abc")&lt;/script&gt;'; // 恶意代码let message = SaferHTML`&lt;p&gt;$&#123;sender&#125; has sent you a message.&lt;/p&gt;`;message// &lt;p&gt;&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt; 标签模板的另一个应用，就是多语言转换（国际化处理）。 12i18n`Welcome to $&#123;siteName&#125;, you are visitor number $&#123;visitorNumber&#125;!`// "欢迎访问xxx，您是第xxxx位访问者！" 模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。 123456789// 下面的hashTemplate函数// 是一个自定义的模板处理函数let libraryHtml = hashTemplate` &lt;ul&gt; #for book in $&#123;myBooks&#125; &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt; #end &lt;/ul&gt;`; 除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。 123456789jsx` &lt;div&gt; &lt;input ref='input' onChange='$&#123;this.handleChange&#125;' defaultValue='$&#123;this.state.value&#125;' /&gt; $&#123;this.state.value&#125; &lt;/div&gt;` 上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 Github 找到jsx函数的具体实现。 下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。 12345678java`class HelloWorldApp &#123; public static void main(String[] args) &#123; System.out.println(“Hello World!”); // Display the string. &#125;&#125;`HelloWorldApp.main(); 模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。 12console.log`123`// ["123", raw: Array[1]] 上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。 请看下面的例子。 1234567tag`First line\nSecond line`function tag(strings) &#123; console.log(strings.raw[0]); // strings.raw[0] 为 "First line\\nSecond line" // 打印输出 "First line\nSecond line"&#125; 上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[“First line\nSecond line”]，那么strings.raw数组就是[“First line\nSecond line”]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\n视为\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。 14.String.raw()ES6 还为原生的 String 对象，提供了一个raw方法。 String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。 12345String.raw`Hi\n$&#123;2+3&#125;!`;// 返回 "Hi\\n5!"String.raw`Hi\u000A!`;// 返回 "Hi\\u000A!" 如果原字符串的斜杠已经转义，那么String.raw会进行再次转义。 12String.raw`Hi\\n`// 返回 "Hi\\\\n" String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。 String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。 12345String.raw(&#123; raw: 'test' &#125;, 0, 1, 2);// 't0e1s2t'// 等同于String.raw(&#123; raw: ['t','e','s','t'] &#125;, 0, 1, 2); 作为函数，String.raw的代码实现基本如下。 12345678910String.raw = function (strings, ...values) &#123; let output = ''; let index; for (index = 0; index &lt; values.length; index++) &#123; output += strings.raw[index] + values[index]; &#125; output += strings.raw[index] return output;&#125; 15.模板字符串的限制前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。 举例来说，标签模板里面可以嵌入 LaTEX 语言。 1234567891011function latex(strings) &#123; // ...&#125;let document = latex`\newcommand&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125; // 正常工作\newcommand&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; // 报错\newcommand&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; // 报错Breve over the h goes \u&#123;h&#125;ere // 报错` 上面代码中，变量document内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。 模板字符串会将\u00FF和\u{42}当作 Unicode 字符进行转义，所以\unicode解析时报错；而\x56会被当作十六进制字符串转义，所以\xerxes会报错。也就是说，\u和\x在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。 为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。 12345function tag(strs) &#123; strs[0] === undefined strs.raw[0] === "\\unicode and \\u&#123;55&#125;";&#125;tag`\unicode and \u&#123;55&#125;` 上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。 注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。 1let bad = `bad escape sequence: \unicode`; // 报错]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 -- 03.变量的解构赋值]]></title>
    <url>%2F2018%2F06%2F11%2FES6%2F03.%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC%2F</url>
    <content type="text"><![CDATA[变量的解构赋值1.变量的解构赋值基本用法ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。 以前，为变量赋值，只能直接指定值。 123let a = 1;let b = 2;let c = 3; ES6 允许写成下面这样。 1let [a, b, c] = [1, 2, 3]; 上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。 本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。 1234567891011121314151617181920let [foo, [[bar], baz]] = [1, [[2], 3]];foo // 1bar // 2baz // 3let [ , , third] = ["foo", "bar", "baz"];third // "baz"let [x, , y] = [1, 2, 3];x // 1y // 3let [head, ...tail] = [1, 2, 3, 4];head // 1tail // [2, 3, 4]let [x, y, ...z] = ['a'];x // "a"y // undefinedz // [] 如果解构不成功，变量的值就等于undefined。 12let [foo] = [];let [bar, foo] = [1]; 以上两种情况都属于解构不成功，foo的值都会等于undefined。 另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。 12345678let [x, y] = [1, 2, 3];x // 1y // 2let [a, [b], d] = [1, [2, 3], 4];a // 1b // 2d // 4 上面两个例子，都属于不完全解构，但是可以成功。 如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。 1234567// 报错let [foo] = 1;let [foo] = false;let [foo] = NaN;let [foo] = undefined;let [foo] = null;let [foo] = &#123;&#125;; 上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。 对于 Set 结构，也可以使用数组的解构赋值。 12let [x, y, z] = new Set(['a', 'b', 'c']);x // "a" 事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。 1234567891011function* fibs() &#123; let a = 0; let b = 1; while (true) &#123; yield a; [a, b] = [b, a + b]; &#125;&#125;let [first, second, third, fourth, fifth, sixth] = fibs();sixth // 5 上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。 默认值解构赋值允许指定默认值。 12345let [foo = true] = [];foo // truelet [x, y = 'b'] = ['a']; // x='a', y='b'let [x, y = 'b'] = ['a', undefined]; // x='a', y='b' 注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。 12345let [x = 1] = [undefined];x // 1let [x = 1] = [null];x // null 上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。 如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。 12345function f() &#123; console.log('aaa');&#125;let [x = f()] = [1]; 上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。 123456let x;if ([1][0] === undefined) &#123; x = f();&#125; else &#123; x = [1][0];&#125; 默认值可以引用解构赋值的其他变量，但该变量必须已经声明。 1234let [x = 1, y = x] = []; // x=1; y=1let [x = 1, y = x] = [2]; // x=2; y=2let [x = 1, y = x] = [1, 2]; // x=1; y=2let [x = y, y = 1] = []; // ReferenceError: y is not defined 上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。 2.对象的解构赋值解构不仅可以用于数组，还可以用于对象。 123let &#123; foo, bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb" 对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。 123456let &#123; bar, foo &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;foo // "aaa"bar // "bbb"let &#123; baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // undefined 上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。 如果变量名与属性名不一致，必须写成下面这样。 1234567let &#123; foo: baz &#125; = &#123; foo: 'aaa', bar: 'bbb' &#125;;baz // "aaa"let obj = &#123; first: 'hello', last: 'world' &#125;;let &#123; first: f, last: l &#125; = obj;f // 'hello'l // 'world' 这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。 1let &#123; foo: foo, bar: bar &#125; = &#123; foo: "aaa", bar: "bbb" &#125;; 也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。 123let &#123; foo: baz &#125; = &#123; foo: "aaa", bar: "bbb" &#125;;baz // "aaa"foo // error: foo is not defined 上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。 与数组一样，解构也可以用于嵌套结构的对象。 12345678910let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World" 注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。 1234567891011let obj = &#123; p: [ 'Hello', &#123; y: 'World' &#125; ]&#125;;let &#123; p, p: [x, &#123; y &#125;] &#125; = obj;x // "Hello"y // "World"p // ["Hello", &#123;y: "World"&#125;] 下面是另一个例子。 12345678910111213const node = &#123; loc: &#123; start: &#123; line: 1, column: 5 &#125; &#125;&#125;;let &#123; loc, loc: &#123; start &#125;, loc: &#123; start: &#123; line &#125;&#125; &#125; = node;line // 1loc // Object &#123;start: Object&#125;start // Object &#123;line: 1, column: 5&#125; 上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。 下面是嵌套赋值的例子。 1234567let obj = &#123;&#125;;let arr = [];(&#123; foo: obj.prop, bar: arr[0] &#125; = &#123; foo: 123, bar: true &#125;);obj // &#123;prop:123&#125;arr // [true] 对象的解构也可以指定默认值。 123456789101112131415var &#123;x = 3&#125; = &#123;&#125;;x // 3var &#123;x, y = 5&#125; = &#123;x: 1&#125;;x // 1y // 5var &#123;x: y = 3&#125; = &#123;&#125;;y // 3var &#123;x: y = 3&#125; = &#123;x: 5&#125;;y // 5var &#123; message: msg = 'Something went wrong' &#125; = &#123;&#125;;msg // "Something went wrong" 默认值生效的条件是，对象的属性值严格等于undefined。 12345var &#123;x = 3&#125; = &#123;x: undefined&#125;;x // 3var &#123;x = 3&#125; = &#123;x: null&#125;;x // null 上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。 如果解构失败，变量的值等于undefined。 12let &#123;foo&#125; = &#123;bar: 'baz'&#125;;foo // undefined 如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。 12// 报错let &#123;foo: &#123;bar&#125;&#125; = &#123;baz: 'baz'&#125;; 上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。 12let _tmp = &#123;baz: 'baz'&#125;;_tmp.foo.bar // 报错 如果要将一个已经声明的变量用于解构赋值，必须非常小心。 1234// 错误的写法let x;&#123;x&#125; = &#123;x: 1&#125;;// SyntaxError: syntax error 上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。 123// 正确的写法let x;(&#123;x&#125; = &#123;x: 1&#125;); 上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。 解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。 123(&#123;&#125; = [true, false]);(&#123;&#125; = 'abc');(&#123;&#125; = []); 上面的表达式虽然毫无意义，但是语法是合法的，可以执行。 对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。 1let &#123; log, sin, cos &#125; = Math; 上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。 由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。 1234let arr = [1, 2, 3];let &#123;0 : first, [arr.length - 1] : last&#125; = arr;first // 1last // 3 上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章） 3.字符串的解构赋值字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。 123456const [a, b, c, d, e] = 'hello';a // "h"b // "e"c // "l"d // "l"e // "o" 类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。 12let &#123;length : len&#125; = 'hello';len // 5 4.数值和布尔值的解构赋值解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。 12345let &#123;toString: s&#125; = 123;s === Number.prototype.toString // truelet &#123;toString: s&#125; = true;s === Boolean.prototype.toString // true 上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。 解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 123上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。 5.函数参数的解构赋值函数的参数也可以使用解构赋值。 12345function add([x, y])&#123; return x + y;&#125;add([1, 2]); // 3 上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。 下面是另一个例子。 1[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b); 函数参数的解构也可以使用默认值。 12345678function move(&#123;x = 0, y = 0&#125; = &#123;&#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, 0]move(&#123;&#125;); // [0, 0]move(); // [0, 0] 上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。 注意，下面的写法会得到不一样的结果。 12345678function move(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;) &#123; return [x, y];&#125;move(&#123;x: 3, y: 8&#125;); // [3, 8]move(&#123;x: 3&#125;); // [3, undefined]move(&#123;&#125;); // [undefined, undefined]move(); // [0, 0] 上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。 undefined就会触发函数参数的默认值。 12[1, undefined, 3].map((x = 'yes') =&gt; x);// [ 1, 'yes', 3 ] 圆括号问题解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。 由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。 但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。 不能使用圆括号的情况以下三种解构赋值不得使用圆括号。 （1）变量声明语句 123456789// 全部报错let [(a)] = [1];let &#123;x: (c)&#125; = &#123;&#125;;let (&#123;x: c&#125;) = &#123;&#125;;let &#123;(x: c)&#125; = &#123;&#125;;let &#123;(x): c&#125; = &#123;&#125;;let &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: 2 &#125; &#125;; （2）函数参数 函数参数也属于变量声明，因此不能带有圆括号。 1234// 报错function f([(z)]) &#123; return z; &#125;// 报错function f([z,(x)]) &#123; return x; &#125; （3）赋值语句的模式 123// 全部报错(&#123; p: a &#125;) = &#123; p: 42 &#125;;([a]) = [5]; 上面代码将整个模式放在圆括号之中，导致报错。 12// 报错[(&#123; p: a &#125;), &#123; x: c &#125;] = [&#123;&#125;, &#123;&#125;]; 上面代码将一部分模式放在圆括号之中，导致报错。 可以使用圆括号的情况可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。 123[(b)] = [3]; // 正确(&#123; p: (d) &#125; = &#123;&#125;); // 正确[(parseInt.prop)] = [3]; // 正确 上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。 7.用途变量的解构赋值用途很多。 （1）交换变量的值 1234let x = 1;let y = 2;[x, y] = [y, x]; 上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。 （2）从函数返回多个值 函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。 12345678910111213141516// 返回一个数组function example() &#123; return [1, 2, 3];&#125;let [a, b, c] = example();// 返回一个对象function example() &#123; return &#123; foo: 1, bar: 2 &#125;;&#125;let &#123; foo, bar &#125; = example(); （3）函数参数的定义 解构赋值可以方便地将一组参数与变量名对应起来。 1234567// 参数是一组有次序的值function f([x, y, z]) &#123; ... &#125;f([1, 2, 3]);// 参数是一组无次序的值function f(&#123;x, y, z&#125;) &#123; ... &#125;f(&#123;z: 3, y: 2, x: 1&#125;); （4）提取 JSON 数据 解构赋值对提取 JSON 对象中的数据，尤其有用。 12345678910let jsonData = &#123; id: 42, status: "OK", data: [867, 5309]&#125;;let &#123; id, status, data: number &#125; = jsonData;console.log(id, status, number);// 42, "OK", [867, 5309] 上面代码可以快速提取 JSON 数据的值。 （5）函数参数的默认值 1234567891011jQuery.ajax = function (url, &#123; async = true, beforeSend = function () &#123;&#125;, cache = true, complete = function () &#123;&#125;, crossDomain = false, global = true, // ... more config&#125; = &#123;&#125;) &#123; // ... do stuff&#125;; 指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。 （6）遍历 Map 结构 任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。 123456789const map = new Map();map.set('first', 'hello');map.set('second', 'world');for (let [key, value] of map) &#123; console.log(key + " is " + value);&#125;// first is hello// second is world 如果只想获取键名，或者只想获取键值，可以写成下面这样。 123456789// 获取键名for (let [key] of map) &#123; // ...&#125;// 获取键值for (let [,value] of map) &#123; // ...&#125; （7）输入模块的指定方法 加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。 1const &#123; SourceMapConsumer, SourceNode &#125; = require("source-map");]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 -- 02.let 和 const 命令]]></title>
    <url>%2F2018%2F06%2F08%2FES6%2F02.let%E5%92%8Cconst%E5%91%BD%E4%BB%A4%2F</url>
    <content type="text"><![CDATA[Let 和 Const 命令1. Let 命令基本用法:ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。 1234567&#123; let a = 10; var b = 1;&#125;a // ReferenceError: a is not defined.b // 1 上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。 for循环的计数器，就很合适使用let命令。 123456for (let i = 0; i &lt; 10; i++) &#123; // ...&#125;console.log(i);// ReferenceError: i is not defined 上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。 下面的代码如果使用var，最后输出的是10。 1234567var a = [];for (var i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 10 上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。 如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。 1234567var a = [];for (let i = 0; i &lt; 10; i++) &#123; a[i] = function () &#123; console.log(i); &#125;;&#125;a[6](); // 6 上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。 另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。 1234567for (let i = 0; i &lt; 3; i++) &#123; let i = 'abc'; console.log(i);&#125;// abc// abc// abc 上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。 不存在变量提升var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。 为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。 1234567// var 的情况console.log(foo); // 输出undefinedvar foo = 2;// let 的情况console.log(bar); // 报错ReferenceErrorlet bar = 2; 上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。 暂时性死区只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。 上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。 ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。 总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。 1234567891011if (true) &#123; // TDZ开始 tmp = 'abc'; // ReferenceError console.log(tmp); // ReferenceError let tmp; // TDZ结束 console.log(tmp); // undefined tmp = 123; console.log(tmp); // 123&#125; 上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。 “暂时性死区”也意味着typeof不再是一个百分之百安全的操作。 12typeof x; // ReferenceErrorlet x; 上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。 作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。 1typeof undeclared_variable // "undefined" 上面代码中，undeclared variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。 有些“死区”比较隐蔽，不太容易发现。 12345function bar(x = y, y = 2) &#123; return [x, y];&#125;bar(); // 报错 上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。 1234function bar(x = 2, y = x) &#123; return [x, y];&#125;bar(); // [2, 2] 另外，下面的代码也会报错，与var的行为不同。 123456// 不报错var x = x;// 报错let x = x;// ReferenceError: x is not defined 上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。 ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。 总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。 不允许重复声明let不允许在相同作用域内，重复声明同一个变量。 1234567891011// 报错function func() &#123; let a = 10; var a = 1;&#125;// 报错function func() &#123; let a = 10; let a = 1;&#125; 因此，不能在函数内部重新声明参数。 123456789function func(arg) &#123; let arg; // 报错&#125;function func(arg) &#123; &#123; let arg; // 不报错 &#125;&#125; 2.块级作用域为什么需要块级作用域ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。 第一种场景，内层变量可能会覆盖外层变量。 12345678910var tmp = new Date();function f() &#123; console.log(tmp); if (false) &#123; var tmp = 'hello world'; &#125;&#125;f(); // undefined 上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。 第二种场景，用来计数的循环变量泄露为全局变量。 1234567var s = 'hello';for (var i = 0; i &lt; s.length; i++) &#123; console.log(s[i]);&#125;console.log(i); // 5 上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。 ES6 的块级作用域let实际上为 JavaScript 新增了块级作用域。 1234567function f1() &#123; let n = 5; if (true) &#123; let n = 10; &#125; console.log(n); // 5&#125; 上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。 ES6 允许块级作用域的任意嵌套。 1&#123;&#123;&#123;&#123;&#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。 1234&#123;&#123;&#123;&#123; &#123;let insane = 'Hello World'&#125; console.log(insane); // 报错&#125;&#125;&#125;&#125;; 内层作用域可以定义外层作用域的同名变量。 1234&#123;&#123;&#123;&#123; let insane = 'Hello World'; &#123;let insane = 'Hello World'&#125;&#125;&#125;&#125;&#125;; 块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。 1234567891011// IIFE 写法(function () &#123; var tmp = ...; ...&#125;());// 块级作用域写法&#123; let tmp = ...; ...&#125; 块级作用域与函数声明函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。 ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。 1234567891011// 情况一if (true) &#123; function f() &#123;&#125;&#125;// 情况二try &#123; function f() &#123;&#125;&#125; catch(e) &#123; // ...&#125; 上面两种函数声明，根据 ES5 的规定都是非法的。 但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。 ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。 12345678910function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;()); 上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。 123456789// ES5 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; function f() &#123; console.log('I am inside!'); &#125; if (false) &#123; &#125; f();&#125;()); ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？ 原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在附录B里面规定，浏览器的实现可以不遵守上面的规定，有自己的行为方式。 允许在块级作用域内声明函数。 函数声明类似于var，即会提升到全局作用域或函数作用域的头部。 同时，函数声明还会提升到所在的块级作用域的头部。 注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。 根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。 123456789101112// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; if (false) &#123; // 重复声明一次函数f function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。 1234567891011// 浏览器的 ES6 环境function f() &#123; console.log('I am outside!'); &#125;(function () &#123; var f = undefined; if (false) &#123; function f() &#123; console.log('I am inside!'); &#125; &#125; f();&#125;());// Uncaught TypeError: f is not a function 考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。 123456789101112131415// 函数声明语句&#123; let a = 'secret'; function f() &#123; return a; &#125;&#125;// 函数表达式&#123; let a = 'secret'; let f = function () &#123; return a; &#125;;&#125; 另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。 12345678910// 不报错'use strict';if (true) &#123; function f() &#123;&#125;&#125;// 报错'use strict';if (true) function f() &#123;&#125; 3.const命令基本用法const声明一个只读的常量。一旦声明，常量的值就不能改变。 12345const PI = 3.1415;PI // 3.1415PI = 3;// TypeError: Assignment to constant variable. 上面代码表明改变常量的值会报错。 const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。 12const foo;// SyntaxError: Missing initializer in const declaration 上面代码表示，对于const来说，只声明不赋值，就会报错。 const的作用域与let命令相同：只在声明所在的块级作用域内有效。 12345if (true) &#123; const MAX = 5;&#125;MAX // Uncaught ReferenceError: MAX is not defined const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。 1234if (true) &#123; console.log(MAX); // ReferenceError const MAX = 5;&#125; 上面代码在常量MAX声明之前就调用，结果报错。 const声明的常量，也与let一样不可重复声明。 123456var message = "Hello!";let age = 25;// 以下两行都会报错const message = "Goodbye!";const age = 30; 本质const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。 12345678const foo = &#123;&#125;;// 为 foo 添加一个属性，可以成功foo.prop = 123;foo.prop // 123// 将 foo 指向另一个对象，就会报错foo = &#123;&#125;; // TypeError: "foo" is read-only 上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。 下面是另一个例子。 1234const a = [];a.push('Hello'); // 可执行a.length = 0; // 可执行a = ['Dave']; // 报错 上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。 如果真的想将对象冻结，应该使用Object.freeze方法。 12345const foo = Object.freeze(&#123;&#125;);// 常规模式时，下面一行不起作用；// 严格模式时，该行会报错foo.prop = 123; 上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。 除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。 12345678var constantize = (obj) =&gt; &#123; Object.freeze(obj); Object.keys(obj).forEach( (key, i) =&gt; &#123; if ( typeof obj[key] === 'object' ) &#123; constantize( obj[key] ); &#125; &#125;);&#125;; ES6 声明变量的六种方法ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。 4.顶层对象的属性顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。 12345window.a = 1;a // 1a = 2;window.a // 2 上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。 顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。 ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。 1234567var a = 1;// 如果在 Node 的 REPL 环境，可以写成 global.a// 或者采用通用方法，写成 this.awindow.a // 1let b = 1;window.b // undefined 上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。 5.global对象ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。 浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。 浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。 Node 里面，顶层对象是global，但其他环境都不支持。 同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。 全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。 函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。 不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。 综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。 12345678910111213141516// 方法一(typeof window !== 'undefined' ? window : (typeof process === 'object' &amp;&amp; typeof require === 'function' &amp;&amp; typeof global === 'object') ? global : this);// 方法二var getGlobal = function () &#123; if (typeof self !== 'undefined') &#123; return self; &#125; if (typeof window !== 'undefined') &#123; return window; &#125; if (typeof global !== 'undefined') &#123; return global; &#125; throw new Error('unable to locate global object');&#125;; 现在有一个提案，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。 垫片库system.global模拟了这个提案，可以在所有环境拿到global。 12345// CommonJS 的写法require('system.global/shim')();// ES6 模块的写法import shim from 'system.global/shim'; shim(); 上面代码可以保证各种环境里面，global对象都是存在的。 123456// CommonJS 的写法var global = require('system.global')();// ES6 模块的写法import getGlobal from 'system.global';const global = getGlobal(); 上面代码将顶层对象放入变量global。]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[ES6 -- 01.ECMAScript 6 简介]]></title>
    <url>%2F2018%2F06%2F08%2FES6%2F01.ECMAScript%2F</url>
    <content type="text"><![CDATA[ECMAScript 6 简介ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。 1.ECMAScript 和 JavaScript 的关系一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？ 要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。 该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。 因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。 2.ES6 与 ECMAScript 2015 的关系ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？ 2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。 但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。 但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。 标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。 ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。 因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。 3.语法提案的批准流程任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。 一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。 Stage 0 - Strawman（展示阶段） Stage 1 - Proposal（征求意见阶段） Stage 2 - Draft（草案阶段） Stage 3 - Candidate（候选人阶段） Stage 4 - Finished（定案阶段） 一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站Github.com/tc39/ecma262查看。 本书的写作目标之一，是跟踪 ECMAScript 语言的最新进展，介绍 5.1 版本以后所有的新语法。对于那些明确或很有希望，将要列入标准的新语法，都将予以介绍。 4.ECMAScript 的历史ES6 从开始制定到最后发布，整整用了 15 年。 前面提到，ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。 2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。 为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。 2007 年 10 月，ECMAScript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。 2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。 2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 委员会的总体考虑是，ES5 与 ES3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是 ES6，第六版发布以后，就指 ES7。TC39 的判断是，ES5 会在 2013 年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。 2011 年 6 月，ECMAscript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。 2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。 2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。 2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。 5.部署进度各大浏览器的最新版本，对 ES6 的支持可以查看kangax.github.io/es5-compat-table/es6/。随着时间的推移，支持度已经越来越高了，超过 90%的 ES6 语法特性都实现了。 Node 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node 已经实现的 ES6 特性。 1$ node --v8-options | grep harmony 上面命令的输出结果，会因为版本的不同而有所不同。 6.Babel 转码器Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。 1234567// 转码前input.map(item =&gt; item + 1);// 转码后input.map(function (item) &#123; return item + 1;&#125;); 上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。 配置文件.babelrcBabel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。 该文件用来设置转码规则和插件，基本格式如下。 1234&#123; "presets": [], "plugins": []&#125; presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。 1234567891011# 最新转码规则$ npm install --save-dev babel-preset-latest# react 转码规则$ npm install --save-dev babel-preset-react# 不同阶段语法提案的转码规则（共有4个阶段），选装一个$ npm install --save-dev babel-preset-stage-0$ npm install --save-dev babel-preset-stage-1$ npm install --save-dev babel-preset-stage-2$ npm install --save-dev babel-preset-stage-3 然后，将这些规则加入.babelrc。 12345678&#123; "presets": [ "latest", "react", "stage-2" ], "plugins": [] &#125; 注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。 命令行转码babel-cliBabel 提供babel-cli工具，用于命令行转码。 它的安装命令如下。 1$ npm install --global babel-cli 基本用法如下。 1234567891011121314151617# 转码结果输出到标准输出$ babel example.js# 转码结果写入一个文件# --out-file 或 -o 参数指定输出文件$ babel example.js --out-file compiled.js# 或者$ babel example.js -o compiled.js# 整个目录转码# --out-dir 或 -d 参数指定输出目录$ babel src --out-dir lib# 或者$ babel src -d lib# -s 参数生成source map文件$ babel src -d lib -s 上面代码是在全局环境下，进行 Babel 转码。这意味着，如果项目要运行，全局环境必须有 Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的 Babel。 一个解决办法是将babel-cli安装在项目之中。 12# 安装$ npm install --save-dev babel-cli 然后，改写package.json。 123456789&#123; // ... "devDependencies": &#123; "babel-cli": "^6.0.0" &#125;, "scripts": &#123; "build": "babel src -d lib" &#125;,&#125; 转码的时候，就执行下面的命令。 1$ npm run build babel-nodebabel-cli工具自带一个babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。 它不用单独安装，而是随babel-cli一起安装。然后，执行babel-node就进入 REPL 环境。 123$ babel-node&gt; (x =&gt; x * 2)(1)2 babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。 12$ babel-node es6.js2 babel-node也可以安装在项目中。 1$ npm install --save-dev babel-cli 然后，改写package.json。 12345&#123; "scripts": &#123; "script-name": "babel-node script.js" &#125;&#125; 上面代码中，使用babel-node替代node，这样script.js本身就不用做任何转码处理。 babel-registerbabel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。 1$ npm install --save-dev babel-register 使用时，必须首先加载babel-register。 12require("babel-register");require("./index.js"); 然后，就不需要手动对index.js转码了。 需要注意的是，babel-register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。 babel-core如果某些代码需要调用 Babel 的 API 进行转码，就要使用babel-core模块。 安装命令如下。 1$ npm install babel-core --save 然后，在项目中就可以调用babel-core。 123456789101112131415161718var babel = require('babel-core');// 字符串转码babel.transform('code();', options);// =&gt; &#123; code, map, ast &#125;// 文件转码（异步）babel.transformFile('filename.js', options, function(err, result) &#123; result; // =&gt; &#123; code, map, ast &#125;&#125;);// 文件转码（同步）babel.transformFileSync('filename.js', options);// =&gt; &#123; code, map, ast &#125;// Babel AST转码babel.transformFromAst(ast, code, options);// =&gt; &#123; code, map, ast &#125; 配置对象options，可以参看官方文档http://babeljs.io/docs/usage/options/。 下面是一个例子。 1234567var es6Code = 'let x = n =&gt; n + 1';var es5Code = require('babel-core') .transform(es6Code, &#123; presets: ['latest'] &#125;) .code;// '"use strict";\n\nvar x = function x(n) &#123;\n return n + 1;\n&#125;;' 上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。 babel-polyfillBabel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。 举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。 安装命令如下。 1$ npm install --save babel-polyfill 然后，在脚本头部，加入如下一行代码。 123import 'babel-polyfill';// 或者require('babel-polyfill'); Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的definitions.js文件。 浏览器环境Babel 也可以用于浏览器环境。但是，从 Babel 6.0 开始，不再直接提供浏览器版本，而是要用构建工具构建出来。如果你没有或不想使用构建工具，可以使用babel-standalone模块提供的浏览器版本，将其插入网页。 1234&lt;script src="https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js"&gt;&lt;/script&gt;&lt;script type="text/babel"&gt;// Your ES6 code&lt;/script&gt; 注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。 下面是如何将代码打包成浏览器可以使用的脚本，以Babel配合Browserify为例。首先，安装babelify模块。 1$ npm install --save-dev babelify babel-preset-latest 然后，再用命令行转换 ES6 脚本。 12$ browserify script.js -o bundle.js \ -t [ babelify --presets [ latest ] ] 上面代码将 ES6 脚本script.js，转为bundle.js，浏览器直接加载后者就可以了。 在package.json设置下面的代码，就不用每次命令行都输入参数了。 12345&#123; "browserify": &#123; "transform": [["babelify", &#123; "presets": ["latest"] &#125;]] &#125;&#125; 在线转换Babel 提供一个REPL 在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。 与其他工具的配合许多工具需要 Babel 进行前置转码，这里举两个例子：ESLint 和 Mocha。 ESLint 用于静态检查代码的语法和风格，安装命令如下。 1$ npm install --save-dev eslint babel-eslint 然后，在项目根目录下，新建一个配置文件.eslintrc，在其中加入parser字段。 123456&#123; "parser": "babel-eslint", "rules": &#123; ... &#125;&#125; 再在package.json之中，加入相应的scripts脚本。 12345678910&#123; "name": "my-module", "scripts": &#123; "lint": "eslint my-files.js" &#125;, "devDependencies": &#123; "babel-eslint": "...", "eslint": "..." &#125;&#125; Mocha 则是一个测试框架，如果需要执行使用 ES6 语法的测试脚本，可以修改package.json的scripts.test。 123"scripts": &#123; "test": "mocha --ui qunit --compilers js:babel-core/register"&#125; 上面命令中，–compilers参数指定脚本的转码器，规定后缀名为js的文件，都需要使用babel-core/register先转码。 7.Traceur 转码器Google 公司的Traceur转码器，也可以将 ES6 代码转为 ES5 代码。 直接插入网页Traceur 允许将 ES6 代码直接插入网页。首先，必须在网页头部加载 Traceur 库文件。 123456&lt;script src="https://google.github.io/traceur-compiler/bin/traceur.js"&gt;&lt;/script&gt;&lt;script src="https://google.github.io/traceur-compiler/bin/BrowserSystem.js"&gt;&lt;/script&gt;&lt;script src="https://google.github.io/traceur-compiler/src/bootstrap.js"&gt;&lt;/script&gt;&lt;script type="module"&gt; import './Greeter.js';&lt;/script&gt; 上面代码中，一共有 4 个script标签。第一个是加载 Traceur 的库文件，第二个和第三个是将这个库文件用于浏览器环境，第四个则是加载用户脚本，这个脚本里面可以使用 ES6 代码。 注意，第四个script标签的type属性的值是module，而不是text/javascript。这是 Traceur 编译器识别 ES6 代码的标志，编译器会自动将所有type=module的代码编译为 ES5，然后再交给浏览器执行。 除了引用外部 ES6 脚本，也可以直接在网页中放置 ES6 代码。 12345678910111213&lt;script type="module"&gt; class Calc &#123; constructor() &#123; console.log('Calc constructor'); &#125; add(a, b) &#123; return a + b; &#125; &#125; var c = new Calc(); console.log(c.add(4,5));&lt;/script&gt; 正常情况下，上面代码会在控制台打印出9。 如果想对 Traceur 的行为有精确控制，可以采用下面参数配置的写法。 123456789101112131415161718192021&lt;script&gt; // Create the System object window.System = new traceur.runtime.BrowserTraceurLoader(); // Set some experimental options var metadata = &#123; traceurOptions: &#123; experimental: true, properTailCalls: true, symbols: true, arrayComprehension: true, asyncFunctions: true, asyncGenerators: exponentiation, forOn: true, generatorComprehension: true &#125; &#125;; // Load your module System.import('./myModule.js', &#123;metadata: metadata&#125;).catch(function(ex) &#123; console.error('Import failed', ex.stack || ex); &#125;);&lt;/script&gt; 上面代码中，首先生成 Traceur 的全局对象window.System，然后System.import方法可以用来加载 ES6。加载的时候，需要传入一个配置对象metadata，该对象的traceurOptions属性可以配置支持 ES6 功能。如果设为experimental: true，就表示除了 ES6 以外，还支持一些实验性的新功能。 在线转换Traceur 也提供一个在线编译器，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。 上面的例子转为 ES5 代码运行，就是下面这个样子。 1234567891011121314151617181920&lt;script src="https://google.github.io/traceur-compiler/bin/traceur.js"&gt;&lt;/script&gt;&lt;script src="https://google.github.io/traceur-compiler/bin/BrowserSystem.js"&gt;&lt;/script&gt;&lt;script src="https://google.github.io/traceur-compiler/src/bootstrap.js"&gt;&lt;/script&gt;&lt;script&gt;$traceurRuntime.ModuleStore.getAnonymousModule(function() &#123; "use strict"; var Calc = function Calc() &#123; console.log('Calc constructor'); &#125;; ($traceurRuntime.createClass)(Calc, &#123;add: function(a, b) &#123; return a + b; &#125;&#125;, &#123;&#125;); var c = new Calc(); console.log(c.add(4, 5)); return &#123;&#125;;&#125;);&lt;/script&gt; 命令行转换作为命令行工具使用时，Traceur 是一个 Node 的模块，首先需要用 npm 安装。 1$ npm install -g traceur 安装成功后，就可以在命令行下使用 Traceur 了。 Traceur 直接运行 ES6 脚本文件，会在标准输出显示运行结果，以前面的calc.js为例。 123$ traceur calc.jsCalc constructor9 如果要将 ES6 脚本转为 ES5 保存，要采用下面的写法。 1$ traceur --script calc.es6.js --out calc.es5.js 上面代码的–script选项表示指定输入文件，–out选项表示指定输出文件。 为了防止有些特性编译不成功，最好加上–experimental选项。 1$ traceur --script calc.es6.js --out calc.es5.js --experimental 命令行下转换生成的文件，就可以直接放到浏览器中运行。 Node 环境的用法Traceur 的 Node 用法如下（假定已安装traceur模块）。 1234567891011121314151617181920var traceur = require('traceur');var fs = require('fs');// 将 ES6 脚本转为字符串var contents = fs.readFileSync('es6-file.js').toString();var result = traceur.compile(contents, &#123; filename: 'es6-file.js', sourceMap: true, // 其他设置 modules: 'commonjs'&#125;);if (result.error) throw result.error;// result 对象的 js 属性就是转换后的 ES5 代码fs.writeFileSync('out.js', result.js);// sourceMap 属性对应 map 文件fs.writeFileSync('out.js.map', result.sourceMap);]]></content>
      <categories>
        <category>ES6</category>
      </categories>
      <tags>
        <tag>ES6</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.Quick Start -- 06.Handling Events]]></title>
    <url>%2F2018%2F05%2F11%2Freact%2F02.Quick_Start%2F06.Handling_Events%2F</url>
    <content type="text"><![CDATA[Handling Events(处理事件)Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences: 用React元素处理事件与在DOM元素上处理事件非常相似。这里有一些语法不同： React events are named using camelCase, rather than lowercase. With JSX you pass a function as the event handler, rather than a string. React事件使用驼峰命名法，而不是小写字母命名法。 使用JSX作为您函数事件处理的参数，而不是字符串。 For example, the HTML: 例如，HTML： 123&lt;button onclick="activateLasers()"&gt; Activate Lasers&lt;/button&gt; is slightly different in React: 在React中有点不同： 123&lt;button onClick=&#123;activateLasers&#125;&gt; Activate Lasers&lt;/button&gt; Another difference is that you cannot return false to prevent default behavior in React. You must call preventDefault explicitly. For example, with plain HTML, to prevent the default link behavior of opening a new page, you can write: 另一个不同是您不能返回false来阻止React中的默认事件。您必须明确地调用preventDefault。例如，在HTML代码中，为了阻止默认点击事件，打开一个新的页面的表现，您可以这么写： 123&lt;a href="#" onclick="console.log('The link was clicked.'); return false"&gt; Click me&lt;/a&gt; In React, this could instead be: 在React中，应当是这样的： 123456789101112function ActionLink() &#123; function handleClick(e) &#123; e.preventDefault(); console.log('The link was clicked.'); &#125; return ( &lt;a href="#" onClick=&#123;handleClick&#125;&gt; Click me &lt;/a&gt; );&#125; Here, e is a synthetic event. React defines these synthetic events according to the W3C spec, so you don’t need to worry about cross-browser compatibility. See the SyntheticEvent reference guide to learn more. 这里，e代表了一个事件。React根据W3C规范定义了这些事件，因此您不必担心跨浏览器兼容性。 请参阅SyntheticEvent参考指南以了解更多信息。 When using React you should generally not need to call addEventListener to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered. 在使用React时，通常不需要调用addEventListener在创建DOM元素后向其添加监听器。相反，只需在元素初始呈现时添加监听器。 When you define a component using an ES6 class, a common pattern is for an event handler to be a method on the class. For example, this Toggle component renders a button that lets the user toggle between “ON” and “OFF” states: 当您使用ES6的类来定义一个组件时，一个常见的模式是让一个事件处理器成为该类的一个方法。 例如，这个Toggle组件呈现一个按钮，让用户在“ON”和“OFF”状态之间切换： 12345678910111213141516171819202122232425262728class Toggle extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;isToggleOn: true&#125;; // This binding is necessary to make `this` work in the callback this.handleClick = this.handleClick.bind(this); &#125; handleClick() &#123; this.setState(prevState =&gt; (&#123; isToggleOn: !prevState.isToggleOn &#125;)); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; &#123;this.state.isToggleOn ? 'ON' : 'OFF'&#125; &lt;/button&gt; ); &#125;&#125;ReactDOM.render( &lt;Toggle /&gt;, document.getElementById('root')); Try it on CodePen. You have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not bound by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called. 您必须在JSX回调中注意这一点的含义。在JavaScript中，类方法默认没有绑定。如果您忘记绑定this.handleClick并将其传递给onClick，则在实际调用该函数时，这将是未定义的。 This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method. 这不是React特定的表现; 在JavaScript中它是函数的一部分。一般来说，如果你在它后面引用一个没有()的方法，比如onClick = {this.handleClick}，你就应该绑定该方法。 If calling bind annoys you, there are two ways you can get around this. If you are using the experimental public class fields syntax, you can use class fields to correctly bind callbacks: 如果调用bind会让你感到困扰，那么有两种方法可以解决这个问题。 如果您使用的是尝试性的公共类字段语法，则可以使用类字段来正确地绑定回调： 123456789101112131415class LoggingButton extends React.Component &#123; // This syntax ensures `this` is bound within handleClick. // Warning: this is *experimental* syntax. handleClick = () =&gt; &#123; console.log('this is:', this); &#125; render() &#123; return ( &lt;button onClick=&#123;this.handleClick&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; This syntax is enabled by default in Create React App. 这种语法在Create React App中是默认启用的。 If you aren’t using class fields syntax, you can use an arrow function in the callback: 如果您不使用类字段语法，则可以在回调中使用箭头函数： 1234567891011121314class LoggingButton extends React.Component &#123; handleClick() &#123; console.log('this is:', this); &#125; render() &#123; // This syntax ensures `this` is bound within handleClick return ( &lt;button onClick=&#123;(e) =&gt; this.handleClick(e)&#125;&gt; Click me &lt;/button&gt; ); &#125;&#125; The problem with this syntax is that a different callback is created each time the LoggingButton renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem. 这个语法的问题是每次LoggingButton呈现时都会创建一个不同的回调函数。 在大多数情况下，这没有问题。但是，如果将此回调作为参数传递给较低组件，则这些组件可能会重新渲染。我们通常建议在构造函数中绑定或使用类字段语法来避免此类性能问题。 Passing Arguments to Event Handlers(将参数传递给事件处理程序)Inside a loop it is common to want to pass an extra parameter to an event handler. For example, if id is the row ID, either of the following would work: 在循环内部，通常需要将一个额外的参数传递给事件处理程序。 例如，如果id是行ID，则以下任一项都可以工作 12&lt;button onClick=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;Delete Row&lt;/button&gt;&lt;button onClick=&#123;this.deleteRow.bind(this, id)&#125;&gt;Delete Row&lt;/button&gt; The above two lines are equivalent, and use arrow functions and Function.prototype.bind respectively. 以上两行都是相等的，分别使用了箭头函数和Function.prototype.bind。 In both cases, the e argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically forwarded. 在这两种情况下，e参数代表了React事件，并将作为ID之后的第二个参数传递。使用箭头函数，我们必须明确地传递它，但是任何额外的参数都会自动绑定起来，并自动转发。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.Quick Start -- 05.State and Lifecycle]]></title>
    <url>%2F2018%2F05%2F11%2Freact%2F02.Quick_Start%2F05.State_and_Lifecycle%2F</url>
    <content type="text"><![CDATA[State and LifecycleConsider the ticking clock example from one of the previous sections. 考虑在前几章节中涉及到的秒钟案例。 So far we have only learned one way to update the UI. 直到现在，我们都只学了一种更新UI的方法。 We call ReactDOM.render() to change the rendered output: 我们会调用ReactDOM.render()来更新渲染输出: 1234567891011121314function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render( element, document.getElementById('root') );&#125;setInterval(tick, 1000); Try it on CodePen. In this section, we will learn how to make the Clock component truly reusable and encapsulated. It will set up its own timer and update itself every second. 这一章节中，我们将学到如何构建一个真正可复用和封装良好的Clock组件。它每秒都会被重新设置并更新其本身。 We can start by encapsulating how the clock looks: 我们可以简单的构建出钟表最开始的样式： 1234567891011121314151617function Clock(props) &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; );&#125;function tick() &#123; ReactDOM.render( &lt;Clock date=&#123;new Date()&#125; /&gt;, document.getElementById('root') );&#125;setInterval(tick, 1000); Try it on CodePen However, it misses a crucial requirement: the fact that the Clock sets up a timer and updates the UI every second should be an implementation detail of the Clock. 然而，它忘了一个重要的先决条件：事实就是设置一个计时器并每秒都更新UI是Clock本身应该实现的一个细节。 Ideally we want to write this once and have the Clock update itself: 理想情况下，我们只想写一次Clock并由其本身完成更新： 1234ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); To implement this, we need to add “state” to the Clock component. 为了实现这个目标，我们应该为Clock组件添加“状态”。 State is similar to props, but it is private and fully controlled by the component. 状态和属性相似，但是它是私密的，并且完全由组件控制。 We mentioned before that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes. 我们之前提到，当组件被定义为类时会有一些额外的特性。本地状态就是其中一种：一个只对类有效的特性。 Converting a Function to a Class(将一个函数转化为类)You can convert a functional component like Clock to a class in five steps: 您可以通过以下五步将一个函数组件转化为类： Create an ES6 class, with the same name, that extends React.Component. Add a single empty method to it called render(). Move the body of the function into the render() method. Replace props with this.props in the render() body. Delete the remaining empty function declaration. 创建一个具有相同名字，由React.Component扩展出来的ES6的类。 添加一个单一的空的方法，并由render()调用。 将函数主体移动到render()方法中。 在render()主体内，用this.props取代props。 删除剩余的空的函数声明。 12345678910class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; Try it on CodePen. Clock is now defined as a class rather than a function. Clock现在被定义为一个类而不是函数。 This lets us use additional features such as local state and lifecycle hooks. 这样可以让我们添加一些额外的特性，如本地状态和生命周期钩子。 Adding Local State to a Class(向一个类中添加本地状态)We will move the date from props to state in three steps: 我们将用三步将时间从属性移动到状态里： Replace this.props.date with this.state.date in the render() method:(在render()方法中用this.state.date取代this.props.date) 12345678910class Clock extends React.Component &#123; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; Add a class constructor that assigns the initial this.state:(添加一个类的构造函数来初始化this.state) 123456789101112131415class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; Note how we pass props to the base constructor: 注意我们是如何将参数传给基本的构造函数的： 1234constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; Class components should always call the base constructor with props. 类组件应该永远由带有参数的基本的构造函数来调用。 Remove the date prop from the Clock element:(从Clock中移除时间属性) 1234ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); We will later add the timer code back to the component itself. 我们稍后会将计时器组件代码到这个组件本身中。 The result looks like this: 最后的结果大致如下： 1234567891011121314151617181920class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); Try it on CodePen. Next, we’ll make the Clock set up its own timer and update itself every second. 接下来，我们将为Clock设置它自己的计时器并每秒都更新它。 Adding Lifecycle Methods to a Class(为类添加生命周期方法)In applications with many components, it’s very important to free up resources taken by the components when they are destroyed. 在具有多个组件的应用程序中在销毁组件时释放所占用的资源是非常重要的。 We want to set up a timer whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React. 我们想当Clock在被DOM初次渲染时设置一个计时器，这在React中叫做“挂载”。 We also want to clear that timer whenever the DOM produced by the Clock is removed. This is called “unmounting” in React. 我们也想在Clock在被DOM中移除时清除计时器。这在React中叫做“解挂”。 We can declare special methods on the component class to run some code when a component mounts and unmounts: 当组件被挂载和解挂时，我们可以在组件类中声明特殊的方法来运行一些代码： 1234567891011121314151617181920212223class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; &#125; componentWillUnmount() &#123; &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125; These methods are called “lifecycle hooks”. 这些方法叫做“生命周期钩子”。 The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer: componentDidMount()钩子会在组件输出被渲染到DOM后执行。这是一个好的设置计时器的时间点： 123456componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; Note how we save the timer ID right on this. 现在我们在其上设置计时器的ID。 While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that doesn’t participate in the data flow (like a timer ID). 因为this.props由React自己设置，this.state具有特殊含义，但如果您需要存储不参与数据流的内容（例如计时器ID），则需要手动将其他字段添加到类中）。 We will tear down the timer in the componentWillUnmount() lifecycle hook: 我们将会在componentWillUnmount()生命周期钩子中卸载计时器： 123componentWillUnmount() &#123; clearInterval(this.timerID);&#125; Finally, we will implement a method called tick() that the Clock component will run every second. 最后，我们将会应用一个叫做tick()的方法让Clock组件每秒都运行。 It will use this.setState() to schedule updates to the component local state: 它会使用this.setState()来设置更新计时器的本地状态： 12345678910111213141516171819202122232425262728293031323334353637class Clock extends React.Component &#123; constructor(props) &#123; super(props); this.state = &#123;date: new Date()&#125;; &#125; componentDidMount() &#123; this.timerID = setInterval( () =&gt; this.tick(), 1000 ); &#125; componentWillUnmount() &#123; clearInterval(this.timerID); &#125; tick() &#123; this.setState(&#123; date: new Date() &#125;); &#125; render() &#123; return ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); &#125;&#125;ReactDOM.render( &lt;Clock /&gt;, document.getElementById('root')); Try it on CodePen. Now the clock ticks every second. 现在，钟表将会每秒都运行。 Let’s quickly recap what’s going on and the order in which the methods are called: 让我们简单回顾一下在这个方法被调用时发生了什么，和它们的次序是什么： When Clock is passed to ReactDOM.render(), React calls the constructor of the Clock component. Since Clock needs to display the current time, it initializes this.state with an object including the current time. We will later update this state. React then calls the Clock component’s render() method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the Clock’s render output. When the Clock output is inserted in the DOM, React calls the componentDidMount() lifecycle hook. Inside it, the Clock component asks the browser to set up a timer to call the component’s tick() method once a second. Every second the browser calls the tick() method. Inside it, the Clock component schedules a UI update by calling setState() with an object containing the current time. Thanks to the setState() call, React knows the state has changed, and calls the render() method again to learn what should be on the screen. This time, this.state.date in the render() method will be different, and so the render output will include the updated time. React updates the DOM accordingly. If the Clock component is ever removed from the DOM, React calls the componentWillUnmount() lifecycle hook so the timer is stopped. 当Clock传递给ReactDOM.render()时，React调用Clock组件的构造函数。由于Clock需要显示当前时间，因此它会使用包含当前时间的对象初始化this.state。我们稍后将更新这个状态。 然后React调用Clock组件的render()方法。这就是React如何在屏幕上显示对应的内容。然后React更新DOM以匹配时钟的渲染输出。 当时钟输出插入到DOM中时，React调用componentDidMount()生命周期钩子。在它里面，Clock组件要求浏览器设置一个定时器，每秒调用一次该组件的tick（）方法。 浏览器每秒钟都会调用tick()方法。在它里面，Clock组件通过调用setState()和包含当前时间的对象来调度UI更新。因为setState()已经被调用，React知道状态已经改变，并再次调用render()方法在屏幕上显示应有的内容。这一次，render()方法中的this.state.date将会不同，所以渲染的结果包含更新的时间。并且React会相应地更新DOM。 如果Clock组件从DOM中删除，React将调用componentWillUnmount()生命周期钩子，定时器也随之停止。 Using State Correctly(正确地使用状态)There are three things you should know about setState(). 您应当知道有关setState()的三个事情。 Do Not Modify State Directly(不要直接调整状态)There are three things you should know about setState(). 有关setState()，您应当知道三件事情。 Do Not Modify State Directly(不要直接调整状态)For example, this will not re-render a component: 例如，下列代码不会重新渲染组件： 12// Wrongthis.state.comment = 'Hello'; Instead, use setState(): 相反的，您应当使用setState(): 12// Correctthis.setState(&#123;comment: 'Hello'&#125;); The only place where you can assign this.state is the constructor. 您唯一能设置this.state的地方就是构造函数。 State Updates May Be Asynchronous(状态更新可能是异步的)React may batch multiple setState() calls into a single update for performance. React可能会批量处理多个setState(),以便为单个更新提高性能。 Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state. 因为this.props和this.state可能会异步更新，所以不应该依赖它们的值来计算下一个状态。 For example, this code may fail to update the counter: 例如，此代码可能无法更新计数器: 1234// Wrongthis.setState(&#123; counter: this.state.counter + this.props.increment,&#125;); To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument: 为了修复它，我们可以使用接受函数的setState()而不是一个对象。该函数将接收前一个状态作为第一个参数，并将更新应用时的状态作为第二个参数： 1234// Correctthis.setState((prevState, props) =&gt; (&#123; counter: prevState.counter + props.increment&#125;)); We used an arrow function above, but it also works with regular functions: 我们在此使用箭头函数，但是它也对常规函数起作用： 123456// Correctthis.setState(function(prevState, props) &#123; return &#123; counter: prevState.counter + props.increment &#125;;&#125;); State Updates are Merged(状态更新已合并)When you call setState(), React merges the object you provide into the current state. 当您调用setState()时，React会合并您当前状态下提供的对象。 For example, your state may contain several independent variables: 例如，您的状态可能包含几个相互独立的变量： 1234567constructor(props) &#123; super(props); this.state = &#123; posts: [], comments: [] &#125;;&#125; Then you can update them independently with separate setState() calls: 然后您可以独立地使用setState()调用来更新它们： 12345678910111213componentDidMount() &#123; fetchPosts().then(response =&gt; &#123; this.setState(&#123; posts: response.posts &#125;); &#125;); fetchComments().then(response =&gt; &#123; this.setState(&#123; comments: response.comments &#125;); &#125;); &#125; The merging is shallow, so this.setState({comments}) leaves this.state.posts intact, but completely replaces this.state.comments. 合并是浅层的，所以this.setState({comments})会完整保留this.state.posts，但完全取代了this.state.comments。 The Data Flows Down(数据流失向下的)Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care whether it is defined as a function or a class. 父组件和孩组件都不知道某个组件是有状态的还是无状态的，并且它们不应该关心它是被定义为一个函数还是一个类。 This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it. 这就是为什么状态通常被称作本地的或被封装的。除了包含和设置它的组件之外，其他任何组件都无法访问它。 A component may choose to pass its state down as props to its child components: 组件可以选择将其状态作为参数传递给其子组件： 1&lt;h2&gt;It is &#123;this.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt; This also works for user-defined components: 这对用户自定义的组件也有效： 1&lt;FormattedDate date=&#123;this.state.date&#125; /&gt; The FormattedDate component would receive the date in its props and wouldn’t know whether it came from the Clock’s state, from the Clock’s props, or was typed by hand: FormattedDate组件应当在它们的属性中接受数据并不会知道它是来自Clock的状态，Clock的属性还是人为输入的。 123function FormattedDate(props) &#123; return &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;;&#125; Try it on CodePen. This is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components “below” them in the tree. 通常这被称之为“自顶向下”或者“无方向”的数据流。任何状态总是由某个特定组件拥有，并且从该状态派生的任何数据或UI只能影响树中“在其下”的组件。 If you imagine a component tree as a waterfall of props, each component’s state is like an additional water source that joins it at an arbitrary point but also flows down. 如果将组件树想象成参数的瀑布，则每个组件的状态就像是一个额外的水源，它可以在任意点加入它，但也会向下流。 To show that all components are truly isolated, we can create an App component that renders three Clocks: 为了显示所有组件都是真正隔离的，我们可以创建一个呈现三个Clock的App组件： 1234567891011121314function App() &#123; return ( &lt;div&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;Clock /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); Try it on CondePen. Each Clock sets up its own timer and updates independently. 每个表都会独立地设置它本身的计时器并独立更新。 In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa. 在React应用中，无论组件是有状态的还是无状态的，都被视为可能随时间而改变的组件的细节。您可以在有状态组件内使用无状态组件，反之亦然。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[git problem -- 1.git&gerrit邮箱不匹配]]></title>
    <url>%2F2018%2F05%2F11%2Fgit%2Fgit_problem%2F01.git_problem%2F</url>
    <content type="text"><![CDATA[git problem – git&amp;gerrit邮箱不匹配Git邮箱不匹配问题 does not match your user account 在活动比较多，使用分支开发的时候，从远端拉取分支，在完成fetch-&gt;rebase-&gt;修改代码以后，执行gerrit push指令时，提示用户信息不匹配。类似于下图所示： 123remote: ERROR: In commit 024c0bd88da87274f956a10dfa6b41e8c69ebd04remote: ERROR: author email address xxxxx@xx.comremote: ERROR: does not match your user account. 此问题解决方法：（不仅仅限于分支，master分支出现类似问题也可以用此方法） 12345(1)git config user.email (email地址)(2)git checkout -b another_branch（如果已经被占，随便再换一个）(3)git branch -D pre_branch(删除出现问题的分支)(4)git checkout --track origin/pre_branch(5)git push origin/pre_branch:refs/for/pre_branch 此时原先出现问题的分支就可以push成功了]]></content>
      <categories>
        <category>git</category>
      </categories>
      <tags>
        <tag>git problem</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.Quick Start -- 04.Components and Props]]></title>
    <url>%2F2018%2F05%2F08%2Freact%2F02.Quick_Start%2F04.Components_and_Props%2F</url>
    <content type="text"><![CDATA[Components and PropsComponents let you split the UI into independent, reusable pieces, and think about each piece in isolation. 组件可以让您将用户界面分成独立的，可重复使用的部分，并且每一部分都相互独立。 Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen. 从概念上讲，组件就像JavaScript的函数一样。他可以接受任意值的输入（我们通常称之为“参数”）并返回显示在屏幕上的React元素。 Functional and Class Components(函数和类组件)The simplest way to define a component is to write a JavaScript function: 定义一个组件最简单的方法是写一个JavaScript函数： 123function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125; This function is a valid React component because it accepts a single “props” (which stands for properties) object argument with data and returns a React element. We call such components “functional” because they are literally JavaScript functions. 这个函数是一个有效的React组件，因为它可以接受一个带有数据的单一的“参数”（通常代表着属性）对象并返回一个React元素。我们称这样的组件是“函数化”的，因为它们都是JavaScript字面上的方法。 You can also use an ES6 class to define a component: 您也可以使用ES6 class来定义一个组件： 12345class Welcome extends React.Component &#123; render() &#123; return &lt;h1&gt;Hello, &#123;this.props.name&#125;&lt;/h1&gt;; &#125;&#125; The above two components are equivalent from React’s point of view. 以上两种组件对于React来说是等价的。 Classes have some additional features that we will discuss in the next sections. Until then, we will use functional components for their conciseness. 类通常有一些额外的特性，我们会在下一章节讨论这些内容。在此之前，我们将会使用更为简洁的函数组件。 Rendering a Component(渲染一个组件)Previously, we only encountered React elements that represent DOM tags: 在此之前，我们仅仅遇到过使用DOM标签表示的React元素： 1const element = &lt;div /&gt;; However, elements can also represent user-defined components: 然而，元素也可以代表用户自定义的组件： 1const element = &lt;Welcome name="Sara" /&gt;; When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object “props”. 当React遇到一个用户自定义的组件时，他就会传递JSX属性作为单一的对象给它们的组件。我们称之为对象的“属性”。 For example, this code renders “Hello, Sara” on the page: 例如，以下代码将会把“Hello, Sara”渲染到页面上： 123456789function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;const element = &lt;Welcome name="Sara" /&gt;;ReactDOM.render( element, document.getElementById('root')); Try it on CodePen. Let’s recap what happens in this example: 让我们回顾一下上述代码发生了什么： We call ReactDOM.render() with the element. React calls the Welcome component with {name: ‘Sara’} as the props. Our Welcome component returns a Hello, Sara element as the result. React DOM efficiently updates the DOM to match Hello, Sara. 我们对元素调用了ReactDOM.render()。 React调用了Welcome组件，并将{name: ‘Sara’}作为参数。 我们的Welcome返回一个Hello, Sara元素作为结果。 React DOM会很快更新DOM，并显示Hello, Sara。 Note: Always start component names with a capital letter.React treats components starting with lowercase letters as DOM tags. For example, div represents an HTML div tag, but Welcome represents a component and requires Welcome to be in scope.You can read more about the reasoning behind this convention here. 注意：通常一个组件的命名是以大写字母开始的。React会将以小写字母开头的组件视为DOM标签。例如，div表示一个HTML div标签，但Welcome表示一个组件，并且要求Welcome在作用域内。您可以在这里阅读更多关于背后的内容。 Composing Components(构成组件)Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components. 组件能在它们的输出中引用其他的组件。这让我们可以对任何有相同内容的细节抽象出相同的部分。例如一个按钮，一个表格，一个对话框，一个屏幕：在React应用程序中，所有这些都通常表示为组件。 For example, we can create an App component that renders Welcome many times: 例如，我们可以创建一个App组件来渲染很多遍Welcome： 123456789101112131415161718function Welcome(props) &#123; return &lt;h1&gt;Hello, &#123;props.name&#125;&lt;/h1&gt;;&#125;function App() &#123; return ( &lt;div&gt; &lt;Welcome name="Sara" /&gt; &lt;Welcome name="Cahal" /&gt; &lt;Welcome name="Edite" /&gt; &lt;/div&gt; );&#125;ReactDOM.render( &lt;App /&gt;, document.getElementById('root')); Try it on CodePen. Typically, new React apps have a single App component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like Button and gradually work your way to the top of the view hierarchy. 通常情况下，一个新的ReactAPP会在顶层架构上有单一的应用组件。但是，如果您将React集成到现有的应用程序中，则可以使用Button之类的小组件自下而上地嵌入进去，并逐渐转向视图层次结构的顶部。 Extracting Components(抽象组件)Don’t be afraid to split components into smaller components. 永远不要担心将组件分成更小的组件。 For example, consider this Comment component: 观看下列例子，考虑Comment组件： 123456789101112131415161718192021function Comment(props) &#123; return ( &lt;div className="Comment"&gt; &lt;div className="UserInfo"&gt; &lt;img className="Avatar" src=&#123;props.author.avatarUrl&#125; alt=&#123;props.author.name&#125; /&gt; &lt;div className="UserInfo-name"&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className="Comment-text"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className="Comment-date"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; Try it on CodePen. It accepts author (an object), text (a string), and date (a date) as props, and describes a comment on a social media website. 它会接受用户(一个对象)，文本(一个字符串)，和日期(一个时间)作为参数，并且可以描述一个社交媒体平台上的一个评论。 This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let’s extract a few components from it. 因为有大量的嵌套，这个组件可能会变得很棘手，并且它的单一部分也很难复用。让我们将它抽象成一些小的组件。 First, we will extract Avatar: 首先，我们会抽象出Avatar： 123456789function Avatar(props) &#123; return ( &lt;img className="Avatar" src=&#123;props.user.avatarUrl&#125; alt=&#123;props.user.name&#125; /&gt; );&#125; The Avatar doesn’t need to know that it is being rendered inside a Comment. This is why we have given its prop a more generic name: user rather than author. Avatar不需要知道它是否被渲染在一个评论中。这也是为什么我们可以将它的参数设置为一个更符合的名字：使用user而不是author We recommend naming props from the component’s own point of view rather than the context in which it is being used. 我们建议从组件自身的角度命名参数而不是从它使用的环境下命名。 We can now simplify Comment a tiny bit: 因此我们可以将评论简化一些： 123456789101112131415161718function Comment(props) &#123; return ( &lt;div className="Comment"&gt; &lt;div className="UserInfo"&gt; &lt;Avatar user=&#123;props.author&#125; /&gt; &lt;div className="UserInfo-name"&gt; &#123;props.author.name&#125; &lt;/div&gt; &lt;/div&gt; &lt;div className="Comment-text"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className="Comment-date"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; Next, we will extract a UserInfo component that renders an Avatar next to the user’s name: 接下来，我们将会将UserInfo组件抽象出来，该组件会将Avatar呈现给旁边的用户的姓名出来： 12345678910function UserInfo(props) &#123; return ( &lt;div className="UserInfo"&gt; &lt;Avatar user=&#123;props.user&#125; /&gt; &lt;div className="UserInfo-name"&gt; &#123;props.user.name&#125; &lt;/div&gt; &lt;/div&gt; );&#125; This lets us simplify Comment even further: 这样Comment比之前更加简化了。 12345678910111213function Comment(props) &#123; return ( &lt;div className="Comment"&gt; &lt;UserInfo user=&#123;props.author&#125; /&gt; &lt;div className="Comment-text"&gt; &#123;props.text&#125; &lt;/div&gt; &lt;div className="Comment-date"&gt; &#123;formatDate(props.date)&#125; &lt;/div&gt; &lt;/div&gt; );&#125; Try it on CodePen. Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be a reusable component. 首先提取组件可能看起来像重复工作，但在更大的应用程序中，我们可以提取出可重用的部分。一个好的经验法则是，如果你的用户界面的一部分被多次使用（按钮，面板，头像），或者它本身已经足够复杂，那么它会是一个好的可重用组件的选择。 Props are Read-Only(属性是只读的)Whether you declare a component as a function or a class, it must never modify its own props. Consider this sum function: 不管您是否是通过函数或者类来声明组件的，它永远都不能修改属于它自己的参数。考虑下面的加法函数： 123function sum(a, b) &#123; return a + b;&#125; Such functions are called “pure” because they do not attempt to change their inputs, and always return the same result for the same inputs. 这样的函数是“纯函数”，因为它们不会试图改变它们的输入，并总会对于相同的输入返回相同的值。 In contrast, this function is impure because it changes its own input: 相反的，下面这个函数就是动机不纯的，因为它会改变它本身的输入： 123function withdraw(account, amount) &#123; account.total -= amount;&#125; React is pretty flexible but it has a single strict rule: React十分灵活，但是它有一个特别严格的规定： All React components must act like pure functions with respect to their props. 所有的React组件都必须表现的想一个纯函数一样，并不会修改它们的属性。 Of course, application UIs are dynamic and change over time. In the next section, we will introduce a new concept of “state”. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule. 当然，应用的UI是动态的，并且会随时间的改变而改变。在下一章节中，我们会介绍一个新的概念“状态”。状态允许React组件随着用户的动作，网络的反馈和任何其他事情的来随时改变它们的输出，并且不会违背这个规则。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.Quick Start -- 03.Rendering Elements]]></title>
    <url>%2F2018%2F05%2F04%2Freact%2F02.Quick_Start%2F03.Rendering_Elements%2F</url>
    <content type="text"><![CDATA[Rendering ElementsElements are the smallest building blocks of React apps. 元素是React 应用中最小的构建组块。 An element describes what you want to see on the screen: 以下是一个描述了您在在屏幕上想看到的元素： 1const element = &lt;h1&gt;Hello, world&lt;/h1&gt;; Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements. 不想浏览器的DOM元素，React元素是普通对象，并且很容易创建。React DOM负责更新DOM以便于匹配React元素。 Note:One might confuse elements with a more widely known concept of “components”. We will introduce components in the next section. Elements are what components are “made of”, and we encourage you to read this section before jumping ahead. 注意：人们可能会将元素与更广为人知的“组件”概念混为一谈。 我们将在下一部分介绍组件。 组件是由元素“组成”的，我们鼓励您在跳过本节之前先阅读本节内容。 Rendering an Element into the DOM(渲染一个在DOM中的元素)Let’s say there is a somewhere in your HTML file: 以下是一个在您的HTML文件中的 1&lt;div id="root"&gt;&lt;/div&gt; We call this a “root” DOM node because everything inside it will be managed by React DOM. 我们叫它为“root”DOM节点，因为它其中的所有元素都由React DOM控制。 Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like. 仅使用React构建的应用程序通常只有单个根DOM节点。如果您将React集成到现有的应用程序中，您可以根据需要选择多个独立的根DOM节点。 To render a React element into a root DOM node, pass both to ReactDOM.render(): 为了将一个React元素渲染到一个根DOM节点，将它们全部传给ReactDOM.render(): 12const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;ReactDOM.render(element, document.getElementById('root')); Try it on CodePen It displays “Hello, world” on the page. 它将会在页面上显示“Hello, world”。 Updating the Rendered Element(更新渲染的元素)React elements are immutable. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time. React元素是不可变的。一旦您创建了一个元素，您就不能改变它的子元素或者属性。一个元素就像电影里的一帧：它代表着一个特定时间点的UI。 With our knowledge so far, the only way to update the UI is to create a new element, and pass it to ReactDOM.render(). 以我们目前所有的知识，更新UI的唯一方法就是创建一个新的元素，并将它传给ReactDOM.render()。 Consider this ticking clock example: 考虑以下秒表的例子： 1234567891011function tick() &#123; const element = ( &lt;div&gt; &lt;h1&gt;Hello, world!&lt;/h1&gt; &lt;h2&gt;It is &#123;new Date().toLocaleTimeString()&#125;.&lt;/h2&gt; &lt;/div&gt; ); ReactDOM.render(element, document.getElementById('root'));&#125;setInterval(tick, 1000); Try it on CodePen It calls ReactDOM.render() every second from a setInterval() callback. 它会每秒从setInterval()函数的回调函数中调用ReactDOM.render()。 Note:In practice, most React apps only call ReactDOM.render() once. In the next sections we will learn how such code gets encapsulated into stateful components.We recommend that you don’t skip topics because they build on each other. 注意：在实际使用过程中，大多数的React应用仅仅只调用ReactDOM.render()一次。在接下来的部分中，我们将学习如何将这些代码封装到有状态的组件中。我们建议您不要跳过这些内容，因为它们互相之间都有联系。 React Only Updates What’s Necessary(React只有在必须的时候才会更新)React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state. React DOM 会将元素和它的子元素与上一个状态的元素和子元素比较，并且只在DOM必须更新的时候才会让DOM变化到期待的状态。 You can verify by inspecting the last example with the browser tools: 您可以通过浏览器工具监视最后一个例子。 Even though we create an element describing the whole UI tree on every tick, only the text node whose contents has changed gets updated by React DOM. 尽管我们创建了一个元素来描述在每秒钟的整个结构，但是只有内容改变的文本节点会被React DOM更新。 In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs. 根据我们的经验，思考如何在任何特定时刻看到UI，而不是随着时间的推移如何改变，从而消除了一整类错误。根据我们的经验，考率如何在任何特定时刻看到特定的样式，而不是随着时间的推移而变化，只有这样做才能消除了一系列相关的错误。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.Quick Start -- 02.Introducing JSX]]></title>
    <url>%2F2018%2F05%2F04%2Freact%2F02.Quick_Start%2F02.Introducing_JSX%2F</url>
    <content type="text"><![CDATA[Introducing JSXConsider this variable declaration: 考虑以下变量声明： 1const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;; This funny tag syntax is neither a string nor HTML. It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript. 它叫做JSX，并且它是基于JavaScript的语法进行扩展的。我们建议是在React中使用它来描述UI的样式。JSX也许让您想起一些模板语言，但是它具有JavaScript的全部功能。 JSX produces React “elements”. We will explore rendering them to the DOM in the next section. Below, you can find the basics of JSX necessary to get you started. JSX生成了React“元素”。我们将在下一章节内探索它是如果将React渲染到DOM上的。除此之外，您还可以学习到使用JSX的基本知识。 Why JSX?(为什么使用JSX?)React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display. React认为渲染逻辑与其他UI逻辑是有耦合的：事件如何处理，状态如何随时间变化以及数据如何准备显示。 Instead of artificially separating technologies by putting markup and logic in separate files, React separates concerns with loosely coupled units called “components” that contain both. We will come back to components in a further section, but if you’re not yet comfortable putting markup in JS, this talk might convince you otherwise. React不再人为地通过将标记和逻辑放在单独的文件中来分离技术，React通过将问题与“组件”–一个松散耦合的单元分隔开。我们将在接下来的章节内回到组件中，但如果你不习惯在JS中添加标记，那么这个话题可能会让你习惯这个改变。 React doesn’t require using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages. React不需要使用JSX，但是大多数人认为在JavaScript代码中使用它时，有助于从视觉上更清晰地理解代码。它还允许React显示更多有用的错误和警告消息。 With that out of the way, let’s get started! 那就这样，让我们开始吧！ Embedding Expressions in JSX(在JSX中嵌入表达式)You can embed any JavaScript expression in JSX by wrapping it in curly braces. 您可以用大括号在JSX中包括任何JavaScript表达式。 For example, 2 + 2, user.firstName, and formatName(user) are all valid expressions: 例如，2 + 2, user.firstName, and formatName(user)都是有效的表达式： 12345678910111213141516171819function formatName(user) &#123; return user.firstName + ' ' + user.lastName;&#125;const user = &#123; firstName: 'Harper', lastName: 'Perez'&#125;;const element = ( &lt;h1&gt; Hello, &#123;formatName(user)&#125;! &lt;/h1&gt;);ReactDOM.render( element, document.getElementById('root')); Try it on CodePen. We split JSX over multiple lines for readability. While it isn’t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of automatic semicolon insertion. 为了便于阅读，我们将JSX分成多行。虽然这不是必需的，但是我们还建议将其包装在括号内以避免自动分号插入的缺陷。 JSX is an Expression Too(JSX也是一个表达式)After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects. 在编译完后，JSX表达式会变成常规的JavaScript方法的调用，并且会转为JavaScript对象。 This means that you can use JSX inside of if statements and for loops, assign it to variables, accept it as arguments, and return it from functions: 这意味着您可以在if语句和for循环中使用JSX，将其分配给变量，将其作为参数接受，并从函数中返回： 123456function getGreeting(user) &#123; if (user) &#123; return &lt;h1&gt;Hello, &#123;formatName(user)&#125;!&lt;/h1&gt;; &#125; return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;&#125; Specifying Attributes with JSX(使用JSX指定属性)You may use quotes to specify string literals as attributes: 您可以使用引号将字符串文字指定为属性： 1const element = &lt;div tabIndex="0"&gt;&lt;/div&gt;; You may also use curly braces to embed a JavaScript expression in an attribute: 您也可以使用大括号包裹JavaScript表达式作为属性： 1const element = &lt;img src=&#123;user.avatarUrl&#125;&gt;&lt;/img&gt;; Don’t put quotes around curly braces when embedding a JavaScript expression in an attribute. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute. 当将JavaScript表达式作为属性时，不要在大括号外边加引号。您应该要么使用引号（对于字符串的值来说）或者大括号（对于表达式来说）,但是不能两者一起使用。 Warning:Since JSX is closer to JavaScript than to HTML, React DOM uses camelCase property naming convention instead of HTML attribute names.For example, class becomes className in JSX, and tabindex becomes tabIndex. 警告：因为JSX相对于HTML来说更接近于JavaScript，React Dom使用传统的驼峰命名方法来命名，而不是像HTML属性一样命名。例如，在JSX中，class应该是className，tabindex应该是tabIndex Specifying Children with JSX(用JSX指定子元素)If a tag is empty, you may close it immediately with /&gt;, like XML: 如果一个标签是空的，您应该立即使用/&gt;的方式关闭它，像XML一样： 1const element = &lt;img src=&#123;user.avatarUrl&#125; /&gt;; JSX tags may contain children: JSX标签可以包含子元素： 123456const element = ( &lt;div&gt; &lt;h1&gt;Hello!&lt;/h1&gt; &lt;h2&gt;Good to see you here.&lt;/h2&gt; &lt;/div&gt;); JSX Prevents Injection Attacks(JSX可以防止注入攻击)It is safe to embed user input in JSX: 将用户输入置于JSX中是安全的： 123const title = response.potentiallyMaliciousInput;// This is safe:const element = &lt;h1&gt;&#123;title&#125;&lt;/h1&gt;; By default, React DOM escapes any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent XSS (cross-site-scripting) attacks. 默认情况下，React DOM在渲染之前会转义嵌入在JSX中的任何值。因此它确保您永远不会注入任何未明确的写入应用程序中的内容。在呈现之前，所有内容都会转换为字符串。这有助于防止XSS(跨站点脚本)攻击。 JSX Represents Objects(JSX表示对象)Babel compiles JSX down to React.createElement() calls. Babel会将JSX编译成React.createElement()的调用。 These two examples are identical: 以下两个例子是一样的： 12345const element = ( &lt;h1 className="greeting"&gt; Hello, world! &lt;/h1&gt;); 12345const element = React.createElement( 'h1', &#123;className: 'greeting'&#125;, 'Hello, world!'); React.createElement() performs a few checks to help you write bug-free code but essentially it creates an object like this: React.createElement()会执行一些检查来帮助您编写无错代码，但本质上它会创建一个如下所示的对象： 12345678// Note: this structure is simplifiedconst element = &#123; type: 'h1', props: &#123; className: 'greeting', children: 'Hello, world!' &#125;&#125;; These objects are called “React elements”. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date. 这些对象被称为“React元素”。你可以把它们想象成你想要在屏幕上看到的东西。React会读取这些对象并使用它们来构建DOM并使其保持最新状态。 We will explore rendering React elements to the DOM in the next section. 我们将会在下一章里探索如何在DOM中渲染React元素。 Tip:We recommend using the “Babel” language definition for your editor of choice so that both ES6 and JSX code is properly highlighted. This website uses the Oceanic Next color scheme which is compatible with it.提示：我们将以使用“Babel”语言定义作为您的编译器，以便正确突出显示ES6和JSX代码。本网站采用与其兼容的Oceanic Next色彩方案。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[02.Quick Start -- 01.Hello World]]></title>
    <url>%2F2018%2F05%2F04%2Freact%2F02.Quick_Start%2F01.Hello_World%2F</url>
    <content type="text"><![CDATA[Hello WorldThe easiest way to get started with React is to use this Hello World example code on CodePen. You don’t need to install anything; you can just open it in another tab and follow along as we go through examples. If you’d rather use a local development environment, check out the Installation section. 开始学习React最简单的方式是使用Codepen上的Hello World的例子。您不必安装任何东西；您只需要在另一个窗口打开就能查看我们写下的例子。如果您想在本地搭建环境，请查看安装章节。 The smallest React example looks like this: 最小的React例子像这个样子： 1234ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root')); It renders a heading saying “Hello, world!” on the page. 它将会在页面上渲染一个写着“Hello World”的标题。 The next few sections will gradually introduce you to using React. We will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces. 接下来的章节将会逐渐向您介绍如何使用React。我们将检查React应用程序的构建部分：元素和组件。一旦您掌握了它们，您就可以通过小型可重复使用的部分创建复杂的应用程序。 A Note on JavaScript(一个关于JavaScript的注意点)React is a JavaScript library, and so we’ll assume you have a basic understanding of the JavaScript language. If you don’t feel very confident, we recommend refreshing your JavaScript knowledge so you can follow along more easily. React是一个JavaScript库，因此我们假设您对于JavaScript语言有一个基本的了解。如果您不是很自信，我们建议您重新回顾JavaScript的相关知识，以便能让您在接下来的内容上更容易。 We also use some of the ES6 syntax in the examples. We try to use it sparingly because it’s still relatively new, but we encourage you to get familiar with arrow functions, classes, template literals, let, and const statements. You can use the Babel REPL to check what ES6 code compiles to. 我们在案例中也使用了一些ES6的语法。我们尽量少的使用它们，因为它们还相对较新，但是我们还是建议您熟悉箭头函数，类，模板字面量，let和const等概念。您可以使用Babel REPL来查看ES6代码编译过后的结果。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.Try React -- 04.CDN Links]]></title>
    <url>%2F2018%2F05%2F03%2Freact%2F01.Try_React%2F04.CDN_Links%2F</url>
    <content type="text"><![CDATA[CDN Links(CDN链接)The UMD builds of React and ReactDOM are available over a CDN. React和ReactDOM的UMD版本可通过CDN获得。 12&lt;script crossorigin src="https://unpkg.com/react@16/umd/react.development.js"&gt;&lt;/script&gt;&lt;script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.development.js"&gt;&lt;/script&gt; The versions above are only meant for development, and are not suitable for production. 以上版本仅用于开发，不适合生产。 Minified and optimized production versions of React are available at: 缩小和优化的React生产版本可以用以下方式获得： 12&lt;script crossorigin src="https://unpkg.com/react@16/umd/react.production.min.js"&gt;&lt;/script&gt;&lt;script crossorigin src="https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"&gt;&lt;/script&gt; To load a specific version of react and react-dom, replace 16 with the version number. 如果要加载特定版本的react和react-dom，请将16替换为对应的版本号。 Why the crossorigin Attribute?(为什么要设置crossorigin属性?)If you serve React from a CDN, we recommend to keep the crossorigin attribute set: 如果您使用基于CDN的React，我们建议保留crossorigin属性集： 1&lt;script crossorigin src="..."&gt;&lt;/script&gt; We also recommend to verify that the CDN you are using sets the Access-Control-Allow-Origin: * HTTP header: 我们还建议验证您使用的CDN是否设置了Access-Control-Allow-Origin：* HTTP标头： This enables a better error handling experience in React 16 and later. 这可以保证在React16或更高的版本上有一个更好的错误处理方法。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.Try React -- 03.Add React to an Existing Application]]></title>
    <url>%2F2018%2F05%2F03%2Freact%2F01.Try_React%2F03.Add_React_to_an_Existing_Application%2F</url>
    <content type="text"><![CDATA[Add React to an Existing Application(在一个已存的项目中添加React)You don’t need to rewrite your app to start using React. 您不必重写您的应用程序来开始使用React We recommend adding React to a small part of your application, such as an individual widget, so you can see if it works well for your use case. 我们建议将React添加到应用程序中的一小部分中，例如单个小部件，以便您可以查看它是否适合您的用例。 While React can be used without a build pipeline, we recommend setting it up so you can be more productive. A modern build pipeline typically consists of: 虽然可以在没有构建通道的情况下使用React，但我们建议设置通道，以此来提高生产力。现代构建通道通常由以下部分组成： A package manager, such as Yarn or npm. It lets you take advantage of a vast ecosystem of third-party packages, and easily install or update them. A bundler, such as webpack or Browserify. It lets you write modular code and bundle it together into small packages to optimize load time. A compiler such as Babel. It lets you write modern JavaScript code that still works in older browsers. 一个包管理器，如Yarn或npm。它可让您充分利用第三方软件包的完整的生态系统，并轻松安装或更新它们。 一个捆绑器，如webpack或Browserify。它允许您编写模块化代码，并将它们组合在一起成为小包，以优化加载时间。 一个编辑器,如Babel。它可以让你在旧版浏览器中仍然可以使用的现代JavaScript代码。 Installing React(安装React) Note: Once installed, we strongly recommend setting up a production build process to ensure you’re using the fast version of React in production.注意:一旦完成安装，我们强烈建议您设置生成的构建流程，以此确保您可以在开发环境中使用更快版本的React。 We recommend using Yarn or npm for managing front-end dependencies. If you’re new to package managers, the Yarn documentation is a good place to get started. 我们建议使用Yarn或者npm来管理前端依赖。如果您是新接触包管理器的开发者，Yarn的文档是一个开始学习的不错的地方。 To install React with Yarn, run: 使用Yarn安装React，请运行： 12yarn inityarn add react react-dom 如果使用npm安装React，请运行：12npm initnpm install --save react react-dom Both Yarn and npm download packages from the npm registry. Yarn和npm都从npm注册表中下载软件包。 Note:To prevent potential incompatibilities, all react packages should use the same version. (This includes react, react-dom, react-test-renderer, etc.) 注意：为了避免潜在的不兼容性，所有的react包都应该使用相同的版本。（这包括react, react-dom, react-test-renderer等等。） Enabling ES6 and JSX(启用ES6和JSX)We recommend using React with Babel to let you use ES6 and JSX in your JavaScript code. ES6 is a set of modern JavaScript features that make development easier, and JSX is an extension to the JavaScript language that works nicely with React. 我们建议在React上使用Babel以便让您在您的JavaScript代码中使用ES6和JSX。ES6包括一系列的现代化JavaScript特性，以便让开发更容易，并且JSX是一个JavaScript语言的扩展，以便让React工作更方便。 The Babel setup instructions explain how to configure Babel in many different build environments. Make sure you install babel-preset-react and babel-preset-env and enable them in your .babelrc configuration, and you’re good to go. Babel设置介绍解释了如何在许多不同的构建环境中配置Babel。以此可以确保您安装了babel-preset-react和babel-preset-env，并在你的.babelrc configuration中启用它们，并且可以方便访问。 Hello World with ES6 and JSX(使用ES6和JSX编写Hello World)We recommend using a bundler like webpack or Browserify, so you can write modular code and bundle it together into small packages to optimize load time. 我们建议使用像webpack或者Browserify这样的捆绑器，这样您就可以编写现代化代码并将他们绑定在小的包上以优化加载时间。 The smallest React example looks like this： 最小的React案例如下： 1234567import React from 'react';import ReactDOM from 'react-dom';ReactDOM.render( &lt;h1&gt;Hello, world!&lt;/h1&gt;, document.getElementById('root')); This code renders into a DOM element with the id of root, so you need somewhere in your HTML file. 这些代码会在一个id为root的DOM元素上渲染，所以您需要在您的HTML文件上有。 Similarly, you can render a React component inside a DOM element somewhere inside your existing app written with any other JavaScript UI library. 相似的，您可以在现有的，由其他任何JavaScript UI库编写的应用程序内的某个DOM元素内部渲染一个React组件。 Learn more about integrating React with existing code. 了解有关将React与现有代码集成的更多信息。 A Complete Example(一个完整的例子)You can find step-by-step instructions detailing a basic implementation from scratch, including Babel and Webpack setup here. 您可以从零开始找到详细的说明,这也包括如何设置Babel和Webpack。 Development and Production Versions(开发和生成环境的版本)By default, React includes many helpful warnings. These warnings are very useful in development. 通常情况下，React包括许多有用的警告。这些警告对于开发非常有用。 However, they make the development version of React larger and slower so you should use the production version when you deploy the app. 但是，它们会使React的开发版本变得更大并且更慢，所以当您部署应用程序时，请使用生产版本 Learn how to tell if your website is serving the right version of React, and how to configure the production build process most efficiently: 了解如何判断您的网站是否提供正确版本的React，以及如何最有效地配置生产构建过程： Creating a Production Build with Create React App Creating a Production Build with Single-File Builds Creating a Production Build with Brunch Creating a Production Build with Browserify Creating a Production Build with Rollup Creating a Production Build with webpack 使用Create React App来实现生产环境的构建 使用单个文件构建来实现生产环境构建 使用Brunch来实现生产环境的构建 使用Browserify来实现生产环境的构建 使用Rollup来实现生产环境的构建 使用webpack来实现生产环境的构建 Using a CDN(使用CDN)If you don’t want to use npm to manage client packages, the react and react-dom npm packages also provide single-file distributions in umd folders. See the CDN page for links. 如果您不想用npm来管理客户端的包，react和react-dom的npm的包也提供在umd单个文件的发布。请CDN查看相关链接。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.Try React -- 02.Add React to a New Application]]></title>
    <url>%2F2018%2F05%2F03%2Freact%2F01.Try_React%2F02.Add_React_to_a_New_Application%2F</url>
    <content type="text"><![CDATA[Add React to a New Application(在一个新的应用上添加React)The easiest way to get started on a new React project is by using a starter kit. 最简单的开始一个新的React项目的方式是使用一个入门套件。 Note:This page describes setting up a single-page application with everything you need for a comfortable development workflow, including linting, testing, production optimizations, and more. Full-featured tools like these require some time and disk space to install.If you are looking for a lightweight environment to experiment with React, check out the Try React page instead. A single HTML file is enough to get you started!Finally, if you’re not building a single-page application, you can either add React to your existing build pipeline or use it from CDN and without a build step. 注意:本页面介绍如何设置一个单页面应用程序，其中包含您需要的所有功能以实现完整的开发工作流程，包括linting，测试，生产优化等。像这些包括全功能的工具需要一些时间和磁盘空间来安装。如果您在寻找一个轻量级的环境来使用React，请查看尝试React页面。一个简单的HTML文件足以让您开始入门！最后，如果您不是在搭建一个单页面的应用，您可以查看将React添加到您现存的环境上 or 从CDN使用React and 不适用搭建步骤. Create React App(创建React应用)Create React App is the best way to start building a new React single page application. It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You’ll need to have Node &gt;= 6 on your machine. 创建React应用是开始构建新的React单页应用程序的最佳方式。 它为您设置好了开发环境，以便您可以使用最新的JavaScript功能，为开发者提供了良好的体验并从生产环境上优化了您的应用程序。注意您需要保证您的开发机上的node版本大于等于6。 12345npm install -g create-react-appcreate-react-app my-appcd my-appnpm start If you have npm 5.2.0+ installed, you may use npx instead. 如果您安装的npm版本号为5.2.0+，您也可以使用npx。 1234npx create-react-app my-appcd my-appnpm start Create React App doesn’t handle backend logic or databases; it just creates a frontend build pipeline, so you can use it with any backend you want. It uses build tools like Babel and webpack under the hood, but works with zero configuration. 创建React应用不会处理后端逻辑或者数据库；它只是创建了一个前端构建通道，所以您可以使用任何您相适应的后端语言。它基于钩子上使用像Babel和Webpack这样的构建工具，但是在使用是时为不需要配置。 When you’re ready to deploy to production, running npm run build will create an optimized build of your app in the build folder. You can learn more about Create React App from its README and the User Guide. 当您准备部署到生产环境时，您可以运行npm run build，在build文件夹中创建一个优化的应用程序版本。您可以从README和用户指南中了解有关创建React应用程序的更多信息。 Other Starter Kits(其他的入门套件)We have created a curated list of third-party starter kits that we officially recommend. 我们已经创建了我们正式推荐的第三方入门套件的策划清单。 They slightly differ in their focus but are all production-ready, well-maintained, and don’t require configuration to get started. 他们的重点略有不同，但在生成环境上准备就绪，并且维护良好的，不需要配置即可开始使用。 You can also check out a list of other kits contributed by the community. 您还可以查看社区贡献的其他工具包列表。 Advanced(高级)If you prefer to configure a project manually, see Installing React in the next section. 如果您想人工配置一个项目，请在下一章节中查看安装React。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[01.Try React -- 01.Add React To A New App]]></title>
    <url>%2F2018%2F05%2F03%2Freact%2F01.Try_React%2F01.Add_React_To_A_New_App%2F</url>
    <content type="text"><![CDATA[Try React(尝试使用React)Try React online or set up your local development environment. 设置在线的react或您本地的react环境。 Online(在线)If you’re just interested in playing around with React, you can use an online code playground. Try a Hello World template on CodePen or CodeSandbox. 如果您只是对如何使用React有兴趣，您可以使用在线的编码器。您可以在CodePen或者 CodeSandbox上尝试Hello World模板。 Minimal HTML Template(最小的HTML模板)If you prefer to use your own text editor, you can also download this HTML file, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so don’t use it in production. 如果您倾向于使用您自己的文本编辑器，您可以下载该HTML文件，编辑它并用浏览器在您本地文件系统上打开它。它会花费比较长的时间用来进行代码转换，所以不要在应用产品层上使用它。 Next Steps(下一步)Quick Start Head over to the Quick Start section for a step-by-step introduction to React concepts. Try the Tutorial for a hands-on practical example. 从快速开始部分，开始一步一步地熟悉React的内容。 尝试教程部分，开始上手的练习。 Complete Development Environment(完成开发环境)The lightweight solutions above are the best fit if you are new to React or just experimenting. 如果您是新接触React，或者只是想尝试一下React的话，这种轻量级解决方案是最适合的。 When you are ready to build your first application with React, check out the install guides below. These setups are designed to get you up and running with a great developer experience and are ready for production. They include linting, testing, and optimizations built-in; however, they require more time and disk space to set up and install. 当您开始准备使用React搭建您第一个应用时，请先阅读下面的安装指南。这些步骤的目的是在让您在开发过程中获得丰富的开发体验，并且可以随时投入生产环境中使用。它们包括linting，测试和内置优化; 但是，它们需要更多时间和磁盘空间来设置和安装。 Add React to a New App: Create a new app with a fully-featured starter kit. Add React to an Existing App: Add React to a build system or a larger app. Add React to a New App:使用包括全套功能的入门套件来创建新应用程序。 Add React to an Existing App:构建系统或更大的应用程序上添加使用React。]]></content>
      <categories>
        <category>react document</category>
      </categories>
      <tags>
        <tag>react document</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript对象与继承---单一继承.md]]></title>
    <url>%2F2018%2F03%2F16%2Fblog%2Fproblem%2FJavascript_Objects_and_Inheritance%2F</url>
    <content type="text"><![CDATA[JavaScript对象与继承–单一对象说真的，这次的博客我写了三个小时硬是一点都没写出来，洋洋洒洒把自己最近的心情写了1000多字，但是感觉自己太幼稚，又删了;然后打算写大三时候给前女友写的主界面和音乐播放器，想了想，算了吧，往事随风，又删了，现在两手空空，然后纠结了半个小时，只能是写写无关痛痒的问题。 哈哈哈在一小时后我终于找到了这个比较符合我的情况的内容哈哈哈 原文在Objects and Inheritance中,不容易呀。 概括的讲所有的js对象都是从字符串到值的映射，一个对象中的某一项（键，值对）称作对象的属性。属性的key始终是一个字符串而值可以是任何js值，包括函数。方法是指值为函数的属性。 属性的种类三种属性: 属性（Properties，或称为数据属性） 普通属性，在一个对象里面的一个键值对包括方法，最常用属性。 访问器(Accessors，或者叫访问属性) 类似于读写属性的特殊方法。属性值存在普通属性中，而访问属性可以计算他们的值。你可以把他们看作是虚拟的属性，比如（getter 和 setter）. 内置属性(Internal property) 只存在于ECMAscript规范当中，他们不能被js直接访问，但可以间接的方式访问到。规范里规定将这种属性放在[[]]当中，比如[[Property]]吃有一个对象的原型，它可以通过Object.getPrototypeOf() 访问到。 对象字面量JavaScript对象字面量允许你直接的创建简单的对象（Object直接实例）。 EX:123456var jane = &#123; name: 'Jane', describe: function () &#123; return 'Person named '+this.name; // (1) &#125;, // (2)&#125;; 你可能有这样的印象，对象仅仅是字符串到值的映射。事实上远不止这些，有一些真正意义上的通用对象。 比如你可以做对象的继承，还可以保护对象不被修改。直接创建对象的功能是标准的js特性之一：你可以在没有类的前提下创建一个正确的对象，然后再对他进行抽象。 例如：构造函数（constructors）大体和其他语言的类相似，我们在后面会讲到。 点运算符 (.): 通过固定值来访问属性点运算符提供了一种简洁的语法来访问属性,属性的名称必须是合法标识符. 你可以用中括号来读写任意名称的属性. 1234567var jane = &#123; name: 'Jane', describe: function () &#123; return 'Person named '+this.name; &#125;&#125;; 获取属性点操作符获取属性 (读值).例如: 1234&gt; jane.name // get property `name`'Jane'&gt; jane.describe // get property `describe`[Function] 如果属性不存在则返回 undefined: 12&gt; jane.unknownPropertyundefined 调用方法也可以调用方法: 12&gt; jane.describe() // call method `describe`'Person named Jane' 设置属性可以用赋值符=来给.指向的属性赋值: 123&gt; jane.name = 'John'; // set property `name`&gt; jane.describe()'Person named John' 如果设置的属性不存在在赋值的时候就自动创建一个属性.如果存在就修改该属性。 删除属性delete操作符可以完全的从对象里面删除一个属性（键值对）： 12345&gt; var obj = &#123; hello: 'world' &#125;;&gt; delete obj.hellotrue&gt; obj.helloundefined 如果你仅仅给一个属性设置为undefined，这个属性会仍然存在，而且这个对象包含这个键： 1234&gt; var obj = &#123; foo: 'a', bar: 'b' &#125;;&gt; obj.foo = undefined;&gt; Object.keys(obj)[ 'foo', 'bar' ] 但是如果你将属性删除那么他的键就不存在了 1234&gt; delete obj.footrue&gt; Object.keys(obj)[ 'bar' ] delete只影响一个对象的直接属性（非继承的，自有属性）。并不会删除对象的原型。 Tip:慎用delete操作符，大多数现代化js引擎都会针对构造函数的创建实例进行优化，前提是这些实例不会发生形态改变（就是说没有删除或者添加属性的），但是删除属性会破坏这种优化。 delete的返回值如果属性是一个自有属性且不能删除，那么delete会反回false，其他情况返回true。例子：作为准备，我们用Object.defineProperty创建一个不被删除自有属性 123456789var obj = &#123;&#125;;Object.defineProperty(obj, 'canBeDeleted', &#123; value: 123, configurable: true&#125;);Object.defineProperty(obj, 'cannotBeDeleted', &#123; value: 456, configurable: false&#125;); delete cannotBeDeleted 时候返回 false : 12&gt; delete obj.cannotBeDeletedfalse 其他情况下delete 返回 true: 1234&gt; delete obj.doesNotExisttrue&gt; delete obj.canBeDeletedtrue 即使delete没有起作用也会返回true (继承的属性是不会被移除的): 1234&gt; delete obj.toStringtrue&gt; obj.toString // still there[Function: toString] 特殊属性键虽然你不能使用保留字作为变量名，但是你可以把他们作为属性键。 12345&gt; var obj = &#123; var: 'a', function: 'b' &#125;;&gt; obj.var'a'&gt; obj.function'b' 数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用[]来访问：12345&gt; var obj = &#123; 0.7: 'abc' &#125;;&gt; Object.keys(obj)[ '0.7' ]&gt; obj['0.7']'abc' 对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用[]来访问。12345&gt; var obj = &#123; 'not an identifier': 123 &#125;;&gt; Object.keys(obj)[ 'not an identifier' ]&gt; obj['not an identifier']123 中括号 ([]): 通过计算出来的键访问属性中括号可以通过表达式引用一个属性。 用中括号获取属性：12345678&gt; var obj = &#123; someProperty: 'abc' &#125;;&gt; obj['some' + 'Property']'abc'&gt; var propKey = 'someProperty';&gt; obj[propKey]'abc' 非标识符:123&gt; var obj = &#123; 'not an identifier': 123 &#125;;&gt; obj['not an identifier']123 表达式，转换成字符串:123&gt; var obj = &#123; '6': 'bar' &#125;;&gt; obj[3+3] // key: the string '6''bar' 用中括号调用方法123&gt; var obj = &#123; myMethod: function () &#123; return true &#125; &#125;;&gt; obj['myMethod']()true 用中括号设置属性1234&gt; var obj = &#123;&#125;;&gt; obj['anotherProperty'] = 'def';&gt; obj.anotherProperty'def' 用中括号删除属性1234567&gt; var obj = &#123; 'not an identifier': 1, prop: 2 &#125;;&gt; Object.keys(obj)[ 'not an identifier', 'prop' ]&gt; delete obj['not an identifier']true&gt; Object.keys(obj)[ 'prop' ]]]></content>
      <categories>
        <category>前端常见问题</category>
      </categories>
      <tags>
        <tag>前端问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Javascript闭包及相关问题]]></title>
    <url>%2F2018%2F03%2F09%2Fblog%2Fproblem%2FJavascript%E9%97%AD%E5%8C%85%2F</url>
    <content type="text"><![CDATA[Javascript闭包及相关问题基本概念：闭包是指有权访问另一个函数作用域中的变量的函数。 当某个函数第一次被调用时，会创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性[[scope]]。然后使用this，arguments和其他的值初始化函数的活动对象。 12345678910function compare(value1, value2) &#123; if(value1 &lt; value2) &#123; return -1; &#125; else if(value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125;&#125;var result = compare(5,10); 在全局作用域中调用了compare函数，会创建一个compare的活动对象，其中会包含this，arguments，value1，value2，而在全局执行环境中，会有this，result，arguments，位于作用域链的第二层。 后台在每个执行环境中都有一个表示变量的对象–变量对象。全局环境的变量对象始终存在，而局部环境的变量对象在函数执行时存在。 在创建compare函数时，会创建一个包含全局变量对象的活动对象，此时活动对象指向作用域链，而作用域链指向[[scope]]属性。当调用compare函数时，会创建一个compare的执行环境，这个执行环境会复制函数的[[scope]]属性中的作用域链，之后这个局部作用域链会被推入执行环境作用域链的前端，所以，对于compare函数而言，其作用域链包含本地活动对象和全局变量对象。因此，作用域链的本质是一个指向变量对象的指针列表，只引用，但不包含变量对象。 正常情况下，在函数中访问变量，会沿着作用域链搜索对应名字的变量。一般在函数执行完后，局部活动对象就会被销毁，内存中只有全局作用域。 闭包：在另一个函数内部定义的函数会将包括它的函数的活动对象添加到它的作用域上。 12345678910111213function createComparisonFunction(propertyName) &#123; return function(object1, object2) &#123; var value1 = object1[propertyName]; var value2 = object2[propertyName]; if(value1 &lt; value2) &#123; return -1; &#125; else if(value1 &gt; value2) &#123; return 1; &#125; else &#123; return 0; &#125; &#125;;&#125; 注意，在return一个匿名函数后，要添加上’;’ 当执行以下两部操作时：12var compareName = createComparisonFunction('name');var result = compare(&#123;name:'lpld'&#125;, &#123;name:'plws'&#125;); 在compare()时，向上面一样，会有全局活动对象和局部活动对象两个作用域链，而根据上面说的闭包的内容：在另一个函数内部定义的函数会将包括它的函数的活动对象添加到它的作用域上。对于result而言，是createComparisonFunction的返回函数，所以也包括了compare的活动对象。所以，当createComparisonFunction返回后，其执行环境的作用域链会被销毁，但是其活动对象会留在内存中。因为在匿名函数中会把其活动对象添加到匿名函数的作用域链上。 因此，在执行compareName = null;相当于解除匿名函数的作用域链，至此该匿名函数作用域链上的活动对象（也包括外部函数内的活动对象）也都会释放。 闭包缺点：闭包会携带包含它的函数的作用域，换句话说，是会保留包括它的函数的活动对象。因此会占用更多的内存。（在外部函数没有被释放时，也会在内部函数的作用域链上生成新的外部函数的活动对象，会产生新的内存）。 this对象： this永远指向调用它的函数 1234567891011121314151617181920212223241.var name = 'The Window';var object = &#123; name : 'My Object', getNameFunc : function()&#123; return function() &#123; return this.name; &#125;; &#125; &#125;;alert(object.getNameFunc()());//The Window2.var name = 'The Window';var object = &#123; name : 'My Object', getNameFunc : function()&#123; var that = this; return function()&#123; return that.name; &#125;; &#125;&#125;;alert(object.getNameFunc()());//My Object 根据书中的内容，匿名函数的执行环境具有全局性，所以第一个返回的是window，第二个是object，在执行函数时，当执行到object.getNameFunc()时，此时的name对应的是object，这时执行匿名函数，相当于返回全局中的name，即是window。]]></content>
      <categories>
        <category>前端常见问题</category>
      </categories>
      <tags>
        <tag>前端问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[JavaScript学习笔记（1）]]></title>
    <url>%2F2018%2F03%2F02%2Fblog%2Fproblem%2FJavaScript%E5%9F%BA%E6%9C%AC1%2F</url>
    <content type="text"><![CDATA[JavaScrip学习笔记（1）JavaScript函数表达式和函数声明首先，来了解一下函数表达式和函数声明： 在ECMAScript中，创建函数的最常用的两个方法是函数表达式和函数声明，两者还是有一定的区别，在ECMA规范中提到：函数声明必须带有标示符（Identifier）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符，即： 函数声明: function 函数名称 (参数：可选){ 函数体 } 函数表达式： function 函数名称（可选）(参数：可选){ 函数体 } 所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称，ECMAScript是通过上下文来区分的，如果function foo(){}是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。 123456function foo()&#123;&#125; // 声明，因为它是程序的一部分var bar = function foo()&#123;&#125;; // 表达式，因为它是赋值表达式的一部分new function bar()&#123;&#125;; // 表达式，因为它是new表达式(function()&#123; function bar()&#123;&#125; // 声明，因为它是函数体的一部分&#125;)(); 还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式，我们来看几个例子： 12345678function foo()&#123;&#125; // 函数声明(function foo()&#123;&#125;); // 函数表达式：包含在分组操作符内try &#123; (var x = 5); // 分组操作符，只能包含表达式而不能包含语句，这里的var就是语句&#125; catch(err) &#123;// SyntaxError&#125; 在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：eval(‘(‘ + json + ‘)’)，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。 1234567try &#123; &#123; "x": 5 &#125;; // "&#123;" 和 "&#125;" 做解析成代码块 &#125; catch(err) &#123; // SyntaxError &#125; (&#123; "x": 5 &#125;); // 分组操作符强制将"&#123;" 和 "&#125;"作为对象字面量来解析 表达式和声明存在着十分微妙的区别，函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值，也就是所谓的函数提升。参考如下例子，函数fn是在alert之后声明的，但是在alert执行的时候，fn已经有定义了： 1234alert(fn());function fn() &#123; return 'Hello world!';&#125; 还有一点，函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式： 12345678910111213141516171819202122232425262728// 千万别这样做！// 因为有的浏览器会返回first的这个function，而有的浏览器返回的却是第二个if (true) &#123; function foo() &#123; return 'first'; &#125;&#125;else &#123; function foo() &#123; return 'second'; &#125;&#125;foo();// 相反，这样情况，我们要用函数表达式var foo;if (true) &#123; foo = function() &#123; return 'first'; &#125;;&#125;else &#123; foo = function() &#123; return 'second'; &#125;;&#125;foo(); 函数声明的实际规则如下： 函数声明只能出现在程序或函数体内。从句法上讲，它们 不能出现在Block（块）（{ … }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含Statement语句， 而不能包含函数声明这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让表达式出现在Block（块）中情形，就是让它作为表达式语句的一部分。但是，规范明确规定了表达式语句不能以关键字function开头。而这实际上就是说，函数表达式同样也不能出现在Statement语句或Block（块）中（因为Block（块）就是由Statement语句构成的）。 函数表达式的命名函数表达式在实际应用中还是很常见的，但由于这种方式都是在同一作用域内，所以基本上一定要用函数表达式： 12345678910111213141516171819 var contains = (function() &#123; var docEl = document.documentElement; if (typeof docEl.compareDocumentPosition != 'undefined') &#123; return function(el, b) &#123; return (el.compareDocumentPosition(b) &amp; 16) !== 0; &#125;; &#125; else if (typeof docEl.contains != 'undefined') &#123; return function(el, b) &#123; return el !== b &amp;&amp; el.contains(b); &#125;; &#125; return function(el, b) &#123; if (el === b) return false; while (el != b &amp;&amp; (b = b.parentNode) != null); return el === b; &#125;;&#125;)(); 提到命名函数表达式，理所当然，就是它得有名字，前面的例子var bar = function foo(){};就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效： 123456var f = function foo()&#123; return typeof foo; // foo是在内部作用域内有效&#125;;// foo在外部用于是不可见的typeof foo; // "undefined"f(); // "function" 原型和原型链首先，我们可以从这几个方面理解： 1.原型使用方式1： 12345678910111213var Calculator = function (decimalDigits, tax) &#123; this.decimalDigits = decimalDigits; this.tax = tax;&#125;;//然后，通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象的原型。Calculator.prototype = &#123; add: function (x, y) &#123; return x + y;&#125;, subtract: function (x, y) &#123; return x - y; &#125;&#125;; 这样，就可以new Calculator对象以后，就可以调用add方法来计算结果了。 2.原型使用方式2： 123456789101112Calculator.prototype = function () &#123; add = function (x, y) &#123; return x + y; &#125;, subtract = function (x, y) &#123; return x - y; &#125; return &#123; add: add, subtract: subtract &#125;&#125; (); 这样我们可以new Calculator对象以后调用add方法来计算结果了。 以上有一个限制就是一次性设置了原型对象，我们再来说一下如何分开设置原型的每个属性吧。 12345678910111213var BaseCalculator = function () &#123; //为每个实例都声明一个小数位数 this.decimalDigits = 2;&#125;;//使用原型给BaseCalculator扩展2个对象方法BaseCalculator.prototype.add = function (x, y) &#123; return x + y;&#125;;BaseCalculator.prototype.subtract = function (x, y) &#123; return x - y;&#125;; 首先，声明了一个BaseCalculator对象，构造函数里会初始化一个小数位数的属性decimalDigits，然后通过原型属性设置2个function，分别是add(x,y)和subtract(x,y)，当然你也可以使用前面提到的2种方式的任何一种，我们的主要目的是看如何将BaseCalculator对象设置到真正的Calculator的原型上。 123456789101112var BaseCalculator = function() &#123; this.decimalDigits = 2;&#125;;BaseCalculator.prototype = &#123; add: function(x, y) &#123; return x + y; &#125;, subtract: function(x, y) &#123; return x - y; &#125;&#125;; 创建完上述代码以后123456var Calculator = function () &#123; //为每个实例都声明一个税收数字 this.tax = 5;&#125;;Calculator.prototype = new BaseCalculator(); 我们可以看到Calculator的原型是指向到BaseCalculator的一个实例上，目的是让Calculator集成它的add(x,y)和subtract(x,y)这2个function，还有一点要说的是，由于它的原型是BaseCalculator的一个实例，所以不管你创建多少个Calculator对象实例，他们的原型指向的都是同一个实例。 1234var calc = new Calculator();alert(calc.add(1, 1));//BaseCalculator 里声明的decimalDigits属性，在 Calculator里是可以访问到的alert(calc.decimalDigits); 上面的代码，运行以后，我们可以看到因为Calculator的原型是指向BaseCalculator的实例上的，所以可以访问他的decimalDigits属性值，如果我不想让Calculator访问BaseCalculator的构造函数里声明: 12345var Calculator = function () &#123; this.tax= 5;&#125;;Calculator.prototype = BaseCalculator.prototype; 通过将BaseCalculator的原型赋给Calculator的原型，这样你在Calculator的实例上就访问不到那个decimalDigits值了，如果你访问如下代码，那将会提升出错。 123var calc = new Calculator();alert(calc.add(1, 1));alert(calc.decimalDigits); 先是这部分内容，看的有些部分没有懂还没有写完，等第二版到了读第二版吧。。。]]></content>
      <categories>
        <category>前端常见问题</category>
      </categories>
      <tags>
        <tag>前端问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[2.5~2.9所遇问题]]></title>
    <url>%2F2018%2F02%2F09%2Fblog%2Fproblem%2F2.5~2.9_questions%2F</url>
    <content type="text"><![CDATA[2.5~2.9所遇问题一.开发所遇问题在这次开发过程中，是真正自己做的第一个迭代版本，在开发中主要遇到的问题有：从理清思路到代码的实现；代码的格式规范与模块化；如何与后台人员沟通好。 1.从理清思路到代码的实现 这部分内容主要是因为自己以前写的代码只考虑到最后呈现的效果，没有具体深入探讨如何高效的写代码，拿生庆哥的话讲就是：没有真正明白要做什么。这个做什么不仅仅是你要实现的效果是什么，还包括你对整体项目的思路。之前我写代码都是只想到大概有哪些代码块，但是几个代码块传参是什么，怎么传，情况考虑全不全，整体的逻辑也是只有个大概的印象就开始动手，造成的结果就是每个代码块之间都有一定的耦合，没有全部拆分开，这造成的结果就是会有很多重复的代码，本来能拆分成函数的内容都没有抽象出来，每个函数功能目的不明确，有很多“胶水代码”，归根结底是因为一开始太着急动手，写代码时又没有细究逻辑，功能是完成了，但过不了组内review的关卡，所以总结一句话：解决问题从源头开始，这次实现代码后发现，原本想象的多复杂多复杂的代码，其实并没有想象中那么难，只要逻辑正确，思路正确其实还是很好解决的。 2.代码的格式规范与模块化 这次写代码的过程真真切切的明白了一个道理：良好的命名的重要性，因为一开始想的功能不全，所以在中途添加了不少变量，这就造成了不断添加变量，但是因为函数的功能性不清晰，所以在定义变量的时候又会有代码名称比较接近的结果，一开始还没觉得什么，但是写的稍微多一点就会发现，自己不知道当时为什么要用这个变量名定义了，虽然名称有一定的含义，但是有一个变量名跟预期的函数功能还是有偏差，还得重新看一遍代码的过程，也是一个不好的习惯。 3.如何与后台人员沟通 因为这次的后台是千仪哥提供的，自己刚刚来，总是觉得千仪哥做的肯定没问题，所以在看接口的时候当不满足自己这边的需求时，在检查完对应的接口功能发现有问题时，先自己偷偷的看能不能自己生产这样的过程。在中间造成了不小的麻烦，经过这件事懂得了：尊重规范，按规范办事，这样才是解决问题最有效也是最便捷的方法。 二.如何生成一个比1px更短的边框因为css提供最短的就是1px的长度，这也是屏幕的最短像素，所以要生成1px的边框长度也是有一定的技巧的； 1.使用rgba，通过添加透明度来在视觉上减少边框的长度。 这个是没什么好说的，效果虽然有，但是不是一个好的解决方法。 2.利用box-shadow实现窄边框1box-shadow:0 0 1px 0 red 利用了盒子阴影绘制。可以用于各种场景。但是最后的颜色会变暗，而且box-shadow不占位置，语义化不符合标准。不是实际意义的边框。 3.多背景渐变实现 12345background:linear-gradient(180deg, red, red 50%, transparent 50%) top left / 100% 1px no-repeat, linear-gradient(90deg, red, red 50%, transparent 50%) top right / 1px 100% no-repeat, linear-gradient(0deg, red, red 50%, transparent 50%) bottom right / 100% 1px no-repeat, linear-gradient(-270deg, red, red 50%, transparent 50%) bottom left / 1px 100% no-repeat; 可以通过不同的四种角度的渐变，实现边框，颜色可以自定义。缺点是代码比较多，而且不能实现圆角。 4.伪类 + transform 实现 1234567891011121314:after&#123; content: ''; position: absolute; top: 0; left: 0; border: 1px solid red; -webkit-box-sizing: border-box; box-sizing: border-box; width: 200%; height: 200%; -webkit-transform: scale(0.5); transform: scale(0.5); -webkit-transform-origin: left top; transform-origin: left top; &#125; 利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半， 然后进行绝对定位，这种方法现在没有发现问题。 三.图的遍历这部分是上次分享没有添加的内容： 广度优先 搜索(Breadth-First Search，BFS)和深度优先搜索(Depth-First Search，DFS)。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通等。 图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。 广度优先搜索广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点。 以下是从顶点v开始的广度优先搜索算法所遵循的步骤。(1) 创建一个队列Q。(2) 将v标注为被发现的(灰色)，并将v入队列Q。(3) 如果Q非空，则运行以下步骤: (a) 将u从Q中出队列; (b) 将标注u为被发现的(灰色); (c) 将u所有未被访问过的邻点(白色)入队列; (d) 将u标注为已被探索的(黑色)。 1234567891011121314151617181920212223242526var initializeColor = function()&#123; var color = []; for (var i=0; i&lt;vertices.length; i++)&#123; color[vertices[i]] = 'white'; &#125; return color; &#125;; this.bfs = function(v, callback)&#123; var color = initializeColor(), queue = new Queue(); queue.enqueue(v); while (!queue.isEmpty())&#123; var u = queue.dequeue(), neighbors = adjList.get(u); color[u] = 'grey'; for (var i=0; i&lt;neighbors.length; i++)&#123; var w = neighbors[i]; if (color[w] === 'white')&#123; color[w] = 'grey'; queue.enqueue(w); &#125; &#125; color[u] = 'black'; if (callback) &#123; callback(u); &#125; &#125; &#125;; 深度优先搜索深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点。 12345678910111213141516171819202122this.dfs = function(callback)&#123; var color = initializeColor(); for (var i=0; i&lt;vertices.length; i++)&#123; if (color[vertices[i]] === 'white')&#123; dfsVisit(vertices[i], color, callback); &#125; &#125; &#125;;var dfsVisit = function(u, color, callback)&#123; color[u] = 'grey'; if (callback) &#123; &#125; callback(u); &#125; var neighbors = adjList.get(u); for (var i=0; i&lt;neighbors.length; i++)&#123; var w = neighbors[i]; if (color[w] === 'white')&#123; dfsVisit(w, color, callback); &#125; &#125; color[u] = 'black'; &#125;; 以上是两个基本的图的遍历方法。]]></content>
      <categories>
        <category>前端常见问题</category>
      </categories>
      <tags>
        <tag>前端问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 23.Missing Number]]></title>
    <url>%2F2018%2F02%2F02%2FleetCode%2Farray%2F23.Missing_Number%2F</url>
    <content type="text"><![CDATA[Problem 23.Missing NumberGiven an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array. Example 1 Input: [3,0,1]Output: 2 Example 2Input: [9,6,4,2,3,5,7,0,1]Output: 8 Note:Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity? Credits:Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases. solution 1.这道题也是比较简单，只要先对数组排好序，然后跟序数进行对比，返回不相等的下标即可。 123456789var missingNumber = function(nums) &#123; nums.sort(function(a,b)&#123;return a-b;&#125;); for (var i = 0; i &lt; nums.length; i++) &#123; if(nums[i] != i) &#123; return i; &#125; &#125; return nums.length;&#125;; 复杂度分析：Time Complexity：O(n2), n为数组长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 22.Maximum Product of Three Numbers]]></title>
    <url>%2F2018%2F02%2F02%2FleetCode%2Farray%2F22.Maximum_Product_of_Three_Numbers%2F</url>
    <content type="text"><![CDATA[Problem 22.Maximum Product of Three NumbersGiven an integer array, find three numbers whose product is maximum and output the maximum product. Example 1: Input: [1,2,3]Output: 6 Example 2: Input: [1,2,3,4]Output: 24 Note: The length of the given array will be in range [3,104] and all elements are in the range [-1000, 1000]. Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer. solution: 1.因为最短数组长度为3，所以不要考虑数组长度小于3的情况。本题的元素大小可能为负数，若都为正数或都为负数，则取前三个元素，若有正数有负数，通过查资料可以得到，此时3个数之积的最大值为max(第一大数第二大数第三大数， 第一大数最小数倒数第二小数)。这个方法可以记住。 1234var maximumProduct = function(nums) &#123; nums.sort(function(a,b)&#123;return b-a;&#125;); return Math.max(nums[nums.length - 1] * nums[nums.length - 2] * nums[0], nums[0] * nums[1] * nums[2]);&#125;; 复杂度分析：Time Complexity：O(n2), n为数组长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 21. Image Smoother]]></title>
    <url>%2F2018%2F02%2F02%2FleetCode%2Farray%2F21.Image_Smoother%2F</url>
    <content type="text"><![CDATA[Problem 21. Image SmootherGiven a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can. Example 1: Input:[[1,1,1], [1,0,1], [1,1,1]]Output:[[0, 0, 0], [0, 0, 0], [0, 0, 0]]Explanation:For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0For the point (1,1): floor(8/9) = floor(0.88888889) = 0 Note: The value in the given matrix is in the range of [0, 255]. The length and width of the given matrix are in the range of [1, 150]. solution: 1.这道题想了半天没想出什么好点的方法，就用最笨的方法写了，判断周围八个位置是否正常，如果正常，就计算到总额里并得到平均值。注意，js里不满1会向上取整，所以应该用Math.floor()。代码如下： 123456789101112131415161718192021222324252627282930var imageSmoother = function(M) &#123; var nx = M.length; var ny = M[0].length; var res = new Array(nx); for(var n = 0; n &lt; nx; n++)&#123; res[n] = new Array(ny); &#125; ; for (var i = 0; i &lt; nx; i++) &#123; for (var j = 0; j &lt; ny; j++) &#123; res[i][j] = smooth(M, i, j); &#125; &#125; return res; &#125; var smooth = function(M, x, y) &#123; var nx = M.length; var ny = M[0].length; var sum = 0; var count = 0; for (var i = -1; i &lt;= 1; i++) &#123; for (var j = -1; j &lt;= 1; j++) &#123; if (x + i &lt; 0 || x + i &gt;= nx || y + j &lt; 0 || y + j &gt;= ny) &#123; continue; &#125; count++; sum += M[x + i][y + j]; &#125; &#125; return Math.floor(sum / count); &#125; 复杂度分析： Time Complexity：O(r X c),r为M.length,c为M[0].length.]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 20.Contains Duplicate]]></title>
    <url>%2F2018%2F01%2F31%2FleetCode%2Farray%2F20.Contains_Duplicate%2F</url>
    <content type="text"><![CDATA[Problem 20:Contains DuplicateGiven an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct. solution: 1.先对数组进行sort，然后除去特殊情况下判断只要元素周围两侧元素有一个相同，就返回true，否则为false。 123456789101112var containsDuplicate = function(nums) &#123; nums.sort(function(a,b)&#123;return a-b&#125;); if(nums.length == 0) return false; if(nums.length == 1) return false; if(nums.length == 2 &amp;&amp; nums[0] ==nums[1]) return true; for(var i = 1; i &lt; nums.length - 1; i++) &#123; if(nums[i] == nums[i-1] || nums[i] == nums[i+1]) &#123; return true; &#125; &#125; return false;&#125;; 复杂度分析：Time Complexity：O(n), n为数组长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 19.Degree of an Array]]></title>
    <url>%2F2018%2F01%2F31%2FleetCode%2Farray%2F19.Degree_of_an_Array%2F</url>
    <content type="text"><![CDATA[Problem 19: Degree of an ArrayGiven a non-empty array of non-negative integers nums, the degree of this array is defined as the maximum frequency of any one of its elements. Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums. Example 1: Input: [1, 2, 2, 3, 1]Output: 2Explanation:The input array has a degree of 2 because both elements 1 and 2 appear twice.Of the subarrays that have the same degree:[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]The shortest length is 2. So return 2. Example 2: Input: [1,2,2,3,1,4,2]Output: 6 Note: nums.length will be between 1 and 50,000. nums[i] will be an integer between 0 and 49,999. solution: 1.本题本来想用数组的方式解决，但感觉比较麻烦，所以选择map来解决 1234567891011121314151617181920var findShortestSubArray = function(nums) &#123; var m = new Map(), degree = 1, whichDegree = nums[0] for (var i = 0; i &lt; nums.length; i++) &#123; if (m.has(nums[i])) &#123; var pos = m.get(nums[i]) pos.push(i) if (pos.length &gt; degree) &#123; degree = pos.length whichDegree = nums[i] &#125; else if (pos.length == degree &amp;&amp; pos[pos.length - 1] - pos[0] &lt; m.get(whichDegree)[m.get(whichDegree).length - 1] - m.get(whichDegree)[0]) &#123; degree = pos.length whichDegree = nums[i] &#125; &#125; else m.set(nums[i], [i]) &#125; return m.get(whichDegree)[m.get(whichDegree).length - 1] - m.get(whichDegree)[0] + 1&#125;; 复杂度分析：Time Complexity：O(n), n为数组长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 18.Two Sum II - Input array is sorted]]></title>
    <url>%2F2018%2F01%2F31%2FleetCode%2Farray%2F18.Two_Sum_II_Input_array_is_sorted%2F</url>
    <content type="text"><![CDATA[Problem 18: Two Sum II - Input array is sortedGiven an array of integers that is already sorted in ascending order, find two numbers such that they add up to a specific target number. The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based. You may assume that each input would have exactly one solution and you may not use the same element twice. Input: numbers={2, 7, 11, 15}, target=9Output: index1=1, index2=2 solution: 1.因为已经是升序的，所以只要从数组头尾往中间收拢，就必然会找到对应的两个数。 1234567891011var twoSum = function(numbers, target) &#123; var left = 0, right= numbers.length - 1; var sum = 0; while (left &lt; right) &#123; sum = numbers[left] + numbers[right]; if (sum == target)&#123;return [left + 1, right + 1];&#125; else if(sum &lt; target) left++; else right--; &#125; return [];&#125;; 复杂度分析：Time Complexity：O(n), n为数组长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 17.Majority Element]]></title>
    <url>%2F2018%2F01%2F30%2FleetCode%2Farray%2F17.Majority_Element%2F</url>
    <content type="text"><![CDATA[Problem 17: Majority ElementGiven an array of size n, find the majority element. The majority element is the element that appears more than ⌊ n/2 ⌋ times. You may assume that the array is non-empty and the majority element always exist in the array. Credits:Special thanks to @ts for adding this problem and creating all test cases. solution: 1.这里比较取巧，因为内容全部为数字，所以sort按序排序然后选择中位数即可。 1234var majorityElement = function(nums) &#123; nums.sort(function(a,b)&#123;return a-b;&#125;); return nums[Math.floor(nums.length/2)];&#125;; 复杂度分析：Time Complexity：O(n), n为数组长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 16.Best Time to Buy and Sell Stock II]]></title>
    <url>%2F2018%2F01%2F30%2FleetCode%2Farray%2F16.Best_Time_to_Buy_and_Sell_Stock_II%2F</url>
    <content type="text"><![CDATA[Problem 16: Best Time to Buy and Sell Stock IISay you have an array for which the ith element is the price of a given stock on day i. Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again). solution: 1.题目信息请见之前的题目地址，这道题的思路比较奇特，因为可以选择多次，所以只要后一次大于前一次，即可以在总额上加上差值，因为若后面的数继续大于前面的数，累加的差值等于之后的差值。若后面的小，则可以跳过，因为前面的内容已经得到最多的利润。 12345678var maxProfit = function(prices) &#123; var maxprofit = 0; for(var i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &gt; prices[i - 1]) maxprofit += prices[i] - prices[i - 1]; &#125; return maxprofit;&#125;; 复杂度分析：Time Complexity：O(n), n为数组长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 15.1-bit and 2-bit Characters]]></title>
    <url>%2F2018%2F01%2F30%2FleetCode%2Farray%2F15.1_bit_and_2_bit_Characters%2F</url>
    <content type="text"><![CDATA[Problem 15: 1-bit and 2-bit CharactersWe have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11). Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero. Example 1: Input:bits = [1, 0, 0]Output: TrueExplanation:The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character. Example 2: Input:bits = [1, 1, 1, 0]Output: FalseExplanation:The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character. Note: 1 &lt;= len(bits) &lt;= 1000. bits[i] is always 0 or 1. solution: 1.近期因为时间比较紧，所以只用一种方法解决。本题选择递归，当前元素若为1，则删掉前两个，当前元素为0，则删除一个，直到最后长度为0或时，返回false或true。 1234567var isOneBitCharacter = function(bits) &#123; if(bits.length==0) return false; else if(bits.length==1) return true; if(bits[0]==0)bits.splice(0,1); else bits.splice(0,2); return isOneBitCharacter(bits)&#125;; 复杂度分析：Time Complexity：O(n), n为数组长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 14.Move Zeroes]]></title>
    <url>%2F2018%2F01%2F27%2FleetCode%2Farray%2F14.Move_Zeroes%2F</url>
    <content type="text"><![CDATA[Problem 14: Move ZeroesGiven an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements. For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0]. Note: You must do this in-place without making a copy of the array. Minimize the total number of operations. Credits: Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases. solution: 这跟之前做的题很类似，只要注意在splice之后要对i减一即可。 12345678910111213var moveZeroes = function(nums) &#123; var sumZero = 0; for(var i = 0; i &lt; nums.length; i++) &#123; if(nums[i] == 0) &#123; nums.splice(i, 1); i--; sumZero++; &#125; &#125; for(var n = 0; n &lt; sumZero; n++) &#123; nums.push(0); &#125;&#125;; 复杂度分析：Time Complexity：O(n), n为数组长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 13.Find All Numbers Disappeared in an Array]]></title>
    <url>%2F2018%2F01%2F27%2FleetCode%2Farray%2F13.Find_All_Numbers_Disappeared_in_an_Array%2F</url>
    <content type="text"><![CDATA[Problem 13: Find All Numbers Disappeared in an ArrayGiven an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once. Find all the elements of [1, n] inclusive that do not appear in this array. Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space. Example: Input:[4,3,2,7,8,2,3,1] Output:[5,6] solution: 1.本来想最简单的方法就是先筛选出1 ≤ a[i] ≤ n 中哪个元素不再数组里，然后push到最后一位在splice之前的内容，但是要求without extra space and in O(n) runtime，所以选择其他的方法。这里选择先将数组排序，然后判断哪个元素不是对应位置上的数字，最后push到数组中。 12345678910111213141516var findDisappearedNumbers = function(nums) &#123; var res = []; for (var i = 0; i &lt; nums.length; i++) &#123; if (nums[i] != nums[nums[i] - 1]) &#123; var inchange = nums[nums[i] - 1]; nums[nums[i] - 1] = nums[i]; nums[i] = inchange; i--; &#125; &#125; for (var j = 0; j &lt; nums.length; j++) &#123; if (nums[j] != j + 1) res.push(j + 1); &#125; return res;&#125;; 复杂度分析：Time Complexity：O(n), n为数组长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 12.Max Area of Island]]></title>
    <url>%2F2018%2F01%2F27%2FleetCode%2Farray%2F12.Max_Area_of_Island%2F</url>
    <content type="text"><![CDATA[Problem 12: Max Area of IslandGiven a non-empty 2D array grid of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water. Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.) Example 1: [[0,0,1,0,0,0,0,1,0,0,0,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,1,1,0,1,0,0,0,0,0,0,0,0], [0,1,0,0,1,1,0,0,1,0,1,0,0], [0,1,0,0,1,1,0,0,1,1,1,0,0], [0,0,0,0,0,0,0,0,0,0,1,0,0], [0,0,0,0,0,0,0,1,1,1,0,0,0], [0,0,0,0,0,0,0,1,1,0,0,0,0]] Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally. Example 2: [[0,0,0,0,0,0,0,0]] Given the above grid, return 0. Note: The length of each dimension in the given grid does not exceed 50. solution: 因为选取最多的相邻的1，本来打算遍历一遍，如果当前元素右边和下边为1，则对右下方元素加对应的值，但是边界条件判断比较复杂。所以，选择递归实现，虽然实现很简单，但是时间复杂度相对较高，做了比较多重复的操作。以下为对应代码： 12345678910111213141516171819var maxAreaOfIsland = function(grid) &#123; var res = 0; for(var i = 0; i &lt; grid.length; i++)&#123; for(var j = 0; j &lt; grid[0].length; j++)&#123; if(grid[i][j] == 1) res = Math.max(res, helper(grid, i, j)); &#125; &#125; return res;&#125;;var helper = function(grid, r, c) &#123; if(r &lt; 0 || r &gt;= grid.length || c &lt; 0 || c &gt;= grid[0].length) return 0; var res = 0; if(grid[r][c] == 1)&#123; grid[r][c] = 0; res = 1 + helper(grid, r-1, c) + helper(grid, r+1, c) + helper(grid, r, c-1) + helper(grid, r, c+1); &#125; return res;&#125; 复杂度分析：Time Complexity：O(r X c), r为行的个数，c为列的个数。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 11.Shortest Word Distance]]></title>
    <url>%2F2018%2F01%2F27%2FleetCode%2Farray%2F11.Shortest_Word_Distance%2F</url>
    <content type="text"><![CDATA[Problem 11: Shortest Word DistanceGiven a list of words and two words word1 and word2, return the shortest distance between these two words in the list. For example,Assume that words = [&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]. Given word1 = &quot;coding&quot;, word2 = &quot;practice&quot;, return 3.Given word1 = &quot;makes&quot;, word2 = &quot;coding&quot;, return 1. Note: You may assume that word1 does not equal to word2, and word1 and word2 are both in the list. solution: 根据题意，选出最近的两个对应的单词的间距，因为所选单词最短的间距即相邻间距，所以最小的匹配值间距的绝对值即是所求答案。 1234567891011121314151617var shortestDistance = function(words, word1, word2) &#123; var index1 = -1, index2 = -1; var minDistance = words.length; var currentDistance; for (var i = 0; i &lt; words.length; i++) &#123; if (words[i] == word1) &#123; index1 = i; &#125; else if (words[i] == word2) &#123; index2 = i; &#125; if (index1 != -1 &amp;&amp; index2 != -1) &#123; minDistance = Math.min(minDistance, Math.abs(index1 - index2)); &#125; &#125; return minDistance;&#125;; 复杂度分析：Time Complexity：O(n), n为数组的长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 10.Max Consecutive Ones]]></title>
    <url>%2F2018%2F01%2F26%2FleetCode%2Farray%2F10.Max_Consecutive_Ones%2F</url>
    <content type="text"><![CDATA[Problem 10: Max Consecutive OnesGiven a binary array, find the maximum number of consecutive 1s in this array. Example 1: Input: [1,1,0,1,1,1]Output: 3Explanation: The first two digits or the last three digits are consecutive 1s. The maximum number of consecutive 1s is 3. Note: The input array will only contain 0 and 1. The length of input array is a positive integer and will not exceed 10,000 solution: 1.这道题算是福利题了，只要确定最长的1的长度就行了，所以直接判断即可： 123456789var findMaxConsecutiveOnes = function(nums) &#123; var res = 0; var cnt = 0; for (var i = 0; i&lt; nums.length; i++) &#123; cnt = (nums[i] == 0) ? 0 : cnt + 1; res = Math.max(res, cnt); &#125; return res;&#125;; 复杂度分析：Time Complexity：O(n),n为nums的长度； 2.除此之外还看到一个人的另一种比较有趣的方法，因为是01串，那么连续1的和跟个数相等，所以我们可以计算和，通过加上num，再乘以num来计算，如果当前数字是0，那么sum就被重置为0，还是要更新结果res。 123456789var findMaxConsecutiveOnes = function(nums) &#123; var res = 0; var cnt = 0; for (var i = 0; i&lt; nums.length; i++) &#123; cnt = (cnt + nums[i]) * nums[i]; res = Math.max(res, cnt); &#125; return res;&#125;; 复杂度分析：Time Complexity：O(n),n为nums的长度；]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 9.Reshape the Matrix]]></title>
    <url>%2F2018%2F01%2F26%2FleetCode%2Farray%2F09.Reshape_the_Matrix%2F</url>
    <content type="text"><![CDATA[Problem 9:Reshape the MatrixIn MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data. You’re given a matrix represented by a two-dimensional array, and two positive integers r and c representing the row number and column number of the wanted reshaped matrix, respectively. The reshaped matrix need to be filled with all the elements of the original matrix in the same row-traversing order as they were. If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix. Example 1: Input:nums =[[1,2], [3,4]]r = 1, c = 4Output:[[1,2,3,4]]Explanation:The row-traversing of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list. Example 2: Input:nums =[[1,2], [3,4]]r = 2, c = 4Output:[[1,2], [3,4]]Explanation:There is no way to reshape a 2 X 2 matrix to a 2 X 4 matrix. So output the original matrix. Note:The height and width of the given matrix is in range [1, 100].The given r and c are all positive. solution: 做这道题时主要的问题在于如何创建一个二维数组，因为js创建二维数组时出现问题，所以选择设两个一维数组，先判断是否符合要求，不符合返回原数组，然后将元素通过concat添加到一个一维数组中，然后根据所给的r,c一一赋值即可。这道题主要纠结在如何设置一个空的二维数组以及如何对二维数组进行赋值。最后回避了这个问题。 1234567891011121314151617var matrixReshape = function(nums, r, c) &#123; var result_storage = []; var result = []; if(nums.length * nums[0].length != r * c) &#123; return nums; &#125; for(var i=0; i &lt; nums.length; i++) &#123; result_storage = result_storage.concat(nums[i]); &#125; for(var i = 0; i &lt; r; i++) &#123; result.push([]); for(var j = 0; j &lt; c ; j++)&#123; result[i][j] = result_storage[i * c + j]; &#125; &#125; return result;&#125;; 复杂度分析：Time Complexity：O(r X c), r为矩阵的横向长度，c为矩阵的纵向长度。 2.经过查询过后，发现二维数组不是通过创建`var result = new Array[][]这样的形式创建，而是通过先创建一个一维数组，再对其中的元素设置为数组的形式创建多维数组。接下来就对数组中的内容进行判断，若没有到下一行，则继续对下一位内容赋值，若倒下一行，则换行输入。12345678910111213141516171819202122var matrixReshape = function(nums, r, c) &#123; var result = new Array(r); for(var n = 0; n &lt; result.length; n++)&#123; result[n] = new Array(c); &#125; var rows = 0; var cols = 0; var count = 0; if(nums.length == 0 || nums.length * nums[0].length != r * c) return nums; for (var i = 0; i &lt; nums.length; i ++) &#123; for (var j = 0; j &lt; nums[0].length; j++) &#123; result[rows][cols] = nums[i][j]; cols++; if (cols == c) &#123; rows++; cols = 0; &#125; &#125; &#125; return result;&#125;; 复杂度分析：Time Complexity：O(num.length X num[0].length), 与上述方法的复杂度类似，不过更直观一些。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 8.Toeplitz Matrix]]></title>
    <url>%2F2018%2F01%2F26%2FleetCode%2Farray%2F08.Toeplitz_Matrix%2F</url>
    <content type="text"><![CDATA[Problem 8: Toeplitz MatrixA matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element. Now given an M x N matrix, return True if and only if the matrix is Toeplitz. Example 1: Input: matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]Output: TrueExplanation:123451239512 In the above grid, the diagonals are “[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”, and in each diagonal all elements are the same, so the answer is True. Example 2: Input: matrix = [[1,2],[2,2]]Output: FalseExplanation:The diagonal “[1, 2]” has different elements. Note: matrix will be a 2D array of integers. matrix will have a number of rows and columns in range [1, 20]. matrix[i][j] will be integers in range [0, 99]. solution: 1.通过画图可得，从左上角的元素开始，如果每行（最后一行除外）元素可以与右下方（每行最后一个元素除外）的元素相等，既符合要求，所以可以选择遍历得到答案。 目前就只有这一种比较好的解法，所以就先写一个算法了。 12345678910var isToeplitzMatrix = function(matrix) &#123; for(var r = 0; r &lt; matrix.length - 1; r++) &#123; for(var c = 0; c &lt; matrix[0].length - 1; c++) &#123; if(matrix[r][c] != matrix[r+1][c+1]) &#123; return false; &#125; &#125; &#125; return true;&#125;; 复杂度分析：Time Complexity: O(m X n), m为矩阵的横向长度，n为矩阵的纵向长度。]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 7.Array Partition I]]></title>
    <url>%2F2018%2F01%2F26%2FleetCode%2Farray%2F07.array_partition_I%2F</url>
    <content type="text"><![CDATA[Problem 7:Array Partition IGiven an array of 2n integers, your task is to group these integers into n pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible. Example 1: Input: [1,4,3,2]Output: 4Explanation: n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4). Note: n is a positive integer, which is in the range of [1, 10000]. All the integers in the array will be in the range of [-10000, 10000]. solution: 1.这道题比较简单的做法是对数组排序，然后隔一个数字取一个，就可以保证数组中所有的每两个数字的最小值的总和是最小值。 目前也没有找到比这个更简单的算法，所以就先写一个算法了。 123456789var arrayPairSum = function(nums) &#123; var sum = 0; var i = 0; nums.sort(function(a, b)&#123;return a-b;&#125;); for(var i = 0; i&lt; nums.length; i+=2) &#123; sum+=nums[i]; &#125; return sum;&#125;; 复杂度分析：Time Complexity：O(n), n为nums的长度；]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[1.22~1.26所遇问题]]></title>
    <url>%2F2018%2F01%2F25%2Fblog%2Fproblem%2F1.22~1.16_questions%2F</url>
    <content type="text"><![CDATA[1.22~1.26所遇问题1.导入css文件时，import和link的区别 &lt;link&gt;标签是html标签，除了可以引入CSS之外还可以定义RSS，定义rel属性等，而@import只能引入CSS样式； &lt;link&gt;标签引用的CSS文件会在页面加载时与html同时加载，而@import引入的CSS文件会等页面全部加载完以后再加载； @import标签必须放在页面样式表的顶部，而&lt;link&gt;不必； 那为什么会有很多人建议使用link标签，而非import呢？在Steve Souders（编写过《高性能网站建设指南》等书）的博客中通过一些实例来说明don’t use @import。以下节选部分内容并进行翻译： 原文链接http://www.stevesouders.com/blog/2009/04/09/dont-use-import/——————————————————————————————————————LINK vs. @import There are two ways to include a stylesheet in your web page. You can use the LINK tag: 以下有两种将样式表引入到您的网页中的方式。您可以使用LINK标签： 1&lt;link rel='stylesheet' href='a.css'&gt; Or you can use the @import rule: 或者您可以使用@import规则：123&lt;style&gt;@import url('a.css');&lt;/style&gt; I prefer using LINK for simplicity—you have to remember to put @import at the top of the style block or else it won’t work. It turns out that avoiding @import is better for performance, too. 为了简单起见，我更倾向于使用LINK。如果您使用@import的话，您必须将它放在样式内容的顶部，否则它将无法显示。事实证明，处于性能来说，避免使用@import也是一个更好的选择。 @import @import I’m going to walk through the different ways LINK and @import can be used. In these examples, there are two stylesheets: a.css and b.css. Each stylesheet is configured to take two seconds to download to make it easier to see the performance impact. The first example uses @import to pull in these two stylesheets. In this example, called @import @import, the HTML document contains the following style block: 我将在不同的情况下使用LINK和@import。在这些例子中，有两个样式表：a.css和b.css。每个样式表都需要花费两秒钟的时间下载，以便更容易地观测性能。第一个示例中，我们使用@import来下载这两个样式表。我们叫这个例子为@import @import在这个示例中，HTML文档包含以下样式块：1234&lt;style&gt;@import url('a.css');@import url('b.css');&lt;/style&gt; If you always use @import in this way, there are no performance problems, although we’ll see below it could result in JavaScript errors due to race conditions. The two stylesheets are downloaded in parallel, as shown in Figure 1. (The first tiny request is the HTML document.) The problems arise when @import is embedded in other stylesheets or is used in combination with LINK. 如果您总是使用@import的方式，不会有什么性能方面的问题，尽管可能由于竞争的原因导致JavaScript报错。如图1所示，这两个样式表是并行下载的。（第一个请求时HTML文档），但是，当@import与LINK结合使用引入其他样式表时，问题就出现了。 只使用@import 由此可见，只使用@import是没有问题的。 LINK @import The LINK @import example uses LINK for a.css, and @import for b.css: LINK @import示例中使用LINK标签引入a.css，使用@import引入b.css： 1234&lt;link rel='stylesheet' type='text/css' href='a.css'&gt;&lt;style&gt;@import url('b.css');&lt;/style&gt; In IE (tested on 6, 7, and 8), this causes the stylesheets to be downloaded sequentially, as shown in Figure 2. Downloading resources in parallel is key to a faster page. As shown here, this behavior in IE causes the page to take a longer time to finish. 在IE（在IE6， 7， 8下测试）中，如下图所示，这将导致样式表按顺序下载，而并行下载资源是让页面加载更快的关键。如图所示，在IE中的这会导致页面花费较长的时间完成渲染。 混合使用@import和link标签 LINK with @import In the LINK with @import example, a.css is inserted using LINK, and a.css has an @import rule to pull in b.css: 在使用LINK中使用@import的示例中，a.css使用LINK嵌入在DOM中，而a.css中则通过@import导入b.css：1234in the HTML document:&lt;link rel='stylesheet' type='text/css' href='a.css'&gt;in a.css:@import url('b.css'); This pattern also prevents the stylesheets from loading in parallel, but this time it happens on all browsers. When we stop and think about it, we shouldn’t be too surprised. The browser has to download a.css and parse it. At that point, the browser sees the @import rule and starts to fetch b.css. 这种方式也可以防止样式表的并行加载，但是这次它发生在所有的浏览器上。其实仔细想一想，我们都不应该感到惊讶。浏览器必须先下载a.css并解析它，只有解析它后，浏览器才会看到@import规则并开始加载b.css。 在link标签引入@import LINK blocks @import A slight variation on the previous example with surprising results in IE: LINK is used for a.css and for a new stylesheet called proxy.css. proxy.css is configured to return immediately; it contains an @import rule for b.css. 在IE中与上述结果有些许不同：对a.css和名为proxy.css的样式表使用LINK引入。而proxy.css会立即执行并渲染; 注意，它包含一个b.css的@import规则 12345in the HTML document:&lt;link rel='stylesheet' type='text/css' href='a.css'&gt;&lt;link rel='stylesheet' type='text/css' href='proxy.css'&gt;in proxy.css:@import url('b.css'); The results of this example in IE, LINK blocks @import, are shown in Figure 4. The first request is the HTML document. The second request is a.css (two seconds). The third (tiny) request is proxy.css. The fourth request is b.css (two seconds). Surprisingly, IE won’t start downloading b.css until a.css finishes. In all other browsers, this blocking issue doesn’t occur, resulting in a faster page as shown in Figure 5. 在IE中的LINK bock @import例子里，第一个请求时HTML文件，第二个请求是a.css（花费了两秒），第三个请求（很短）是proxy.css。第四个请求时b.css（花费了两秒）。令人惊奇的是，IE不会等到a.css结束后再开始下载b.css。在所有其他的浏览器里，这种加速渲染页面的情况不会发生。 LINK blocks @import embedded in other stylesheets in IE LINK doesn’t block @import embedded stylesheets in browsers other than IE many @imports The many @imports example shows that using @import in IE causes resources to be downloaded in a different order than specified. This example has six stylesheets (each takes two seconds to download) followed by a script (a four second download). 在many @imports例子中显示了在IE中使用@import会导致不同于指定的顺序下载资源。这个例子有六个样式表（每个需要两秒钟下载），后面是一个脚本（四秒钟的下载） 123456789&lt;style&gt;@import url('a.css');@import url('b.css');@import url('c.css');@import url('d.css');@import url('e.css');@import url('f.css');&lt;/style&gt;&lt;script src='one.js' type='text/javascript'&gt;&lt;/script&gt; Looking at Figure 6, the longest bar is the four second script. Even though it was listed last, it gets downloaded first in IE. If the script contains code that depends on the styles applied from the stylesheets (a la getElementsByClassName, etc.), then unexpected results may occur because the script is loaded before the stylesheets, despite the developer listing it last. 看下图，最长的一条是一个四秒的脚本。尽管它位于最后，但是它在IE中是最早下载下来的。如果脚本包括依赖于样式表中的样式，会有未知的结果发生，因为脚本不是按照预期的顺序在样式之后加载的。 多个import LINK LINK It’s simpler and safer to use LINK to pull in stylesheets: 使用LINK加载样式更快捷也更安全： 12&lt;link rel='stylesheet' type='text/css' href='a.css'&gt;&lt;link rel='stylesheet' type='text/css' href='b.css'&gt; Using LINK ensures that stylesheets will be downloaded in parallel across all browsers. The LINK LINK example demonstrates this, as shown in Figure 7. Using LINK also guarantees resources are downloaded in the order specified by the developer. 使用LINK会确保样式表会在所有的浏览器中都并行下载。这个LINK LINK的例子证明了这点，使用LINk也保证资源会按开发者的顺序加载。 使用link加载样式表 These issues need to be addressed in IE. It’s especially bad that resources can end up getting downloaded in a different order. All browsers should implement a small lookahead when downloading stylesheets to extract any @import rules and start those downloads immediately. Until browsers make these changes, I recommend avoiding @import and instead using LINK for inserting stylesheets. 这些问题在IE中都需要解决。尤其是资源会以不同的顺序下载的问题尤为糟糕。所有的浏览器都应该在下载样式表的时候就提取任何@import规则并立即开始下载。在浏览器进行这些更改之前，我建议避免使用@import，而应使用LINK来引入样式表。 The load times of these resources are exaggerated to make it easy to see what’s happening. But for people with slow connections, especially those in some of the world’s emerging markets, these response times may not be that far from reality. The takeaways are: Using @import within a stylesheet adds one more roundtrip to the overall download time of the page. Using @import in IE causes the download order to be altered. This may cause stylesheets to take longer to download, which hinders progress rendering making the page feel slower. 因为这些资源的加载时间被夸大，所有我们很容易看到发生了什么事情。但是对于那些网速慢的人来说，网络的响应时间也许并不那么块。 原因是： 在样式表中使用@import会使得页面的整体下载时间再增加一倍。 在IE中使用@import会导致资源的下载顺序发生改变。这可能会导致样式表花费更长的时间来下载，因此会阻碍渲染，使页面加载的更慢。 2.微格式对应官网为：http://microformats.org/ 微格式产生背景：由于早期HTML中缺少相应的元素，很难突出显示人、地点或日期等类型的信息。为了解决这个问题，有一组开发人员决定开发一套标准的命名约定盒标记模式来表示这些数据。这些命名约定基于vCard（电子名片）和iCalendar（日历数据交换）等现有的数据格式，现在称为微格式（microformat)。 微格式定义：建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式（microformats.org官方定义）。是把语义嵌入到HTML以便有助于分离式开发而制定的一些简单约定，是兼顾人机可读性设计的数据表达方式，对Web网页进行语义注解的方法。 微格式意义：微格式按照某种已有的被广泛应用的标准，通过对内容块的语义标记，可以让外部应用程序、聚合程序和搜索引擎能够做以下事情： 在捉取Web内容时，能够更为准确地识别内容块的语义； 对内容进行操作，包括提供访问、校对，还可以将其转化成其他的相关格式，提供给外部程序和Web服务使用。 因此，微格式实际上就是为现有的HTML元素添加元数据和其他属性以增强语义化。 常见的微格式是hCard hCard是一种微格式，用来发布个人，公司，组织，地点等详细的联系信息。它可以包含在(X)HTML，Atom，RSS等可扩展置标语言中。hCard使用vCard（RFC 2426）的属性和值来实现这些功能。 它可以使分析器（比如其他网站，Firefox的Operator插件）获得详细的信息，并通过别的网站或者地图工具进行显示，或者载入到地址簿等其他程序。 example： 123456&lt;div&gt; &lt;div&gt;Joe Doe&lt;/div&gt; &lt;div&gt;The Example Company&lt;/div&gt; &lt;div&gt;604-555-1234&lt;/div&gt; &lt;a href="http://example.com/"&gt;http://example.com/&lt;/a&gt; &lt;/div&gt; 如下代码添加了微格式后，成为: 123456&lt;div class="vcard"&gt; &lt;div class="fn"&gt;Joe Doe&lt;/div&gt; &lt;div class="org"&gt;The Example Company&lt;/div&gt; &lt;div class="tel"&gt;604-555-1234&lt;/div&gt; &lt;a class="url" href="http://example.com/"&gt;http://example.com/&lt;/a&gt;&lt;/div&gt; 这里，正式名称（class=”fn”），组织（class=”org”），电话号码（class=”tel”）和url（class=”url”）分别用相应的class标示；同时，所有内容都包含在class=”vcard”里。 以上就是微格式的大体内容。 外边距叠加首先，先说明是什么导致的外边距叠加。 首先，外边距叠加是因为外边距塌陷(margin collapse)导致的。实际它也是由于一个缺省值的设定而导致的。在Chrome浏览器里，这个缺省值就是由-webkit-margin-collapse规定的。-webkit-margin-collapse的缺省值就是collapse，所以导致塌陷。这个属性还有另外2个取值：一个是discard，一个是separate。下面我们来具体看一下它们的不同表现形式。 -webkit-margin-collapse: collapse我们先从简单的看起。假定我们有这样一个&lt;div&gt;，这个&lt;div&gt;里面有3个&lt;p&gt;，如果我们什么也不设，它就是这个样子： 会看到每一个&lt;p&gt;下面都有一个下边距。现在我们加上margin: 20px 0;表示为每一个&lt;p&gt;增加一个20px的上边距和一个20px的下边距，现在再看一下效果： 这时我们看到虽然第一个&lt;p&gt;有20px的上边距，但第2个&lt;p&gt;的20px上边距已经被第一个&lt;p&gt;的下边距『吃掉』了，这就是我们大家所熟知的外边距塌陷。 -webkit-margin-collapse: separate现在我们来看一下第2种情况，如果我们设定-webkit-margin-collapse: separate之后会怎么样： 现在我们看到塌陷的外边距回来了。 -webkit-margin-collapse: discard那么第3种取值discard是什么作用呢？ 外边距完全没有了。 所以，如果我们想强制所有元素边距都不塌陷，那么该怎么办呢？ 我们不能再简单地同时设置上下边距为margin: 20px 0;而应该更精确控制，给&lt;p&gt;只设置下边距为20px就可以了，这样我们就实现了在强制不塌陷的情况下依然保持了行与行之间的距离。 Tips:『外边距塌陷』其实是W3C早期标准为了一时方便而引入的一个过度设计，它的设计初衷是为了简化，但结果在CSS高度发展的情况下反倒造成了更大的混乱，使得前端工程师无法一目了然地知道自己的代码结果，不明白自己明明已经设置好的margin-top: 20px;怎么就会没有了？结果被人告知还要学习外边距塌陷这样的知识。这样的错误责任不在于工程师没有好好学习，而根本原因在于CSS本身设计的缺陷，才导致了工程师学习成本的增加，并且还增加了浏览器开发者的工作量，需要特意为外边距塌陷开发额外的代码。无论如何，这是一件各方成本都增加的双输设计。 至于水平方向上为什么没有外边距叠加，我也不知道呀，也许当时就是为了解决垂直方向上外边距累加的问题吧，定义上就是这么定义的。 最后总结一下W3C中外边距叠加的内容 In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin. 在CSS中，两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。 我们可以注意定义中的几个关键字：毗邻、两个或多个、垂直方向和普通流。 毗邻毗邻说明了他们的位置关系，没有被 padding、border、clear 和 line box 分隔开。 两个或多个两个或多个盒子是指元素之间的相互影响，单个元素不会存在外边距叠加的情况。 垂直方向 Horizontal margins never collapse. 只有垂直方向的外边距会发生外边距叠加。水平方向的外边距不存在叠加的情况。 普通流(in flow)什么是普通流？W3C 只对 out of flow 作了定义： An element is called out of flow if it is floated, absolutely positioned, or is the root element.An element is called in-flow if it is not out-of-flow. 从定义中我们可以知道只要不是 float、absolutely positioned 和 root element 时就是 in flow。 什么时候会发生外边距叠加外边距叠加存在两种情况：一是父子外边距叠加；二是兄弟外边距叠加。 W3C 对于什么是毗邻的外边距也有定义： Two margins are adjoining if and only if: - both belong to in-flow block-level boxes that participate in the same block formatting context - no line boxes, no clearance, no padding and no border separate them - both belong to vertically-adjacent box edges, i.e. form one of the following pairs: top margin of a box and top margin of its first in-flow child bottom margin of box and top margin of its next in-flow following sibling bottom margin of a last in-flow child and bottom margin of its parent if the &gt; parent has “auto” computed height top and bottom margins of a box that does not establish a new block formatting context and that has zero computed “min-height”, zero or “auto” computed “height”, and no in-flow children 从定义中我们可以很清楚的知道要符合哪些情况才会发生外边距折叠： 都属于普通流的块级盒子且参与到相同的块级格式上下文中 没有被padding、border、clear和line box分隔开 都属于垂直毗邻盒子边缘： 盒子的top margin和它第一个普通流子元素的top margin 盒子的bottom margin和它下一个普通流兄弟的top margin 盒子的bottom margin和它父元素的bottom margin 盒子的top margin和bottom margin，且没有创建一个新的块级格式上下文，且有被计算为0的min-height，被计算为0或auto的height，且没有普通流子元素 如何避免外边距叠加上面讲了外边距的叠加，那如何避免呢，其实只要破坏上面讲到的四个条件中的任何一个即可：毗邻、两个或多个、普通流和垂直方向。 W3C也对此做了总结： Margins between a floated box and any other box do not collapse (not even between a float and its in-flow children). Margins of elements that establish new block formatting contexts (such as floats and elements with “overflow” other than “visible”) do not collapse with their in-flow children. Margins of absolutely positioned boxes do not collapse (not even with their in-flow children). Margins of inline-block boxes do not collapse (not even with their in-flow children). The bottom margin of an in-flow block-level element always collapses with the top margin of its next in-flow block-level sibling, unless that sibling has clearance. The top margin of an in-flow block element collapses with its first in-flow block-level child”s top margin if the element has no top border, no top padding, and the child has no clearance. The bottom margin of an in-flow block box with a “height” of “auto” and a “min-height” of zero collapses with its last in-flow block-level child”s bottom margin if the box has no bottom padding and no bottom border and the child”s bottom margin does not collapse with a top margin that has clearance. A box”s own margins collapse if the “min-height” property is zero, and it has neither top or bottom borders nor top or bottom padding, and it has a “height” of either 0 or “auto”, and it does not contain a line box, and all of its in-flow children”s margins (if any) collapse. 浮动元素不会与任何元素发生叠加，也包括它的子元素 创建了 BFC 的元素不会和它的子元素发生外边距叠加 绝对定位元素和其他任何元素之间不发生外边距叠加，也包括它的子元素 inline-block 元素和其他任何元素之间不发生外边距叠加，也包括它的子元素 普通流中的块级元素的 margin-bottom 永远和它相邻的下一个块级元素的 margin-top 叠加，除非相邻的兄弟元素 clear 普通流中的块级元素（没有 border-top、没有 padding-top）的 margin-top 和它的第一个普通流中的子元素（没有clear）发生 margin-top 叠加 普通流中的块级元素（height为 auto、min-height为0、没有 border-bottom、没有 padding-bottom）和它的最后一个普通流中的子元素（没有自身发生margin叠加或clear）发生 margin-bottom叠加 如果一个元素的 min-height 为0、没有 border、没有padding、高度为0或者auto、不包含子元素，那么它自身的外边距会发生叠加 以上就是外边距叠加的主要内容。]]></content>
      <categories>
        <category>前端常见问题</category>
      </categories>
      <tags>
        <tag>前端问题</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array --6.Min Cost Climbing Stairs]]></title>
    <url>%2F2018%2F01%2F25%2FleetCode%2Farray%2F06.Min_Cost_Climbing_Stairs%2F</url>
    <content type="text"><![CDATA[Problem six: Min Cost Climbing StairsOn a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed). Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1. Example 1: Input: cost = [10, 15, 20] Output: 15 Explanation: Cheapest is start on cost[1], pay that cost and go to the top. Example 2: Input: cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1] Output: 6 Explanation: Cheapest is start on cost[0], and only step on 1s, skipping cost[3]. Note: cost will have a length in the range [2, 1000]. Every cost[i] will be an integer in the range [0, 999]. solution: 1.第一眼看这道题，显然是一道递归题，照着这个思路做很容易就做出来了。12345678var minCostClimbingStairs = function(cost) &#123; for(var i=2;i&lt;=cost.length-1;i++)&#123; cost[i]=cost[i]+Math.min(cost[i-1],cost[i-2]); &#125; return Math.min(cost[cost.length-1],cost[cost.length-2]);&#125;; 复杂度分析：Time Complexity：O(n), n为nums的长度； 同理，也有一种类似的解法，三个元素三个元素的比较，最后一个元素的最小值就是前两个元素的最小值加上对应的值。123456789var minCostClimbingStairs = function(cost) &#123; var firstElement = 0, secondElement = 0, thirdElement = 0; for(var i=2;i &lt;= cost.length;i++)&#123; thirdElement = Math.min(secondElement + cost[i-1], firstElement + cost[i-2]); firstElement = secondElement; secondElement = thirdElement; &#125; return thirdElement;&#125;; 复杂度分析：Time Complexity：O(n), n为nums的长度；]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 5.Largest Number At Least Twice of Others]]></title>
    <url>%2F2018%2F01%2F25%2FleetCode%2Farray%2F05.Largest_Number_At_Least_Twice_of_Others%2F</url>
    <content type="text"><![CDATA[Problem five: Largest Number At Least Twice of OthersIn a given integer array nums, there is always exactly one largest element. Find whether the largest element in the array is at least twice as much as every other number in the array. If it is, return the index of the largest element, otherwise return -1. Example 1: Input: nums = [3, 6, 1, 0] Output: 1 Explanation: 6 is the largest integer, and for every other number in the array x, 6 is more than twice as big as x. The index of value 6 is 1, so we return 1. Example 2: Input: nums = [1, 2, 3, 4] Output: -1 Explanation: 4 isn’t at least as big as twice the value of 3, so we return -1. Note: nums will have a length in the range [1, 50]. Every nums[i] will be an integer in the range [0, 99]. solution: 1.最开始想到的是用sort()函数来解决这个问题，但是需要注意两点：在sort函数中添加判断数字大小的函数，否则会将数字视为字符串，用最开始的数字进行排序；再一个就是在复制数组时，不能直接使用‘=’进行复制操作，因为这样其实传递的是数组地址，如果这样赋值，在对原先数组进行操作时，其实会对新建的数组进行修改。123456789101112131415161718192021222324252627282930313233function sequence(a,b)&#123; if (a&gt;b) &#123; return 1; &#125;else if(a&lt;b)&#123; return -1 &#125;else&#123; return 0; &#125;&#125;;var dominantIndex = function(nums) &#123; var nums_copy; nums_copy = []; for(var m = 0; m &lt; nums.length; m++) &#123; nums_copy[m] = nums[m]; &#125; nums.sort(sequence); if(nums.length == 1) return 0; if(nums[nums.length - 2] &gt; 0) &#123; if(nums[nums.length - 1]/nums[nums.length - 2] &gt;= 2) &#123; for(var i = 0; i &lt; nums_copy.length; i++) &#123; if(nums_copy[i] == nums[nums.length -1]) return i; &#125; &#125; else return -1; &#125; else &#123; for(var n = 0; n &lt; nums_copy.length; n++) &#123; if(nums_copy[n] == nums[nums.length -1]) return n; &#125; &#125;&#125;; 复杂度分析：Time Complexity: O(n), n为nums的长度； 2.一开始以为上述方法比较简单，但实际写下来还有需要细节要注意，因此，先选出数组中的最大值，在与数组中的所有元素进行对比，当有元素大于nums[maxIndex]的1/2时，返回-1，否则返回该最大值下标。123456789101112var dominantIndex = function(nums) &#123; var maxIndex = 0; for (var i = 0; i &lt; nums.length; ++i) &#123; if (nums[i] &gt; nums[maxIndex]) maxIndex = i; &#125; for (var i = 0; i &lt; nums.length; ++i) &#123; if (maxIndex != i &amp;&amp; nums[maxIndex] &lt; 2 * nums[i]) return -1; &#125; return maxIndex;&#125;; 复杂度分析：Time Complexity: O(n), n为nums的长度;]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 4.longest continuous increasing subsequence]]></title>
    <url>%2F2018%2F01%2F25%2FleetCode%2Farray%2F04.longest_continuous_increasing_subsequence%2F</url>
    <content type="text"><![CDATA[Problem four: longest continuous increasing subsequenceGiven an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray). Example 1: Input: [1,3,5,4,7] Output: 3 Explanation: The longest continuous increasing subsequence is [1,3,5], its length is 3. Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4. Example 2: Input: [2,2,2,2,2] Output: 1 Explanation: The longest continuous increasing subsequence is [2], its length is 1. Note: Length of the array will not exceed 10,000. solution: 1.直观的想法是遍历数组时，当数字持续增加时用一个数字存储累加的总和，在减少时与另一个初始为0的数字对比，如果大于这个存放之前的最长长度的数字，则替换该值，并重置计数的大小。最后，比较最后一次累加数值的大小，返回最大值。1234567891011121314151617181920var findLengthOfLCIS = function(nums) &#123; var num = 1; var maxLength = 0; if(nums.length == 0) return 0; for(var i = 1; i &lt; nums.length; i++) &#123; if(nums[i] &gt; nums[i-1]) &#123; num++; &#125; else &#123; if(num &gt; maxLength) &#123; maxLength = num; &#125; num = 1; &#125; &#125; if(num &gt; maxLength) return num; else return maxLength;&#125;; 复杂度分析：Time Complexity：O(n), n为nums的长度； 2.因为累加的子串是在nums[i-1] &gt;= nums[i]时发生变化的，也就是说我们将变化的元素下标记录下来，当前一个元素大于后一个元素时，将当前元素下标赋值给anchor，在累加的过程中，ans会用之前的最长串与现在的累加的串的长度作对比，保留最长串。12345678910var findLengthOfLCIS = function(nums) &#123; var ans = 0; var anchor = 0; for (var i = 0; i &lt; nums.length; ++i) &#123; if (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i]) anchor = i; ans = Math.max(ans, i - anchor + 1); &#125; return ans;&#125;; 复杂度分析：Time Complexity：O(n), n为nums的长度；]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Array -- 3.Best Time to Buy and Sell Stock]]></title>
    <url>%2F2018%2F01%2F23%2FleetCode%2Farray%2F03.Best_Time_to_Buy_and_sell_stock%2F</url>
    <content type="text"><![CDATA[Problem three: Best Time to Buy and Sell StockSay you have an array for which the ith element is the price of a given stock on day i. If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit. Example 1: Input: [7, 1, 5, 3, 6, 4]Output: 5max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price) Example 2: Input: [7, 6, 4, 3, 1]Output: 0In this case, no transaction is done, i.e. max profit = 0. solution: 1.这道题主要考察的是边界条件的判断，首先，将第二个元素与第一个元素进行对比，如果第二个元素大，则设置maxProfit，minPrice和maxPrice，如果第一个元素大，设置maxPrice，minPrice。若不为前两个元素，需要考虑下一个元素与之前最小的元素比较是否会大于之前的maxProfit，若大于，则设置maxProfit和maxPrice，否则设置minPrice。以此类推，最后返回maxProfit。 1234567891011121314151617181920212223242526272829var maxProfit = function(prices) &#123; var maxProfit = 0; var maxPrice = 0; var minPrice = 0; for(var i = 1; i &lt; prices.length; i++) &#123; if(i == 1) &#123; if((prices[i] - prices[i-1]) &gt; maxProfit) &#123; maxProfit = prices[i] - prices[i-1]; minPrice = prices[i - 1]; maxPrice = prices[i]; &#125; else &#123; minPrice = prices[i]; maxPrice = prices[i-1]; &#125; &#125;else &#123; if((prices[i] - minPrice) &gt; maxProfit) &#123; maxProfit = prices[i] - minPrice; maxPrice = prices[i]; &#125; else&#123; if(minPrice &gt; prices[i]) &#123; minPrice = prices[i]; &#125; &#125; &#125; &#125; return maxProfit;&#125;; 复杂度分析：Time Complexity：O(n), n为nums的长度； 2.接下来换一种思想比较简单的方法，现在需要找到最大的差值，且大的数在后面，小的数在前面，所以，可以两层嵌套，比较元素后面的值并选出最大的值。1234567891011var maxProfit = function(prices) &#123; var maxprofit = 0; for (var i = 0; i &lt; prices.length - 1; i++) &#123; for (var j = i + 1; j &lt; prices.length; j++) &#123; var profit = prices[j] - prices[i]; if (profit &gt; maxprofit) maxprofit = profit; &#125; &#125; return maxprofit; &#125;; 复杂度分析：Time Complexity：O(n2), 循环n(n-1)/2遍，效果很差。 3.接下来的方法和第一种类似，先去一个特别大的最小值和特别大的最大值，然后进行遍历，若当前元素小于最小值，则替换最小值，否则就与最小值比较，若大于最大差值，则替换最大差值。这个方法与第一种比不需要保存最大值。1234567891011var maxProfit = function(prices) &#123; var minprice = 9999999; var maxprofit = 0; for (var i = 0; i &lt; prices.length; i++) &#123; if (prices[i] &lt; minprice) minprice = prices[i]; else if (prices[i] - minprice &gt; maxprofit) maxprofit = prices[i] - minprice; &#125; return maxprofit; &#125;; 复杂度分析：Time Complexity：O(n), n为nums的长度；]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[LeetCode Array -- 2.Remove Element]]></title>
    <url>%2F2018%2F01%2F23%2FleetCode%2Farray%2F02.remove_element%2F</url>
    <content type="text"><![CDATA[Problem two: Remove ElementGiven an array and a value, remove all instances of that value in-place and return the new length. Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory. The order of elements can be changed. It doesn’t matter what you leave beyond the new length. Example: Given nums = [3,2,2,3], val = 3, Your function should return length = 2, with the first two elements of nums being 2. solution: 1.最直接的方法是使用数组自带的splice方法，需要注意的是当remove掉相符合的元素后，要将下标减一，不然会造成数组减少一个元素后，原元素后面的元素序号会提前一个，会忽略掉下一个元素。 123456789var removeElement = function(nums, val) &#123; for(var i = 0; i&lt; nums.length; i++) &#123; if(nums[i] == val) &#123; nums.splice(i, 1); i -= 1; &#125; &#125; return nums.length;&#125;; 复杂度分析：Time Complexity：O(n), n为nums的长度； 2.另一种方法是在遍历数组过程中，如果元素的值等于对应的value，则将当前元素与最后一个元素交换位置，然后将数组长度减1，变相的去除数组的重复项，可惜的是，这种方法和splice()消耗的时间几近相同。12345678910111213var removeElement = function(nums, val) &#123; var i = 0; var num = nums.length; while (i &lt; num) &#123; if (nums[i] == val) &#123; nums[i] = nums[num - 1]; num--; &#125; else &#123; i++; &#125; &#125; return num;&#125;; 复杂度分析：Time Complexity：O(n), n为nums的长度；]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[leetCode Array -- 1.Find Pivot Index]]></title>
    <url>%2F2018%2F01%2F23%2FleetCode%2Farray%2F01.find_pivot_index%2F</url>
    <content type="text"><![CDATA[Problem one: Find Pivot IndexGiven an array of integers nums, write a method that returns the “pivot” index of this array. We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index. If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index. Example 1: Input:nums = [1, 7, 3, 6, 5, 6]Output: 3Explanation:The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.Also, 3 is the first index where this occurs. Example 2: Input:nums = [1, 2, 3]Output: -1Explanation:There is no index that satisfies the conditions in the problem statement. Note: The length of nums will be in the range [0, 10000]. Each element nums[i] will be an integer in the range [-1000, 1000]. solution: 直接想到的是遍历数组，将每个元素左侧的元素和与右侧元素和比较，相同则返回对应元素下标。（若第一个元素右侧和为0，则返回第一个元素下标）。否则返回-1；123456789101112131415161718 var pivotIndex = function(nums) &#123; var leftSum = 0; var rightSum = 0; for(var i = 0; i &lt; nums.length; i++) &#123; if(i == 0) &#123; leftSum =0; &#125;else&#123; leftSum += nums[i-1]; &#125; for(var n = i+1; n &lt; nums.length; n++) &#123; rightSum += nums[n]; &#125; if(leftSum == rightSum) return i; rightSum = 0; &#125; return -1;&#125;; 复杂度分析：Time Complexity：O(n2), n为nums的长度； 上一种方法的问题在于要用两遍for循环，时间复杂度过高，所以尽量减少嵌套：123456789101112 var pivotIndex = function(nums) &#123; var leftSum =0; var sum = 0; for(var i = 0; i&lt; nums.length; i++) sum += nums[i]; for (var n = 0; n &lt; nums.length; n++) &#123; if (leftSum == (sum - leftSum - nums[n])) return n; leftSum += nums[n]; &#125; return -1;&#125; 复杂度分析：Time Complexity: O(n), n为nums的长度；]]></content>
      <categories>
        <category>leetCode</category>
      </categories>
      <tags>
        <tag>leetCode</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[搭建github博客]]></title>
    <url>%2F2018%2F01%2F12%2Fblog%2Fproblem%2F%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2%2F</url>
    <content type="text"><![CDATA[搭建github博客&amp;使用hexo博客框架&amp;使用material主题因为原先在CSDN上有各种各样的限制和难言之隐，所以在生庆哥的帮助和怂恿下，选择使用github搭建博客并个性化设置，主要说一下大体过程和期间的问题。主要的内容可以分为以下三类： 搭建github博客 使用hexo框架 使用material主题 搭建github博客其实之前在学校的时候一直知道github看可以搭建博客，还可以直接使用对应的域名，但是出于各种原因一直没有自己搭建一个博客尝试尝试，终于，现在正好有时间和精力可以试试。在个人github首页上，创建一个github.io的框架，即个人账户+仓库名，如：lpldplws.github.io。因为此仓库就是用来放博客的，所以在master分支上开发，然后在setting页面中选择launch automatic page generator生成博客项目。然后将该项目clone到本地，最初的博客就搭建成了~ 个人博客地址是lpldplws.github.io。接下来要做的就是redirect到自己的域名，在阿里上买了一个29一年的域名，名字是lpldplws.cn,需要做的是在clone下的项目的根目录下建立好映射，创建一个”CNAME”（没有后缀名）的文件，之后访问lpldplws.github.io就会redirect到此域名，或者您在对应的域名服务商上面修改CNAME到对应的github仓库地址也是可以的。注意：此处因为是直接在master分支上创建的，之后也是在master分支上使用的框架和主题，导致最后hexo generate的内容保存到了github.io中，这部分是接下来一周需要解决的问题之一。 使用hexo框架之所以知道这个框架是因为咱们的FE团队的翻译框架就是这个，所以此处借鉴了以下，嘿嘿。在hexo官网上,介绍了这是一个简单高效的博客框架，在github.io仓库中，使用npm安装即可。虽然可以支持markdown的格式，但是其自带的tag也是非常方便的，我看还可以使用youtube视频，厉害了，这理所当然的成为下周需要学习的内容之一了。还有一个比较深的体会是使用hexo的感觉就像开发机一样，通过hexo server相当于在开发机上查看效果，使用hexo generate和hexo deploy相当于部署在线上环境，就是少了review的部分，不过对于一个个人博客来说还是比较完善的了。 使用material主题使用hexo默认界面当然不能满足自己的审美了，在一番选择（选择恐惧症）后，终于选(sui)择(ji)了一个比较好看的theme，这就是material，这个主题比较素雅，正好很吸引我~以下主要说明material主题配置中遇到的问题。其中主要的配置文件在config.template.yaml中，不过需要先将其改名为config.yaml。在页面配置中，按照流程可以选择对应的插件和效果，比较吸引人的是它的背景可以从必应上选择，后来因为颜色不匹配主题就去掉了，个人打算通过对选项加一个filter或者下到对应文件随机加载是个不错的选择，所以下周又新加了一项任务。还有一点就是评论系统和统计系统，个人选择的是Valine，因为考虑到可以使用对应后台查看信息，不过缺点就是有点丑。。。后来生庆哥说Google的后台数据处理用的人很多，所以打算抛弃当前评论系统，投入其他评论系统的怀抱。对于独立页面部分还没有怎么看，下周来吧，除此之外，除了在mobile上效果还行，pc上两端有点空，所以想加一个音乐播放器，这部分打算选择网易云的api，实现一个音乐播放的效果。其他的内容就慢慢补全吧，这周过的虽然很累但还是很充实，个人也应该静下心来，虽然很多不会，但是相信通过付出比别人更多的努力，一定快速达到可以帮助到胡老师和FE团队的地步，fighting！]]></content>
      <categories>
        <category>前端常见问题</category>
      </categories>
      <tags>
        <tag>前端问题</tag>
      </tags>
  </entry>
</search>
