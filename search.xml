<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[03.Advanced Guides -- 01.Accessibility]]></title>
      <url>/2018/06/29/react/03.Advanced_Guides/01.Accessibility/</url>
      <content type="html"><![CDATA[<h2 id="Accessibility-可访问性"><a href="#Accessibility-可访问性" class="headerlink" title="Accessibility(可访问性)"></a>Accessibility(可访问性)</h2><h3 id="Why-Accessibility-为什么要考虑可访问性？"><a href="#Why-Accessibility-为什么要考虑可访问性？" class="headerlink" title="Why Accessibility?(为什么要考虑可访问性？)"></a>Why Accessibility?(为什么要考虑可访问性？)</h3><p>Web accessibility (also referred to as <a href="https://en.wiktionary.org/wiki/a11y" target="_blank" rel="noopener">a11y</a>) is the design and creation of websites that can be used by everyone. Accessibility support is necessary to allow assistive technology to interpret web pages.</p>
<p>Web可访问性（也称为<a href="https://en.wiktionary.org/wiki/a11y" target="_blank" rel="noopener">a11y</a>）是指如何设计和创建可供任何人都可以使用的网站。可访问性的支持是必须的，因为它们可以才协助辅助性技术渲染网页。</p>
<p>React fully supports building accessible websites, often by using standard HTML techniques.</p>
<p>React可以通过使用标准的HTML技术来完全支持构建可访问性的网站。</p>
<h3 id="Standards-and-Guidelines（标准和指南）"><a href="#Standards-and-Guidelines（标准和指南）" class="headerlink" title="Standards and Guidelines（标准和指南）"></a>Standards and Guidelines（标准和指南）</h3><h4 id="WCAG"><a href="#WCAG" class="headerlink" title="WCAG"></a>WCAG</h4><p>The <a href="https://www.w3.org/WAI/intro/wcag" target="_blank" rel="noopener">Web Content Accessibility Guidelines</a> provides guidelines for creating accessible web sites.</p>
<p><a href="https://www.w3.org/WAI/intro/wcag" target="_blank" rel="noopener">网站内容可访问性指南</a>为创建可访问网站的提供了指导指南。</p>
<p>The following WCAG checklists provide an overview:</p>
<p>以下为WCAG清单提供了一个概述：</p>
<ul>
<li><a href="https://www.wuhcag.com/wcag-checklist/" target="_blank" rel="noopener">WCAG checklist from Wuhcag</a></li>
<li><a href="http://webaim.org/standards/wcag/checklist" target="_blank" rel="noopener">WCAG checklist from WebAIM</a></li>
<li><p><a href="http://a11yproject.com/checklist.html" target="_blank" rel="noopener">Checklist from The A11Y Project</a></p>
</li>
<li><p><a href="https://www.wuhcag.com/wcag-checklist/" target="_blank" rel="noopener">关于WCAG的Wuhcag概述</a></p>
</li>
<li><a href="http://webaim.org/standards/wcag/checklist" target="_blank" rel="noopener">关于WCAG的WebAIM概述</a></li>
<li><a href="http://a11yproject.com/checklist.html" target="_blank" rel="noopener">来自A11Y项目的概述</a></li>
</ul>
<h4 id="WAI-ARIA"><a href="#WAI-ARIA" class="headerlink" title="WAI-ARIA"></a>WAI-ARIA</h4><p>The <a href="https://www.w3.org/WAI/intro/aria" target="_blank" rel="noopener">Web Accessibility Initiative - Accessible Rich Internet Applications</a> document contains techniques for building fully accessible JavaScript widgets.</p>
<p><a href="https://www.w3.org/WAI/intro/aria" target="_blank" rel="noopener">网页可访问性倡议 - 充分可访问性的互联网应用程序</a>文章中包含了对于构建充分可访问的JavaScript部件的技术。</p>
<p>Note that all <code>aria-*</code> HTML attributes are fully supported in JSX. Whereas most DOM properties and attributes in React are camelCased, these attributes should be lowercased:</p>
<p>注意，JSX完全支持所有<code>aria- *</code> HTML属性。尽管React中的大多数DOM属性和特性都是camelCased的，但<code>aria-*</code>属性应该是小写的：</p>
<pre><code>&lt;input
  type=&quot;text&quot;
  aria-label={labelText}
  aria-required=&quot;true&quot;
  onChange={onchangeHandler}
  value={inputValue}
  name=&quot;name&quot;
/&gt;
</code></pre><h3 id="Semantic-HTML-语义化的HTML"><a href="#Semantic-HTML-语义化的HTML" class="headerlink" title="Semantic HTML(语义化的HTML)"></a>Semantic HTML(语义化的HTML)</h3><p>Semantic HTML is the foundation of accessibility in a web application. Using the various HTML elements to reinforce the meaning of information in our websites will often give us accessibility for free.</p>
<p>语义化的HTML是一个web应用可访问性的基础。我们可以通过在网站中使用不同的HTML元素来加强想表达的信息的含义，这可以让我们的应用更具有可访问性。</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element" target="_blank" rel="noopener">MDN HTML elements reference(MDN HTML元素的参阅)</a></li>
</ul>
<p>Sometimes we break HTML semantics when we add <div> elements to our JSX to make our React code work, especially when working with lists (<ol>, <ul> and <dl>) and the HTML <table>. In these cases we should rather use React Fragments to group together multiple elements.</table></dl></ul></ol></div></p>
<p>有时，当我们将<code>&lt;div&gt;</code>元素添加到JSX中以使我们的React代码工作时，我们会破坏HTML语义，尤其是在使用列表（<code>&lt;ol&gt;</code>，<code>&lt;ul&gt;</code>和<code>&lt;dl&gt;</code>）和HTML <code>&lt;table&gt;</code>时。 在这些情况下，我们应该使用React Fragments将多个元素组合在一起。</p>
<p>Use <code>&lt;Fragment&gt;</code> when a key prop is required:</p>
<p>在key的属性是必须时使用<code>&lt;Fragment&gt;</code></p>
<pre><code>import React, { Fragment } from &#39;react&#39;;

function Glossary(props) {
  return (
    &lt;dl&gt;
      {props.items.map(item =&gt; (
        // Without the `key`, React will fire a key warning
        &lt;Fragment key={item.id}&gt;
          &lt;dt&gt;{item.term}&lt;/dt&gt;
          &lt;dd&gt;{item.description}&lt;/dd&gt;
        &lt;/Fragment&gt;
      ))}
    &lt;/dl&gt;
  );
}
</code></pre><p>Use <code>&lt;&gt;&lt;/&gt;</code> syntax everywhere else:</p>
<p>在任何地方使用<code>&lt;&gt;&lt;/&gt;</code>语法</p>
<pre><code>function ListItem({ item }) {
  return (
    &lt;&gt;
      &lt;dt&gt;{item.term}&lt;/dt&gt;
      &lt;dd&gt;{item.description}&lt;/dd&gt;
    &lt;/&gt;
  );
}
</code></pre><blockquote>
<p>即为了不破坏HTML结构的完整性和统一性，可以将React Fragment或者<code>&lt;&gt;&lt;/&gt;</code>添加到React组件返回的内容上以此来保持返回元素的可访问性。</p>
</blockquote>
<h3 id="Accessible-Forms-可访问性的表单"><a href="#Accessible-Forms-可访问性的表单" class="headerlink" title="Accessible Forms(可访问性的表单)"></a>Accessible Forms(可访问性的表单)</h3><h4 id="Labeling-标签"><a href="#Labeling-标签" class="headerlink" title="Labeling(标签)"></a>Labeling(标签)</h4><p>Every HTML form control, such as <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code>, needs to be labeled accessibly. We need to provide descriptive labels that are also exposed to screen readers.</p>
<p>每个HTML表单中的控制元件，例如<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>都需要有可访问性的标签。我们也需要也向屏幕阅读器提供公开的描述性标签。</p>
<p>The following resources show us how to do this:</p>
<p>下列资源告诉我们如何做到这些：</p>
<ul>
<li><a href="https://www.w3.org/WAI/tutorials/forms/labels/" target="_blank" rel="noopener">The W3C shows us how to label elements</a></li>
<li><a href="http://webaim.org/techniques/forms/controls" target="_blank" rel="noopener">WebAIM shows us how to label elements</a></li>
<li><p><a href="https://www.paciellogroup.com/blog/2017/04/what-is-an-accessible-name/" target="_blank" rel="noopener">The Paciello Group explains accessible names</a></p>
</li>
<li><p><a href="https://www.w3.org/WAI/tutorials/forms/labels/" target="_blank" rel="noopener">W3C 告诉我们如何标记元素</a></p>
</li>
<li><a href="http://webaim.org/techniques/forms/controls" target="_blank" rel="noopener">WebAIM告诉我们如何标记元素</a></li>
<li><a href="https://www.paciellogroup.com/blog/2017/04/what-is-an-accessible-name/" target="_blank" rel="noopener">Paciello项目组介绍了如何让名称具有可访问性</a></li>
</ul>
<p>Although these standard HTML practices can be directly used in React, note that the <code>for</code> attribute is written as <code>htmlFor</code> in JSX:</p>
<p>尽管这些标准的HTML元素可以直接在React中使用，但还要注意<code>for</code>属性在JSX中应当写成’htmlFor’:</p>
<pre><code>&lt;label htmlFor=&quot;namedInput&quot;&gt;Name:&lt;/label&gt;
&lt;input id=&quot;namedInput&quot; type=&quot;text&quot; name=&quot;name&quot;/&gt;
</code></pre><h4 id="Notifying-the-user-of-errors-通知用户错误信息"><a href="#Notifying-the-user-of-errors-通知用户错误信息" class="headerlink" title="Notifying the user of errors(通知用户错误信息)"></a>Notifying the user of errors(通知用户错误信息)</h4><p>Error situations need to be understood by all users. The following link shows us how to expose error texts to screen readers as well:</p>
<p>所有用户都需要能够读懂错误信息。以下链接向我们展示了如何将错误文本展示给屏幕阅读器：</p>
<ul>
<li><a href="https://www.w3.org/WAI/tutorials/forms/notifications/" target="_blank" rel="noopener">The W3C demonstrates user notifications</a></li>
<li><a href="http://webaim.org/techniques/formvalidation/" target="_blank" rel="noopener">WebAIM looks at form validation</a></li>
<li><a href="https://www.w3.org/WAI/tutorials/forms/notifications/" target="_blank" rel="noopener">W3C演示用户通知示例</a></li>
<li><a href="http://webaim.org/techniques/formvalidation/" target="_blank" rel="noopener">WebAIM演示表单验证</a></li>
</ul>
<h3 id="Focus-Control-焦点控制"><a href="#Focus-Control-焦点控制" class="headerlink" title="Focus Control(焦点控制)"></a>Focus Control(焦点控制)</h3><p>Ensure that your web application can be fully operated with the keyboard only:</p>
<p>确保您的web应用只可以通过键盘进行操作：</p>
<ul>
<li><a href="http://webaim.org/techniques/keyboard/" target="_blank" rel="noopener">WebAIM talks about keyboard accessibility</a></li>
<li><a href="http://webaim.org/techniques/keyboard/" target="_blank" rel="noopener">WebAIM讨论键盘的可访问性</a></li>
</ul>
<h4 id="Keyboard-focus-and-focus-outline-键盘聚焦和轮廓聚焦"><a href="#Keyboard-focus-and-focus-outline-键盘聚焦和轮廓聚焦" class="headerlink" title="Keyboard focus and focus outline(键盘聚焦和轮廓聚焦)"></a>Keyboard focus and focus outline(键盘聚焦和轮廓聚焦)</h4><p>Keyboard focus refers to the current element in the DOM that is selected to accept input from the keyboard. We see it everywhere as a focus outline similar to that shown in the following image:</p>
<p>键盘聚焦是指选用DOM中的当前元素作为键盘中的输入。这种表现非常常见，与下图所示类似的焦点轮廓类似：</p>
<p><img src="/images/react_document/03-01-keyboard_focus_button.png" style="margin:0 auto;display:block"></p>
<p>Only ever use CSS that removes this outline, for example by setting <code>outline: 0</code>, if you are replacing it with another focus outline implementation.</p>
<p>只可以通过CSS来删除外边框，如果您用另一种聚焦外边框来替换它，可以通过设置<code>outline: 0</code>来实现。</p>
<h4 id="Mechanisms-to-skip-to-desired-content-跳转到期待的内容的机制"><a href="#Mechanisms-to-skip-to-desired-content-跳转到期待的内容的机制" class="headerlink" title="Mechanisms to skip to desired content(跳转到期待的内容的机制)"></a>Mechanisms to skip to desired content(跳转到期待的内容的机制)</h4><p>Provide a mechanism to allow users to skip past navigation sections in your application as this assists and speeds up keyboard navigation.</p>
<p>我们提供了一种机制，允许用户在您的应用中跳过导航部分，因为这有助于通过键盘导航。</p>
<p>Skiplinks or Skip Navigation Links are hidden navigation links that only become visible when keyboard users interact with the page. They are very easy to implement with internal page anchors and some styling:</p>
<p>跳转链接或跳转导航链接通常是隐藏的，只有当用户通过键盘与页面进行交互时才会显示。通过内部页面锚点和一些样式，我们非常容易实现这种功能：</p>
<ul>
<li><a href="http://webaim.org/techniques/skipnav/" target="_blank" rel="noopener">WebAIM - Skip Navigation Links</a></li>
<li><a href="http://webaim.org/techniques/skipnav/" target="_blank" rel="noopener">WebAIM - 跳转导航链接</a></li>
</ul>
<h4 id="Programmatically-managing-focus-用编程化的方式来管理焦点"><a href="#Programmatically-managing-focus-用编程化的方式来管理焦点" class="headerlink" title="Programmatically managing focus(用编程化的方式来管理焦点)"></a>Programmatically managing focus(用编程化的方式来管理焦点)</h4><p>Our React applications continuously modify the HTML DOM during runtime, sometimes leading to keyboard focus being lost or set to an unexpected element. In order to repair this, we need to programmatically nudge the keyboard focus in the right direction. For example, by resetting keyboard focus to a button that opened a modal window after that modal window is closed.</p>
<p>我们的React项目会在运行时持续的调整HTML节点，有时会导致键盘丢失焦点或设置到意想不到的元素上。为了修复这个问题，我们需要以正确的方向以编程方式来设置键盘焦点。例如，在一个模式窗口关闭后通过重置键盘焦点到一个按钮上来打开一个模式窗口。</p>
<p>MDN Web Docs takes a look at this and describes how we can build keyboard-navigable <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets" target="_blank" rel="noopener">JavaScript widgets</a>.</p>
<p>MDN Web文档考虑到了这方面的问题并向我们介绍了如何搭建键盘导航的<a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets" target="_blank" rel="noopener">JavaScript组件</a></p>
<p>To set focus in React, we can use <a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">Refs to DOM elements</a>.</p>
<p>为了设置React焦点，我们可以使用<a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">DOM元素的Refs</a></p>
<p>Using this, we first create a ref to an element in the JSX of a component class:</p>
<p>为了介绍Refs，我们首先在组件类的JSX中创建一个元素的ref：</p>
<pre><code>class CustomTextInput extends React.Component {
  constructor(props) {
    super(props);
    // Create a ref to store the textInput DOM element
    this.textInput = React.createRef();
  }
  render() {
  // Use the `ref` callback to store a reference to the text input DOM
  // element in an instance field (for example, this.textInput).
    return (
      &lt;input
        type=&quot;text&quot;
        ref={this.textInput}
      /&gt;
    );
  }
}
</code></pre><p>Then we can focus it elsewhere in our component when needed:</p>
<p>然后当我们需要时，我们可以在组件的任何地方调用focus函数了：</p>
<pre><code>focus() {
  // Explicitly focus the text input using the raw DOM API
  // Note: we&#39;re accessing &quot;current&quot; to get the DOM node
  this.textInput.current.focus();
}
</code></pre><p>Sometimes a parent component needs to set focus to an element in a child component. We can do this by exposing <a href="https://reactjs.org/docs/refs-and-the-dom.html#exposing-dom-refs-to-parent-components" target="_blank" rel="noopener">DOM refs to parent components</a> through a special prop on the child component that forwards the parent’s ref to the child’s DOM node.</p>
<p>有些时候父组件需要将焦点设置在子组件的一个元素上。我们可以根据<a href="https://reactjs.org/docs/refs-and-the-dom.html#exposing-dom-refs-to-parent-components" target="_blank" rel="noopener">向父组件传递DOM refs</a>通过在子组件上设置一个特殊的属性,然后父组件通过ref指向子组件的DOM节点。</p>
<pre><code>function CustomTextInput(props) {
  return (
    &lt;div&gt;
      &lt;input ref={props.inputRef} /&gt;
    &lt;/div&gt;
  );
}

class Parent extends React.Component {
  constructor(props) {
    super(props);
    this.inputElement = React.createRef();
  }
  render() {
    return (
      &lt;CustomTextInput inputRef={this.inputElement} /&gt;
    );
  }
}
/&gt;

// Now you can set focus when required.
this.inputElement.current.focus();
</code></pre><p>When using a HOC to extend components, it is recommended to <a href="https://reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener">forward the ref</a> to the wrapped component using the <code>forwardRef</code> function of React. If a third party HOC does not implement ref forwarding, the above pattern can still be used as a fallback.</p>
<p>当使用HOC扩展组件时，建议使用React的<code>forwardRef</code>函数<a href="https://reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener">将ref传到</a>到包装好的组件。如果第三方库HOC没有使用向下传递ref，上述模式仍然可以用作备用方案。</p>
<p>A great focus management example is the <a href="https://github.com/davidtheclark/react-aria-modal" target="_blank" rel="noopener">react-aria-modal</a>. This is a relatively rare example of a fully accessible modal window. Not only does it set initial focus on the cancel button (preventing the keyboard user from accidentally activating the success action) and trap keyboard focus inside the modal, it also resets focus back to the element that initially triggered the modal.</p>
<p>一个很好的焦点管理的例子就是<a href="https://github.com/davidtheclark/react-aria-modal" target="_blank" rel="noopener">react-aria-modal</a>。 这是一个相当罕见的完全无障碍的窗口模式的例子。它不仅将初始焦点设置在取消按钮上以避免键盘焦点陷入该模式中（防止键盘用户意外激活成功操作）还将焦点重置回最初触发模式的元素。</p>
<blockquote>
<p>Note:<br>While this is a very important accessibility feature, it is also a technique that should be used judiciously. Use it to repair the keyboard focus flow when it is disturbed, not to try and anticipate how users want to use applications.</p>
<p>提示：<br>虽然这是可访问性非常重要的一个特点，但它也是一种应该谨慎使用的技术。用它修复键盘焦点流时，不要试图预测用户是如何使用应用程序的。</p>
</blockquote>
<h3 id="More-Complex-Widgets-更复杂的组件"><a href="#More-Complex-Widgets-更复杂的组件" class="headerlink" title="More Complex Widgets(更复杂的组件)"></a>More Complex Widgets(更复杂的组件)</h3><p>A more complex user experience should not mean a less accessible one. Whereas accessibility is most easily achieved by coding as close to HTML as possible, even the most complex widget can be coded accessibly.</p>
<p>更复杂的用户体验不应该意味着可访问性更差。尽管通过类似HTML编码最容易实现可访问性，但即使是最复杂的小部件也可以有良好的访问性。</p>
<p>Here we require knowledge of <a href="https://www.w3.org/TR/wai-aria/#roles" target="_blank" rel="noopener">ARIA Roles</a> as well as <a href="https://www.w3.org/TR/wai-aria/#states_and_properties" target="_blank" rel="noopener">ARIA States and Properties</a>. These are toolboxes filled with HTML attributes that are fully supported in JSX and enable us to construct fully accessible, highly functional React components.</p>
<p>在这里，我们需要知道<a href="https://www.w3.org/TR/wai-aria/#roles" target="_blank" rel="noopener">ARIA角色</a>以及<a href="https://www.w3.org/TR/wai-aria/#states_and_properties" target="_blank" rel="noopener">ARIA的状态和属性</a>。 这些工具箱包含了JSX完全支持的HTML属性，使我们能够构建可访问性良好，功能强大的React组件。</p>
<p>Each type of widget has a specific design pattern and is expected to function in a certain way by users and user agents alike:</p>
<p>每个类型的组件都有一个特定的设计模式，并且预计会以某种方式由用户和用户代理运行：</p>
<ul>
<li><a href="https://www.w3.org/TR/wai-aria-practices/#aria_ex" target="_blank" rel="noopener">WAI-ARIA Authoring Practices - Design Patterns and Widgets</a></li>
<li><a href="http://heydonworks.com/practical_aria_examples/" target="_blank" rel="noopener">Heydon Pickering - ARIA Examples</a></li>
<li><p><a href="https://inclusive-components.design/" target="_blank" rel="noopener">Inclusive Components</a></p>
</li>
<li><p><a href="https://www.w3.org/TR/wai-aria-practices/#aria_ex" target="_blank" rel="noopener">WAI-ARIA创作实践 - 设计模式和小工具</a></p>
</li>
<li><a href="http://heydonworks.com/practical_aria_examples/" target="_blank" rel="noopener">Heydon Pickering - ARIA示例</a></li>
<li><a href="https://inclusive-components.design/" target="_blank" rel="noopener">包容性组件</a></li>
</ul>
<h3 id="Other-Points-for-Consideration-其他需要考虑的点"><a href="#Other-Points-for-Consideration-其他需要考虑的点" class="headerlink" title="Other Points for Consideration(其他需要考虑的点)"></a>Other Points for Consideration(其他需要考虑的点)</h3><h4 id="Setting-the-language-设置语言"><a href="#Setting-the-language-设置语言" class="headerlink" title="Setting the language(设置语言)"></a>Setting the language(设置语言)</h4><p>Indicate the human language of page texts as screen reader software uses this to select the correct voice settings:</p>
<p>当屏幕阅读器软件选择语音设置时，请指明页面上对应的语言：</p>
<ul>
<li><a href="http://webaim.org/techniques/screenreader/#language" target="_blank" rel="noopener">WebAIM - Document Language</a></li>
<li><a href="http://webaim.org/techniques/screenreader/#language" target="_blank" rel="noopener">WebAIM - 文本语言</a></li>
</ul>
<h4 id="Setting-the-document-title-设置文本标题"><a href="#Setting-the-document-title-设置文本标题" class="headerlink" title="Setting the document title(设置文本标题)"></a>Setting the document title(设置文本标题)</h4><p>Set the document <code>&lt;title&gt;</code> to correctly describe the current page content as this ensures that the user remains aware of the current page context:</p>
<p>设置文本的<code>&lt;title&gt;</code>来正确的描述现在页面的内容，以此来保证用户始终正确了解页面的内容：</p>
<ul>
<li><a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/navigation-mechanisms-title.html" target="_blank" rel="noopener">WCAG - Understanding the Document Title Requirement</a></li>
<li><a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/navigation-mechanisms-title.html" target="_blank" rel="noopener">WCAG - 理解文档标题的需要</a></li>
</ul>
<p>We can set this in React using the <a href="https://github.com/gaearon/react-document-title" target="_blank" rel="noopener">React Document Title Component.</a></p>
<p>我们可以使用<a href="https://github.com/gaearon/react-document-title" target="_blank" rel="noopener">React文档标题组件</a>在React中使用。</p>
<h4 id="Color-contrast-颜色对比"><a href="#Color-contrast-颜色对比" class="headerlink" title="Color contrast(颜色对比)"></a>Color contrast(颜色对比)</h4><p>Ensure that all readable text on your website has sufficient color contrast to remain maximally readable by users with low vision:</p>
<p>确保您的网站页面上所有可阅读的文本度有足够的颜色对比，以便视力不便的用户也有最好的阅读体验。</p>
<ul>
<li><a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html" target="_blank" rel="noopener">WCAG - Understanding the Color Contrast Requirement</a></li>
<li><a href="https://www.smashingmagazine.com/2014/10/color-contrast-tips-and-tools-for-accessibility/" target="_blank" rel="noopener">Everything About Color Contrast And Why You Should Rethink It</a></li>
<li><p><a href="http://a11yproject.com/posts/what-is-color-contrast/" target="_blank" rel="noopener">A11yProject - What is Color Contrast</a></p>
</li>
<li><p><a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html" target="_blank" rel="noopener">WCAG - 理解颜色对比的需要</a></p>
</li>
<li><a href="https://www.smashingmagazine.com/2014/10/color-contrast-tips-and-tools-for-accessibility/" target="_blank" rel="noopener">有关颜色对比的所有事及为什么应该重新思考它</a></li>
<li><a href="http://a11yproject.com/posts/what-is-color-contrast/" target="_blank" rel="noopener">A11yProject - 什么是颜色对比</a></li>
</ul>
<p>It can be tedious to manually calculate the proper color combinations for all cases in your website so instead, you can <a href="http://jxnblk.com/colorable/" target="_blank" rel="noopener">calculate an entire accessible color palette with Colorable</a>.</p>
<p>手动计算网站中所有组件适当的颜色组合可能是非常繁琐的，因此您可以<a href="http://jxnblk.com/colorable/" target="_blank" rel="noopener">使用Colorable来计算整个可访问的调色板</a>。</p>
<p>Both the aXe and WAVE tools mentioned below also include color contrast tests and will report on contrast errors.</p>
<p>下面提到的ax和WAVE工具都包括颜色对比测试，并会提到对比度误差。</p>
<p>If you want to extend your contrast testing abilities you can use these tools:</p>
<p>如果您想扩展您的颜色对比测试能力，您可以使用下列工具：</p>
<ul>
<li><a href="http://webaim.org/resources/contrastchecker/" target="_blank" rel="noopener">WebAIM - Color Contrast Checker</a></li>
<li><p><a href="https://www.paciellogroup.com/resources/contrastanalyser/" target="_blank" rel="noopener">The Paciello Group - Color Contrast Analyzer</a></p>
</li>
<li><p><a href="http://webaim.org/resources/contrastchecker/" target="_blank" rel="noopener">WebAIM - 颜色对比度检查器</a></p>
</li>
<li><a href="https://www.paciellogroup.com/resources/contrastanalyser/" target="_blank" rel="noopener">Paciello组 - 颜色对比处理器</a></li>
</ul>
<h3 id="Development-and-Testing-Tools-开发及测试工具"><a href="#Development-and-Testing-Tools-开发及测试工具" class="headerlink" title="Development and Testing Tools(开发及测试工具)"></a>Development and Testing Tools(开发及测试工具)</h3><p>There are a number of tools we can use to assist in the creation of accessible web applications.</p>
<p>下面是可以用来协助我们创建可访问性的网站的一系列的工具。</p>
<h4 id="The-keyboard-键盘"><a href="#The-keyboard-键盘" class="headerlink" title="The keyboard(键盘)"></a>The keyboard(键盘)</h4><p>By far the easiest and also one of the most important checks is to test if your entire website can be reached and used with the keyboard alone. Do this by:</p>
<p>到目前为止，最简单也是最重要的检查之一是测试整个网站是否可以与键盘一起使用。通过下面几步，我们可以做到这一点：</p>
<ol>
<li>Plugging out your mouse.</li>
<li>Using Tab and Shift+Tab to browse.</li>
<li>Using Enter to activate elements.</li>
<li><p>Where required, using your keyboard arrow keys to interact with some elements, such as menus and dropdowns.</p>
</li>
<li><p>拔下鼠标。</p>
</li>
<li>使用Tab和Shift + Tab浏览。</li>
<li>使用Enter激活元素。</li>
<li>根据需要，使用键盘上的箭头键与某些元素（如菜单和下拉菜单）进行交互。</li>
</ol>
<h4 id="Development-assistance-开发者工具"><a href="#Development-assistance-开发者工具" class="headerlink" title="Development assistance(开发者工具)"></a>Development assistance(开发者工具)</h4><p>We can check some accessibility features directly in our JSX code. Often intellisense checks are already provided in JSX aware IDE’s for the ARIA roles, states and properties. We also have access to the following tool:</p>
<p>我们可以在我们的JSX代码中直接检测一些可访问性的因素。通常IDE会扮演ARIA的角色自动进行状态和属性的检测。 我们也可以访问以下工具：</p>
<blockquote>
<p>eslint-plugin-jsx-a11y</p>
</blockquote>
<p>The <a href="https://github.com/evcohen/eslint-plugin-jsx-a11y" target="_blank" rel="noopener">eslint-plugin-jsx-a11y</a> plugin for ESLint provides AST linting feedback regarding accessibility issues in your JSX. Many IDE’s allow you to integrate these findings directly into code analysis and source code windows.</p>
<p>ESLint的<a href="https://github.com/evcohen/eslint-plugin-jsx-a11y" target="_blank" rel="noopener">eslint-plugin-jsx-a11y</a>提供了JSX在AST中可访问性问题的linting反馈。许多IDE允许您将这些问题直接集成到代码分析窗口和源代码窗口中。</p>
<p><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a> has this plugin with a subset of rules activated. If you want to enable even more accessibility rules, you can create an <code>.eslintrc</code> file in the root of your project with this content:</p>
<p><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>已有这个插件并沿用其中的一些规则。如果您希望使用更多可访问性的规则，则可以使用以下指令在项目的根目录下创建<code>.eslintrc</code>文件：</p>
<pre><code>{
  &quot;extends&quot;: [&quot;react-app&quot;, &quot;plugin:jsx-a11y/recommended&quot;],
  &quot;plugins&quot;: [&quot;jsx-a11y&quot;]
}
</code></pre><h4 id="Testing-accessibility-in-the-browser-在浏览器中测试可访问性"><a href="#Testing-accessibility-in-the-browser-在浏览器中测试可访问性" class="headerlink" title="Testing accessibility in the browser(在浏览器中测试可访问性)"></a>Testing accessibility in the browser(在浏览器中测试可访问性)</h4><p>A number of tools exist that can run accessibility audits on web pages in your browser. Please use them in combination with other accessibility checks mentioned here as they can only test the technical accessibility of your HTML.</p>
<p>许多工具可以在浏览器的网页上测试可访问性。请将它们与其他可访问性检查结合使用，因为它们只能测试与HTML相关的可访问性。</p>
<blockquote>
<p>aXe, aXe-core and react-axe</p>
</blockquote>
<p>Deque Systems offers <a href="https://github.com/dequelabs/axe-core" target="_blank" rel="noopener">aXe-core</a> for automated and end-to-end accessibility tests of your applications. This module includes integrations for Selenium.</p>
<p>Deque Systems为您的应用程序的自动化和端对端可访问性测试提供了<a href="https://github.com/dequelabs/axe-core" target="_blank" rel="noopener">ax-core</a>。 该模块包含Selenium的集成。</p>
<p><a href="https://www.deque.com/products/axe/" target="_blank" rel="noopener">The Accessibility Engine</a> or aXe, is an accessibility inspector browser extension built on <code>aXe-core</code>.</p>
<p><a href="https://www.deque.com/products/axe/" target="_blank" rel="noopener">可访问性的引擎</a>或者aXe,是一个内嵌在<code>aXe-core</code>上的检测可访问性的浏览器插件。</p>
<p>You can also use the <a href="https://github.com/dylanb/react-axe" target="_blank" rel="noopener">react-axe</a> module to report these accessibility findings directly to the console while developing and debugging.</p>
<p>您也可以使用<a href="https://github.com/dylanb/react-axe" target="_blank" rel="noopener">react-axe</a>模块在开发和调试时直接向控制台报告这些可访问性结果。</p>
<blockquote>
<p>WebAIM WAVE</p>
</blockquote>
<p>The <a href="http://wave.webaim.org/extension/" target="_blank" rel="noopener">Web Accessibility Evaluation Tool</a> is another accessibility browser extension.</p>
<p><a href="http://wave.webaim.org/extension/" target="_blank" rel="noopener">网络可访问性评估工具</a>是另一个可访问性的浏览器插件。</p>
<blockquote>
<p>Accessibility inspectors and the Accessibility Tree(可访问性检测器及可访问性树)</p>
</blockquote>
<p><a href="https://www.paciellogroup.com/blog/2015/01/the-browser-accessibility-tree/" target="_blank" rel="noopener">The Accessibility Tree</a> is a subset of the DOM tree that contains accessible objects for every DOM element that should be exposed to assistive technology, such as screen readers.</p>
<p><a href="https://www.paciellogroup.com/blog/2015/01/the-browser-accessibility-tree/" target="_blank" rel="noopener">可访问性树</a>是DOM树的子集，其中包含每个DOM元素的可访问对象，这些元素会暴露给可访问的设备，例如屏幕阅读器。</p>
<p>In some browsers we can easily view the accessibility information for each element in the accessibility tree:</p>
<p>在一些浏览器中，我们可以轻松地查看可访问性功能树中每个元素的可访问性信息：</p>
<ul>
<li>Activate the Accessibility Inspector in Chrome</li>
<li><p>Using the Accessibility Inspector in OS X Safari</p>
</li>
<li><p>在Chrome中激活辅助功能检查器</p>
</li>
<li>在OS X Safari中使用辅助功能检查器</li>
</ul>
<h4 id="Screen-readers-屏幕阅读器"><a href="#Screen-readers-屏幕阅读器" class="headerlink" title="Screen readers(屏幕阅读器)"></a>Screen readers(屏幕阅读器)</h4><p>Testing with a screen reader should form part of your accessibility tests.</p>
<p>测试屏幕阅读器应该是您可访问性测试的一部分。</p>
<p>Please note that browser / screen reader combinations matter. It is recommended that you test your application in the browser best suited to your screen reader of choice.</p>
<p>请注意，浏览器/屏幕阅读器的组合很重要。建议您在最适合的屏幕阅读器的浏览器中测试您的应用程序。</p>
<h4 id="Commonly-Used-Screen-Readers-通用的屏幕阅读器"><a href="#Commonly-Used-Screen-Readers-通用的屏幕阅读器" class="headerlink" title="Commonly Used Screen Readers(通用的屏幕阅读器)"></a>Commonly Used Screen Readers(通用的屏幕阅读器)</h4><blockquote>
<p>NVDA in Firefox</p>
</blockquote>
<p><a href="https://www.nvaccess.org/" target="_blank" rel="noopener">NonVisual Desktop Access</a> or NVDA is an open source Windows screen reader that is widely used.</p>
<p><a href="https://www.nvaccess.org/" target="_blank" rel="noopener">不可视的桌面访问</a>或者NVDA时一个广泛使用的开源的Windows屏幕阅读器。</p>
<p>Refer to the following guides on how to best use NVDA:</p>
<p>您可以参考下列的目录来学习如何最好的使用NVDA：</p>
<ul>
<li><a href="http://webaim.org/articles/nvda/" target="_blank" rel="noopener">WebAIM - Using NVDA to Evaluate Web Accessibility</a></li>
<li><p><a href="https://dequeuniversity.com/screenreaders/nvda-keyboard-shortcuts" target="_blank" rel="noopener">Deque - NVDA Keyboard Shortcuts</a></p>
</li>
<li><p><a href="http://webaim.org/articles/nvda/" target="_blank" rel="noopener">WebAIM - 使用NVDA来评估网络的可访问性</a></p>
</li>
<li><a href="https://dequeuniversity.com/screenreaders/nvda-keyboard-shortcuts" target="_blank" rel="noopener">Deque - NVDA键盘的快捷键</a></li>
</ul>
<blockquote>
<p>VoiceOver in Safari</p>
</blockquote>
<p>VoiceOver is an integrated screen reader on Apple devices.</p>
<p>VoiceOver是Apple设备上的集成屏幕阅读器。</p>
<p>Refer to the following guides on how activate and use VoiceOver:</p>
<p>您可以参考下列的目录来学习如何激活并使用VoiceOver：</p>
<ul>
<li><a href="http://webaim.org/articles/voiceover/" target="_blank" rel="noopener">WebAIM - Using VoiceOver to Evaluate Web Accessibility</a></li>
<li><a href="https://dequeuniversity.com/screenreaders/voiceover-keyboard-shortcuts" target="_blank" rel="noopener">Deque - VoiceOver for OS X Keyboard Shortcuts</a></li>
<li><p><a href="https://dequeuniversity.com/screenreaders/voiceover-ios-shortcuts" target="_blank" rel="noopener">Deque - VoiceOver for iOS Shortcuts</a></p>
</li>
<li><p><a href="http://webaim.org/articles/voiceover/" target="_blank" rel="noopener">WebAIM - 使用VoiceOver来评估Web可访问性</a></p>
</li>
<li><a href="https://dequeuniversity.com/screenreaders/voiceover-keyboard-shortcuts" target="_blank" rel="noopener">Deque- VoiceOver在OS X的快捷键</a></li>
<li><a href="https://dequeuniversity.com/screenreaders/voiceover-ios-shortcuts" target="_blank" rel="noopener">Deque - VoiceOver在iOS上的快捷键</a></li>
</ul>
<blockquote>
<p>JAWS in Internet Explorer</p>
</blockquote>
<p><a href="http://www.freedomscientific.com/Products/Blindness/JAWS" target="_blank" rel="noopener">Job Access With Speech</a> or JAWS, is a prolifically used screen reader on Windows.</p>
<p><a href="http://www.freedomscientific.com/Products/Blindness/JAWS" target="_blank" rel="noopener">Job Access With Speech</a>或JAWS进行工作访问是Windows上一种多用途的屏幕阅读器。</p>
<p>Refer to the following guides on how to best use JAWS:</p>
<p>参考下列目录来学习如何最好的使用JAWS：</p>
<ul>
<li><a href="http://webaim.org/articles/jaws/" target="_blank" rel="noopener">WebAIM - Using JAWS to Evaluate Web Accessibility</a></li>
<li><p><a href="https://dequeuniversity.com/screenreaders/jaws-keyboard-shortcuts" target="_blank" rel="noopener">Deque - JAWS Keyboard Shortcuts</a></p>
</li>
<li><p><a href="http://webaim.org/articles/jaws/" target="_blank" rel="noopener">WebAIM - 使用JAWS来评估Web的可访问性</a></p>
</li>
<li><a href="https://dequeuniversity.com/screenreaders/jaws-keyboard-shortcuts" target="_blank" rel="noopener">Deque - JAWS键盘快捷键</a></li>
</ul>
<h4 id="Other-Screen-Readers-其他的屏幕阅读器"><a href="#Other-Screen-Readers-其他的屏幕阅读器" class="headerlink" title="Other Screen Readers(其他的屏幕阅读器)"></a>Other Screen Readers(其他的屏幕阅读器)</h4><blockquote>
<p>ChromeVox in Google Chrome</p>
</blockquote>
<p><a href="http://www.chromevox.com/" target="_blank" rel="noopener">ChromeVox</a> is an integrated screen reader on Chromebooks and is available as an extension for Google Chrome.</p>
<p><a href="http://www.chromevox.com/" target="_blank" rel="noopener">ChromeVox</a>是Chromebook上的集成屏幕阅读器，可作为Google Chrome的扩展程序。</p>
<p>Refer to the following guides on how best to use ChromeVox:</p>
<p>参考下列目录来学习如何最好的使用ChromeVox：</p>
<ul>
<li><a href="https://support.google.com/chromebook/answer/7031755?hl=en" target="_blank" rel="noopener">Google Chromebook Help - Use the Built-in Screen Reader</a></li>
<li><p><a href="http://www.chromevox.com/keyboard_shortcuts.html" target="_blank" rel="noopener">ChromeVox Classic Keyboard Shortcuts Reference</a></p>
</li>
<li><p><a href="https://support.google.com/chromebook/answer/7031755?hl=en" target="_blank" rel="noopener">Google Chromebook帮助 - 使用内建的屏幕阅读器</a></p>
</li>
<li><a href="http://www.chromevox.com/keyboard_shortcuts.html" target="_blank" rel="noopener">ChromeVox Classic传统的快捷键参阅</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react组件之间的通信]]></title>
      <url>/2018/06/23/blog/react_communication/</url>
      <content type="html"><![CDATA[<h2 id="react组件之间的通信"><a href="#react组件之间的通信" class="headerlink" title="react组件之间的通信"></a>react组件之间的通信</h2><p>说 React 组件间通讯之前，我们先来讨论一下 React 组件究竟有多少种层级间的关系。假设我们开发的项目是一个纯 React 的项目，那我们项目应该有如下类似的关系：</p>
<p><img src="/images/blog/react_communicatioin.png"></p>
<p>父子：Parent 与 Child_1、Child_2、Child_1_1、Child_1_2、Child_2_1</p>
<p>兄弟：Child_1 与 Child_2、Child_1_1 与 Child_2、etc.</p>
<p>针对这些关系，我们将来好好讨论一下这些关系间的通讯方式。</p>
<p>（在 React 中，React 组件之间的关系为从属关系，与 DOM 元素之间的父子关系有所不同，下面只是为了说明方便，将 React 组件的关系类比成父子关系进行阐述）</p>
<hr>
<h3 id="父组件向子组件通讯"><a href="#父组件向子组件通讯" class="headerlink" title="父组件向子组件通讯"></a>父组件向子组件通讯</h3><p>通讯是单向的，数据必须是由一方传到另一方。在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。</p>
<pre><code>class Parent extends Component{
  state = {
    msg: &#39;start&#39;
  };

  componentDidMount() {
    setTimeout(() =&gt; {
      this.setState({
        msg: &#39;end&#39;
      });
    }, 1000);
  }

  render() {
    return &lt;Child_1 msg={this.state.msg} /&gt;;
  }
}

class Child_1 extends Component{
  render() {
    return &lt;p&gt;{this.props.msg}&lt;/p&gt;
  }
}
</code></pre><p>如果父组件与子组件之间不止一个层级，如 Parent 与 Child_1_1 这样的关系，可通过 … 运算符（Object 剩余和展开属性），将父组件的信息，以更简洁的方式传递给更深层级的子组件。通过这种方式，不用考虑性能的问题，通过 babel 转义后的 … 运算符 性能和原生的一致，且上级组件 props 与 state 的改变，会导致组件本身及其子组件的生命周期改变，</p>
<pre><code>// 通过 ... 运算符 向 Child_1_1 传递 Parent 组件的信息
class Child_1 extends Component{
  render() {
    return &lt;div&gt;
      &lt;p&gt;{this.props.msg}&lt;/p&gt;
      &lt;Child_1_1 {...this.props}/&gt;
    &lt;/div&gt;
  }
}

class Child_1_1 extends Component{
  render() {
    return &lt;p&gt;{this.props.msg}&lt;/p&gt;
  }
}
</code></pre><hr>
<h3 id="子组件向父组件通讯"><a href="#子组件向父组件通讯" class="headerlink" title="子组件向父组件通讯"></a>子组件向父组件通讯</h3><p>在上一个例子中，父组件可以通过传递 props 的方式，自顶而下向子组件进行通讯。而子组件向父组件通讯，同样也需要父组件向子组件传递 props 进行通讯，只是父组件传递的，是作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中。</p>
<pre><code>class Parent extends Component{
  state = {
    msg: &#39;start&#39;
  };

  transferMsg(msg) {
    this.setState({
      msg
    });
  }

  render() {
    return &lt;div&gt;
        &lt;p&gt;child msg: {this.state.msg}&lt;/p&gt;
        &lt;Child_1 transferMsg = {msg =&gt; this.transferMsg(msg)} /&gt;
      &lt;/div&gt;;
  }
}

class Child_1 extends Component{
  componentDidMount() {
    setTimeout(() =&gt; {
      this.props.transferMsg(&#39;end&#39;)
    }, 1000);
  }

  render() {
    return &lt;div&gt;
      &lt;p&gt;child_1 component&lt;/p&gt;
    &lt;/div&gt;
  }
}
</code></pre><p>在上面的例子中，我们使用了 箭头函数，将父组件的 transferMsg 函数通过 props 传递给子组件，得益于箭头函数，保证子组件在调用 transferMsg 函数时，其内部 this 仍指向父组件。</p>
<p>当然，对于层级比较深的子组件与父组件之间的通讯，仍可使用 … 运算符，将父组件的调用函数传递给子组件，具体方法和上面的例子类似。</p>
<hr>
<h3 id="兄弟组件间通讯"><a href="#兄弟组件间通讯" class="headerlink" title="兄弟组件间通讯"></a>兄弟组件间通讯</h3><p>对于没有直接关联关系的两个节点，就如 Child_1 与 Child_2 之间的关系，他们唯一的关联点，就是拥有相同的父组件。参考之前介绍的两种关系的通讯方式，如果我们向由 Child_1 向 Child_2 进行通讯，我们可以先通过 Child_1 向 Parent 组件进行通讯，再由 Parent 向 Child_2 组件进行通讯，所以有以下代码。</p>
<pre><code>class Parent extends Component{
  state = {
    msg: &#39;start&#39;
  };

  transferMsg(msg) {
    this.setState({
      msg
    });
  }

  componentDidUpdate() {
    console.log(&#39;Parent update&#39;);
  }

  render() {
    return (
      &lt;div&gt;
        &lt;Child_1 transferMsg = {msg =&gt; this.transferMsg(msg)} /&gt;
        &lt;Child_2 msg = {this.state.msg} /&gt;
      &lt;/div&gt;
    );
  }
}

class Child_1 extends Component{
  componentDidMount() {
    setTimeout(() =&gt; {
      this.props.transferMsg(&#39;end&#39;)
    }, 1000);
  }

  componentDidUpdate() {
    console.log(&#39;Child_1 update&#39;);
  }

  render() {
    return &lt;div&gt;
      &lt;p&gt;child_1 component&lt;/p&gt;
    &lt;/div&gt;
  }
}

class Child_2 extends Component{
  componentDidUpdate() {
    console.log(&#39;Child_2 update&#39;);
  }

  render() {
    return &lt;div&gt;
      &lt;p&gt;child_2 component: {this.props.msg}&lt;/p&gt;
      &lt;Child_2_1 /&gt;
    &lt;/div&gt;
  }
}

class Child_2_1 extends Component{
  componentDidUpdate() {
    console.log(&#39;Child_2_1 update&#39;);
  }

  render() {
    return &lt;div&gt;
      &lt;p&gt;child_2_1 component&lt;/p&gt;
    &lt;/div&gt;
  }
}
</code></pre><p>然而，这个方法有一个问题，由于 Parent 的 state 发生变化，会触发 Parent 及从属于 Parent 的子组件的生命周期，所以我们在控制台中可以看到，在各个组件中的 componentDidUpdate 方法均被触发。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 10.Symbol]]></title>
      <url>/2018/06/19/ES6/10.symbol/</url>
      <content type="html"><![CDATA[<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="概-述"><a href="#概-述" class="headerlink" title="概 述"></a>概 述</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>
<p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<pre><code>let s = Symbol();

typeof s
// &quot;symbol&quot;
</code></pre><p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型。</p>
<p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<pre><code>let s1 = Symbol(&#39;foo&#39;);
let s2 = Symbol(&#39;bar&#39;);

s1 // Symbol(foo)
s2 // Symbol(bar)

s1.toString() // &quot;Symbol(foo)&quot;
s2.toString() // &quot;Symbol(bar)&quot;
</code></pre><p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p>
<pre><code>const obj = {
  toString() {
    return &#39;abc&#39;;
  }
};
const sym = Symbol(obj);
sym // Symbol(abc)
</code></pre><p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p>
<pre><code>// 没有参数的情况
let s1 = Symbol();
let s2 = Symbol();

s1 === s2 // false

// 有参数的情况
let s1 = Symbol(&#39;foo&#39;);
let s2 = Symbol(&#39;foo&#39;);

s1 === s2 // false
</code></pre><p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p>
<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
<pre><code>let sym = Symbol(&#39;My symbol&#39;);

&quot;your symbol is &quot; + sym
// TypeError: can&#39;t convert symbol to string
`your symbol is ${sym}`
// TypeError: can&#39;t convert symbol to string
</code></pre><p>但是，Symbol 值可以显式转为字符串。</p>
<pre><code>let sym = Symbol(&#39;My symbol&#39;);

String(sym) // &#39;Symbol(My symbol)&#39;
sym.toString() // &#39;Symbol(My symbol)&#39;
</code></pre><p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
<pre><code>let sym = Symbol();
Boolean(sym) // true
!sym  // false

if (sym) {
  // ...
}

Number(sym) // TypeError
sym + 2 // TypeError
</code></pre><h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<pre><code>let mySymbol = Symbol();

// 第一种写法
let a = {};
a[mySymbol] = &#39;Hello!&#39;;

// 第二种写法
let a = {
  [mySymbol]: &#39;Hello!&#39;
};

// 第三种写法
let a = {};
Object.defineProperty(a, mySymbol, { value: &#39;Hello!&#39; });

// 以上写法都得到同样结果
a[mySymbol] // &quot;Hello!&quot;
</code></pre><p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<pre><code>const mySymbol = Symbol();
const a = {};

a.mySymbol = &#39;Hello!&#39;;
a[mySymbol] // undefined
a[&#39;mySymbol&#39;] // &quot;Hello!&quot;
</code></pre><p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p>
<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<pre><code>let s = Symbol();

let obj = {
  [s]: function (arg) { ... }
};

obj[s](123);
</code></pre><p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p>
<p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p>
<pre><code>let obj = {
  [s](arg) { ... }
};
</code></pre><p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
<pre><code>const log = {};

log.levels = {
  DEBUG: Symbol(&#39;debug&#39;),
  INFO: Symbol(&#39;info&#39;),
  WARN: Symbol(&#39;warn&#39;)
};
console.log(log.levels.DEBUG, &#39;debug message&#39;);
console.log(log.levels.INFO, &#39;info message&#39;);
</code></pre><p>下面是另外一个例子。</p>
<pre><code>const COLOR_RED    = Symbol();
const COLOR_GREEN  = Symbol();

function getComplement(color) {
  switch (color) {
    case COLOR_RED:
      return COLOR_GREEN;
    case COLOR_GREEN:
      return COLOR_RED;
    default:
      throw new Error(&#39;Undefined color&#39;);
    }
}
</code></pre><p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</p>
<p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<h2 id="实例：消除魔术字符串"><a href="#实例：消除魔术字符串" class="headerlink" title="实例：消除魔术字符串"></a>实例：消除魔术字符串</h2><p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p>
<pre><code>function getArea(shape, options) {
  let area = 0;

  switch (shape) {
    case &#39;Triangle&#39;: // 魔术字符串
      area = .5 * options.width * options.height;
      break;
    /* ... more code ... */
  }

  return area;
}

getArea(&#39;Triangle&#39;, { width: 100, height: 100 }); // 魔术字符串
</code></pre><p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>
<p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p>
<pre><code>const shapeType = {
  triangle: &#39;Triangle&#39;
};

function getArea(shape, options) {
  let area = 0;
  switch (shape) {
    case shapeType.triangle:
      area = .5 * options.width * options.height;
      break;
  }
  return area;
}

getArea(shapeType.triangle, { width: 100, height: 100 });
</code></pre><p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p>
<p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p>
<pre><code>const shapeType = {
  triangle: Symbol()
};
</code></pre><p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个 Symbol，其他地方都不用修改。</p>
<h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<pre><code>const obj = {};
let a = Symbol(&#39;a&#39;);
let b = Symbol(&#39;b&#39;);

obj[a] = &#39;Hello&#39;;
obj[b] = &#39;World&#39;;

const objectSymbols = Object.getOwnPropertySymbols(obj);

objectSymbols
// [Symbol(a), Symbol(b)]
</code></pre><p>下面是另一个例子，<code>Object.getOwnPropertySymbols</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p>
<pre><code>const obj = {};

let foo = Symbol(&quot;foo&quot;);

Object.defineProperty(obj, foo, {
  value: &quot;foobar&quot;,
});

for (let i in obj) {
  console.log(i); // 无输出
}

Object.getOwnPropertyNames(obj)
// []

Object.getOwnPropertySymbols(obj)
// [Symbol(foo)]
</code></pre><p>上面代码中，使用<code>Object.getOwnPropertyNames</code>方法得不到<code>Symbol</code>属性名，需要使用<code>Object.getOwnPropertySymbols</code>方法。</p>
<p>另一个新的 API，<code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<pre><code>let obj = {
  [Symbol(&#39;my_key&#39;)]: 1,
  enum: 2,
  nonEnum: 3
};

Reflect.ownKeys(obj)
//  [&quot;enum&quot;, &quot;nonEnum&quot;, Symbol(my_key)]
</code></pre><p>由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<pre><code>let size = Symbol(&#39;size&#39;);

class Collection {
  constructor() {
    this[size] = 0;
  }

  add(item) {
    this[this[size]] = item;
    this[size]++;
  }

  static sizeOf(instance) {
    return instance[size];
  }
}

let x = new Collection();
Collection.sizeOf(x) // 0

x.add(&#39;foo&#39;);
Collection.sizeOf(x) // 1

Object.keys(x) // [&#39;0&#39;]
Object.getOwnPropertyNames(x) // [&#39;0&#39;]
Object.getOwnPropertySymbols(x) // [Symbol(size)]
</code></pre><p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p>
<h2 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<pre><code>let s1 = Symbol.for(&#39;foo&#39;);
let s2 = Symbol.for(&#39;foo&#39;);

s1 === s2 // true
</code></pre><p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p>
<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p>
<pre><code>Symbol.for(&quot;bar&quot;) === Symbol.for(&quot;bar&quot;)
// true

Symbol(&quot;bar&quot;) === Symbol(&quot;bar&quot;)
// false
</code></pre><p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p>
<p><code>Symbol.keyFor</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p>
<pre><code>let s1 = Symbol.for(&quot;foo&quot;);
Symbol.keyFor(s1) // &quot;foo&quot;

let s2 = Symbol(&quot;foo&quot;);
Symbol.keyFor(s2) // undefined
</code></pre><p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p>
<p>需要注意的是，<code>Symbol.for</code>为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。</p>
<pre><code>iframe = document.createElement(&#39;iframe&#39;);
iframe.src = String(window.location);
document.body.appendChild(iframe);

iframe.contentWindow.Symbol.for(&#39;foo&#39;) === Symbol.for(&#39;foo&#39;)
// true
</code></pre><p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p>
<h2 id="实例：模块的-Singleton-模式"><a href="#实例：模块的-Singleton-模式" class="headerlink" title="实例：模块的 Singleton 模式"></a>实例：模块的 Singleton 模式</h2><p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p>
<p>对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p>
<p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p>
<pre><code>// mod.js
function A() {
  this.foo = &#39;hello&#39;;
}

if (!global._foo) {
  global._foo = new A();
}

module.exports = global._foo;
</code></pre><p>然后，加载上面的<code>mod.js</code>。</p>
<pre><code>const a = require(&#39;./mod.js&#39;);
console.log(a.foo);
</code></pre><p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p>
<p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p>
<pre><code>global._foo = { foo: &#39;world&#39; };

const a = require(&#39;./mod.js&#39;);
console.log(a.foo);
</code></pre><p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p>
<p>为了防止这种情况出现，我们就可以使用 Symbol。</p>
<pre><code>// mod.js
const FOO_KEY = Symbol.for(&#39;foo&#39;);

function A() {
  this.foo = &#39;hello&#39;;
}

if (!global[FOO_KEY]) {
  global[FOO_KEY] = new A();
}

module.exports = global[FOO_KEY];
</code></pre><p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p>
<pre><code>global[Symbol.for(&#39;foo&#39;)] = { foo: &#39;world&#39; };

const a = require(&#39;./mod.js&#39;);
</code></pre><p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p>
<pre><code>// mod.js
const FOO_KEY = Symbol(&#39;foo&#39;);

// 后面代码相同 ……
</code></pre><p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p>
<h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>
<h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>
<pre><code>class MyClass {
  [Symbol.hasInstance](foo) {
    return foo instanceof Array;
  }
}

[1, 2, 3] instanceof new MyClass() // true
</code></pre><p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p>
<p>下面是另一个例子。</p>
<pre><code>class Even {
  static [Symbol.hasInstance](obj) {
    return Number(obj) % 2 === 0;
  }
}

// 等同于
const Even = {
  [Symbol.hasInstance](obj) {
    return Number(obj) % 2 === 0;
  }
};

1 instanceof Even // false
2 instanceof Even // true
12345 instanceof Even // false
</code></pre><h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p>
<pre><code>let arr1 = [&#39;c&#39;, &#39;d&#39;];
[&#39;a&#39;, &#39;b&#39;].concat(arr1, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
arr1[Symbol.isConcatSpreadable] // undefined

let arr2 = [&#39;c&#39;, &#39;d&#39;];
arr2[Symbol.isConcatSpreadable] = false;
[&#39;a&#39;, &#39;b&#39;].concat(arr2, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, [&#39;c&#39;,&#39;d&#39;], &#39;e&#39;]
</code></pre><p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p>
<p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p>
<pre><code>let obj = {length: 2, 0: &#39;c&#39;, 1: &#39;d&#39;};
[&#39;a&#39;, &#39;b&#39;].concat(obj, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, obj, &#39;e&#39;]

obj[Symbol.isConcatSpreadable] = true;
[&#39;a&#39;, &#39;b&#39;].concat(obj, &#39;e&#39;) // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39;]
</code></pre><p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p>
<pre><code>class A1 extends Array {
  constructor(args) {
    super(args);
    this[Symbol.isConcatSpreadable] = true;
  }
}
class A2 extends Array {
  constructor(args) {
    super(args);
  }
  get [Symbol.isConcatSpreadable] () {
    return false;
  }
}
let a1 = new A1();
a1[0] = 3;
a1[1] = 4;
let a2 = new A2();
a2[0] = 5;
a2[1] = 6;
[1, 2].concat(a1).concat(a2)
// [1, 2, 3, 4, [5, 6]]
</code></pre><p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p>
<p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p>
<h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h3><p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p>
<pre><code>class MyArray extends Array {
}

const a = new MyArray(1, 2, 3);
const b = a.map(x =&gt; x);
const c = a.filter(x =&gt; x &gt; 1);

b instanceof MyArray // true
c instanceof MyArray // true
</code></pre><p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p>
<p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p>
<pre><code>class MyArray extends Array {
  static get [Symbol.species]() { return Array; }
}
</code></pre><p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p>
<pre><code>static get [Symbol.species]() {
  return this;
}
</code></pre><p>现在，再来看前面的例子。</p>
<pre><code>class MyArray extends Array {
  static get [Symbol.species]() { return Array; }
}

const a = new MyArray();
const b = a.map(x =&gt; x);

b instanceof MyArray // false
b instanceof Array // true
</code></pre><p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p>
<p>再看一个例子。</p>
<pre><code>class T1 extends Promise {
}

class T2 extends Promise {
  static get [Symbol.species]() {
    return Promise;
  }
}

new T1(r =&gt; r()).then(v =&gt; v) instanceof T1 // true
new T2(r =&gt; r()).then(v =&gt; v) instanceof T2 // false
</code></pre><p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p>
<p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p>
<h3 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h3><p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>
<pre><code>String.prototype.match(regexp)
// 等同于
regexp[Symbol.match](this)

class MyMatcher {
  [Symbol.match](string) {
    return &#39;hello world&#39;.indexOf(string);
  }
}

&#39;e&#39;.match(new MyMatcher()) // 1
</code></pre><h3 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h3><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>
<pre><code>String.prototype.replace(searchValue, replaceValue)
// 等同于
searchValue[Symbol.replace](this, replaceValue)
</code></pre><p>下面是一个例子。</p>
<pre><code>const x = {};
x[Symbol.replace] = (...s) =&gt; console.log(s);

&#39;Hello&#39;.replace(x, &#39;World&#39;) // [&quot;Hello&quot;, &quot;World&quot;]
</code></pre><p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p>
<h3 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h3><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>
<pre><code>String.prototype.search(regexp)
// 等同于
regexp[Symbol.search](this)

class MySearch {
  constructor(value) {
    this.value = value;
  }
  [Symbol.search](string) {
    return string.indexOf(this.value);
  }
}
&#39;foobar&#39;.search(new MySearch(&#39;foo&#39;)) // 0
</code></pre><h3 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h3><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>
<pre><code>String.prototype.split(separator, limit)
// 等同于
separator[Symbol.split](this, limit)
</code></pre><p>下面是一个例子。</p>
<pre><code>class MySplitter {
  constructor(value) {
    this.value = value;
  }
  [Symbol.split](string) {
    let index = string.indexOf(this.value);
    if (index === -1) {
      return string;
    }
    return [
      string.substr(0, index),
      string.substr(index + this.value.length)
    ];
  }
}

&#39;foobar&#39;.split(new MySplitter(&#39;foo&#39;))
// [&#39;&#39;, &#39;bar&#39;]

&#39;foobar&#39;.split(new MySplitter(&#39;bar&#39;))
// [&#39;foo&#39;, &#39;&#39;]

&#39;foobar&#39;.split(new MySplitter(&#39;baz&#39;))
// &#39;foobar&#39;
</code></pre><p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p>
<h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p>
<pre><code>const myIterable = {};
myIterable[Symbol.iterator] = function* () {
  yield 1;
  yield 2;
  yield 3;
};

[...myIterable] // [1, 2, 3]
</code></pre><p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。</p>
<pre><code>class Collection {
  *[Symbol.iterator]() {
    let i = 0;
    while(this[i] !== undefined) {
      yield this[i];
      ++i;
    }
  }
}

let myCollection = new Collection();
myCollection[0] = 1;
myCollection[1] = 2;

for(let value of myCollection) {
  console.log(value);
}
// 1
// 2
</code></pre><h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
<p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>
<ul>
<li>Number：该场合需要转成数值</li>
<li>String：该场合需要转成字符串</li>
<li><p>Default：该场合可以转成数值，也可以转成字符串</p>
<p>let obj = {<br>  <a href="hint">Symbol.toPrimitive</a> {</p>
<pre><code>switch (hint) {
  case &#39;number&#39;:
    return 123;
  case &#39;string&#39;:
    return &#39;str&#39;;
  case &#39;default&#39;:
    return &#39;default&#39;;
  default:
    throw new Error();
 }
</code></pre><p>   }<br>};</p>
<p>2 * obj // 246<br>3 + obj // ‘3default’<br>obj == ‘default’ // true<br>String(obj) // ‘str’</p>
</li>
</ul>
<h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>
<pre><code>// 例一
({[Symbol.toStringTag]: &#39;Foo&#39;}.toString())
// &quot;[object Foo]&quot;

// 例二
class Collection {
  get [Symbol.toStringTag]() {
    return &#39;xxx&#39;;
  }
}
let x = new Collection();
Object.prototype.toString.call(x) // &quot;[object xxx]&quot;
</code></pre><p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p>
<ul>
<li><code>JSON[Symbol.toStringTag]</code>：’JSON’</li>
<li><code>Math[Symbol.toStringTag]</code>：’Math’</li>
<li>Module 对象<code>M[Symbol.toStringTag]</code>：’Module’</li>
<li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：’ArrayBuffer’</li>
<li><code>DataView.prototype[Symbol.toStringTag]</code>：’DataView’</li>
<li><code>Map.prototype[Symbol.toStringTag]</code>：’Map’</li>
<li><code>Promise.prototype[Symbol.toStringTag]</code>：’Promise’</li>
<li><code>Set.prototype[Symbol.toStringTag]</code>：’Set’</li>
<li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：’Uint8Array’等</li>
<li><code>WeakMap.prototype[Symbol.toStringTag]</code>：’WeakMap’</li>
<li><code>WeakSet.prototype[Symbol.toStringTag]</code>：’WeakSet’</li>
<li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：’Map Iterator’</li>
<li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：’Set Iterator’</li>
<li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：’String Iterator’</li>
<li><code>Symbol.prototype[Symbol.toStringTag]</code>：’Symbol’</li>
<li><code>Generator.prototype[Symbol.toStringTag]</code>：’Generator’</li>
<li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：’GeneratorFunction’</li>
</ul>
<h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>
<pre><code>Array.prototype[Symbol.unscopables]
// {
//   copyWithin: true,
//   entries: true,
//   fill: true,
//   find: true,
//   findIndex: true,
//   includes: true,
//   keys: true
// }

Object.keys(Array.prototype[Symbol.unscopables])
// [&#39;copyWithin&#39;, &#39;entries&#39;, &#39;fill&#39;, &#39;find&#39;, &#39;findIndex&#39;, &#39;includes&#39;, &#39;keys&#39;]
</code></pre><p>上面代码说明，数组有 7 个属性，会被<code>with</code>命令排除。</p>
<pre><code>// 没有 unscopables 时
class MyClass {
  foo() { return 1; }
}

var foo = function () { return 2; };

with (MyClass.prototype) {
  foo(); // 1
}

// 有 unscopables 时
class MyClass {
  foo() { return 1; }
  get [Symbol.unscopables]() {
    return { foo: true };
  }
}

var foo = function () { return 2; };

with (MyClass.prototype) {
  foo(); // 2
}
</code></pre><p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 09.对象的扩展]]></title>
      <url>/2018/06/19/ES6/09.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="1-属性的简洁表示法"><a href="#1-属性的简洁表示法" class="headerlink" title="1.属性的简洁表示法 "></a>1.属性的简洁表示法 </h2><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。</p>
<pre><code>const foo = &#39;bar&#39;;
const baz = {foo};
baz // {foo: &quot;bar&quot;}

// 等同于
const baz = {foo: foo};
</code></pre><p>上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。</p>
<pre><code>function f(x, y) {
  return {x, y};
}

// 等同于

function f(x, y) {
  return {x: x, y: y};
}

f(1, 2) // Object {x: 1, y: 2}
</code></pre><p>除了属性简写，方法也可以简写。</p>
<pre><code>const o = {
  method() {
    return &quot;Hello!&quot;;
  }
};

// 等同于

const o = {
  method: function() {
    return &quot;Hello!&quot;;
  }
};
</code></pre><p>下面是一个实际的例子。</p>
<pre><code>let birth = &#39;2000/01/01&#39;;

const Person = {

  name: &#39;张三&#39;,

  //等同于birth: birth
  birth,

  // 等同于hello: function ()...
  hello() { console.log(&#39;我的名字是&#39;, this.name); }

};
</code></pre><p>这种写法用于函数的返回值，将会非常方便。</p>
<pre><code>function getPoint() {
  const x = 1;
  const y = 10;
  return {x, y};
}

getPoint()
// {x:1, y:10}
</code></pre><p>CommonJS 模块输出一组变量，就非常合适使用简洁写法。</p>
<pre><code>let ms = {};

function getItem (key) {
  return key in ms ? ms[key] : null;
}

function setItem (key, value) {
  ms[key] = value;
}

function clear () {
  ms = {};
}

module.exports = { getItem, setItem, clear };
// 等同于
module.exports = {
  getItem: getItem,
  setItem: setItem,
  clear: clear
};
</code></pre><p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。</p>
<pre><code>const cart = {
  _wheels: 4,

  get wheels () {
    return this._wheels;
  },

  set wheels (value) {
    if (value &lt; this._wheels) {
      throw new Error(&#39;数值太小了！&#39;);
    }
    this._wheels = value;
  }
}
</code></pre><p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>
<pre><code>const obj = {
  class () {}
};

// 等同于

var obj = {
  &#39;class&#39;: function() {}
};
</code></pre><p>上面代码中，<code>class</code>是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p>
<p>如果某个方法的值是一个 Generator 函数，前面需要加上星号。</p>
<pre><code>const obj = {
  * m() {
    yield &#39;hello world&#39;;
  }
};
</code></pre><h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><p>JavaScript 定义对象的属性，有两种方法。</p>
<pre><code>// 方法一
obj.foo = true;

// 方法二
obj[&#39;a&#39; + &#39;bc&#39;] = 123;
</code></pre><p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>
<pre><code>var obj = {
  foo: true,
  abc: 123
};
</code></pre><p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<pre><code>let propKey = &#39;foo&#39;;

let obj = {
  [propKey]: true,
  [&#39;a&#39; + &#39;bc&#39;]: 123
};
</code></pre><p>下面是另一个例子。</p>
<pre><code>let lastWord = &#39;last word&#39;;

const a = {
  &#39;first word&#39;: &#39;hello&#39;,
  [lastWord]: &#39;world&#39;
};

a[&#39;first word&#39;] // &quot;hello&quot;
a[lastWord] // &quot;world&quot;
a[&#39;last word&#39;] // &quot;world&quot;
</code></pre><p>表达式还可以用于定义方法名。</p>
<pre><code>let obj = {
  [&#39;h&#39; + &#39;ello&#39;]() {
    return &#39;hi&#39;;
  }
};

obj.hello() // hi
</code></pre><p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<pre><code>// 报错
const foo = &#39;bar&#39;;
const bar = &#39;abc&#39;;
const baz = { [foo] };

// 正确
const foo = &#39;bar&#39;;
const baz = { [foo]: &#39;abc&#39;};
</code></pre><p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p>
<pre><code>const keyA = {a: 1};
const keyB = {b: 2};

const myObject = {
  [keyA]: &#39;valueA&#39;,
  [keyB]: &#39;valueB&#39;
};

myObject // Object {[object Object]: &quot;valueB&quot;}
</code></pre><p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p>
<h2 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h2><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>
<pre><code>const person = {
  sayName() {
    console.log(&#39;hello!&#39;);
  },
};

person.sayName.name   // &quot;sayName&quot;
</code></pre><p>上面代码中，方法的<code>name</code>属性返回函数名（即方法名）。</p>
<p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p>
<pre><code>const obj = {
  get foo() {},
  set foo(x) {}
};

obj.foo.name
// TypeError: Cannot read property &#39;name&#39; of undefined

const descriptor = Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;);

descriptor.get.name // &quot;get foo&quot;
descriptor.set.name // &quot;set foo&quot;
</code></pre><p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p>
<pre><code>(new Function()).name // &quot;anonymous&quot;

var doSomething = function() {
  // ...
};
doSomething.bind().name // &quot;bound doSomething&quot;
</code></pre><p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>
<pre><code>const key1 = Symbol(&#39;description&#39;);
const key2 = Symbol();
let obj = {
  [key1]() {},
  [key2]() {},
};
obj[key1].name // &quot;[description]&quot;
obj[key2].name // &quot;&quot;
</code></pre><p>上面代码中，<code>key1</code>对应的 Symbol 值有描述，<code>key2</code>没有。</p>
<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<pre><code>Object.is(&#39;foo&#39;, &#39;foo&#39;)
// true
Object.is({}, {})
// false
</code></pre><p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p>
<pre><code>+0 === -0 //true
NaN === NaN // false

Object.is(+0, -0) // false
Object.is(NaN, NaN) // true
</code></pre><p>ES5 可以通过下面的代码，部署<code>Object.is</code>。</p>
<pre><code>Object.defineProperty(Object, &#39;is&#39;, {
  value: function(x, y) {
    if (x === y) {
      // 针对+0 不等于 -0的情况
      return x !== 0 || 1 / x === 1 / y;
    }
    // 针对NaN的情况
    return x !== x &amp;&amp; y !== y;
  },
  configurable: true,
  enumerable: false,
  writable: true
});
</code></pre><h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<pre><code>const target = { a: 1 };

const source1 = { b: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre><p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。</p>
<pre><code>const target = { a: 1, b: 1 };

const source1 = { b: 2, c: 2 };
const source2 = { c: 3 };

Object.assign(target, source1, source2);
target // {a:1, b:2, c:3}
</code></pre><p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。</p>
<pre><code>const obj = {a: 1};
Object.assign(obj) === obj // true
</code></pre><p>如果该参数不是对象，则会先转成对象，然后返回。</p>
<pre><code>typeof Object.assign(2) // &quot;object&quot;
</code></pre><p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。</p>
<pre><code>Object.assign(undefined) // 报错
Object.assign(null) // 报错
</code></pre><p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。</p>
<pre><code>let obj = {a: 1};
Object.assign(obj, undefined) === obj // true
Object.assign(obj, null) === obj // true
</code></pre><p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。</p>
<pre><code>const v1 = &#39;abc&#39;;
const v2 = true;
const v3 = 10;

const obj = Object.assign({}, v1, v2, v3);
console.log(obj); // { &quot;0&quot;: &quot;a&quot;, &quot;1&quot;: &quot;b&quot;, &quot;2&quot;: &quot;c&quot; }
</code></pre><p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>
<pre><code>Object(true) // {[[PrimitiveValue]]: true}
Object(10)  //  {[[PrimitiveValue]]: 10}
Object(&#39;abc&#39;) // {0: &quot;a&quot;, 1: &quot;b&quot;, 2: &quot;c&quot;, length: 3, [[PrimitiveValue]]: &quot;abc&quot;}
</code></pre><p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>
<p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p>
<pre><code>Object.assign({b: &#39;c&#39;},
  Object.defineProperty({}, &#39;invisible&#39;, {
    enumerable: false,
    value: &#39;hello&#39;
  })
)
// { b: &#39;c&#39; }
</code></pre><p>上面代码中，<code>Object.assign</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p>
<p>属性名为 Symbol 值的属性，也会被<code>Object.assign</code>拷贝。</p>
<pre><code>Object.assign({ a: &#39;b&#39; }, { [Symbol(&#39;c&#39;)]: &#39;d&#39; })
// { a: &#39;b&#39;, Symbol(c): &#39;d&#39; }
</code></pre><h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>（1）浅拷贝</strong></p>
<p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。</p>
<pre><code>const obj1 = {a: {b: 1}};
const obj2 = Object.assign({}, obj1);

obj1.a.b = 2;
obj2.a.b // 2
</code></pre><p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<p><strong>（2）同名属性的替换</strong></p>
<p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。</p>
<pre><code>const target = { a: { b: &#39;c&#39;, d: &#39;e&#39; } }
const source = { a: { b: &#39;hello&#39; } }
Object.assign(target, source)
// { a: { b: &#39;hello&#39; } }
</code></pre><p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>{ a: { b: &#39;hello&#39;, d: &#39;e&#39; } }</code>的结果。这通常不是开发者想要的，需要特别小心。</p>
<p>一些函数库提供<code>Object.assign</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep</code>方法），可以得到深拷贝的合并。</p>
<p><strong>（3）数组的处理</strong></p>
<p><code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。</p>
<pre><code>Object.assign([1, 2, 3], [4, 5])
// [4, 5, 3]
</code></pre><p>上面代码中，<code>Object.assign</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p>
<p><strong>（4）取值函数的处理</strong></p>
<p><code>Object.assign</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。</p>
<pre><code>const source = {
  get foo() { return 1 }
};
const target = {};

Object.assign(target, source)
// { foo: 1 }
</code></pre><p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p><code>Object.assign</code>方法有很多用处。</p>
<p><strong>（1）为对象添加属性</strong></p>
<pre><code>class Point {
  constructor(x, y) {
    Object.assign(this, {x, y});
  }
}
</code></pre><p>上面方法通过<code>Object.assign</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p>
<p><strong>（2）为对象添加方法</strong></p>
<pre><code>Object.assign(SomeClass.prototype, {
  someMethod(arg1, arg2) {
    ···
  },
  anotherMethod() {
    ···
  }
});

// 等同于下面的写法
SomeClass.prototype.someMethod = function (arg1, arg2) {
  ···
};
SomeClass.prototype.anotherMethod = function () {
  ···
};
</code></pre><p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign</code>方法添加到<code>SomeClass.prototype</code>之中。</p>
<p><strong>（3）克隆对象</strong></p>
<pre><code>function clone(origin) {
  return Object.assign({}, origin);
}
</code></pre><p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。</p>
<pre><code>function clone(origin) {
  let originProto = Object.getPrototypeOf(origin);
  return Object.assign(Object.create(originProto), origin);
}
</code></pre><p><strong>（4）合并多个对象</strong></p>
<p>将多个对象合并到某个对象。</p>
<pre><code>const merge =
  (target, ...sources) =&gt; Object.assign(target, ...sources);
</code></pre><p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。</p>
<pre><code>const merge =
  (...sources) =&gt; Object.assign({}, ...sources);
</code></pre><p><strong>（5）为属性指定默认值</strong></p>
<pre><code>const DEFAULTS = {
  logLevel: 0,
  outputFormat: &#39;html&#39;
};

function processContent(options) {
  options = Object.assign({}, DEFAULTS, options);
  console.log(options);
  // ...
}
</code></pre><p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>option</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p>
<p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。</p>
<pre><code>const DEFAULTS = {
  url: {
    host: &#39;example.com&#39;,
    port: 7070
  },
};

processContent({ url: {port: 8000} })
// {
//   url: {port: 8000}
// }
</code></pre><p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p>
<h2 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h2><h3 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h3><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。</p>
<pre><code>let obj = { foo: 123 };
Object.getOwnPropertyDescriptor(obj, &#39;foo&#39;)
//  {
//    value: 123,
//    writable: true,
//    enumerable: true,
//    configurable: true
//  }
</code></pre><p>描述对象的<code>enumerable</code>属性，称为”可枚举性“，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。</p>
<pre><code>Object.getOwnPropertyDescriptor(Object.prototype, &#39;toString&#39;).enumerable
// false

Object.getOwnPropertyDescriptor([], &#39;length&#39;).enumerable
// false
</code></pre><p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>
<p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。</p>
<pre><code>Object.getOwnPropertyDescriptor(class {foo() {}}.prototype, &#39;foo&#39;).enumerable
// false
</code></pre><p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p>
<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<p><strong>（1）for…in</strong></p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（2）Object.keys(obj)</strong></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li><p>最后遍历所有 Symbol 键，按照加入时间升序排列。</p>
<p>Reflect.ownKeys({ [Symbol()]:0, b:0, 10:0, 2:0, a:0 })<br>// [‘2’, ‘10’, ‘b’, ‘a’, Symbol()]</p>
</li>
</ul>
<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 Symbol 属性。</p>
<h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>前面说过，<code>Object.getOwnPropertyDescriptor</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。</p>
<pre><code>const obj = {
  foo: 123,
  get bar() { return &#39;abc&#39; }
};

Object.getOwnPropertyDescriptors(obj)
// { foo:
//    { value: 123,
//      writable: true,
//      enumerable: true,
//      configurable: true },
//   bar:
//    { get: [Function: get bar],
//      set: undefined,
//      enumerable: true,
//      configurable: true } }
</code></pre><p>上面代码中，<code>Object.getOwnPropertyDescriptors</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>
<p>该方法的实现非常容易。</p>
<pre><code>function getOwnPropertyDescriptors(obj) {
  const result = {};
  for (let key of Reflect.ownKeys(obj)) {
    result[key] = Object.getOwnPropertyDescriptor(obj, key);
  }
  return result;
}
</code></pre><p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。</p>
<pre><code>const source = {
  set foo(value) {
    console.log(value);
  }
};

const target1 = {};
Object.assign(target1, source);

Object.getOwnPropertyDescriptor(target1, &#39;foo&#39;)
// { value: undefined,
//   writable: true,
//   enumerable: true,
//   configurable: true }
</code></pre><p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>
<p>这时，<code>Object.getOwnPropertyDescriptors</code>方法配合<code>Object.defineProperties</code>方法，就可以实现正确拷贝。</p>
<pre><code>const source = {
  set foo(value) {
    console.log(value);
  }
};

const target2 = {};
Object.defineProperties(target2, Object.getOwnPropertyDescriptors(source));
Object.getOwnPropertyDescriptor(target2, &#39;foo&#39;)
// { get: undefined,
//   set: [Function: set foo],
//   enumerable: true,
//   configurable: true }
</code></pre><p>上面代码中，两个对象合并的逻辑可以写成一个函数。</p>
<pre><code>const shallowMerge = (target, source) =&gt; Object.defineProperties(
  target,
  Object.getOwnPropertyDescriptors(source)
);
</code></pre><p><code>Object.getOwnPropertyDescriptors</code>方法的另一个用处，是配合<code>Object.create</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。</p>
<pre><code>const clone = Object.create(Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj));

// 或者

const shallowClone = (obj) =&gt; Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
);
</code></pre><p>上面代码会克隆对象<code>obj</code>。</p>
<p>另外，<code>Object.getOwnPropertyDescriptors</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。</p>
<pre><code>const obj = {
  __proto__: prot,
  foo: 123,
};
</code></pre><p>ES6 规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。</p>
<pre><code>const obj = Object.create(prot);
obj.foo = 123;

// 或者

const obj = Object.assign(
  Object.create(prot),
  {
    foo: 123,
  }
);
</code></pre><p>有了<code>Object.getOwnPropertyDescriptors</code>，我们就有了另一种写法。</p>
<pre><code>const obj = Object.create(
  prot,
  Object.getOwnPropertyDescriptors({
    foo: 123,
  })
);
</code></pre><p><code>Object.getOwnPropertyDescriptors</code>也可以用来实现 Mixin（混入）模式。</p>
<pre><code>let mix = (object) =&gt; ({
  with: (...mixins) =&gt; mixins.reduce(
    (c, mixin) =&gt; Object.create(
      c, Object.getOwnPropertyDescriptors(mixin)
    ), object)
});

// multiple mixins example
let a = {a: &#39;a&#39;};
let b = {b: &#39;b&#39;};
let c = {c: &#39;c&#39;};
let d = mix(c).with(a, b);

d.c // &quot;c&quot;
d.b // &quot;b&quot;
d.a // &quot;a&quot;
</code></pre><p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。</p>
<p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors</code>方法。</p>
<h2 id="proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a><code>__proto__</code>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。</p>
<h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a><code>__proto__</code>属性</h3><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的<code>prototype</code>对象。目前，所有浏览器（包括 IE11）都部署了这个属性。</p>
<pre><code>// es5 的写法
const obj = {
  method: function() { ... }
};
obj.__proto__ = someOtherObj;

// es6 的写法
var obj = Object.create(someOtherObj);
obj.method = function() { ... };
</code></pre><p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。</p>
<pre><code>Object.defineProperty(Object.prototype, &#39;__proto__&#39;, {
  get() {
    let _thisObj = Object(this);
    return Object.getPrototypeOf(_thisObj);
  },
  set(proto) {
    if (this === undefined || this === null) {
      throw new TypeError();
    }
    if (!isObject(this)) {
      return undefined;
    }
    if (!isObject(proto)) {
      return undefined;
    }
    let status = Reflect.setPrototypeOf(this, proto);
    if (!status) {
      throw new TypeError();
    }
  },
});

function isObject(value) {
  return Object(value) === value;
}
</code></pre><p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。</p>
<pre><code>Object.getPrototypeOf({ __proto__: null })
// null
</code></pre><h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。</p>
<pre><code>// 格式
Object.setPrototypeOf(object, prototype)

// 用法
const o = Object.setPrototypeOf({}, null);
</code></pre><p>该方法等同于下面的函数。</p>
<pre><code>function (obj, proto) {
  obj.__proto__ = proto;
  return obj;
}
</code></pre><p>下面是一个例子。</p>
<pre><code>let proto = {};
let obj = { x: 10 };
Object.setPrototypeOf(obj, proto);

proto.y = 20;
proto.z = 40;

obj.x // 10
obj.y // 20
obj.z // 40
</code></pre><p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。</p>
<pre><code>Object.setPrototypeOf(1, {}) === 1 // true
Object.setPrototypeOf(&#39;foo&#39;, {}) === &#39;foo&#39; // true
Object.setPrototypeOf(true, {}) === true // true
</code></pre><p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。</p>
<pre><code>Object.setPrototypeOf(undefined, {})
// TypeError: Object.setPrototypeOf called on null or undefined

Object.setPrototypeOf(null, {})
// TypeError: Object.setPrototypeOf called on null or undefined
</code></pre><h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。</p>
<pre><code>Object.getPrototypeOf(obj);
</code></pre><p>下面是一个例子。</p>
<pre><code>function Rectangle() {
  // ...
}

const rec = new Rectangle();

Object.getPrototypeOf(rec) === Rectangle.prototype
// true

Object.setPrototypeOf(rec, Object.prototype);
Object.getPrototypeOf(rec) === Rectangle.prototype
// false
</code></pre><p>如果参数不是对象，会被自动转为对象。</p>
<pre><code>// 等同于 Object.getPrototypeOf(Number(1))
Object.getPrototypeOf(1)
// Number {[[PrimitiveValue]]: 0}

// 等同于 Object.getPrototypeOf(String(&#39;foo&#39;))
Object.getPrototypeOf(&#39;foo&#39;)
// String {length: 0, [[PrimitiveValue]]: &quot;&quot;}

// 等同于 Object.getPrototypeOf(Boolean(true))
Object.getPrototypeOf(true)
// Boolean {[[PrimitiveValue]]: false}

Object.getPrototypeOf(1) === Number.prototype // true
Object.getPrototypeOf(&#39;foo&#39;) === String.prototype // true
Object.getPrototypeOf(true) === Boolean.prototype // true
</code></pre><p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。</p>
<pre><code>Object.getPrototypeOf(null)
// TypeError: Cannot convert undefined or null to object

Object.getPrototypeOf(undefined)
// TypeError: Cannot convert undefined or null to object
</code></pre><h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。</p>
<pre><code>const proto = {
  foo: &#39;hello&#39;
};

const obj = {
  foo: &#39;world&#39;,
  find() {
    return super.foo;
  }
};

Object.setPrototypeOf(obj, proto);
obj.find() // &quot;hello&quot;
</code></pre><p>上面代码中，对象<code>obj</code>的<code>find</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p>
<p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。</p>
<pre><code>// 报错
const obj = {
  foo: super.foo
}

// 报错
const obj = {
  foo: () =&gt; super.foo
}

// 报错
const obj = {
  foo: function () {
    return super.foo
  }
}
</code></pre><p>上面三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的<code>super</code>都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p>
<p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。</p>
<pre><code>const proto = {
  x: &#39;hello&#39;,
  foo() {
    console.log(this.x);
  },
};

const obj = {
  x: &#39;world&#39;,
  foo() {
    super.foo();
  }
}

Object.setPrototypeOf(obj, proto);

obj.foo() // &quot;world&quot;
</code></pre><p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>
<h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。</p>
<pre><code>var obj = { foo: &#39;bar&#39;, baz: 42 };
Object.keys(obj)
// [&quot;foo&quot;, &quot;baz&quot;]
</code></pre><p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries" target="_blank" rel="noopener">引入</a>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。</p>
<pre><code>let {keys, values, entries} = Object;
let obj = { a: 1, b: 2, c: 3 };

for (let key of keys(obj)) {
  console.log(key); // &#39;a&#39;, &#39;b&#39;, &#39;c&#39;
}

for (let value of values(obj)) {
  console.log(value); // 1, 2, 3
}

for (let [key, value] of entries(obj)) {
  console.log([key, value]); // [&#39;a&#39;, 1], [&#39;b&#39;, 2], [&#39;c&#39;, 3]
}
</code></pre><h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。</p>
<pre><code>const obj = { foo: &#39;bar&#39;, baz: 42 };
Object.values(obj)
// [&quot;bar&quot;, 42]
</code></pre><p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。</p>
<pre><code>const obj = { 100: &#39;a&#39;, 2: &#39;b&#39;, 7: &#39;c&#39; };
Object.values(obj)
// [&quot;b&quot;, &quot;c&quot;, &quot;a&quot;]
</code></pre><p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p>
<p><code>Object.values</code>只返回对象自身的可遍历属性。</p>
<pre><code>const obj = Object.create({}, {p: {value: 42}});
Object.values(obj) // []
</code></pre><p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值。</p>
<pre><code>const obj = Object.create({}, {p:
  {
    value: 42,
    enumerable: true
  }
});
Object.values(obj) // [42]
</code></pre><p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。</p>
<pre><code>Object.values({ [Symbol()]: 123, foo: &#39;abc&#39; });
// [&#39;abc&#39;]
</code></pre><p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。</p>
<pre><code>Object.values(&#39;foo&#39;)
// [&#39;f&#39;, &#39;o&#39;, &#39;o&#39;]
</code></pre><p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p>
<p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。</p>
<pre><code>Object.values(42) // []
Object.values(true) // []
</code></pre><h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h3><p><code>Object.entries</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。</p>
<pre><code>const obj = { foo: &#39;bar&#39;, baz: 42 };
Object.entries(obj)
// [ [&quot;foo&quot;, &quot;bar&quot;], [&quot;baz&quot;, 42] ]
</code></pre><p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p>
<p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。</p>
<pre><code>Object.entries({ [Symbol()]: 123, foo: &#39;abc&#39; });
// [ [ &#39;foo&#39;, &#39;abc&#39; ] ]
</code></pre><p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非 Symbol 值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p>
<p><code>Object.entries</code>的基本用途是遍历对象的属性。</p>
<pre><code>let obj = { one: 1, two: 2 };
for (let [k, v] of Object.entries(obj)) {
  console.log(
    `${JSON.stringify(k)}: ${JSON.stringify(v)}`
  );
}
// &quot;one&quot;: 1
// &quot;two&quot;: 2
</code></pre><p><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。</p>
<pre><code>const obj = { foo: &#39;bar&#39;, baz: 42 };
const map = new Map(Object.entries(obj));
map // Map { foo: &quot;bar&quot;, baz: 42 }
</code></pre><p>自己实现<code>Object.entries</code>方法，非常简单。</p>
<pre><code>// Generator函数的版本
function* entries(obj) {
  for (let key of Object.keys(obj)) {
    yield [key, obj[key]];
  }
}

// 非Generator函数的版本
function entries(obj) {
  let arr = [];
  for (let key of Object.keys(obj)) {
    arr.push([key, obj[key]]);
  }
  return arr;
}
</code></pre><h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><p>《数组的扩展》一章中，已经介绍过扩展运算符（<code>...</code>）。</p>
<pre><code>const [a, ...b] = [1, 2, 3];
a // 1
b // [2, 3]
</code></pre><p>ES2018 将这个运算符<a href="https://github.com/sebmarkbage/ecmascript-rest-spread" target="_blank" rel="noopener">引入</a>了对象。</p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。</p>
<pre><code>let { x, y, ...z } = { x: 1, y: 2, a: 3, b: 4 };
x // 1
y // 2
z // { a: 3, b: 4 }
</code></pre><p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p>
<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象。</p>
<pre><code>let { x, y, ...z } = null; // 运行时错误
let { x, y, ...z } = undefined; // 运行时错误
</code></pre><p>解构赋值必须是最后一个参数，否则会报错。</p>
<pre><code>let { ...x, y, z } = obj; // 句法错误
let { x, ...y, ...z } = obj; // 句法错误
</code></pre><p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p>
<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。</p>
<pre><code>let obj = { a: { b: 1 } };
let { ...x } = obj;
obj.a.b = 2;
x.a.b // 2
</code></pre><p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p>
<p>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。</p>
<pre><code>let o1 = { a: 1 };
let o2 = { b: 2 };
o2.__proto__ = o1;
let { ...o3 } = o2;
o3 // { b: 2 }
o3.a // undefined
</code></pre><p>上面代码中，对象<code>o3</code>复制了<code>o2</code>，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性。</p>
<p>下面是另一个例子。</p>
<pre><code>const o = Object.create({ x: 1, y: 2 });
o.z = 3;

let { x, ...newObj } = o;
let { y, z } = newObj;
x // 1
y // undefined
z // 3
</code></pre><p>上面代码中，变量<code>x</code>是单纯的解构赋值，所以可以读取对象<code>o</code>继承的属性；变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值，只能读取对象<code>o</code>自身的属性，所以变量<code>z</code>可以赋值成功，变量<code>y</code>取不到值。ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量<code>newObj</code>，如果写成下面这样会报错。</p>
<pre><code>let { x, ...{ y, z } } = o;
// SyntaxError: ... must be followed by an identifier in declaration contexts
</code></pre><p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。</p>
<pre><code>function baseFunction({ a, b }) {
  // ...
}
function wrapperFunction({ x, y, ...restConfig }) {
  // 使用 x 和 y 参数进行操作
  // 其余参数传给原始函数
  return baseFunction(restConfig);
}
</code></pre><p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。</p>
<pre><code>let z = { a: 3, b: 4 };
let n = { ...z };
n // { a: 3, b: 4 }
</code></pre><p>这等同于使用<code>Object.assign</code>方法。</p>
<pre><code>let aClone = { ...a };
// 等同于
let aClone = Object.assign({}, a);
</code></pre><p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。</p>
<pre><code>// 写法一
const clone1 = {
  __proto__: Object.getPrototypeOf(obj),
  ...obj
};

// 写法二
const clone2 = Object.assign(
  Object.create(Object.getPrototypeOf(obj)),
  obj
);

// 写法三
const clone3 = Object.create(
  Object.getPrototypeOf(obj),
  Object.getOwnPropertyDescriptors(obj)
)
</code></pre><p>上面代码中，写法一的<code>__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>
<p>扩展运算符可以用于合并两个对象。</p>
<pre><code>let ab = { ...a, ...b };
// 等同于
let ab = Object.assign({}, a, b);
</code></pre><p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。</p>
<pre><code>let aWithOverrides = { ...a, x: 1, y: 2 };
// 等同于
let aWithOverrides = { ...a, ...{ x: 1, y: 2 } };
// 等同于
let x = 1, y = 2, aWithOverrides = { ...a, x, y };
// 等同于
let aWithOverrides = Object.assign({}, a, { x: 1, y: 2 });
</code></pre><p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p>
<p>这用来修改现有对象部分的属性就很方便了。</p>
<pre><code>let newVersion = {
  ...previousVersion,
  name: &#39;New Name&#39; // Override the name property
};
</code></pre><p>上面代码中，<code>newVersion</code>对象自定义了<code>name</code>属性，其他属性全部复制自<code>previousVersion</code>对象。</p>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。</p>
<pre><code>let aWithDefaults = { x: 1, y: 2, ...a };
// 等同于
let aWithDefaults = Object.assign({}, { x: 1, y: 2 }, a);
// 等同于
let aWithDefaults = Object.assign({ x: 1, y: 2 }, a);
</code></pre><p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。</p>
<pre><code>const obj = {
  ...(x &gt; 1 ? {a: 1} : {}),
  b: 2,
};
</code></pre><p>如果扩展运算符后面是一个空对象，则没有任何效果。</p>
<pre><code>{...{}, a: 1}
// { a: 1 }
</code></pre><p>如果扩展运算符的参数是<code>null</code>或<code>undefined</code>，这两个值会被忽略，不会报错。</p>
<pre><code>let emptyObject = { ...null, ...undefined }; // 不报错
</code></pre><p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。</p>
<pre><code>// 并不会抛出错误，因为 x 属性只是被定义，但没执行
let aWithXGetter = {
  ...a,
  get x() {
    throw new Error(&#39;not throw yet&#39;);
  }
};

// 会抛出错误，因为 x 属性被执行了
let runtimeError = {
  ...a,
  ...{
    get x() {
      throw new Error(&#39;throw now&#39;);
    }
  }
};
</code></pre>]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 08.数组的扩展]]></title>
      <url>/2018/06/15/ES6/08.%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h3 id="1-扩展运算符"><a href="#1-扩展运算符" class="headerlink" title="1.扩展运算符"></a>1.扩展运算符</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<pre><code>console.log(...[1, 2, 3])
// 1 2 3

console.log(1, ...[2, 3, 4], 5)
// 1 2 3 4 5

[...document.querySelectorAll(&#39;div&#39;)]
// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]
</code></pre><p>该运算符主要用于函数调用。</p>
<pre><code>function push(array, ...items) {
  array.push(...items);
}

function add(x, y) {
  return x + y;
}

const numbers = [4, 38];
add(...numbers) // 42
</code></pre><p>上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<pre><code>function f(v, w, x, y, z) { }
const args = [0, 1];
f(-1, ...args, 2, ...[3]);
</code></pre><p>扩展运算符后面还可以放置表达式。</p>
<pre><code>const arr = [
  ...(x &gt; 0 ? [&#39;a&#39;] : []),
  &#39;b&#39;,
];
</code></pre><p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p>
<pre><code>[...[], 1]
// [1]
</code></pre><h4 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a>替代函数的 apply 方法</h4><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<pre><code>// ES5 的写法
function f(x, y, z) {
  // ...
}
var args = [0, 1, 2];
f.apply(null, args);

// ES6的写法
function f(x, y, z) {
  // ...
}
let args = [0, 1, 2];
f(...args);
</code></pre><p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</p>
<pre><code>// ES5 的写法
Math.max.apply(null, [14, 3, 77])

// ES6 的写法
Math.max(...[14, 3, 77])

// 等同于
Math.max(14, 3, 77);
</code></pre><p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</p>
<p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。</p>
<pre><code>// ES5的 写法
var arr1 = [0, 1, 2];
var arr2 = [3, 4, 5];
Array.prototype.push.apply(arr1, arr2);

// ES6 的写法
let arr1 = [0, 1, 2];
let arr2 = [3, 4, 5];
arr1.push(...arr2);
</code></pre><p>上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>
<p>下面是另外一个例子。</p>
<pre><code>// ES5
new (Date.bind.apply(Date, [null, 2015, 1, 1]))
// ES6
new Date(...[2015, 1, 1]);
</code></pre><h4 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h4><p>（1）复制数组</p>
<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>
<pre><code>const a1 = [1, 2];
const a2 = a1;

a2[0] = 2;
a1 // [2, 2]
</code></pre><p>上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。</p>
<p>ES5 只能用变通方法来复制数组。</p>
<pre><code>const a1 = [1, 2];
const a2 = a1.concat();

a2[0] = 2;
a1 // [1, 2]
</code></pre><p>上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。</p>
<p>扩展运算符提供了复制数组的简便写法。</p>
<pre><code>const a1 = [1, 2];
// 写法一
const a2 = [...a1];
// 写法二
const [...a2] = a1;
</code></pre><p>上面的两种写法，a2都是a1的克隆。</p>
<p>（2）合并数组</p>
<p>扩展运算符提供了数组合并的新写法。</p>
<pre><code>const arr1 = [&#39;a&#39;, &#39;b&#39;];
const arr2 = [&#39;c&#39;];
const arr3 = [&#39;d&#39;, &#39;e&#39;];

// ES5 的合并数组
arr1.concat(arr2, arr3);
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]

// ES6 的合并数组
[...arr1, ...arr2, ...arr3]
// [ &#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;e&#39; ]
</code></pre><p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>
<pre><code>const a1 = [{ foo: 1 }];
const a2 = [{ bar: 2 }];

const a3 = a1.concat(a2);
const a4 = [...a1, ...a2];

a3[0] === a1[0] // true
a4[0] === a1[0] // true
</code></pre><p>上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。</p>
<p>（3）与解构赋值结合</p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<pre><code>// ES5
a = list[0], rest = list.slice(1)
// ES6
[a, ...rest] = list
</code></pre><p>下面是另外一些例子。</p>
<pre><code>const [first, ...rest] = [1, 2, 3, 4, 5];
first // 1
rest  // [2, 3, 4, 5]

const [first, ...rest] = [];
first // undefined
rest  // []

const [first, ...rest] = [&quot;foo&quot;];
first  // &quot;foo&quot;
rest   // []
</code></pre><p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<pre><code>const [...butLast, last] = [1, 2, 3, 4, 5];
// 报错

const [first, ...middle, last] = [1, 2, 3, 4, 5];
// 报错
</code></pre><p>（4）字符串</p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<pre><code>[...&#39;hello&#39;]
// [ &quot;h&quot;, &quot;e&quot;, &quot;l&quot;, &quot;l&quot;, &quot;o&quot; ]
</code></pre><p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</p>
<pre><code>&#39;x\uD83D\uDE80y&#39;.length // 4
[...&#39;x\uD83D\uDE80y&#39;].length // 3
</code></pre><p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<pre><code>function length(str) {
  return [...str].length;
}

length(&#39;x\uD83D\uDE80y&#39;) // 3
</code></pre><p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<p>let str = ‘x\uD83D\uDE80y’;</p>
<pre><code>str.split(&#39;&#39;).reverse().join(&#39;&#39;)
// &#39;y\uDE80\uD83Dx&#39;

[...str].reverse().join(&#39;&#39;)
// &#39;y\uD83D\uDE80x&#39;
</code></pre><p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p>
<p>（5）实现了 Iterator 接口的对象</p>
<p>任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>
<pre><code>let nodeList = document.querySelectorAll(&#39;div&#39;);
let array = [...nodeList];
</code></pre><p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</p>
<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<pre><code>let arrayLike = {
  &#39;0&#39;: &#39;a&#39;,
  &#39;1&#39;: &#39;b&#39;,
  &#39;2&#39;: &#39;c&#39;,
  length: 3
};

// TypeError: Cannot spread non-iterable object.
let arr = [...arrayLike];
</code></pre><p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p>
<p>（6）Map 和 Set 结构，Generator 函数</p>
<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p>
<pre><code>let map = new Map([
  [1, &#39;one&#39;],
  [2, &#39;two&#39;],
  [3, &#39;three&#39;],
]);

let arr = [...map.keys()]; // [1, 2, 3]
</code></pre><p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<pre><code>const go = function*(){
  yield 1;
  yield 2;
  yield 3;
};

[...go()] // [1, 2, 3]
</code></pre><p>上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p>
<pre><code>const obj = {a: 1, b: 2};
let arr = [...obj]; // TypeError: Cannot spread non-iterable object
</code></pre><h3 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2.Array.from()"></a>2.Array.from()</h3><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<p>下面是一个类似数组的对象，Array.from将它转为真正的数组。</p>
<pre><code>let arrayLike = {
    &#39;0&#39;: &#39;a&#39;,
    &#39;1&#39;: &#39;b&#39;,
    &#39;2&#39;: &#39;c&#39;,
    length: 3
};

// ES5的写法
var arr1 = [].slice.call(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]

// ES6的写法
let arr2 = Array.from(arrayLike); // [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]
</code></pre><p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p>
<pre><code>// NodeList对象
let ps = document.querySelectorAll(&#39;p&#39;);
Array.from(ps).filter(p =&gt; {
  return p.textContent.length &gt; 100;
});

// arguments对象
function foo() {
  var args = Array.from(arguments);
  // ...
}
</code></pre><p>上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用filter方法。</p>
<p>只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。</p>
<pre><code>Array.from(&#39;hello&#39;)
// [&#39;h&#39;, &#39;e&#39;, &#39;l&#39;, &#39;l&#39;, &#39;o&#39;]

let namesSet = new Set([&#39;a&#39;, &#39;b&#39;])
Array.from(namesSet) // [&#39;a&#39;, &#39;b&#39;]
</code></pre><p>上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。</p>
<p>如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。</p>
<pre><code>Array.from([1, 2, 3])
// [1, 2, 3]
</code></pre><p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</p>
<pre><code>// arguments对象
function foo() {
  const args = [...arguments];
}

// NodeList对象
[...document.querySelectorAll(&#39;div&#39;)]
</code></pre><p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</p>
<pre><code>Array.from({ length: 3 });
// [ undefined, undefined, undefined ]
</code></pre><p>上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。</p>
<p>对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。</p>
<pre><code>const toArray = (() =&gt;
  Array.from ? Array.from : obj =&gt; [].slice.call(obj)
)();
</code></pre><p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<pre><code>Array.from(arrayLike, x =&gt; x * x);
// 等同于
Array.from(arrayLike).map(x =&gt; x * x);

Array.from([1, 2, 3], (x) =&gt; x * x)
// [1, 4, 9]
</code></pre><p>下面的例子是取出一组 DOM 节点的文本内容。</p>
<pre><code>let spans = document.querySelectorAll(&#39;span.name&#39;);

// map()
let names1 = Array.prototype.map.call(spans, s =&gt; s.textContent);

// Array.from()
let names2 = Array.from(spans, s =&gt; s.textContent)
</code></pre><p>下面的例子将数组中布尔值为false的成员转为0。</p>
<pre><code>Array.from([1, , 2, , 3], (n) =&gt; n || 0)
// [1, 0, 2, 0, 3]
</code></pre><p>另一个例子是返回各种数据的类型。</p>
<pre><code>function typesOf () {
  return Array.from(arguments, value =&gt; typeof value)
}
typesOf(null, [], NaN)
// [&#39;object&#39;, &#39;object&#39;, &#39;number&#39;]
</code></pre><p>如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。</p>
<p>Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>
<pre><code>Array.from({ length: 2 }, () =&gt; &#39;jack&#39;)
// [&#39;jack&#39;, &#39;jack&#39;]
</code></pre><p>上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p>
<p>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。</p>
<pre><code>function countSymbols(string) {
  return Array.from(string).length;
}
</code></pre><h3 id="3-Array-of"><a href="#3-Array-of" class="headerlink" title="3.Array.of()"></a>3.Array.of()</h3><p>Array.of方法用于将一组值，转换为数组。</p>
<pre><code>Array.of(3, 11, 8) // [3,11,8]
Array.of(3) // [3]
Array.of(3).length // 1
</code></pre><p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。</p>
<pre><code>Array() // []
Array(3) // [, , ,]
Array(3, 11, 8) // [3, 11, 8]
</code></pre><p>上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p>Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<pre><code>Array.of() // []
Array.of(undefined) // [undefined]
Array.of(1) // [1]
Array.of(1, 2) // [1, 2]
</code></pre><p>Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<p>Array.of方法可以用下面的代码模拟实现。</p>
<pre><code>function ArrayOf(){
  return [].slice.call(arguments);
}
</code></pre><h3 id="4-数组实例的-copyWithin"><a href="#4-数组实例的-copyWithin" class="headerlink" title="4.数组实例的 copyWithin()"></a>4.数组实例的 copyWithin()</h3><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<pre><code>Array.prototype.copyWithin(target, start = 0, end = this.length)
</code></pre><p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br>这三个参数都应该是数值，如果不是，会自动转为数值。</li>
</ul>
<pre><code>[1, 2, 3, 4, 5].copyWithin(0, 3)
// [4, 5, 3, 4, 5]
</code></pre><p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p>
<p>下面是更多例子。</p>
<pre><code>// 将3号位复制到0号位
[1, 2, 3, 4, 5].copyWithin(0, 3, 4)
// [4, 2, 3, 4, 5]

// -2相当于3号位，-1相当于4号位
[1, 2, 3, 4, 5].copyWithin(0, -2, -1)
// [4, 2, 3, 4, 5]

// 将3号位复制到0号位
[].copyWithin.call({length: 5, 3: 1}, 0, 3)
// {0: 1, 3: 1, length: 5}

// 将2号位到数组结束，复制到0号位
let i32a = new Int32Array([1, 2, 3, 4, 5]);
i32a.copyWithin(0, 2);
// Int32Array [3, 4, 5, 4, 5]

// 对于没有部署 TypedArray 的 copyWithin 方法的平台
// 需要采用下面的写法
[].copyWithin.call(new Int32Array([1, 2, 3, 4, 5]), 0, 3, 4);
// Int32Array [4, 2, 3, 4, 5]
</code></pre><h3 id="5-数组实例的-find-和-findIndex"><a href="#5-数组实例的-find-和-findIndex" class="headerlink" title="5.数组实例的 find() 和 findIndex()"></a>5.数组实例的 find() 和 findIndex()</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<pre><code>[1, 4, -5, 10].find((n) =&gt; n &lt; 0)
// -5
</code></pre><p>上面代码找出数组中第一个小于 0 的成员。</p>
<pre><code>[1, 5, 10, 15].find(function(value, index, arr) {
  return value &gt; 9;
}) // 10
</code></pre><p>上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<pre><code>[1, 5, 10, 15].findIndex(function(value, index, arr) {
  return value &gt; 9;
}) // 2
</code></pre><p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p>
<pre><code>function f(v){
  return v &gt; this.age;
}
let person = {name: &#39;John&#39;, age: 20};
[10, 12, 26, 15].find(f, person);    // 26
</code></pre><p>上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。</p>
<p>另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。</p>
<pre><code>[NaN].indexOf(NaN)
// -1

[NaN].findIndex(y =&gt; Object.is(NaN, y))
// 0
</code></pre><p>上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。</p>
<h3 id="6-数组实例的-fill"><a href="#6-数组实例的-fill" class="headerlink" title="6.数组实例的 fill()"></a>6.数组实例的 fill()</h3><p>fill方法使用给定值，填充一个数组。</p>
<pre><code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7)
// [7, 7, 7]

new Array(3).fill(7)
// [7, 7, 7]
</code></pre><p>上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<pre><code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].fill(7, 1, 2)
// [&#39;a&#39;, 7, &#39;c&#39;]
</code></pre><p>上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p>
<p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p>
<pre><code>let arr = new Array(3).fill({name: &quot;Mike&quot;});
arr[0].name = &quot;Ben&quot;;
arr
// [{name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}, {name: &quot;Ben&quot;}]

let arr = new Array(3).fill([]);
arr[0].push(5);
arr
// [[5], [5], [5]]
</code></pre><h3 id="7-数组实例的-entries-，keys-和-values"><a href="#7-数组实例的-entries-，keys-和-values" class="headerlink" title="7.数组实例的 entries()，keys() 和 values()"></a>7.数组实例的 entries()，keys() 和 values()</h3><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<pre><code>for (let index of [&#39;a&#39;, &#39;b&#39;].keys()) {
  console.log(index);
}
// 0
// 1

for (let elem of [&#39;a&#39;, &#39;b&#39;].values()) {
  console.log(elem);
}
// &#39;a&#39;
// &#39;b&#39;

for (let [index, elem] of [&#39;a&#39;, &#39;b&#39;].entries()) {
  console.log(index, elem);
}
// 0 &quot;a&quot;
// 1 &quot;b&quot;
</code></pre><p>如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。</p>
<pre><code>let letter = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;];
let entries = letter.entries();
console.log(entries.next().value); // [0, &#39;a&#39;]
console.log(entries.next().value); // [1, &#39;b&#39;]
console.log(entries.next().value); // [2, &#39;c&#39;]
</code></pre><h3 id="8-数组实例的-includes"><a href="#8-数组实例的-includes" class="headerlink" title="8.数组实例的 includes()"></a>8.数组实例的 includes()</h3><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。</p>
<pre><code>[1, 2, 3].includes(2)     // true
[1, 2, 3].includes(4)     // false
[1, 2, NaN].includes(NaN) // true
</code></pre><p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>
<pre><code>[1, 2, 3].includes(3, 3);  // false
[1, 2, 3].includes(3, -1); // true
</code></pre><p>没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。</p>
<pre><code>if (arr.indexOf(el) !== -1) {
  // ...
}
</code></pre><p>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。</p>
<pre><code>[NaN].indexOf(NaN)
// -1
</code></pre><p>includes使用的是不一样的判断算法，就没有这个问题。</p>
<pre><code>[NaN].includes(NaN)
// true
</code></pre><p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>
<pre><code>const contains = (() =&gt;
  Array.prototype.includes
    ? (arr, value) =&gt; arr.includes(value)
    : (arr, value) =&gt; arr.some(el =&gt; el === value)
)();
contains([&#39;foo&#39;, &#39;bar&#39;], &#39;baz&#39;); // =&gt; false
</code></pre><p>另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。</p>
<ul>
<li>Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。</li>
<li>Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。</li>
</ul>
<h3 id="9-数组的空位"><a href="#9-数组的空位" class="headerlink" title="9.数组的空位"></a>9.数组的空位</h3><p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。</p>
<pre><code>Array(3) // [, , ,]
</code></pre><p>上面代码中，Array(3)返回一个具有 3 个空位的数组。</p>
<p>注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。</p>
<pre><code>0 in [undefined, undefined, undefined] // true
0 in [, , ,] // false
</code></pre><p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</li>
<li>map()会跳过空位，但会保留这个值</li>
<li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</li>
</ul>
<pre><code>// forEach方法
[,&#39;a&#39;].forEach((x,i) =&gt; console.log(i)); // 1

// filter方法
[&#39;a&#39;,,&#39;b&#39;].filter(x =&gt; true) // [&#39;a&#39;,&#39;b&#39;]

// every方法
[,&#39;a&#39;].every(x =&gt; x===&#39;a&#39;) // true

// reduce方法
[1,,2].reduce((x,y) =&gt; return x+y) // 3

// some方法
[,&#39;a&#39;].some(x =&gt; x !== &#39;a&#39;) // false

// map方法
[,&#39;a&#39;].map(x =&gt; 1) // [,1]

// join方法
[,&#39;a&#39;,undefined,null].join(&#39;#&#39;) // &quot;#a##&quot;

// toString方法
[,&#39;a&#39;,undefined,null].toString() // &quot;,a,,&quot;
</code></pre><p>ES6 则是明确将空位转为undefined。</p>
<p>Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。</p>
<pre><code>Array.from([&#39;a&#39;,,&#39;b&#39;])
// [ &quot;a&quot;, undefined, &quot;b&quot; ]
</code></pre><p>扩展运算符（…）也会将空位转为undefined。</p>
<pre><code>[...[&#39;a&#39;,,&#39;b&#39;]]
// [ &quot;a&quot;, undefined, &quot;b&quot; ]
</code></pre><p>copyWithin()会连空位一起拷贝。</p>
<pre><code>[,&#39;a&#39;,&#39;b&#39;,,].copyWithin(2,0) // [,&quot;a&quot;,,&quot;a&quot;]
</code></pre><p>fill()会将空位视为正常的数组位置。</p>
<pre><code>new Array(3).fill(&#39;a&#39;) // [&quot;a&quot;,&quot;a&quot;,&quot;a&quot;]
</code></pre><p>for…of循环也会遍历空位。</p>
<pre><code>let arr = [, ,];
for (let i of arr) {
  console.log(1);
}
// 1
// 1
</code></pre><p>上面代码中，数组arr有两个空位，for…of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。</p>
<p>entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</p>
<pre><code>// entries()
[...[,&#39;a&#39;].entries()] // [[0,undefined], [1,&quot;a&quot;]]

// keys()
[...[,&#39;a&#39;].keys()] // [0,1]

// values()
[...[,&#39;a&#39;].values()] // [undefined,&quot;a&quot;]

// find()
[,&#39;a&#39;].find(x =&gt; true) // undefined

// findIndex()
[,&#39;a&#39;].findIndex(x =&gt; true) // 0
</code></pre><p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 07.函数的扩展]]></title>
      <url>/2018/06/15/ES6/07.%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h3 id="1-函数的扩展"><a href="#1-函数的扩展" class="headerlink" title="1.函数的扩展"></a>1.函数的扩展</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<pre><code>function log(x, y) {
  y = y || &#39;World&#39;;
  console.log(x, y);
}

log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello World
</code></pre><p>上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。</p>
<p>为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。</p>
<pre><code>if (typeof y === &#39;undefined&#39;) {
  y = &#39;World&#39;;
}
</code></pre><p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<pre><code>function log(x, y = &#39;World&#39;) {
  console.log(x, y);
}

log(&#39;Hello&#39;) // Hello World
log(&#39;Hello&#39;, &#39;China&#39;) // Hello China
log(&#39;Hello&#39;, &#39;&#39;) // Hello
</code></pre><p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。</p>
<pre><code>function Point(x = 0, y = 0) {
  this.x = x;
  this.y = y;
}

const p = new Point();
p // { x: 0, y: 0 }
</code></pre><p>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<p>参数变量是默认声明的，所以不能用let或const再次声明。</p>
<pre><code>function foo(x = 5) {
  let x = 1; // error
  const x = 2; // error
}
</code></pre><p>上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。</p>
<p>使用参数默认值时，函数不能有同名参数。</p>
<pre><code>// 不报错
function foo(x, x, y) {
  // ...
}

// 报错
function foo(x, x, y = 1) {
  // ...
}
// SyntaxError: Duplicate parameter name not allowed in this context// 不报错
function foo(x, x, y) {
  // ...
}
</code></pre><p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<pre><code>let x = 99;
function foo(p = x + 1) {
  console.log(p);
}

foo() // 100

x = 100;
foo() // 101
</code></pre><p>上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</p>
<h4 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h4><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<pre><code>function foo({x, y = 5}) {
  console.log(x, y);
}

foo({}) // undefined 5
foo({x: 1}) // 1 5
foo({x: 1, y: 2}) // 1 2
foo() // TypeError: Cannot read property &#39;x&#39; of undefined
</code></pre><p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>
<pre><code>function foo({x, y = 5} = {}) {
  console.log(x, y);
}

foo() // undefined 5
</code></pre><p>上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。</p>
<p>下面是另一个解构赋值默认值的例子。</p>
<pre><code>function fetch(url, { body = &#39;&#39;, method = &#39;GET&#39;, headers = {} }) {
  console.log(method);
}

fetch(&#39;http://example.com&#39;, {})
// &quot;GET&quot;

fetch(&#39;http://example.com&#39;)
// 报错
</code></pre><p>上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p>
<pre><code>function fetch(url, { body = &#39;&#39;, method = &#39;GET&#39;, headers = {} } = {}) {
  console.log(method);
}

fetch(&#39;http://example.com&#39;)
// &quot;GET&quot;
</code></pre><p>上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。</p>
<p>作为练习，请问下面两种写法有什么差别？</p>
<pre><code>// 写法一
function m1({x = 0, y = 0} = {}) {
  return [x, y];
}

// 写法二
function m2({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}
</code></pre><p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<pre><code>// 函数没有参数的情况
m1() // [0, 0]
m2() // [0, 0]

// x 和 y 都有值的情况
m1({x: 3, y: 8}) // [3, 8]
m2({x: 3, y: 8}) // [3, 8]

// x 有值，y 无值的情况
m1({x: 3}) // [3, 0]
m2({x: 3}) // [3, undefined]

// x 和 y 都无值的情况
m1({}) // [0, 0];
m2({}) // [undefined, undefined]

m1({z: 3}) // [0, 0]
m2({z: 3}) // [undefined, undefined]
</code></pre><h4 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h4><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<pre><code>// 例一
function f(x = 1, y) {
  return [x, y];
}

f() // [1, undefined]
f(2) // [2, undefined])
f(, 1) // 报错
f(undefined, 1) // [1, 1]

// 例二
function f(x, y = 5, z) {
  return [x, y, z];
}

f() // [undefined, 5, undefined]
f(1) // [1, 5, undefined]
f(1, ,2) // 报错
f(1, undefined, 2) // [1, 5, 2]
</code></pre><p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。</p>
<p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p>
<pre><code>function foo(x = 5, y = 6) {
  console.log(x, y);
}

foo(undefined, null)
</code></pre><p>上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。</p>
<h4 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h4><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<pre><code>(function (a) {}).length // 1
(function (a = 5) {}).length // 0
(function (a, b, c = 5) {}).length // 2
</code></pre><p>上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。</p>
<p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。</p>
<pre><code>(function(...args) {}).length // 0
</code></pre><p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p>
<pre><code>(function (a = 0, b, c) {}).length // 0
(function (a, b = 1, c) {}).length // 1
</code></pre><h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<pre><code>var x = 1;

function f(x, y = x) {
  console.log(y);
}

f(2) // 2
</code></pre><p>上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。</p>
<p>再看下面的例子。</p>
<pre><code>let x = 1;

function f(y = x) {
  let x = 2;
  console.log(y);
}

f() // 1
</code></pre><p>上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。</p>
<p>如果此时，全局变量x不存在，就会报错。</p>
<pre><code>function f(y = x) {
  let x = 2;
  console.log(y);
}

f() // ReferenceError: x is not defined
</code></pre><p>下面这样写，也会报错。</p>
<pre><code>var x = 1;

function foo(x = x) {
  // ...
}

foo() // ReferenceError: x is not defined
</code></pre><p>上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p>
<pre><code>let foo = &#39;outer&#39;;

function bar(func = () =&gt; foo) {
  let foo = &#39;inner&#39;;
  console.log(func());
}

bar(); // outer
</code></pre><p>上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。</p>
<p>如果写成下面这样，就会报错。</p>
<pre><code>function bar(func = () =&gt; foo) {
  let foo = &#39;inner&#39;;
  console.log(func());
}

bar() // ReferenceError: foo is not defined
</code></pre><p>上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。</p>
<p>下面是一个更复杂的例子。</p>
<pre><code>var x = 1;
function foo(x, y = function() { x = 2; }) {
  var x = 3;
  y();
  console.log(x);
}

foo() // 3
x // 1
</code></pre><p>上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。</p>
<p>如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。</p>
<pre><code>var x = 1;
function foo(x, y = function() { x = 2; }) {
  x = 3;
  y();
  console.log(x);
}

foo() // 2
x // 1
</code></pre><h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<pre><code>function throwIfMissing() {
  throw new Error(&#39;Missing parameter&#39;);
}

function foo(mustBeProvided = throwIfMissing()) {
  return mustBeProvided;
}

foo()
// Error: Missing parameter
</code></pre><p>上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。</p>
<p>从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p>
<p>另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。</p>
<pre><code>function foo(optional = undefined) { ··· }
</code></pre><h3 id="2-rest-参数"><a href="#2-rest-参数" class="headerlink" title="2.rest 参数"></a>2.rest 参数</h3><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<pre><code>function add(...values) {
  let sum = 0;

  for (var val of values) {
    sum += val;
  }

  return sum;
}

add(2, 5, 3) // 10
</code></pre><p>上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>
<p>下面是一个 rest 参数代替arguments变量的例子。</p>
<pre><code>// arguments变量的写法
function sortNumbers() {
  return Array.prototype.slice.call(arguments).sort();
}

// rest参数的写法
const sortNumbers = (...numbers) =&gt; numbers.sort();
</code></pre><p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p>
<p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。</p>
<pre><code>function push(array, ...items) {
  items.forEach(function(item) {
    array.push(item);
    console.log(item);
  });
}

var a = [];
push(a, 1, 2, 3)
</code></pre><p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<pre><code>// 报错
function f(a, ...b, c) {
  // ...
}
</code></pre><p>函数的length属性，不包括 rest 参数。</p>
<pre><code>(function(a) {}).length  // 1
(function(...a) {}).length  // 0
(function(a, ...b) {}).length  // 1
</code></pre><h3 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3.严格模式"></a>3.严格模式</h3><p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<pre><code>function doSomething(a, b) {
  &#39;use strict&#39;;
  // code
}
</code></pre><p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<pre><code>// 报错
function doSomething(a, b = a) {
  &#39;use strict&#39;;
  // code
}

// 报错
const doSomething = function ({a, b}) {
  &#39;use strict&#39;;
  // code
};

// 报错
const doSomething = (...a) =&gt; {
  &#39;use strict&#39;;
  // code
};

const obj = {
  // 报错
  doSomething({a, b}) {
    &#39;use strict&#39;;
    // code
  }
};
</code></pre><p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p>
<pre><code>// 报错
function doSomething(value = 070) {
  &#39;use strict&#39;;
  return value;
}
</code></pre><p>上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p>
<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p>
<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p>
<pre><code>&#39;use strict&#39;;

function doSomething(a, b = a) {
  // code
}
</code></pre><p>第二种是把函数包在一个无参数的立即执行函数里面。</p>
<pre><code>const doSomething = (function () {
  &#39;use strict&#39;;
  return function(value = 42) {
    return value;
  };
}());
</code></pre><h3 id="4-name-属性"><a href="#4-name-属性" class="headerlink" title="4.name 属性"></a>4.name 属性</h3><p>函数的name属性，返回该函数的函数名。</p>
<pre><code>function foo() {}
foo.name // &quot;foo&quot;
</code></pre><p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。</p>
<pre><code>var f = function () {};

// ES5
f.name // &quot;&quot;

// ES6
f.name // &quot;f&quot;
</code></pre><p>上面代码中，变量f等于一个匿名函数，ES5 和 ES6 的name属性返回的值不一样。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。</p>
<pre><code>const bar = function baz() {};

// ES5
bar.name // &quot;baz&quot;

// ES6
bar.name // &quot;baz&quot;
</code></pre><p>Function构造函数返回的函数实例，name属性的值为anonymous。</p>
<pre><code>(new Function).name // &quot;anonymous&quot;
</code></pre><p>bind返回的函数，name属性值会加上bound前缀。</p>
<pre><code>function foo() {};
foo.bind({}).name // &quot;bound foo&quot;

(function(){}).bind({}).name // &quot;bound &quot;
</code></pre><h3 id="5-箭头函数"><a href="#5-箭头函数" class="headerlink" title="5.箭头函数"></a>5.箭头函数</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<pre><code>var f = v =&gt; v;

// 等同于
var f = function (v) {
  return v;
};
</code></pre><p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<pre><code>var f = () =&gt; 5;
// 等同于
var f = function () { return 5 };

var sum = (num1, num2) =&gt; num1 + num2;
// 等同于
var sum = function(num1, num2) {
  return num1 + num2;
};
</code></pre><p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</p>
<pre><code>var sum = (num1, num2) =&gt; { return num1 + num2; }
</code></pre><p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<pre><code>// 报错
let getTempItem = id =&gt; { id: id, name: &quot;Temp&quot; };

// 不报错
let getTempItem = id =&gt; ({ id: id, name: &quot;Temp&quot; });
</code></pre><p>下面是一种特殊情况，虽然可以运行，但会得到错误的结果。</p>
<pre><code>let foo = () =&gt; { a: 1 };
foo() // undefined
</code></pre><p>上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。</p>
<p>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</p>
<pre><code>let fn = () =&gt; void doesNotReturn();
</code></pre><p>箭头函数可以与变量解构结合使用。</p>
<pre><code>const full = ({ first, last }) =&gt; first + &#39; &#39; + last;

// 等同于
function full(person) {
  return person.first + &#39; &#39; + person.last;
}
</code></pre><p>箭头函数使得表达更加简洁。</p>
<pre><code>const isEven = n =&gt; n % 2 == 0;
const square = n =&gt; n * n;
</code></pre><p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<pre><code>// 正常函数写法
[1,2,3].map(function (x) {
  return x * x;
});

// 箭头函数写法
[1,2,3].map(x =&gt; x * x);
</code></pre><p>另一个例子是</p>
<pre><code>// 正常函数写法
var result = values.sort(function (a, b) {
  return a - b;
});

// 箭头函数写法
var result = values.sort((a, b) =&gt; a - b);
</code></pre><p>下面是 rest 参数与箭头函数结合的例子。</p>
<pre><code>const numbers = (...nums) =&gt; nums;

numbers(1, 2, 3, 4, 5)
// [1,2,3,4,5]

const headAndTail = (head, ...tail) =&gt; [head, tail];

headAndTail(1, 2, 3, 4, 5)
// [1,[2,3,4,5]]
</code></pre><h4 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h4><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</p>
<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<pre><code>function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}

var id = 21;

foo.call({ id: 42 });
// id: 42
</code></pre><p>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。</p>
<p>箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p>
<pre><code>function Timer() {
  this.s1 = 0;
  this.s2 = 0;
  // 箭头函数
  setInterval(() =&gt; this.s1++, 1000);
  // 普通函数
  setInterval(function () {
    this.s2++;
  }, 1000);
}

var timer = new Timer();

setTimeout(() =&gt; console.log(&#39;s1: &#39;, timer.s1), 3100);
setTimeout(() =&gt; console.log(&#39;s2: &#39;, timer.s2), 3100);
// s1: 3
// s2: 0
</code></pre><p>上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。</p>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p>
<pre><code>var handler = {
  id: &#39;123456&#39;,

  init: function() {
    document.addEventListener(&#39;click&#39;,
      event =&gt; this.doSomething(event.type), false);
  },

  doSomething: function(type) {
    console.log(&#39;Handling &#39; + type  + &#39; for &#39; + this.id);
  }
};
</code></pre><p>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成 ES5 的代码如下。</p>
<pre><code>// ES6
function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;id:&#39;, this.id);
  }, 100);
}

// ES5
function foo() {
  var _this = this;

  setTimeout(function () {
    console.log(&#39;id:&#39;, _this.id);
  }, 100);
}
</code></pre><p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。</p>
<p>请问下面的代码之中有几个this？</p>
<pre><code>function foo() {
  return () =&gt; {
    return () =&gt; {
      return () =&gt; {
        console.log(&#39;id:&#39;, this.id);
      };
    };
  };
}

var f = foo.call({id: 1});

var t1 = f.call({id: 2})()(); // id: 1
var t2 = f().call({id: 3})(); // id: 1
var t3 = f()().call({id: 4}); // id: 1
</code></pre><p>上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。</p>
<p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</p>
<pre><code>function foo() {
  setTimeout(() =&gt; {
    console.log(&#39;args:&#39;, arguments);
  }, 100);
}

foo(2, 4, 6, 8)
// args: [2, 4, 6, 8]
</code></pre><p>上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。</p>
<p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p>
<pre><code>(function() {
  return [
    (() =&gt; this.x).bind({ x: &#39;inner&#39; })()
  ];
}).call({ x: &#39;outer&#39; });
// [&#39;outer&#39;]
</code></pre><p>上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。</p>
<p>长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。</p>
<h4 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h4><p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。</p>
<pre><code>function insert(value) {
  return {into: function (array) {
    return {after: function (afterValue) {
      array.splice(array.indexOf(afterValue) + 1, 0, value);
      return array;
    }};
  }};
}

insert(2).into([1, 3]).after(1); //[1, 2, 3]
</code></pre><p>上面这个函数，可以使用箭头函数改写。</p>
<pre><code>let insert = (value) =&gt; ({into: (array) =&gt; ({after: (afterValue) =&gt; {
  array.splice(array.indexOf(afterValue) + 1, 0, value);
  return array;
}})});

insert(2).into([1, 3]).after(1); //[1, 2, 3]
</code></pre><p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>
<pre><code>const pipeline = (...funcs) =&gt;
  val =&gt; funcs.reduce((a, b) =&gt; b(a), val);

const plus1 = a =&gt; a + 1;
const mult2 = a =&gt; a * 2;
const addThenMult = pipeline(plus1, mult2);

addThenMult(5)
// 12
</code></pre><p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>
<pre><code>const plus1 = a =&gt; a + 1;
const mult2 = a =&gt; a * 2;

mult2(plus1(5))
// 12
</code></pre><p>箭头函数还有一个功能，就是可以很方便地改写 λ 演算。</p>
<pre><code>// λ演算的写法
fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))

// ES6的写法
var fix = f =&gt; (x =&gt; f(v =&gt; x(x)(v)))
               (x =&gt; f(v =&gt; x(x)(v)));
</code></pre><p>上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。</p>
<h3 id="6-双冒号运算符"><a href="#6-双冒号运算符" class="headerlink" title="6.双冒号运算符"></a>6.双冒号运算符</h3><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。</p>
<p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<pre><code>foo::bar;
// 等同于
bar.bind(foo);

foo::bar(...arguments);
// 等同于
bar.apply(foo, arguments);

const hasOwnProperty = Object.prototype.hasOwnProperty;
function hasOwn(obj, key) {
  return obj::hasOwnProperty(key);
}
</code></pre><p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<pre><code>var method = obj::obj.foo;
// 等同于
var method = ::obj.foo;

let log = ::console.log;
// 等同于
var log = console.log.bind(console);
</code></pre><p>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。</p>
<pre><code>import { map, takeWhile, forEach } from &quot;iterlib&quot;;

getPlayers()
::map(x =&gt; x.character())
::takeWhile(x =&gt; x.strength &gt; 100)
::forEach(x =&gt; console.log(x));
</code></pre><h3 id="7-尾调用优化"><a href="#7-尾调用优化" class="headerlink" title="7.尾调用优化"></a>7.尾调用优化</h3><h4 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h4><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<pre><code>function f(x){
  return g(x);
}
</code></pre><p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</p>
<p>以下三种情况，都不属于尾调用。</p>
<pre><code>// 情况一
function f(x){
  let y = g(x);
  return y;
}

// 情况二
function f(x){
  return g(x) + 1;
}

// 情况三
function f(x){
  g(x);
}
</code></pre><p>上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</p>
<pre><code>function f(x){
  g(x);
  return undefined;
}
</code></pre><p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<pre><code>function f(x) {
  if (x &gt; 0) {
    return m(x)
  }
  return n(x);
}
</code></pre><p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</p>
<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<pre><code>function f() {
  let m = 1;
  let n = 2;
  return g(m + n);
}
f();

// 等同于
function f() {
  return g(3);
}
f();

// 等同于
g(3);
</code></pre><p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
<pre><code>function addOne(a){
  var one = 1;
  function inner(b){
    return b + one;
  }
  return inner(a);
}
</code></pre><p>上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。</p>
<h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<pre><code>function factorial(n) {
  if (n === 1) return 1;
  return n * factorial(n - 1);
}

factorial(5) // 120
</code></pre><p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<pre><code>function factorial(n, total) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5, 1) // 120
</code></pre><p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p>
<p>非尾递归的 Fibonacci 数列实现如下。</p>
<pre><code>function Fibonacci (n) {
  if ( n &lt;= 1 ) {return 1};

  return Fibonacci(n - 1) + Fibonacci(n - 2);
}

Fibonacci(10) // 89
Fibonacci(100) // 堆栈溢出
Fibonacci(500) // 堆栈溢出
</code></pre><p>尾递归优化过的 Fibonacci 数列实现如下。</p>
<pre><code>function Fibonacci2 (n , ac1 = 1 , ac2 = 1) {
  if( n &lt;= 1 ) {return ac2};

  return Fibonacci2 (n - 1, ac2, ac1 + ac2);
}

Fibonacci2(100) // 573147844013817200000
Fibonacci2(1000) // 7.0330367711422765e+208
Fibonacci2(10000) // Infinity
</code></pre><p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<h4 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h4><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>
<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>
<pre><code>function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

function factorial(n) {
  return tailFactorial(n, 1);
}

factorial(5) // 120
</code></pre><p>上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。</p>
<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<pre><code>function currying(fn, n) {
  return function (m) {
    return fn.call(this, m, n);
  };
}

function tailFactorial(n, total) {
  if (n === 1) return total;
  return tailFactorial(n - 1, n * total);
}

const factorial = currying(tailFactorial, 1);

factorial(5) // 120
</code></pre><p>上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。</p>
<p>第二种方法就简单多了，就是采用 ES6 的函数默认值。</p>
<pre><code>function factorial(n, total = 1) {
  if (n === 1) return total;
  return factorial(n - 1, n * total);
}

factorial(5) // 120
</code></pre><p>上面代码中，参数total有默认值1，所以调用时不用提供这个值。</p>
<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<ul>
<li>func.arguments：返回调用时函数的参数。</li>
<li>func.caller：返回调用当前函数的那个函数。</li>
</ul>
<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<pre><code>function restricted() {
  &#39;use strict&#39;;
  restricted.caller;    // 报错
  restricted.arguments; // 报错
}
restricted();
</code></pre><h4 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h4><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<pre><code>function sum(x, y) {
  if (y &gt; 0) {
    return sum(x + 1, y - 1);
  } else {
    return x;
  }
}

sum(1, 100000)
// Uncaught RangeError: Maximum call stack size exceeded(…)
</code></pre><p>上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<pre><code>function trampoline(f) {
  while (f &amp;&amp; f instanceof Function) {
    f = f();
  }
  return f;
}
</code></pre><p>上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<pre><code>function sum(x, y) {
  if (y &gt; 0) {
    return sum.bind(null, x + 1, y - 1);
  } else {
    return x;
  }
}
</code></pre><p>上面代码中，sum函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行sum，就不会发生调用栈溢出。</p>
<pre><code>trampoline(sum(1, 100000))
// 100001
</code></pre><p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<pre><code>function tco(f) {
  var value;
  var active = false;
  var accumulated = [];

  return function accumulator() {
    accumulated.push(arguments);
    if (!active) {
      active = true;
      while (accumulated.length) {
        value = f.apply(this, accumulated.shift());
      }
      active = false;
      return value;
    }
  };
}

var sum = tco(function(x, y) {
  if (y &gt; 0) {
    return sum(x + 1, y - 1)
  }
  else {
    return x
  }
});

sum(1, 100000)
// 100001
</code></pre><p>上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h3 id="8-函数参数的尾逗号"><a href="#8-函数参数的尾逗号" class="headerlink" title="8.函数参数的尾逗号"></a>8.函数参数的尾逗号</h3><p>ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。</p>
<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>
<pre><code>function clownsEverywhere(
  param1,
  param2
) { /* ... */ }

clownsEverywhere(
  &#39;foo&#39;,
  &#39;bar&#39;
);
</code></pre><p>上面代码中，如果在param2或bar后面加一个逗号，就会报错。</p>
<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownsEverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p>
<pre><code>function clownsEverywhere(
  param1,
  param2,
) { /* ... */ }

clownsEverywhere(
  &#39;foo&#39;,
  &#39;bar&#39;,
);
</code></pre><p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 06.数值的扩展]]></title>
      <url>/2018/06/12/ES6/06.%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><h3 id="1-二进制和八进制表示法"><a href="#1-二进制和八进制表示法" class="headerlink" title="1.二进制和八进制表示法"></a>1.二进制和八进制表示法</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</p>
<pre><code>0b111110111 === 503 // true
0o767 === 503 // true
</code></pre><p>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。</p>
<pre><code>// 非严格模式
(function(){
  console.log(0o11 === 011);
})() // true

// 严格模式
(function(){
  &#39;use strict&#39;;
  console.log(0o11 === 011);
})() // Uncaught SyntaxError: Octal literals are not allowed in strict mode.
</code></pre><p>如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。</p>
<pre><code>Number(&#39;0b111&#39;)  // 7
Number(&#39;0o10&#39;)  // 8
</code></pre><h3 id="2-Number-isFinite-Number-isNaN"><a href="#2-Number-isFinite-Number-isNaN" class="headerlink" title="2.Number.isFinite(), Number.isNaN()"></a>2.Number.isFinite(), Number.isNaN()</h3><p>ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。</p>
<p>Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。</p>
<pre><code>Number.isFinite(15); // true
Number.isFinite(0.8); // true
Number.isFinite(NaN); // false
Number.isFinite(Infinity); // false
Number.isFinite(-Infinity); // false
Number.isFinite(&#39;foo&#39;); // false
Number.isFinite(&#39;15&#39;); // false
Number.isFinite(true); // false
</code></pre><p>注意，如果参数类型不是数值，Number.isFinite一律返回false。</p>
<p>Number.isNaN()用来检查一个值是否为NaN。</p>
<pre><code>Number.isNaN(NaN) // true
Number.isNaN(15) // false
Number.isNaN(&#39;15&#39;) // false
Number.isNaN(true) // false
Number.isNaN(9/NaN) // true
Number.isNaN(&#39;true&#39; / 0) // true
Number.isNaN(&#39;true&#39; / &#39;true&#39;) // true
</code></pre><p>如果参数类型不是NaN，Number.isNaN一律返回false。</p>
<p>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。</p>
<pre><code>isFinite(25) // true
isFinite(&quot;25&quot;) // true
Number.isFinite(25) // true
Number.isFinite(&quot;25&quot;) // false

isNaN(NaN) // true
isNaN(&quot;NaN&quot;) // true
Number.isNaN(NaN) // true
Number.isNaN(&quot;NaN&quot;) // false
Number.isNaN(1) // false
</code></pre><h3 id="3-Number-parseInt-Number-parseFloat"><a href="#3-Number-parseInt-Number-parseFloat" class="headerlink" title="3.Number.parseInt(), Number.parseFloat()"></a>3.Number.parseInt(), Number.parseFloat()</h3><p>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p>
<pre><code>// ES5的写法
parseInt(&#39;12.34&#39;) // 12
parseFloat(&#39;123.45#&#39;) // 123.45

// ES6的写法
Number.parseInt(&#39;12.34&#39;) // 12
Number.parseFloat(&#39;123.45#&#39;) // 123.45
</code></pre><p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p>
<pre><code>Number.parseInt === parseInt // true
Number.parseFloat === parseFloat // true
</code></pre><h3 id="4-Number-isInteger"><a href="#4-Number-isInteger" class="headerlink" title="4.Number.isInteger()"></a>4.Number.isInteger()</h3><p>Number.isInteger()用来判断一个数值是否为整数。</p>
<pre><code>Number.isInteger(25) // true
Number.isInteger(25.1) // false
</code></pre><p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</p>
<pre><code>Number.isInteger(25) // true
Number.isInteger(25.0) // true
</code></pre><p>如果参数不是数值，Number.isInteger返回false。</p>
<pre><code>Number.isInteger() // false
Number.isInteger(null) // false
Number.isInteger(&#39;15&#39;) // false
Number.isInteger(true) // false
</code></pre><p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。</p>
<pre><code>Number.isInteger(3.0000000000000002) // true
</code></pre><p>上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。</p>
<p>类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。</p>
<pre><code>Number.isInteger(5E-324) // false
Number.isInteger(5E-325) // true
</code></pre><p>上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。</p>
<p>总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。</p>
<h3 id="5-Number-EPSILON"><a href="#5-Number-EPSILON" class="headerlink" title="5.Number.EPSILON"></a>5.Number.EPSILON</h3><p>ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p>
<p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</p>
<pre><code>Number.EPSILON === Math.pow(2, -52)
// true
Number.EPSILON
// 2.220446049250313e-16
Number.EPSILON.toFixed(20)
// &quot;0.00000000000000022204&quot;
</code></pre><p>Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p>
<pre><code>0.1 + 0.2
// 0.30000000000000004

0.1 + 0.2 - 0.3
// 5.551115123125783e-17

5.551115123125783e-17.toFixed(20)
// &#39;0.00000000000000005551&#39;
</code></pre><p>上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。</p>
<pre><code>0.1 + 0.2 === 0.3 // false
</code></pre><p>Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p>
<pre><code>5.551115123125783e-17 &lt; Number.EPSILON * Math.pow(2, 2)
// true
</code></pre><p>因此，Number.EPSILON的实质是一个可以接受的最小误差范围。</p>
<pre><code>function withinErrorMargin (left, right) {
  return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(2, 2);
}

0.1 + 0.2 === 0.3 // false
withinErrorMargin(0.1 + 0.2, 0.3) // true

1.1 + 1.3 === 2.4 // false
withinErrorMargin(1.1 + 1.3, 2.4) // true
</code></pre><p>上面的代码为浮点数运算，部署了一个误差检查函数。</p>
<h3 id="6-安全整数和-Number-isSafeInteger"><a href="#6-安全整数和-Number-isSafeInteger" class="headerlink" title="6.安全整数和 Number.isSafeInteger()"></a>6.安全整数和 Number.isSafeInteger()</h3><p>JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<pre><code>Math.pow(2, 53) // 9007199254740992

9007199254740992  // 9007199254740992
9007199254740993  // 9007199254740992

Math.pow(2, 53) === Math.pow(2, 53) + 1
// true
</code></pre><p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p>
<p>ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</p>
<pre><code>Number.MAX_SAFE_INTEGER === Math.pow(2, 53) - 1
// true
Number.MAX_SAFE_INTEGER === 9007199254740991
// true

Number.MIN_SAFE_INTEGER === -Number.MAX_SAFE_INTEGER
// true
Number.MIN_SAFE_INTEGER === -9007199254740991
// true
</code></pre><p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p>
<p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p>
<pre><code>Number.isSafeInteger(&#39;a&#39;) // false
Number.isSafeInteger(null) // false
Number.isSafeInteger(NaN) // false
Number.isSafeInteger(Infinity) // false
Number.isSafeInteger(-Infinity) // false

Number.isSafeInteger(3) // true
Number.isSafeInteger(1.2) // false
Number.isSafeInteger(9007199254740990) // true
Number.isSafeInteger(9007199254740992) // false

Number.isSafeInteger(Number.MIN_SAFE_INTEGER - 1) // false
Number.isSafeInteger(Number.MIN_SAFE_INTEGER) // true
Number.isSafeInteger(Number.MAX_SAFE_INTEGER) // true
Number.isSafeInteger(Number.MAX_SAFE_INTEGER + 1) // false
</code></pre><p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p>
<pre><code>Number.isSafeInteger = function (n) {
  return (typeof n === &#39;number&#39; &amp;&amp;
    Math.round(n) === n &amp;&amp;
    Number.MIN_SAFE_INTEGER &lt;= n &amp;&amp;
    n &lt;= Number.MAX_SAFE_INTEGER);
}
</code></pre><p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</p>
<pre><code>Number.isSafeInteger(9007199254740993)
// false
Number.isSafeInteger(990)
// true
Number.isSafeInteger(9007199254740993 - 990)
// true
9007199254740993 - 990
// 返回结果 9007199254740002
// 正确答案应该是 9007199254740003
</code></pre><p>上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。</p>
<pre><code>9007199254740993 === 9007199254740992
// true
</code></pre><p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</p>
<pre><code>function trusty (left, right, result) {
  if (
    Number.isSafeInteger(left) &amp;&amp;
    Number.isSafeInteger(right) &amp;&amp;
    Number.isSafeInteger(result)
  ) {
    return result;
  }
  throw new RangeError(&#39;Operation cannot be trusted!&#39;);
}

trusty(9007199254740993, 990, 9007199254740993 - 990)
// RangeError: Operation cannot be trusted!

trusty(1, 2, 3)
// 3
</code></pre><h3 id="7-Math-对象的扩展"><a href="#7-Math-对象的扩展" class="headerlink" title="7.Math 对象的扩展"></a>7.Math 对象的扩展</h3><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p>
<h4 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h4><p>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</p>
<pre><code>Math.trunc(4.1) // 4
Math.trunc(4.9) // 4
Math.trunc(-4.1) // -4
Math.trunc(-4.9) // -4
Math.trunc(-0.1234) // -0
</code></pre><p>对于非数值，Math.trunc内部使用Number方法将其先转为数值。</p>
<pre><code>Math.trunc(&#39;123.456&#39;) // 123
Math.trunc(true) //1
Math.trunc(false) // 0
Math.trunc(null) // 0
</code></pre><p>对于空值和无法截取整数的值，返回NaN。</p>
<pre><code>Math.trunc(NaN);      // NaN
Math.trunc(&#39;foo&#39;);    // NaN
Math.trunc();         // NaN
Math.trunc(undefined) // NaN
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<pre><code>Math.trunc = Math.trunc || function(x) {
  return x &lt; 0 ? Math.ceil(x) : Math.floor(x);
};
</code></pre><h4 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h4><p>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为 0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
<pre><code>Math.sign(-5) // -1
Math.sign(5) // +1
Math.sign(0) // +0
Math.sign(-0) // -0
Math.sign(NaN) // NaN
</code></pre><p>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。</p>
<pre><code>Math.sign(&#39;&#39;)  // 0
Math.sign(true)  // +1
Math.sign(false)  // 0
Math.sign(null)  // 0
Math.sign(&#39;9&#39;)  // +1
Math.sign(&#39;foo&#39;)  // NaN
Math.sign()  // NaN
Math.sign(undefined)  // NaN
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<pre><code>Math.sign = Math.sign || function(x) {
  x = +x; // convert to a number
  if (x === 0 || isNaN(x)) {
    return x;
  }
  return x &gt; 0 ? 1 : -1;
};
</code></pre><h4 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h4><p>Math.cbrt方法用于计算一个数的立方根。</p>
<pre><code>Math.cbrt(-1) // -1
Math.cbrt(0)  // 0
Math.cbrt(1)  // 1
Math.cbrt(2)  // 1.2599210498948734
</code></pre><p>对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。</p>
<pre><code>Math.cbrt(&#39;8&#39;) // 2
Math.cbrt(&#39;hello&#39;) // NaN
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<pre><code>Math.cbrt = Math.cbrt || function(x) {
  var y = Math.pow(Math.abs(x), 1/3);
  return x &lt; 0 ? -y : y;
};
</code></pre><h4 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h4><p>JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0。</p>
<pre><code>Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1000) // 22
Math.clz32(0b01000000000000000000000000000000) // 1
Math.clz32(0b00100000000000000000000000000000) // 2
</code></pre><p>上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。</p>
<p>clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。</p>
<p>左移运算符（&lt;&lt;）与Math.clz32方法直接相关。</p>
<pre><code>Math.clz32(0) // 32
Math.clz32(1) // 31
Math.clz32(1 &lt;&lt; 1) // 30
Math.clz32(1 &lt;&lt; 2) // 29
Math.clz32(1 &lt;&lt; 29) // 2
</code></pre><p>对于小数，Math.clz32方法只考虑整数部分。</p>
<pre><code>Math.clz32(3.2) // 30
Math.clz32(3.9) // 30
</code></pre><p>对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。</p>
<pre><code>Math.clz32() // 32
Math.clz32(NaN) // 32
Math.clz32(Infinity) // 32
Math.clz32(null) // 32
Math.clz32(&#39;foo&#39;) // 32
Math.clz32([]) // 32
Math.clz32({}) // 32
Math.clz32(true) // 31
</code></pre><h4 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h4><p>Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>
<pre><code>Math.imul(2, 4)   // 8
Math.imul(-1, 8)  // -8
Math.imul(-2, -2) // 4
</code></pre><p>如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a <em> b的结果是相同的，即该方法等同于(a </em> b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。</p>
<pre><code>(0x7fffffff * 0x7fffffff)|0 // 0
</code></pre><p>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。</p>
<pre><code>Math.imul(0x7fffffff, 0x7fffffff) // 1
</code></pre><h4 id="Math-fround"><a href="#Math-fround" class="headerlink" title="Math.fround()"></a>Math.fround()</h4><p>Math.fround方法返回一个数的32位单精度浮点数形式。</p>
<p>对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。</p>
<pre><code>Math.fround(0)   // 0
Math.fround(1)   // 1
Math.fround(2 ** 24 - 1)   // 16777215
</code></pre><p>如果参数的绝对值大于 224，返回的结果便开始丢失精度。</p>
<pre><code>Math.fround(2 ** 24)       // 16777216
Math.fround(2 ** 24 + 1)   // 16777216
</code></pre><p>Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</p>
<pre><code>// 未丢失有效精度
Math.fround(1.125) // 1.125
Math.fround(7.25)  // 7.25

// 丢失精度
Math.fround(0.3)   // 0.30000001192092896
Math.fround(0.7)   // 0.699999988079071
Math.fround(1.0000000123) // 1
</code></pre><p>对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。</p>
<pre><code>Math.fround(NaN)      // NaN
Math.fround(Infinity) // Infinity

Math.fround(&#39;5&#39;)      // 5
Math.fround(true)     // 1
Math.fround(null)     // 0
Math.fround([])       // 0
Math.fround({})       // NaN
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<pre><code>Math.fround = Math.fround || function (x) {
  return new Float32Array([x])[0];
};
</code></pre><h4 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h4><p>Math.hypot方法返回所有参数的平方和的平方根。</p>
<pre><code>Math.hypot(3, 4);        // 5
Math.hypot(3, 4, 5);     // 7.0710678118654755
Math.hypot();            // 0
Math.hypot(NaN);         // NaN
Math.hypot(3, 4, &#39;foo&#39;); // NaN
Math.hypot(3, 4, &#39;5&#39;);   // 7.0710678118654755
Math.hypot(-3);          // 3
</code></pre><p>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</p>
<p>如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</p>
<h4 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h4><p>ES6 新增了 4 个对数相关方法。</p>
<p>（1） Math.expm1()</p>
<p>Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。</p>
<pre><code>Math.expm1(-1) // -0.6321205588285577
Math.expm1(0)  // 0
Math.expm1(1)  // 1.718281828459045
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<pre><code>Math.expm1 = Math.expm1 || function(x) {
  return Math.exp(x) - 1;
};
</code></pre><p>（2）Math.log1p()</p>
<p>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</p>
<pre><code>Math.log1p(1)  // 0.6931471805599453
Math.log1p(0)  // 0
Math.log1p(-1) // -Infinity
Math.log1p(-2) // NaN
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<pre><code>Math.log1p = Math.log1p || function(x) {
  return Math.log(1 + x);
};
</code></pre><p>（3）Math.log10()</p>
<p>Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。</p>
<pre><code>Math.log10(2)      // 0.3010299956639812
Math.log10(1)      // 0
Math.log10(0)      // -Infinity
Math.log10(-2)     // NaN
Math.log10(100000) // 5
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<pre><code>Math.log10 = Math.log10 || function(x) {
  return Math.log(x) / Math.LN10;
};
</code></pre><p>（4）Math.log2()</p>
<p>Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。</p>
<pre><code>Math.log2(3)       // 1.584962500721156
Math.log2(2)       // 1
Math.log2(1)       // 0
Math.log2(0)       // -Infinity
Math.log2(-2)      // NaN
Math.log2(1024)    // 10
Math.log2(1 &lt;&lt; 29) // 29
</code></pre><p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<pre><code>Math.log2 = Math.log2 || function(x) {
  return Math.log(x) / Math.LN2;
};
</code></pre><h4 id="双曲函数方法"><a href="#双曲函数方法" class="headerlink" title="双曲函数方法"></a>双曲函数方法</h4><p>ES6 新增了 6 个双曲函数方法。</p>
<ul>
<li>Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）</li>
<li>Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）</li>
<li>Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）</li>
<li>Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）</li>
<li>Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）</li>
<li>Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
<h3 id="8-指数运算符"><a href="#8-指数运算符" class="headerlink" title="8.指数运算符"></a>8.指数运算符</h3><p>ES2016 新增了一个指数运算符（**）。</p>
<pre><code>2 ** 2 // 4
2 ** 3 // 8
</code></pre><p>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。</p>
<pre><code>let a = 1.5;
a **= 2;
// 等同于 a = a * a;

let b = 4;
b **= 3;
// 等同于 b = b * b * b;
</code></pre><p>注意，在 V8 引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。</p>
<pre><code>Math.pow(99, 99)
// 3.697296376497263e+197

99 ** 99
// 3.697296376497268e+197
</code></pre><p>上面代码中，两个运算结果的最后一位有效数字是有差异的。</p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 05.正则的扩展]]></title>
      <url>/2018/06/12/ES6/05.%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h2><h3 id="1-RegExp-构造函数"><a href="#1-RegExp-构造函数" class="headerlink" title="1.RegExp 构造函数"></a>1.RegExp 构造函数</h3><p>在 ES5 中，RegExp构造函数的参数有两种情况。</p>
<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>
<pre><code>var regex = new RegExp(&#39;xyz&#39;, &#39;i&#39;);
// 等价于
var regex = /xyz/i;
</code></pre><p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p>
<pre><code>var regex = new RegExp(/xyz/i);
// 等价于
var regex = /xyz/i;
</code></pre><p>但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</p>
<pre><code>var regex = new RegExp(/xyz/, &#39;i&#39;);
// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another
</code></pre><p>ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<pre><code>new RegExp(/abc/ig, &#39;i&#39;).flags
// &quot;i&quot;
</code></pre><p>上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。</p>
<h3 id="2-字符串的正则方法"><a href="#2-字符串的正则方法" class="headerlink" title="2.字符串的正则方法"></a>2.字符串的正则方法</h3><p>字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。</p>
<p>ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>
<ul>
<li>String.prototype.match 调用 RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search 调用 RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split 调用 RegExp.prototype[Symbol.split]</li>
</ul>
<h3 id="3-u-修饰符"><a href="#3-u-修饰符" class="headerlink" title="3.u 修饰符"></a>3.u 修饰符</h3><p>ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p>
<pre><code>/^\uD83D/u.test(&#39;\uD83D\uDC2A&#39;) // false
/^\uD83D/.test(&#39;\uD83D\uDC2A&#39;) // true
</code></pre><p>上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。</p>
<p>一旦加上u修饰符号，就会修改下面这些正则表达式的行为。</p>
<p>（1）点字符</p>
<p>点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。</p>
<pre><code>var s = &#39;𠮷&#39;;

/^.$/.test(s) // false
/^.$/u.test(s) // true
</code></pre><p>上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p>
<p>（2）Unicode 字符表示法</p>
<p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。</p>
<pre><code>/\u{61}/.test(&#39;a&#39;) // false
/\u{61}/u.test(&#39;a&#39;) // true
/\u{20BB7}/u.test(&#39;𠮷&#39;) // true
</code></pre><p>上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的u。</p>
<p>（3）量词</p>
<p>使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。</p>
<pre><code>/a{2}/.test(&#39;aa&#39;) // true
/a{2}/u.test(&#39;aa&#39;) // true
/𠮷{2}/.test(&#39;𠮷𠮷&#39;) // false
/𠮷{2}/u.test(&#39;𠮷𠮷&#39;) // true
</code></pre><p>（4）预定义模式</p>
<p>u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。</p>
<pre><code>/^\S$/.test(&#39;𠮷&#39;) // false
/^\S$/u.test(&#39;𠮷&#39;) // true
</code></pre><p>上面代码的\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。</p>
<p>利用这一点，可以写出一个正确返回字符串长度的函数。</p>
<pre><code>function codePointLength(text) {
  var result = text.match(/[\s\S]/gu);
  return result ? result.length : 0;
}

var s = &#39;𠮷𠮷&#39;;

s.length // 4
codePointLength(s) // 2
</code></pre><p>（5）i 修饰符</p>
<p>有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。</p>
<pre><code>/[a-z]/i.test(&#39;\u212A&#39;) // false
/[a-z]/iu.test(&#39;\u212A&#39;) // true
</code></pre><p>上面代码中，不加u修饰符，就无法识别非规范的K字符。</p>
<h3 id="4-RegExp-prototype-unicode-属性"><a href="#4-RegExp-prototype-unicode-属性" class="headerlink" title="4.RegExp.prototype.unicode 属性"></a>4.RegExp.prototype.unicode 属性</h3><p>正则实例对象新增unicode属性，表示是否设置了u修饰符。</p>
<pre><code>const r1 = /hello/;
const r2 = /hello/u;

r1.unicode // false
r2.unicode // true
</code></pre><p>上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。</p>
<h3 id="5-y-修饰符"><a href="#5-y-修饰符" class="headerlink" title="5.y 修饰符"></a>5.y 修饰符</h3><p>除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。</p>
<p>y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<pre><code>var s = &#39;aaa_aa_a&#39;;
var r1 = /a+/g;
var r2 = /a+/y;

r1.exec(s) // [&quot;aaa&quot;]
r2.exec(s) // [&quot;aaa&quot;]

r1.exec(s) // [&quot;aa&quot;]
r2.exec(s) // null
</code></pre><p>上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。</p>
<p>如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。</p>
<pre><code>var s = &#39;aaa_aa_a&#39;;
var r = /a+_/y;

r.exec(s) // [&quot;aaa_&quot;]
r.exec(s) // [&quot;aa_&quot;]
</code></pre><p>上面代码每次匹配，都是从剩余字符串的头部开始。</p>
<p>使用lastIndex属性，可以更好地说明y修饰符。</p>
<pre><code>const REGEX = /a/g;

// 指定从2号位置（y）开始匹配
REGEX.lastIndex = 2;

// 匹配成功
const match = REGEX.exec(&#39;xaya&#39;);

// 在3号位置匹配成功
match.index // 3

// 下一次匹配从4号位开始
REGEX.lastIndex // 4

// 4号位开始匹配失败
REGEX.exec(&#39;xaya&#39;) // null
</code></pre><p>上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。</p>
<p>y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。</p>
<pre><code>const REGEX = /a/y;

// 指定从2号位置开始匹配
REGEX.lastIndex = 2;

// 不是粘连，匹配失败
REGEX.exec(&#39;xaya&#39;) // null

// 指定从3号位置开始匹配
REGEX.lastIndex = 3;

// 3号位置是粘连，匹配成功
const match = REGEX.exec(&#39;xaya&#39;);
match.index // 3
REGEX.lastIndex // 4
</code></pre><p>实际上，y修饰符号隐含了头部匹配的标志^。</p>
<pre><code>/b/y.exec(&#39;aba&#39;)
// null
</code></pre><p>上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。</p>
<p>下面是字符串对象的replace方法的例子。</p>
<pre><code>const REGEX = /a/gy;
&#39;aaxa&#39;.replace(REGEX, &#39;-&#39;) // &#39;--xa&#39;
</code></pre><p>上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。</p>
<p>单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。</p>
<pre><code>&#39;a1a2a3&#39;.match(/a\d/y) // [&quot;a1&quot;]
&#39;a1a2a3&#39;.match(/a\d/gy) // [&quot;a1&quot;, &quot;a2&quot;, &quot;a3&quot;]
</code></pre><p>y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。</p>
<pre><code>const TOKEN_Y = /\s*(\+|[0-9]+)\s*/y;
const TOKEN_G  = /\s*(\+|[0-9]+)\s*/g;

tokenize(TOKEN_Y, &#39;3 + 4&#39;)
// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]
tokenize(TOKEN_G, &#39;3 + 4&#39;)
// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]

function tokenize(TOKEN_REGEX, str) {
  let result = [];
  let match;
  while (match = TOKEN_REGEX.exec(str)) {
    result.push(match[1]);
  }
  return result;
}
</code></pre><p>上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p>
<pre><code>tokenize(TOKEN_Y, &#39;3x + 4&#39;)
// [ &#39;3&#39; ]
tokenize(TOKEN_G, &#39;3x + 4&#39;)
// [ &#39;3&#39;, &#39;+&#39;, &#39;4&#39; ]
</code></pre><p>上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。</p>
<h3 id="6-RegExp-prototype-sticky-属性"><a href="#6-RegExp-prototype-sticky-属性" class="headerlink" title="6.RegExp.prototype.sticky 属性"></a>6.RegExp.prototype.sticky 属性</h3><p>与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。</p>
<pre><code>var r = /hello\d/y;
r.sticky // true
</code></pre><h3 id="7-RegExp-prototype-flags-属性"><a href="#7-RegExp-prototype-flags-属性" class="headerlink" title="7.RegExp.prototype.flags 属性"></a>7.RegExp.prototype.flags 属性</h3><p>ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。</p>
<pre><code>// ES5 的 source 属性
// 返回正则表达式的正文
/abc/ig.source
// &quot;abc&quot;

// ES6 的 flags 属性
// 返回正则表达式的修饰符
/abc/ig.flags
// &#39;gi&#39;
</code></pre><h3 id="8-s-修饰符：dotAll-模式"><a href="#8-s-修饰符：dotAll-模式" class="headerlink" title="8.s 修饰符：dotAll 模式"></a>8.s 修饰符：dotAll 模式</h3><p>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。</p>
<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于”行终止符“。</p>
<ul>
<li>U+000A 换行符（\n）</li>
<li>U+000D 回车符（\r）</li>
<li>U+2028 行分隔符（line separator）</li>
<li>U+2029 段分隔符（paragraph separator）</li>
</ul>
<pre><code>/foo.bar/.test(&#39;foo\nbar&#39;)
// false
</code></pre><p>上面代码中，因为.不匹配\n，所以正则表达式返回false。</p>
<p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p>
<pre><code>/foo[^]bar/.test(&#39;foo\nbar&#39;)
// true
</code></pre><p>这种解决方案毕竟不太符合直觉，ES2018 <a href="https://github.com/tc39/proposal-regexp-dotall-flag" target="_blank" rel="noopener">引入</a>s修饰符，使得.可以匹配任意单个字符。</p>
<pre><code>/foo.bar/s.test(&#39;foo\nbar&#39;) // true
</code></pre><p>这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。</p>
<pre><code>const re = /foo.bar/s;
// 另一种写法
// const re = new RegExp(&#39;foo.bar&#39;, &#39;s&#39;);

re.test(&#39;foo\nbar&#39;) // true
re.dotAll // true
re.flags // &#39;s&#39;
</code></pre><p>/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。</p>
<h3 id="9-后行断言"><a href="#9-后行断言" class="headerlink" title="9.后行断言"></a>9.后行断言</h3><p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入<a href="https://github.com/tc39/proposal-regexp-lookbehind" target="_blank" rel="noopener">后行断言</a>，V8 引擎 4.9 版（Chrome 62）已经支持。</p>
<p>”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。</p>
<pre><code>/\d+(?=%)/.exec(&#39;100% of US presidents have been male&#39;)  // [&quot;100&quot;]
/\d+(?!%)/.exec(&#39;that’s all 44 of them&#39;)                 // [&quot;44&quot;]
</code></pre><p>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，”先行断言“括号之中的部分（(?=%)），是不计入返回结果的。</p>
<p>“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。</p>
<pre><code>/(?=\$)\d+/.exec(&#39;Benjamin Franklin is on the $100 bill&#39;)  // [&quot;100&quot;]
/(?&lt;!\$)\d+/.exec(&#39;it’s is worth about €90&#39;)                // [&quot;90&quot;]
</code></pre><p>上面的例子中，“后行断言”的括号之中的部分（(?&lt;=\$)），也是不计入返回结果。</p>
<p>下面的例子是使用后行断言进行字符串替换。</p>
<pre><code>const RE_DOLLAR_PREFIX = /(?&lt;=\$)foo/g;
&#39;$foo %foo foo&#39;.replace(RE_DOLLAR_PREFIX, &#39;bar&#39;);
// &#39;$bar %foo foo&#39;
</code></pre><p>上面代码中，只有在美元符号后面的foo才会被替换。</p>
<p>“后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p>
<p>首先，后行断言的组匹配，与正常情况下结果是不一样的。</p>
<pre><code>/(?&lt;=(\d+)(\d+))$/.exec(&#39;1053&#39;) // [&quot;&quot;, &quot;1&quot;, &quot;053&quot;]
/^(\d+)(\d+)$/.exec(&#39;1053&#39;) // [&quot;1053&quot;, &quot;105&quot;, &quot;3&quot;]
</code></pre><p>上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。</p>
<p>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</p>
<pre><code>/(?&lt;=(o)d\1)r/.exec(&#39;hodor&#39;)  // null
/(?&lt;=\1d(o))r/.exec(&#39;hodor&#39;)  // [&quot;r&quot;, &quot;o&quot;]
</code></pre><p>上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</p>
<h3 id="10-Unicode-属性类"><a href="#10-Unicode-属性类" class="headerlink" title="10.Unicode 属性类"></a>10.Unicode 属性类</h3><p>ES2018 引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p>
<pre><code>const regexGreekSymbol = /\p{Script=Greek}/u;
regexGreekSymbol.test(&#39;π&#39;) // true
</code></pre><p>上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。</p>
<p>Unicode 属性类要指定属性名和属性值。</p>
<pre><code>\p{UnicodePropertyName=UnicodePropertyValue}
</code></pre><p>对于某些属性，可以只写属性名，或者只写属性值。</p>
<pre><code>\p{UnicodePropertyName}
\p{UnicodePropertyValue}
</code></pre><p>\P{…}是\p{…}的反向匹配，即匹配不满足条件的字符。</p>
<p>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\p和\P会报错，ECMAScript 预留了这两个类。</p>
<p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p>
<pre><code>const regex = /^\p{Decimal_Number}+$/u;
regex.test(&#39;𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼&#39;) // true
</code></pre><p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p>
<p>\p{Number}甚至能匹配罗马数字。</p>
<pre><code>// 匹配所有数字
const regex = /^\p{Number}+$/u;
regex.test(&#39;²³¹¼½¾&#39;) // true
regex.test(&#39;㉛㉜㉝&#39;) // true
regex.test(&#39;ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ&#39;) // true
</code></pre><p>下面是其他一些例子。</p>
<pre><code>// 匹配所有空格
\p{White_Space}

// 匹配各种文字的所有字母，等同于 Unicode 版的 \w
[\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]

// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 \W
[^\p{Alphabetic}\p{Mark}\p{Decimal_Number}\p{Connector_Punctuation}\p{Join_Control}]

// 匹配 Emoji
/\p{Emoji_Modifier_Base}\p{Emoji_Modifier}?|\p{Emoji_Presentation}|\p{Emoji}\uFE0F/gu

// 匹配所有的箭头字符
const regexArrows = /^\p{Block=Arrows}+$/u;
regexArrows.test(&#39;←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩&#39;) // true
</code></pre><h3 id="11-具名组匹配"><a href="#11-具名组匹配" class="headerlink" title="11.具名组匹配"></a>11.具名组匹配</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>正则表达式使用圆括号进行组匹配。</p>
<pre><code>const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;
</code></pre><p>上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。</p>
<pre><code>const RE_DATE = /(\d{4})-(\d{2})-(\d{2})/;

const matchObj = RE_DATE.exec(&#39;1999-12-31&#39;);
const year = matchObj[1]; // 1999
const month = matchObj[2]; // 12
const day = matchObj[3]; // 31
</code></pre><p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。</p>
<p>ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>
<pre><code>const RE_DATE = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/;

const matchObj = RE_DATE.exec(&#39;1999-12-31&#39;);
const year = matchObj.groups.year; // 1999
const month = matchObj.groups.month; // 12
const day = matchObj.groups.day; // 31
</code></pre><p>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?<year>），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。</year></p>
<p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p>
<p>如果具名组没有匹配，那么对应的groups对象属性会是undefined。</p>
<pre><code>const RE_OPT_A = /^(?&lt;as&gt;a+)?$/;
const matchObj = RE_OPT_A.exec(&#39;&#39;);

matchObj.groups.as // undefined
&#39;as&#39; in matchObj.groups // true
</code></pre><p>上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。</p>
<h4 id="解构赋值和替换"><a href="#解构赋值和替换" class="headerlink" title="解构赋值和替换"></a>解构赋值和替换</h4><p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p>
<pre><code>let {groups: {one, two}} = /^(?&lt;one&gt;.*):(?&lt;two&gt;.*)$/u.exec(&#39;foo:bar&#39;);
one  // foo
two  // bar
</code></pre><p>字符串替换时，使用$&lt;组名&gt;引用具名组。</p>
<pre><code>let re = /(?&lt;year&gt;\d{4})-(?&lt;month&gt;\d{2})-(?&lt;day&gt;\d{2})/u;

&#39;2015-01-02&#39;.replace(re, &#39;$&lt;day&gt;/$&lt;month&gt;/$&lt;year&gt;&#39;)
// &#39;02/01/2015&#39;
</code></pre><p>上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。</p>
<p>replace方法的第二个参数也可以是函数，该函数的参数序列如下。</p>
<pre><code>&#39;2015-01-02&#39;.replace(re, (
   matched, // 整个匹配结果 2015-01-02
   capture1, // 第一个组匹配 2015
   capture2, // 第二个组匹配 01
   capture3, // 第三个组匹配 02
   position, // 匹配开始的位置 0
   S, // 原字符串 2015-01-02
   groups // 具名组构成的一个对象 {year, month, day}
 ) =&gt; {
 let {day, month, year} = args[args.length - 1];
 return `${day}/${month}/${year}`;
});
</code></pre><p>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。</p>
<pre><code>const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;$/;
RE_TWICE.test(&#39;abc!abc&#39;) // true
RE_TWICE.test(&#39;abc!ab&#39;) // false
</code></pre><p>数字引用（\1）依然有效。</p>
<pre><code>const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\1$/;
RE_TWICE.test(&#39;abc!abc&#39;) // true
RE_TWICE.test(&#39;abc!ab&#39;) // false
</code></pre><p>这两种引用语法还可以同时使用。</p>
<pre><code>const RE_TWICE = /^(?&lt;word&gt;[a-z]+)!\k&lt;word&gt;!\1$/;
RE_TWICE.test(&#39;abc!abc!abc&#39;) // true
RE_TWICE.test(&#39;abc!abc!ab&#39;) // false
</code></pre><h3 id="12-String-prototype-matchAll"><a href="#12-String-prototype-matchAll" class="headerlink" title="12.String.prototype.matchAll"></a>12.String.prototype.matchAll</h3><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。</p>
<pre><code>var regex = /t(e)(st(\d?))/g;
var string = &#39;test1test2test3&#39;;

var matches = [];
var match;
while (match = regex.exec(string)) {
  matches.push(match);
}

matches
// [
//   [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;],
//   [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;],
//   [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]
// ]
</code></pre><p>上面代码中，while循环取出每一轮的正则匹配，一共三轮。</p>
<p>目前有一个提案，增加了String.prototype.matchAll方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</p>
<pre><code>const string = &#39;test1test2test3&#39;;

// g 修饰符加不加都可以
const regex = /t(e)(st(\d?))/g;

for (const match of string.matchAll(regex)) {
  console.log(match);
}
// [&quot;test1&quot;, &quot;e&quot;, &quot;st1&quot;, &quot;1&quot;, index: 0, input: &quot;test1test2test3&quot;]
// [&quot;test2&quot;, &quot;e&quot;, &quot;st2&quot;, &quot;2&quot;, index: 5, input: &quot;test1test2test3&quot;]
// [&quot;test3&quot;, &quot;e&quot;, &quot;st3&quot;, &quot;3&quot;, index: 10, input: &quot;test1test2test3&quot;]
</code></pre><p>上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p>
<p>遍历器转为数组是非常简单的，使用…运算符和Array.from方法就可以了。</p>
<pre><code>// 转为数组方法一
[...string.matchAll(regex)]

// 转为数组方法二
Array.from(string.matchAll(regex));
</code></pre>]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 04.字符串的扩展]]></title>
      <url>/2018/06/11/ES6/04.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><p>ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。</p>
<h3 id="1-字符的-Unicode-表示法"><a href="#1-字符的-Unicode-表示法" class="headerlink" title="1.字符的 Unicode 表示法"></a>1.字符的 Unicode 表示法</h3><p>JavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。</p>
<pre><code>&quot;\u0061&quot;
// &quot;a&quot;
</code></pre><p>但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>
<pre><code>&quot;\uD842\uDFB7&quot;
// &quot;𠮷&quot;

&quot;\u20BB7&quot;
// &quot; 7&quot;
</code></pre><p>上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<pre><code>&quot;\u{20BB7}&quot;
// &quot;𠮷&quot;

&quot;\u{41}\u{42}\u{43}&quot;
// &quot;ABC&quot;

let hello = 123;
hell\u{6F} // 123

&#39;\u{1F680}&#39; === &#39;\uD83D\uDE80&#39;
// true
</code></pre><p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p>
<p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p>
<pre><code>&#39;\z&#39; === &#39;z&#39;  // true
&#39;\172&#39; === &#39;z&#39; // true
&#39;\x7A&#39; === &#39;z&#39; // true
&#39;\u007A&#39; === &#39;z&#39; // true
&#39;\u{7A}&#39; === &#39;z&#39; // true
</code></pre><h3 id="2-codePointAt"><a href="#2-codePointAt" class="headerlink" title="2.codePointAt()"></a>2.codePointAt()</h3><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。</p>
<pre><code>var s = &quot;𠮷&quot;;

s.length // 2
s.charAt(0) // &#39;&#39;
s.charAt(1) // &#39;&#39;
s.charCodeAt(0) // 55362
s.charCodeAt(1) // 57271
</code></pre><p>上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>
<pre><code>let s = &#39;𠮷a&#39;;

s.codePointAt(0) // 134071
s.codePointAt(1) // 57271

s.codePointAt(2) // 97
</code></pre><p>codePointAt方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。</p>
<p>总之，codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。</p>
<p>codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。</p>
<pre><code>let s = &#39;𠮷a&#39;;

s.codePointAt(0).toString(16) // &quot;20bb7&quot;
s.codePointAt(2).toString(16) // &quot;61&quot;
</code></pre><p>你可能注意到了，codePointAt方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt方法传入 2。解决这个问题的一个办法是使用for…of循环，因为它会正确识别 32 位的 UTF-16 字符。</p>
<pre><code>let s = &#39;𠮷a&#39;;
for (let ch of s) {
  console.log(ch.codePointAt(0).toString(16));
}
// 20bb7
// 61
</code></pre><p>codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>
<pre><code>function is32Bit(c) {
  return c.codePointAt(0) &gt; 0xFFFF;
}

is32Bit(&quot;𠮷&quot;) // true
is32Bit(&quot;a&quot;) // false
</code></pre><h3 id="3-String-fromCodePoint"><a href="#3-String-fromCodePoint" class="headerlink" title="3.String.fromCodePoint()"></a>3.String.fromCodePoint()</h3><p>ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。</p>
<pre><code>String.fromCharCode(0x20BB7)
// &quot;ஷ&quot;
</code></pre><p>上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。</p>
<p>ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</p>
<pre><code>String.fromCodePoint(0x20BB7)
// &quot;𠮷&quot;
String.fromCodePoint(0x78, 0x1f680, 0x79) === &#39;x\uD83D\uDE80y&#39;
// true
</code></pre><p>上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</p>
<h3 id="4-字符串的遍历器接口"><a href="#4-字符串的遍历器接口" class="headerlink" title="4.字符串的遍历器接口"></a>4.字符串的遍历器接口</h3><p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for…of循环遍历。</p>
<pre><code>for (let codePoint of &#39;foo&#39;) {
  console.log(codePoint)
}
// &quot;f&quot;
// &quot;o&quot;
// &quot;o&quot;
</code></pre><p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p>
<pre><code>let text = String.fromCodePoint(0x20BB7);

for (let i = 0; i &lt; text.length; i++) {
  console.log(text[i]);
}
// &quot; &quot;
// &quot; &quot;

for (let i of text) {
  console.log(i);
}
// &quot;𠮷&quot;
</code></pre><p>上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for…of循环会正确识别出这一个字符。</p>
<h3 id="5-at"><a href="#5-at" class="headerlink" title="5.at()"></a>5.at()</h3><p>ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。</p>
<pre><code>&#39;abc&#39;.charAt(0) // &quot;a&quot;
&#39;𠮷&#39;.charAt(0) // &quot;\uD842&quot;
</code></pre><p>上面代码中的第二条语句，charAt方法期望返回的是用2个字节表示的字符，但汉字“𠮷”占用了4个字节，charAt(0)表示获取这4个字节中的前2个字节，很显然，这是无法正常显示的。</p>
<p>目前，有一个提案，提出字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符。</p>
<pre><code>&#39;abc&#39;.at(0) // &quot;a&quot;
&#39;𠮷&#39;.at(0) // &quot;𠮷&quot;
</code></pre><p>这个方法可以通过<a href="https://github.com/es-shims/String.prototype.at" target="_blank" rel="noopener">垫片库</a>实现。</p>
<h3 id="6-normalize"><a href="#6-normalize" class="headerlink" title="6.normalize()"></a>6.normalize()</h3><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p>
<pre><code>&#39;\u01D1&#39;===&#39;\u004F\u030C&#39; //false

&#39;\u01D1&#39;.length // 1
&#39;\u004F\u030C&#39;.length // 2
</code></pre><p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</p>
<p>ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p>
<pre><code>&#39;\u01D1&#39;.normalize() === &#39;\u004F\u030C&#39;.normalize()
// true
</code></pre><p>normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。</p>
<ul>
<li>NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li>
<li>NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li>
<li>NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）</li>
<li>NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li>
</ul>
<pre><code>&#39;\u004F\u030C&#39;.normalize(&#39;NFC&#39;).length // 1
&#39;\u004F\u030C&#39;.normalize(&#39;NFD&#39;).length // 2
</code></pre><p>上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。</p>
<p>不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</p>
<h3 id="7-includes-startsWith-endsWith"><a href="#7-includes-startsWith-endsWith" class="headerlink" title="7.includes(), startsWith(), endsWith()"></a>7.includes(), startsWith(), endsWith()</h3><p>传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<pre><code>let s = &#39;Hello world!&#39;;

s.startsWith(&#39;Hello&#39;) // true
s.endsWith(&#39;!&#39;) // true
s.includes(&#39;o&#39;) // true
</code></pre><p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<pre><code>let s = &#39;Hello world!&#39;;

s.startsWith(&#39;world&#39;, 6) // true
s.endsWith(&#39;Hello&#39;, 5) // true
s.includes(&#39;Hello&#39;, 6) // false
</code></pre><p>上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p>
<h3 id="8-repeat"><a href="#8-repeat" class="headerlink" title="8.repeat()"></a>8.repeat()</h3><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<pre><code>&#39;x&#39;.repeat(3) // &quot;xxx&quot;
&#39;hello&#39;.repeat(2) // &quot;hellohello&quot;
&#39;na&#39;.repeat(0) // &quot;&quot;
</code></pre><p>参数如果是小数，会被取整。</p>
<p>如果repeat的参数是负数或者Infinity，会报错。</p>
<pre><code>&#39;na&#39;.repeat(Infinity)
// RangeError
&#39;na&#39;.repeat(-1)
// RangeError
</code></pre><p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</p>
<pre><code>&#39;na&#39;.repeat(-0.9) // &quot;&quot;
</code></pre><p>参数NaN等同于 0。</p>
<pre><code>&#39;na&#39;.repeat(NaN) // &quot;&quot;
</code></pre><p>如果repeat的参数是字符串，则会先转换成数字。</p>
<pre><code>&#39;na&#39;.repeat(&#39;na&#39;) // &quot;&quot;
&#39;na&#39;.repeat(&#39;3&#39;) // &quot;nanana&quot;
</code></pre><h3 id="9-padStart-，padEnd"><a href="#9-padStart-，padEnd" class="headerlink" title="9.padStart()，padEnd()"></a>9.padStart()，padEnd()</h3><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<pre><code>&#39;x&#39;.padStart(5, &#39;ab&#39;) // &#39;ababx&#39;
&#39;x&#39;.padStart(4, &#39;ab&#39;) // &#39;abax&#39;

&#39;x&#39;.padEnd(5, &#39;ab&#39;) // &#39;xabab&#39;
&#39;x&#39;.padEnd(4, &#39;ab&#39;) // &#39;xaba&#39;
</code></pre><p>上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>
<pre><code>&#39;xxx&#39;.padStart(2, &#39;ab&#39;) // &#39;xxx&#39;
&#39;xxx&#39;.padEnd(2, &#39;ab&#39;) // &#39;xxx&#39;
</code></pre><p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p>
<pre><code>&#39;abc&#39;.padStart(10, &#39;0123456789&#39;)
// &#39;0123456abc&#39;
</code></pre><p>如果省略第二个参数，默认使用空格补全长度。</p>
<pre><code>&#39;x&#39;.padStart(4) // &#39;   x&#39;
&#39;x&#39;.padEnd(4) // &#39;x   &#39;
</code></pre><p>padStart的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p>
<pre><code>&#39;1&#39;.padStart(10, &#39;0&#39;) // &quot;0000000001&quot;
&#39;12&#39;.padStart(10, &#39;0&#39;) // &quot;0000000012&quot;
&#39;123456&#39;.padStart(10, &#39;0&#39;) // &quot;0000123456&quot;
</code></pre><p>另一个用途是提示字符串格式。</p>
<pre><code>&#39;12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-MM-12&quot;
&#39;09-12&#39;.padStart(10, &#39;YYYY-MM-DD&#39;) // &quot;YYYY-09-12&quot;
</code></pre><h3 id="10-matchAll"><a href="#10-matchAll" class="headerlink" title="10.matchAll()"></a>10.matchAll()</h3><p>matchAll方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p>
<h3 id="11-模板字符串"><a href="#11-模板字符串" class="headerlink" title="11.模板字符串"></a>11.模板字符串</h3><p>传统的 JavaScript 语言，输出模板通常是这样写的。</p>
<pre><code>$(&#39;#result&#39;).append(
  &#39;There are &lt;b&gt;&#39; + basket.count + &#39;&lt;/b&gt; &#39; +
  &#39;items in your basket, &#39; +
  &#39;&lt;em&gt;&#39; + basket.onSale +
  &#39;&lt;/em&gt; are on sale!&#39;
);
</code></pre><p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p>
<pre><code>$(&#39;#result&#39;).append(`
  There are &lt;b&gt;${basket.count}&lt;/b&gt; items
   in your basket, &lt;em&gt;${basket.onSale}&lt;/em&gt;
  are on sale!
`);
</code></pre><p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<pre><code>// 普通字符串
`In JavaScript &#39;\n&#39; is a line-feed.`

// 多行字符串
`In JavaScript this is
 not legal.`

console.log(`string text line 1
string text line 2`);

// 字符串中嵌入变量
let name = &quot;Bob&quot;, time = &quot;today&quot;;
`Hello ${name}, how are you ${time}?`
</code></pre><p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<pre><code>let greeting = `\`Yo\` World!`;
</code></pre><p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
<pre><code>$(&#39;#list&#39;).html(`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`);
</code></pre><p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。</ul></p>
<pre><code>$(&#39;#list&#39;).html(`
&lt;ul&gt;
  &lt;li&gt;first&lt;/li&gt;
  &lt;li&gt;second&lt;/li&gt;
&lt;/ul&gt;
`.trim());
</code></pre><p>模板字符串中嵌入变量，需要将变量名写在${}之中。</p>
<pre><code>function authorize(user, action) {
  if (!user.hasPrivilege(action)) {
    throw new Error(
      // 传统写法为
      // &#39;User &#39;
      // + user.name
      // + &#39; is not authorized to do &#39;
      // + action
      // + &#39;.&#39;
      `User ${user.name} is not authorized to do ${action}.`);
  }
}
</code></pre><p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p>
<pre><code>let x = 1;
let y = 2;

`${x} + ${y} = ${x + y}`
// &quot;1 + 2 = 3&quot;

`${x} + ${y * 2} = ${x + y * 2}`
// &quot;1 + 4 = 5&quot;

let obj = {x: 1, y: 2};
`${obj.x + obj.y}`
// &quot;3&quot;
</code></pre><p>模板字符串之中还能调用函数。</p>
<pre><code>function fn() {
  return &quot;Hello World&quot;;
}

`foo ${fn()} bar`
// foo Hello World bar
</code></pre><p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。</p>
<pre><code>// 变量place没有声明
let msg = `Hello, ${place}`;
// 报错
</code></pre><p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。</p>
<pre><code>`Hello ${&#39;World&#39;}`
// &quot;Hello World&quot;
</code></pre><p>模板字符串甚至还能嵌套。</p>
<pre><code>const tmpl = addrs =&gt; `
  &lt;table&gt;
  ${addrs.map(addr =&gt; `
    &lt;tr&gt;&lt;td&gt;${addr.first}&lt;/td&gt;&lt;/tr&gt;
    &lt;tr&gt;&lt;td&gt;${addr.last}&lt;/td&gt;&lt;/tr&gt;
  `).join(&#39;&#39;)}
  &lt;/table&gt;
`;
</code></pre><p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p>
<pre><code>const data = [
    { first: &#39;&lt;Jane&gt;&#39;, last: &#39;Bond&#39; },
    { first: &#39;Lars&#39;, last: &#39;&lt;Croft&gt;&#39; },
];

console.log(tmpl(data));
// &lt;table&gt;
//
//   &lt;tr&gt;&lt;td&gt;&lt;Jane&gt;&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;Bond&lt;/td&gt;&lt;/tr&gt;
//
//   &lt;tr&gt;&lt;td&gt;Lars&lt;/td&gt;&lt;/tr&gt;
//   &lt;tr&gt;&lt;td&gt;&lt;Croft&gt;&lt;/td&gt;&lt;/tr&gt;
//
// &lt;/table&gt;
</code></pre><p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</p>
<pre><code>// 写法一
let str = &#39;return &#39; + &#39;`Hello ${name}!`&#39;;
let func = new Function(&#39;name&#39;, str);
func(&#39;Jack&#39;) // &quot;Hello Jack!&quot;

// 写法二
let str = &#39;(name) =&gt; `Hello ${name}!`&#39;;
let func = eval.call(null, str);
func(&#39;Jack&#39;) // &quot;Hello Jack!&quot;
</code></pre><h3 id="12-实例：模板编译"><a href="#12-实例：模板编译" class="headerlink" title="12.实例：模板编译"></a>12.实例：模板编译</h3><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p>
<pre><code>let template = `
&lt;ul&gt;
  &lt;% for(let i=0; i &lt; data.supplies.length; i++) { %&gt;
    &lt;li&gt;&lt;%= data.supplies[i] %&gt;&lt;/li&gt;
  &lt;% } %&gt;
&lt;/ul&gt;
`;
</code></pre><p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置 JavaScript 代码，使用&lt;%= … %&gt;输出 JavaScript 表达式。</p>
<p>怎么编译这个模板字符串呢？</p>
<p>一种思路是将其转换为 JavaScript 表达式字符串。</p>
<pre><code>echo(&#39;&lt;ul&gt;&#39;);
for(let i=0; i &lt; data.supplies.length; i++) {
  echo(&#39;&lt;li&gt;&#39;);
  echo(data.supplies[i]);
  echo(&#39;&lt;/li&gt;&#39;);
};
echo(&#39;&lt;/ul&gt;&#39;);
</code></pre><p>这个转换使用正则表达式就行了。</p>
<pre><code>let evalExpr = /&lt;%=(.+?)%&gt;/g;
let expr = /&lt;%([\s\S]+?)%&gt;/g;

template = template
  .replace(evalExpr, &#39;`); \n  echo( $1 ); \n  echo(`&#39;)
  .replace(expr, &#39;`); \n $1 \n  echo(`&#39;);

template = &#39;echo(`&#39; + template + &#39;`);&#39;;
</code></pre><p>然后，将template封装在一个函数里面返回，就可以了。</p>
<pre><code>let script =
`(function parse(data){
  let output = &quot;&quot;;

  function echo(html){
    output += html;
  }

  ${ template }

  return output;
})`;

return script;
</code></pre><p>将上面的内容拼装成一个模板编译函数compile。</p>
<pre><code>function compile(template){
  const evalExpr = /&lt;%=(.+?)%&gt;/g;
  const expr = /&lt;%([\s\S]+?)%&gt;/g;

  template = template
    .replace(evalExpr, &#39;`); \n  echo( $1 ); \n  echo(`&#39;)
    .replace(expr, &#39;`); \n $1 \n  echo(`&#39;);

  template = &#39;echo(`&#39; + template + &#39;`);&#39;;

  let script =
  `(function parse(data){
    let output = &quot;&quot;;

    function echo(html){
      output += html;
    }

    ${ template }

    return output;
  })`;

  return script;
}
</code></pre><p>compile函数的用法如下。</p>
<pre><code>let parse = eval(compile(template));
div.innerHTML = parse({ supplies: [ &quot;broom&quot;, &quot;mop&quot;, &quot;cleaner&quot; ] });
//   &lt;ul&gt;
//     &lt;li&gt;broom&lt;/li&gt;
//     &lt;li&gt;mop&lt;/li&gt;
//     &lt;li&gt;cleaner&lt;/li&gt;
//   &lt;/ul&gt;
</code></pre><h3 id="13-标签模板"><a href="#13-标签模板" class="headerlink" title="13.标签模板"></a>13.标签模板</h3><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>
<pre><code>alert`123`
// 等同于
alert(123)
</code></pre><p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>
<pre><code>let a = 5;
let b = 10;

tag`Hello ${ a + b } world ${ a * b }`;
// 等同于
tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50);
</code></pre><p>上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</p>
<p>函数tag依次会接收到多个参数。</p>
<pre><code>function tag(stringArr, value1, value2){
  // ...
}

// 等同于

function tag(stringArr, ...values){
  // ...
}
</code></pre><p>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p>tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p>
<p>tag函数所有参数的实际值如下。</p>
<ul>
<li>第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]</li>
<li>第二个参数: 15</li>
<li>第三个参数：50</li>
</ul>
<p>也就是说，tag函数实际上以下面的形式调用。</p>
<pre><code>tag([&#39;Hello &#39;, &#39; world &#39;, &#39;&#39;], 15, 50)
</code></pre><p>我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。</p>
<pre><code>let a = 5;
let b = 10;

function tag(s, v1, v2) {
  console.log(s[0]);
  console.log(s[1]);
  console.log(s[2]);
  console.log(v1);
  console.log(v2);

  return &quot;OK&quot;;
}

tag`Hello ${ a + b } world ${ a * b}`;
// &quot;Hello &quot;
// &quot; world &quot;
// &quot;&quot;
// 15
// 50
// &quot;OK&quot;
</code></pre><p>下面是一个更复杂的例子。</p>
<pre><code>let total = 30;
let msg = passthru`The total is ${total} (${total*1.05} with tax)`;

function passthru(literals) {
  let result = &#39;&#39;;
  let i = 0;

  while (i &lt; literals.length) {
    result += literals[i++];
    if (i &lt; arguments.length) {
      result += arguments[i];
    }
  }

  return result;
}

msg // &quot;The total is 30 (31.5 with tax)&quot;
</code></pre><p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p>
<p>passthru函数采用 rest 参数的写法如下。</p>
<pre><code>function passthru(literals, ...values) {
  let output = &quot;&quot;;
  let index;
  for (index = 0; index &lt; values.length; index++) {
    output += literals[index] + values[index];
  }

  output += literals[index]
  return output;
}
</code></pre><p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p>
<pre><code>let message =
  SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`;

function SaferHTML(templateData) {
  let s = templateData[0];
  for (let i = 1; i &lt; arguments.length; i++) {
    let arg = String(arguments[i]);

    // Escape special characters in the substitution.
    s += arg.replace(/&amp;/g, &quot;&amp;amp;&quot;)
            .replace(/&lt;/g, &quot;&amp;lt;&quot;)
            .replace(/&gt;/g, &quot;&amp;gt;&quot;);

    // Don&#39;t escape special characters in the template.
    s += templateData[i];
  }
  return s;
}
</code></pre><p>上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。</p>
<pre><code>let sender = &#39;&lt;script&gt;alert(&quot;abc&quot;)&lt;/script&gt;&#39;; // 恶意代码
let message = SaferHTML`&lt;p&gt;${sender} has sent you a message.&lt;/p&gt;`;

message
// &lt;p&gt;&amp;lt;script&amp;gt;alert(&quot;abc&quot;)&amp;lt;/script&amp;gt; has sent you a message.&lt;/p&gt;
</code></pre><p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>
<pre><code>i18n`Welcome to ${siteName}, you are visitor number ${visitorNumber}!`
// &quot;欢迎访问xxx，您是第xxxx位访问者！&quot;
</code></pre><p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p>
<pre><code>// 下面的hashTemplate函数
// 是一个自定义的模板处理函数
let libraryHtml = hashTemplate`
  &lt;ul&gt;
    #for book in ${myBooks}
      &lt;li&gt;&lt;i&gt;#{book.title}&lt;/i&gt; by #{book.author}&lt;/li&gt;
    #end
  &lt;/ul&gt;
`;
</code></pre><p>除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。</p>
<pre><code>jsx`
  &lt;div&gt;
    &lt;input
      ref=&#39;input&#39;
      onChange=&#39;${this.handleChange}&#39;
      defaultValue=&#39;${this.state.value}&#39; /&gt;
      ${this.state.value}
   &lt;/div&gt;
`
</code></pre><p>上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 Github 找到jsx函数的具体实现。</p>
<p>下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。</p>
<pre><code>java`
class HelloWorldApp {
  public static void main(String[] args) {
    System.out.println(“Hello World!”); // Display the string.
  }
}
`
HelloWorldApp.main();
</code></pre><p>模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。</p>
<pre><code>console.log`123`
// [&quot;123&quot;, raw: Array[1]]
</code></pre><p>上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。</p>
<p>请看下面的例子。</p>
<pre><code>tag`First line\nSecond line`

function tag(strings) {
  console.log(strings.raw[0]);
  // strings.raw[0] 为 &quot;First line\\nSecond line&quot;
  // 打印输出 &quot;First line\nSecond line&quot;
}
</code></pre><p>上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[“First line\nSecond line”]，那么strings.raw数组就是[“First line\nSecond line”]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\n视为\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p>
<h3 id="14-String-raw"><a href="#14-String-raw" class="headerlink" title="14.String.raw()"></a>14.String.raw()</h3><p>ES6 还为原生的 String 对象，提供了一个raw方法。</p>
<p>String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>
<pre><code>String.raw`Hi\n${2+3}!`;
// 返回 &quot;Hi\\n5!&quot;

String.raw`Hi\u000A!`;
// 返回 &quot;Hi\\u000A!&quot;
</code></pre><p>如果原字符串的斜杠已经转义，那么String.raw会进行再次转义。</p>
<pre><code>String.raw`Hi\\n`
// 返回 &quot;Hi\\\\n&quot;
</code></pre><p>String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>
<p>String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</p>
<pre><code>String.raw({ raw: &#39;test&#39; }, 0, 1, 2);
// &#39;t0e1s2t&#39;

// 等同于
String.raw({ raw: [&#39;t&#39;,&#39;e&#39;,&#39;s&#39;,&#39;t&#39;] }, 0, 1, 2);
</code></pre><p>作为函数，String.raw的代码实现基本如下。</p>
<pre><code>String.raw = function (strings, ...values) {
  let output = &#39;&#39;;
  let index;
  for (index = 0; index &lt; values.length; index++) {
    output += strings.raw[index] + values[index];
  }

  output += strings.raw[index]
  return output;
}
</code></pre><h3 id="15-模板字符串的限制"><a href="#15-模板字符串的限制" class="headerlink" title="15.模板字符串的限制"></a>15.模板字符串的限制</h3><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p>
<p>举例来说，标签模板里面可以嵌入 LaTEX 语言。</p>
<pre><code>function latex(strings) {
  // ...
}

let document = latex`
\newcommand{\fun}{\textbf{Fun!}}  // 正常工作
\newcommand{\unicode}{\textbf{Unicode!}} // 报错
\newcommand{\xerxes}{\textbf{King!}} // 报错

Breve over the h goes \u{h}ere // 报错
`
</code></pre><p>上面代码中，变量document内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。</p>
<p>模板字符串会将\u00FF和\u{42}当作 Unicode 字符进行转义，所以\unicode解析时报错；而\x56会被当作十六进制字符串转义，所以\xerxes会报错。也就是说，\u和\x在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。</p>
<p>为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。</p>
<pre><code>function tag(strs) {
  strs[0] === undefined
  strs.raw[0] === &quot;\\unicode and \\u{55}&quot;;
}
tag`\unicode and \u{55}`
</code></pre><p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。</p>
<p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p>
<pre><code>let bad = `bad escape sequence: \unicode`; // 报错
</code></pre>]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 03.变量的解构赋值]]></title>
      <url>/2018/06/11/ES6/03.%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      <content type="html"><![CDATA[<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="1-变量的解构赋值"><a href="#1-变量的解构赋值" class="headerlink" title="1.变量的解构赋值"></a>1.变量的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<pre><code>let a = 1;
let b = 2;
let c = 3;
</code></pre><p>ES6 允许写成下面这样。</p>
<pre><code>let [a, b, c] = [1, 2, 3];
</code></pre><p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>
<pre><code>let [foo, [[bar], baz]] = [1, [[2], 3]];
foo // 1
bar // 2
baz // 3

let [ , , third] = [&quot;foo&quot;, &quot;bar&quot;, &quot;baz&quot;];
third // &quot;baz&quot;

let [x, , y] = [1, 2, 3];
x // 1
y // 3

let [head, ...tail] = [1, 2, 3, 4];
head // 1
tail // [2, 3, 4]

let [x, y, ...z] = [&#39;a&#39;];
x // &quot;a&quot;
y // undefined
z // []
</code></pre><p>如果解构不成功，变量的值就等于undefined。</p>
<pre><code>let [foo] = [];
let [bar, foo] = [1];
</code></pre><p>以上两种情况都属于解构不成功，foo的值都会等于undefined。</p>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<pre><code>let [x, y] = [1, 2, 3];
x // 1
y // 2

let [a, [b], d] = [1, [2, 3], 4];
a // 1
b // 2
d // 4
</code></pre><p>上面两个例子，都属于不完全解构，但是可以成功。</p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<pre><code>// 报错
let [foo] = 1;
let [foo] = false;
let [foo] = NaN;
let [foo] = undefined;
let [foo] = null;
let [foo] = {};
</code></pre><p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p>
<p>对于 Set 结构，也可以使用数组的解构赋值。</p>
<pre><code>let [x, y, z] = new Set([&#39;a&#39;, &#39;b&#39;, &#39;c&#39;]);
x // &quot;a&quot;
</code></pre><p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<pre><code>function* fibs() {
  let a = 0;
  let b = 1;
  while (true) {
    yield a;
    [a, b] = [b, a + b];
  }
}

let [first, second, third, fourth, fifth, sixth] = fibs();
sixth // 5
</code></pre><p>上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。</p>
<pre><code>let [foo = true] = [];
foo // true

let [x, y = &#39;b&#39;] = [&#39;a&#39;]; // x=&#39;a&#39;, y=&#39;b&#39;
let [x, y = &#39;b&#39;] = [&#39;a&#39;, undefined]; // x=&#39;a&#39;, y=&#39;b&#39;
</code></pre><p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</p>
<pre><code>let [x = 1] = [undefined];
x // 1

let [x = 1] = [null];
x // null
</code></pre><p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<pre><code>function f() {
  console.log(&#39;aaa&#39;);
}

let [x = f()] = [1];
</code></pre><p>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。</p>
<pre><code>let x;
if ([1][0] === undefined) {
  x = f();
} else {
  x = [1][0];
}
</code></pre><p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<pre><code>let [x = 1, y = x] = [];     // x=1; y=1
let [x = 1, y = x] = [2];    // x=2; y=2
let [x = 1, y = x] = [1, 2]; // x=1; y=2
let [x = y, y = 1] = [];     // ReferenceError: y is not defined
</code></pre><p>上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。</p>
<h3 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2.对象的解构赋值"></a>2.对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。</p>
<pre><code>let { foo, bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;
</code></pre><p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<pre><code>let { bar, foo } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
foo // &quot;aaa&quot;
bar // &quot;bbb&quot;

let { baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // undefined
</code></pre><p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<pre><code>let { foo: baz } = { foo: &#39;aaa&#39;, bar: &#39;bbb&#39; };
baz // &quot;aaa&quot;

let obj = { first: &#39;hello&#39;, last: &#39;world&#39; };
let { first: f, last: l } = obj;
f // &#39;hello&#39;
l // &#39;world&#39;
</code></pre><p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>
<pre><code>let { foo: foo, bar: bar } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
</code></pre><p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<pre><code>let { foo: baz } = { foo: &quot;aaa&quot;, bar: &quot;bbb&quot; };
baz // &quot;aaa&quot;
foo // error: foo is not defined
</code></pre><p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p>
<p>与数组一样，解构也可以用于嵌套结构的对象。</p>
<pre><code>let obj = {
  p: [
    &#39;Hello&#39;,
    { y: &#39;World&#39; }
  ]
};

let { p: [x, { y }] } = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
</code></pre><p>注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。</p>
<pre><code>let obj = {
  p: [
    &#39;Hello&#39;,
    { y: &#39;World&#39; }
  ]
};

let { p, p: [x, { y }] } = obj;
x // &quot;Hello&quot;
y // &quot;World&quot;
p // [&quot;Hello&quot;, {y: &quot;World&quot;}]
</code></pre><p>下面是另一个例子。</p>
<pre><code>const node = {
  loc: {
    start: {
      line: 1,
      column: 5
    }
  }
};

let { loc, loc: { start }, loc: { start: { line }} } = node;
line // 1
loc  // Object {start: Object}
start // Object {line: 1, column: 5}
</code></pre><p>上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。</p>
<p>下面是嵌套赋值的例子。</p>
<pre><code>let obj = {};
let arr = [];

({ foo: obj.prop, bar: arr[0] } = { foo: 123, bar: true });

obj // {prop:123}
arr // [true]
</code></pre><p>对象的解构也可以指定默认值。</p>
<pre><code>var {x = 3} = {};
x // 3

var {x, y = 5} = {x: 1};
x // 1
y // 5

var {x: y = 3} = {};
y // 3

var {x: y = 3} = {x: 5};
y // 5

var { message: msg = &#39;Something went wrong&#39; } = {};
msg // &quot;Something went wrong&quot;
</code></pre><p>默认值生效的条件是，对象的属性值严格等于undefined。</p>
<pre><code>var {x = 3} = {x: undefined};
x // 3

var {x = 3} = {x: null};
x // null
</code></pre><p>上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。</p>
<p>如果解构失败，变量的值等于undefined。</p>
<pre><code>let {foo} = {bar: &#39;baz&#39;};
foo // undefined
</code></pre><p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>
<pre><code>// 报错
let {foo: {bar}} = {baz: &#39;baz&#39;};
</code></pre><p>上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。</p>
<pre><code>let _tmp = {baz: &#39;baz&#39;};
_tmp.foo.bar // 报错
</code></pre><p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
<pre><code>// 错误的写法
let x;
{x} = {x: 1};
// SyntaxError: syntax error
</code></pre><p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
<pre><code>// 正确的写法
let x;
({x} = {x: 1});
</code></pre><p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p>
<p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p>
<pre><code>({} = [true, false]);
({} = &#39;abc&#39;);
({} = []);
</code></pre><p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<pre><code>let { log, sin, cos } = Math;
</code></pre><p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p>
<p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<pre><code>let arr = [1, 2, 3];
let {0 : first, [arr.length - 1] : last} = arr;
first // 1
last // 3
</code></pre><p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）</p>
<h3 id="3-字符串的解构赋值"><a href="#3-字符串的解构赋值" class="headerlink" title="3.字符串的解构赋值"></a>3.字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<pre><code>const [a, b, c, d, e] = &#39;hello&#39;;
a // &quot;h&quot;
b // &quot;e&quot;
c // &quot;l&quot;
d // &quot;l&quot;
e // &quot;o&quot;
</code></pre><p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<pre><code>let {length : len} = &#39;hello&#39;;
len // 5
</code></pre><h3 id="4-数值和布尔值的解构赋值"><a href="#4-数值和布尔值的解构赋值" class="headerlink" title="4.数值和布尔值的解构赋值"></a>4.数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<pre><code>let {toString: s} = 123;
s === Number.prototype.toString // true

let {toString: s} = true;
s === Boolean.prototype.toString // true
</code></pre><p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<pre><code>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。

解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。
</code></pre><h3 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5.函数参数的解构赋值"></a>5.函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。</p>
<pre><code>function add([x, y]){
  return x + y;
}

add([1, 2]); // 3
</code></pre><p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p>
<p>下面是另一个例子。</p>
<pre><code>[[1, 2], [3, 4]].map(([a, b]) =&gt; a + b);
</code></pre><p>函数参数的解构也可以使用默认值。</p>
<pre><code>function move({x = 0, y = 0} = {}) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, 0]
move({}); // [0, 0]
move(); // [0, 0]
</code></pre><p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p>
<p>注意，下面的写法会得到不一样的结果。</p>
<pre><code>function move({x, y} = { x: 0, y: 0 }) {
  return [x, y];
}

move({x: 3, y: 8}); // [3, 8]
move({x: 3}); // [3, undefined]
move({}); // [undefined, undefined]
move(); // [0, 0]
</code></pre><p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p>
<p>undefined就会触发函数参数的默认值。</p>
<pre><code>[1, undefined, 3].map((x = &#39;yes&#39;) =&gt; x);
// [ 1, &#39;yes&#39;, 3 ]
</code></pre><h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><p>以下三种解构赋值不得使用圆括号。</p>
<p>（1）变量声明语句</p>
<pre><code>// 全部报错
let [(a)] = [1];

let {x: (c)} = {};
let ({x: c}) = {};
let {(x: c)} = {};
let {(x): c} = {};

let { o: ({ p: p }) } = { o: { p: 2 } };
</code></pre><p>（2）函数参数</p>
<p>函数参数也属于变量声明，因此不能带有圆括号。</p>
<pre><code>// 报错
function f([(z)]) { return z; }
// 报错
function f([z,(x)]) { return x; }
</code></pre><p>（3）赋值语句的模式</p>
<pre><code>// 全部报错
({ p: a }) = { p: 42 };
([a]) = [5];
</code></pre><p>上面代码将整个模式放在圆括号之中，导致报错。</p>
<pre><code>// 报错
[({ p: a }), { x: c }] = [{}, {}];
</code></pre><p>上面代码将一部分模式放在圆括号之中，导致报错。</p>
<h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<pre><code>[(b)] = [3]; // 正确
({ p: (d) } = {}); // 正确
[(parseInt.prop)] = [3]; // 正确
</code></pre><p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p>
<h3 id="7-用途"><a href="#7-用途" class="headerlink" title="7.用途"></a>7.用途</h3><p>变量的解构赋值用途很多。</p>
<p>（1）交换变量的值</p>
<pre><code>let x = 1;
let y = 2;

[x, y] = [y, x];
</code></pre><p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<p>（2）从函数返回多个值</p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<pre><code>// 返回一个数组

function example() {
  return [1, 2, 3];
}
let [a, b, c] = example();

// 返回一个对象

function example() {
  return {
    foo: 1,
    bar: 2
  };
}
let { foo, bar } = example();
</code></pre><p>（3）函数参数的定义</p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<pre><code>// 参数是一组有次序的值
function f([x, y, z]) { ... }
f([1, 2, 3]);

// 参数是一组无次序的值
function f({x, y, z}) { ... }
f({z: 3, y: 2, x: 1});
</code></pre><p>（4）提取 JSON 数据</p>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<pre><code>let jsonData = {
  id: 42,
  status: &quot;OK&quot;,
  data: [867, 5309]
};

let { id, status, data: number } = jsonData;

console.log(id, status, number);
// 42, &quot;OK&quot;, [867, 5309]
</code></pre><p>上面代码可以快速提取 JSON 数据的值。</p>
<p>（5）函数参数的默认值</p>
<pre><code>jQuery.ajax = function (url, {
  async = true,
  beforeSend = function () {},
  cache = true,
  complete = function () {},
  crossDomain = false,
  global = true,
  // ... more config
} = {}) {
  // ... do stuff
};
</code></pre><p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<p>（6）遍历 Map 结构</p>
<p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<pre><code>const map = new Map();
map.set(&#39;first&#39;, &#39;hello&#39;);
map.set(&#39;second&#39;, &#39;world&#39;);

for (let [key, value] of map) {
  console.log(key + &quot; is &quot; + value);
}
// first is hello
// second is world
</code></pre><p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<pre><code>// 获取键名
for (let [key] of map) {
  // ...
}

// 获取键值
for (let [,value] of map) {
  // ...
}
</code></pre><p>（7）输入模块的指定方法</p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<pre><code>const { SourceMapConsumer, SourceNode } = require(&quot;source-map&quot;);
</code></pre>]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 02.let 和 const 命令]]></title>
      <url>/2018/06/08/ES6/02.let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="Let-和-Const-命令"><a href="#Let-和-Const-命令" class="headerlink" title="Let 和 Const 命令"></a>Let 和 Const 命令</h2><h3 id="1-Let-命令"><a href="#1-Let-命令" class="headerlink" title="1. Let 命令"></a>1. Let 命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法:"></a>基本用法:</h4><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<pre><code>{
  let a = 10;
  var b = 1;
}

a // ReferenceError: a is not defined.
b // 1
</code></pre><p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</p>
<p>for循环的计数器，就很合适使用let命令。</p>
<pre><code>for (let i = 0; i &lt; 10; i++) {
  // ...
}

console.log(i);
// ReferenceError: i is not defined
</code></pre><p>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。</p>
<p>下面的代码如果使用var，最后输出的是10。</p>
<pre><code>var a = [];
for (var i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 10
</code></pre><p>上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。</p>
<p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<pre><code>var a = [];
for (let i = 0; i &lt; 10; i++) {
  a[i] = function () {
    console.log(i);
  };
}
a[6](); // 6
</code></pre><p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p>
<p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<pre><code>for (let i = 0; i &lt; 3; i++) {
  let i = &#39;abc&#39;;
  console.log(i);
}
// abc
// abc
// abc
</code></pre><p>上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<pre><code>// var 的情况
console.log(foo); // 输出undefined
var foo = 2;

// let 的情况
console.log(bar); // 报错ReferenceError
let bar = 2;
</code></pre><p>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<pre><code>if (true) {
  // TDZ开始
  tmp = &#39;abc&#39;; // ReferenceError
  console.log(tmp); // ReferenceError

  let tmp; // TDZ结束
  console.log(tmp); // undefined

  tmp = 123;
  console.log(tmp); // 123
}
</code></pre><p>上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。</p>
<p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。</p>
<pre><code>typeof x; // ReferenceError
let x;
</code></pre><p>上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。</p>
<p>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。</p>
<pre><code>typeof undeclared_variable // &quot;undefined&quot;
</code></pre><p>上面代码中，undeclared variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>
<p>有些“死区”比较隐蔽，不太容易发现。</p>
<pre><code>function bar(x = y, y = 2) {
  return [x, y];
}

bar(); // 报错
</code></pre><p>上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。</p>
<pre><code>function bar(x = 2, y = x) {
  return [x, y];
}
bar(); // [2, 2]
</code></pre><p>另外，下面的代码也会报错，与var的行为不同。</p>
<pre><code>// 不报错
var x = x;

// 报错
let x = x;
// ReferenceError: x is not defined
</code></pre><p>上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。</p>
<p>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p>let不允许在相同作用域内，重复声明同一个变量。</p>
<pre><code>// 报错
function func() {
  let a = 10;
  var a = 1;
}

// 报错
function func() {
  let a = 10;
  let a = 1;
}
</code></pre><p>因此，不能在函数内部重新声明参数。</p>
<pre><code>function func(arg) {
  let arg; // 报错
}

function func(arg) {
  {
    let arg; // 不报错
  }
}
</code></pre><h3 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2.块级作用域"></a>2.块级作用域</h3><h4 id="为什么需要块级作用域"><a href="#为什么需要块级作用域" class="headerlink" title="为什么需要块级作用域"></a>为什么需要块级作用域</h4><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
<pre><code>var tmp = new Date();

function f() {
  console.log(tmp);
  if (false) {
    var tmp = &#39;hello world&#39;;
  }
}

f(); // undefined
</code></pre><p>上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<pre><code>var s = &#39;hello&#39;;

for (var i = 0; i &lt; s.length; i++) {
  console.log(s[i]);
}

console.log(i); // 5
</code></pre><p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h4 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h4><p>let实际上为 JavaScript 新增了块级作用域。</p>
<pre><code>function f1() {
  let n = 5;
  if (true) {
    let n = 10;
  }
  console.log(n); // 5
}
</code></pre><p>上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。</p>
<p>ES6 允许块级作用域的任意嵌套。</p>
<pre><code>{{{{{let insane = 'Hello World'}}}}};
</code></pre><p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p>
<pre><code>{{{{
  {let insane = 'Hello World'}
  console.log(insane); // 报错
}}}};
</code></pre><p>内层作用域可以定义外层作用域的同名变量。</p>
<pre><code>{{{{
  let insane = 'Hello World';
  {let insane = 'Hello World'}
}}}};
</code></pre><p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<pre><code>// IIFE 写法
(function () {
  var tmp = ...;
  ...
}());

// 块级作用域写法
{
  let tmp = ...;
  ...
}
</code></pre><h4 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h4><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<pre><code>// 情况一
if (true) {
  function f() {}
}

// 情况二
try {
  function f() {}
} catch(e) {
  // ...
}
</code></pre><p>上面两种函数声明，根据 ES5 的规定都是非法的。</p>
<p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p>
<pre><code>function f() { console.log(&#39;I am outside!&#39;); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log(&#39;I am inside!&#39;); }
  }

  f();
}());
</code></pre><p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。</p>
<pre><code>// ES5 环境
function f() { console.log(&#39;I am outside!&#39;); }

(function () {
  function f() { console.log(&#39;I am inside!&#39;); }
  if (false) {
  }
  f();
}());
</code></pre><p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p>
<p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics" target="_blank" rel="noopener">附录B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a href="http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6" target="_blank" rel="noopener">行为方式</a>。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p>
<p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</p>
<pre><code>// 浏览器的 ES6 环境
function f() { console.log(&#39;I am outside!&#39;); }

(function () {
  if (false) {
    // 重复声明一次函数f
    function f() { console.log(&#39;I am inside!&#39;); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
</code></pre><p>上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。</p>
<pre><code>// 浏览器的 ES6 环境
function f() { console.log(&#39;I am outside!&#39;); }
(function () {
  var f = undefined;
  if (false) {
    function f() { console.log(&#39;I am inside!&#39;); }
  }

  f();
}());
// Uncaught TypeError: f is not a function
</code></pre><p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<pre><code>// 函数声明语句
{
  let a = &#39;secret&#39;;
  function f() {
    return a;
  }
}

// 函数表达式
{
  let a = &#39;secret&#39;;
  let f = function () {
    return a;
  };
}
</code></pre><p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p>
<pre><code>// 不报错
&#39;use strict&#39;;
if (true) {
  function f() {}
}

// 报错
&#39;use strict&#39;;
if (true)
  function f() {}
</code></pre><h3 id="3-const命令"><a href="#3-const命令" class="headerlink" title="3.const命令"></a>3.const命令</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<pre><code>const PI = 3.1415;
PI // 3.1415

PI = 3;
// TypeError: Assignment to constant variable.
</code></pre><p>上面代码表明改变常量的值会报错。</p>
<p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<pre><code>const foo;
// SyntaxError: Missing initializer in const declaration
</code></pre><p>上面代码表示，对于const来说，只声明不赋值，就会报错。</p>
<p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
<pre><code>if (true) {
  const MAX = 5;
}

MAX // Uncaught ReferenceError: MAX is not defined
</code></pre><p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<pre><code>if (true) {
  console.log(MAX); // ReferenceError
  const MAX = 5;
}
</code></pre><p>上面代码在常量MAX声明之前就调用，结果报错。</p>
<p>const声明的常量，也与let一样不可重复声明。</p>
<pre><code>var message = &quot;Hello!&quot;;
let age = 25;

// 以下两行都会报错
const message = &quot;Goodbye!&quot;;
const age = 30;
</code></pre><h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<pre><code>const foo = {};

// 为 foo 添加一个属性，可以成功
foo.prop = 123;
foo.prop // 123

// 将 foo 指向另一个对象，就会报错
foo = {}; // TypeError: &quot;foo&quot; is read-only
</code></pre><p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<pre><code>const a = [];
a.push(&#39;Hello&#39;); // 可执行
a.length = 0;    // 可执行
a = [&#39;Dave&#39;];    // 报错
</code></pre><p>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。</p>
<p>如果真的想将对象冻结，应该使用Object.freeze方法。</p>
<pre><code>const foo = Object.freeze({});

// 常规模式时，下面一行不起作用；
// 严格模式时，该行会报错
foo.prop = 123;
</code></pre><p>上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<pre><code>var constantize = (obj) =&gt; {
  Object.freeze(obj);
  Object.keys(obj).forEach( (key, i) =&gt; {
    if ( typeof obj[key] === &#39;object&#39; ) {
      constantize( obj[key] );
    }
  });
};
</code></pre><h4 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h4><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。</p>
<h3 id="4-顶层对象的属性"><a href="#4-顶层对象的属性" class="headerlink" title="4.顶层对象的属性"></a>4.顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>
<pre><code>window.a = 1;
a // 1

a = 2;
window.a // 2
</code></pre><p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<pre><code>var a = 1;
// 如果在 Node 的 REPL 环境，可以写成 global.a
// 或者采用通用方法，写成 this.a
window.a // 1

let b = 1;
window.b // undefined
</code></pre><p>上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。</p>
<h3 id="5-global对象"><a href="#5-global对象" class="headerlink" title="5.global对象"></a>5.global对象</h3><p>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p>
<ul>
<li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li>
<li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。</li>
<li>Node 里面，顶层对象是global，但其他环境都不支持。</li>
</ul>
<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p>
<ul>
<li>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。</li>
<li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li>
<li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li>
</ul>
<p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p>
<pre><code>// 方法一
(typeof window !== &#39;undefined&#39;
   ? window
   : (typeof process === &#39;object&#39; &amp;&amp;
      typeof require === &#39;function&#39; &amp;&amp;
      typeof global === &#39;object&#39;)
     ? global
     : this);

// 方法二
var getGlobal = function () {
  if (typeof self !== &#39;undefined&#39;) { return self; }
  if (typeof window !== &#39;undefined&#39;) { return window; }
  if (typeof global !== &#39;undefined&#39;) { return global; }
  throw new Error(&#39;unable to locate global object&#39;);
};
</code></pre><p>现在有一个<a href="https://github.com/tc39/proposal-global" target="_blank" rel="noopener">提案</a>，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p>
<p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。</p>
<pre><code>// CommonJS 的写法
require(&#39;system.global/shim&#39;)();

// ES6 模块的写法
import shim from &#39;system.global/shim&#39;; shim();
</code></pre><p>上面代码可以保证各种环境里面，global对象都是存在的。</p>
<pre><code>// CommonJS 的写法
var global = require(&#39;system.global&#39;)();

// ES6 模块的写法
import getGlobal from &#39;system.global&#39;;
const global = getGlobal();
</code></pre><p>上面代码将顶层对象放入变量global。</p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 01.ECMAScript 6 简介]]></title>
      <url>/2018/06/08/ES6/01.ECMAScript/</url>
      <content type="html"><![CDATA[<h2 id="ECMAScript-6-简介"><a href="#ECMAScript-6-简介" class="headerlink" title="ECMAScript 6 简介"></a>ECMAScript 6 简介</h2><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<hr>
<h3 id="1-ECMAScript-和-JavaScript-的关系"><a href="#1-ECMAScript-和-JavaScript-的关系" class="headerlink" title="1.ECMAScript 和 JavaScript 的关系"></a>1.ECMAScript 和 JavaScript 的关系</h3><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p>
<p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p>
<p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p>
<h3 id="2-ES6-与-ECMAScript-2015-的关系"><a href="#2-ES6-与-ECMAScript-2015-的关系" class="headerlink" title="2.ES6 与 ECMAScript 2015 的关系"></a>2.ES6 与 ECMAScript 2015 的关系</h3><p>ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？</p>
<p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。</p>
<p>但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。</p>
<p>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。</p>
<p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。</p>
<p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。</p>
<p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。</p>
<h3 id="3-语法提案的批准流程"><a href="#3-语法提案的批准流程" class="headerlink" title="3.语法提案的批准流程"></a>3.语法提案的批准流程</h3><p>任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。</p>
<p>一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。</p>
<ul>
<li>Stage 0 - Strawman（展示阶段）</li>
<li>Stage 1 - Proposal（征求意见阶段）</li>
<li>Stage 2 - Draft（草案阶段）</li>
<li>Stage 3 - Candidate（候选人阶段）</li>
<li>Stage 4 - Finished（定案阶段）</li>
</ul>
<p>一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站<a href="https://github.com/tc39/ecma262" target="_blank" rel="noopener">Github.com/tc39/ecma262</a>查看。</p>
<p>本书的写作目标之一，是跟踪 ECMAScript 语言的最新进展，介绍 5.1 版本以后所有的新语法。对于那些明确或很有希望，将要列入标准的新语法，都将予以介绍。</p>
<h3 id="4-ECMAScript-的历史"><a href="#4-ECMAScript-的历史" class="headerlink" title="4.ECMAScript 的历史"></a>4.ECMAScript 的历史</h3><p>ES6 从开始制定到最后发布，整整用了 15 年。</p>
<p>前面提到，ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。</p>
<p>2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。</p>
<p>为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。</p>
<p>2007 年 10 月，ECMAScript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。</p>
<p>2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。</p>
<p>2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 委员会的总体考虑是，ES5 与 ES3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是 ES6，第六版发布以后，就指 ES7。TC39 的判断是，ES5 会在 2013 年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。</p>
<p>2011 年 6 月，ECMAscript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。</p>
<p>2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。</p>
<p>2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。</p>
<p>2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。</p>
<h3 id="5-部署进度"><a href="#5-部署进度" class="headerlink" title="5.部署进度"></a>5.部署进度</h3><p>各大浏览器的最新版本，对 ES6 的支持可以查看<a href="https://kangax.github.io/es5-compat-table/es6/" target="_blank" rel="noopener">kangax.github.io/es5-compat-table/es6/</a>。随着时间的推移，支持度已经越来越高了，超过 90%的 ES6 语法特性都实现了。</p>
<p>Node 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node 已经实现的 ES6 特性。</p>
<pre><code>$ node --v8-options | grep harmony
</code></pre><p>上面命令的输出结果，会因为版本的不同而有所不同。</p>
<h3 id="6-Babel-转码器"><a href="#6-Babel-转码器" class="headerlink" title="6.Babel 转码器"></a>6.Babel 转码器</h3><p>Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。</p>
<pre><code>// 转码前
input.map(item =&gt; item + 1);

// 转码后
input.map(function (item) {
  return item + 1;
});
</code></pre><p>上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。</p>
<h4 id="配置文件-babelrc"><a href="#配置文件-babelrc" class="headerlink" title="配置文件.babelrc"></a>配置文件.babelrc</h4><p>Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。</p>
<p>该文件用来设置转码规则和插件，基本格式如下。</p>
<pre><code>{
  &quot;presets&quot;: [],
  &quot;plugins&quot;: []
}
</code></pre><p>presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</p>
<pre><code># 最新转码规则
$ npm install --save-dev babel-preset-latest

# react 转码规则
$ npm install --save-dev babel-preset-react

# 不同阶段语法提案的转码规则（共有4个阶段），选装一个
$ npm install --save-dev babel-preset-stage-0
$ npm install --save-dev babel-preset-stage-1
$ npm install --save-dev babel-preset-stage-2
$ npm install --save-dev babel-preset-stage-3
</code></pre><p>然后，将这些规则加入.babelrc。</p>
<pre><code> {
    &quot;presets&quot;: [
      &quot;latest&quot;,
      &quot;react&quot;,
      &quot;stage-2&quot;
    ],
    &quot;plugins&quot;: []
  }
</code></pre><p>注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。</p>
<h4 id="命令行转码babel-cli"><a href="#命令行转码babel-cli" class="headerlink" title="命令行转码babel-cli"></a>命令行转码babel-cli</h4><p>Babel 提供babel-cli工具，用于命令行转码。</p>
<p>它的安装命令如下。</p>
<pre><code>$ npm install --global babel-cli
</code></pre><p>基本用法如下。</p>
<pre><code># 转码结果输出到标准输出
$ babel example.js

# 转码结果写入一个文件
# --out-file 或 -o 参数指定输出文件
$ babel example.js --out-file compiled.js
# 或者
$ babel example.js -o compiled.js

# 整个目录转码
# --out-dir 或 -d 参数指定输出目录
$ babel src --out-dir lib
# 或者
$ babel src -d lib

# -s 参数生成source map文件
$ babel src -d lib -s
</code></pre><p>上面代码是在全局环境下，进行 Babel 转码。这意味着，如果项目要运行，全局环境必须有 Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的 Babel。</p>
<p>一个解决办法是将babel-cli安装在项目之中。</p>
<pre><code># 安装
$ npm install --save-dev babel-cli
</code></pre><p>然后，改写package.json。</p>
<pre><code>{
  // ...
  &quot;devDependencies&quot;: {
    &quot;babel-cli&quot;: &quot;^6.0.0&quot;
  },
  &quot;scripts&quot;: {
    &quot;build&quot;: &quot;babel src -d lib&quot;
  },
}
</code></pre><p>转码的时候，就执行下面的命令。</p>
<pre><code>$ npm run build
</code></pre><h4 id="babel-node"><a href="#babel-node" class="headerlink" title="babel-node"></a>babel-node</h4><p>babel-cli工具自带一个babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。</p>
<p>它不用单独安装，而是随babel-cli一起安装。然后，执行babel-node就进入 REPL 环境。</p>
<pre><code>$ babel-node
&gt; (x =&gt; x * 2)(1)
2
</code></pre><p>babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。</p>
<pre><code>$ babel-node es6.js
2
</code></pre><p>babel-node也可以安装在项目中。</p>
<pre><code>$ npm install --save-dev babel-cli
</code></pre><p>然后，改写package.json。</p>
<pre><code>{
  &quot;scripts&quot;: {
    &quot;script-name&quot;: &quot;babel-node script.js&quot;
  }
}
</code></pre><p>上面代码中，使用babel-node替代node，这样script.js本身就不用做任何转码处理。</p>
<h4 id="babel-register"><a href="#babel-register" class="headerlink" title="babel-register"></a>babel-register</h4><p>babel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。</p>
<pre><code>$ npm install --save-dev babel-register
</code></pre><p>使用时，必须首先加载babel-register。</p>
<pre><code>require(&quot;babel-register&quot;);
require(&quot;./index.js&quot;);
</code></pre><p>然后，就不需要手动对index.js转码了。</p>
<p>需要注意的是，babel-register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。</p>
<h4 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h4><p>如果某些代码需要调用 Babel 的 API 进行转码，就要使用babel-core模块。</p>
<p>安装命令如下。</p>
<pre><code>$ npm install babel-core --save
</code></pre><p>然后，在项目中就可以调用babel-core。</p>
<pre><code>var babel = require(&#39;babel-core&#39;);

// 字符串转码
babel.transform(&#39;code();&#39;, options);
// =&gt; { code, map, ast }

// 文件转码（异步）
babel.transformFile(&#39;filename.js&#39;, options, function(err, result) {
  result; // =&gt; { code, map, ast }
});

// 文件转码（同步）
babel.transformFileSync(&#39;filename.js&#39;, options);
// =&gt; { code, map, ast }

// Babel AST转码
babel.transformFromAst(ast, code, options);
// =&gt; { code, map, ast }
</code></pre><p>配置对象options，可以参看官方文档<a href="http://babeljs.io/docs/usage/options/" target="_blank" rel="noopener">http://babeljs.io/docs/usage/options/</a>。</p>
<p>下面是一个例子。</p>
<pre><code>var es6Code = &#39;let x = n =&gt; n + 1&#39;;
var es5Code = require(&#39;babel-core&#39;)
  .transform(es6Code, {
    presets: [&#39;latest&#39;]
  })
  .code;
// &#39;&quot;use strict&quot;;\n\nvar x = function x(n) {\n  return n + 1;\n};&#39;
</code></pre><p>上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。</p>
<h4 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h4><p>Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。</p>
<p>举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。</p>
<p>安装命令如下。</p>
<pre><code>$ npm install --save babel-polyfill
</code></pre><p>然后，在脚本头部，加入如下一行代码。</p>
<pre><code>import &#39;babel-polyfill&#39;;
// 或者
require(&#39;babel-polyfill&#39;);
</code></pre><p>Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的<a href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/definitions.js" target="_blank" rel="noopener">definitions.js</a>文件。</p>
<h4 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h4><p>Babel 也可以用于浏览器环境。但是，从 Babel 6.0 开始，不再直接提供浏览器版本，而是要用构建工具构建出来。如果你没有或不想使用构建工具，可以使用babel-standalone模块提供的浏览器版本，将其插入网页。</p>
<pre><code>&lt;script src=&quot;https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;text/babel&quot;&gt;
// Your ES6 code
&lt;/script&gt;
</code></pre><p>注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。</p>
<p>下面是如何将代码打包成浏览器可以使用的脚本，以Babel配合Browserify为例。首先，安装babelify模块。</p>
<pre><code>$ npm install --save-dev babelify babel-preset-latest
</code></pre><p>然后，再用命令行转换 ES6 脚本。</p>
<pre><code>$  browserify script.js -o bundle.js \
  -t [ babelify --presets [ latest ] ]
</code></pre><p>上面代码将 ES6 脚本script.js，转为bundle.js，浏览器直接加载后者就可以了。</p>
<p>在package.json设置下面的代码，就不用每次命令行都输入参数了。</p>
<pre><code>{
  &quot;browserify&quot;: {
    &quot;transform&quot;: [[&quot;babelify&quot;, { &quot;presets&quot;: [&quot;latest&quot;] }]]
  }
}
</code></pre><h4 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h4><p>Babel 提供一个<a href="https://babeljs.io/repl/" target="_blank" rel="noopener">REPL 在线编译器</a>，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
<h4 id="与其他工具的配合"><a href="#与其他工具的配合" class="headerlink" title="与其他工具的配合"></a>与其他工具的配合</h4><p>许多工具需要 Babel 进行前置转码，这里举两个例子：ESLint 和 Mocha。</p>
<p>ESLint 用于静态检查代码的语法和风格，安装命令如下。</p>
<pre><code>$ npm install --save-dev eslint babel-eslint
</code></pre><p>然后，在项目根目录下，新建一个配置文件.eslintrc，在其中加入parser字段。</p>
<pre><code>{
  &quot;parser&quot;: &quot;babel-eslint&quot;,
  &quot;rules&quot;: {
    ...
  }
}
</code></pre><p>再在package.json之中，加入相应的scripts脚本。</p>
<pre><code>  {
    &quot;name&quot;: &quot;my-module&quot;,
    &quot;scripts&quot;: {
      &quot;lint&quot;: &quot;eslint my-files.js&quot;
    },
    &quot;devDependencies&quot;: {
      &quot;babel-eslint&quot;: &quot;...&quot;,
      &quot;eslint&quot;: &quot;...&quot;
    }
  }
</code></pre><p>Mocha 则是一个测试框架，如果需要执行使用 ES6 语法的测试脚本，可以修改package.json的scripts.test。</p>
<pre><code>&quot;scripts&quot;: {
  &quot;test&quot;: &quot;mocha --ui qunit --compilers js:babel-core/register&quot;
}
</code></pre><p>上面命令中，–compilers参数指定脚本的转码器，规定后缀名为js的文件，都需要使用babel-core/register先转码。</p>
<h3 id="7-Traceur-转码器"><a href="#7-Traceur-转码器" class="headerlink" title="7.Traceur 转码器"></a>7.Traceur 转码器</h3><p>Google 公司的<a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a>转码器，也可以将 ES6 代码转为 ES5 代码。</p>
<h4 id="直接插入网页"><a href="#直接插入网页" class="headerlink" title="直接插入网页"></a>直接插入网页</h4><p>Traceur 允许将 ES6 代码直接插入网页。首先，必须在网页头部加载 Traceur 库文件。</p>
<pre><code>&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/BrowserSystem.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt;
&lt;script type=&quot;module&quot;&gt;
  import &#39;./Greeter.js&#39;;
&lt;/script&gt;
</code></pre><p>上面代码中，一共有 4 个script标签。第一个是加载 Traceur 的库文件，第二个和第三个是将这个库文件用于浏览器环境，第四个则是加载用户脚本，这个脚本里面可以使用 ES6 代码。</p>
<p>注意，第四个script标签的type属性的值是module，而不是text/javascript。这是 Traceur 编译器识别 ES6 代码的标志，编译器会自动将所有type=module的代码编译为 ES5，然后再交给浏览器执行。</p>
<p>除了引用外部 ES6 脚本，也可以直接在网页中放置 ES6 代码。</p>
<pre><code>&lt;script type=&quot;module&quot;&gt;
  class Calc {
    constructor() {
      console.log(&#39;Calc constructor&#39;);
    }
    add(a, b) {
      return a + b;
    }
  }

  var c = new Calc();
  console.log(c.add(4,5));
&lt;/script&gt;
</code></pre><p>正常情况下，上面代码会在控制台打印出9。</p>
<p>如果想对 Traceur 的行为有精确控制，可以采用下面参数配置的写法。</p>
<pre><code>&lt;script&gt;
  // Create the System object
  window.System = new traceur.runtime.BrowserTraceurLoader();
  // Set some experimental options
  var metadata = {
    traceurOptions: {
      experimental: true,
      properTailCalls: true,
      symbols: true,
      arrayComprehension: true,
      asyncFunctions: true,
      asyncGenerators: exponentiation,
      forOn: true,
      generatorComprehension: true
    }
  };
  // Load your module
  System.import(&#39;./myModule.js&#39;, {metadata: metadata}).catch(function(ex) {
    console.error(&#39;Import failed&#39;, ex.stack || ex);
  });
&lt;/script&gt;
</code></pre><p>上面代码中，首先生成 Traceur 的全局对象window.System，然后System.import方法可以用来加载 ES6。加载的时候，需要传入一个配置对象metadata，该对象的traceurOptions属性可以配置支持 ES6 功能。如果设为experimental: true，就表示除了 ES6 以外，还支持一些实验性的新功能。</p>
<h4 id="在线转换-1"><a href="#在线转换-1" class="headerlink" title="在线转换"></a>在线转换</h4><p>Traceur 也提供一个<a href="http://google.github.io/traceur-compiler/demo/repl.html" target="_blank" rel="noopener">在线编译器</a>，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
<p>上面的例子转为 ES5 代码运行，就是下面这个样子。</p>
<pre><code>&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/traceur.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://google.github.io/traceur-compiler/bin/BrowserSystem.js&quot;&gt;&lt;/script&gt;
&lt;script src=&quot;https://google.github.io/traceur-compiler/src/bootstrap.js&quot;&gt;&lt;/script&gt;
&lt;script&gt;
$traceurRuntime.ModuleStore.getAnonymousModule(function() {
  &quot;use strict&quot;;

  var Calc = function Calc() {
    console.log(&#39;Calc constructor&#39;);
  };

  ($traceurRuntime.createClass)(Calc, {add: function(a, b) {
    return a + b;
  }}, {});

  var c = new Calc();
  console.log(c.add(4, 5));
  return {};
});
&lt;/script&gt;
</code></pre><h4 id="命令行转换"><a href="#命令行转换" class="headerlink" title="命令行转换"></a>命令行转换</h4><p>作为命令行工具使用时，Traceur 是一个 Node 的模块，首先需要用 npm 安装。</p>
<pre><code>$ npm install -g traceur
</code></pre><p>安装成功后，就可以在命令行下使用 Traceur 了。</p>
<p>Traceur 直接运行 ES6 脚本文件，会在标准输出显示运行结果，以前面的calc.js为例。</p>
<pre><code>$ traceur calc.js
Calc constructor
9
</code></pre><p>如果要将 ES6 脚本转为 ES5 保存，要采用下面的写法。</p>
<pre><code>$ traceur --script calc.es6.js --out calc.es5.js
</code></pre><p>上面代码的–script选项表示指定输入文件，–out选项表示指定输出文件。</p>
<p>为了防止有些特性编译不成功，最好加上–experimental选项。</p>
<pre><code>$ traceur --script calc.es6.js --out calc.es5.js --experimental
</code></pre><p>命令行下转换生成的文件，就可以直接放到浏览器中运行。</p>
<h4 id="Node-环境的用法"><a href="#Node-环境的用法" class="headerlink" title="Node 环境的用法"></a>Node 环境的用法</h4><p>Traceur 的 Node 用法如下（假定已安装traceur模块）。</p>
<pre><code>var traceur = require(&#39;traceur&#39;);
var fs = require(&#39;fs&#39;);

// 将 ES6 脚本转为字符串
var contents = fs.readFileSync(&#39;es6-file.js&#39;).toString();

var result = traceur.compile(contents, {
  filename: &#39;es6-file.js&#39;,
  sourceMap: true,
  // 其他设置
  modules: &#39;commonjs&#39;
});

if (result.error)
  throw result.error;

// result 对象的 js 属性就是转换后的 ES5 代码
fs.writeFileSync(&#39;out.js&#39;, result.js);
// sourceMap 属性对应 map 文件
fs.writeFileSync(&#39;out.js.map&#39;, result.sourceMap);
</code></pre>]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 06.Handling Events]]></title>
      <url>/2018/05/11/react/02.Quick_Start/06.Handling_Events/</url>
      <content type="html"><![CDATA[<h2 id="Handling-Events-处理事件"><a href="#Handling-Events-处理事件" class="headerlink" title="Handling Events(处理事件)"></a>Handling Events(处理事件)</h2><p>Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:</p>
<p>用React元素处理事件与在DOM元素上处理事件非常相似。这里有一些语法不同：</p>
<ul>
<li>React events are named using camelCase, rather than lowercase.</li>
<li>With JSX you pass a function as the event handler, rather than a string.</li>
</ul>
<hr>
<ul>
<li>React事件使用驼峰命名法，而不是小写字母命名法。</li>
<li>使用JSX作为您函数事件处理的参数，而不是字符串。</li>
</ul>
<p>For example, the HTML:</p>
<p>例如，HTML：</p>
<pre><code>&lt;button onclick=&quot;activateLasers()&quot;&gt;
  Activate Lasers
&lt;/button&gt;
</code></pre><p>is slightly different in React:</p>
<p>在React中有点不同：</p>
<pre><code>&lt;button onClick={activateLasers}&gt;
  Activate Lasers
&lt;/button&gt;
</code></pre><p>Another difference is that you cannot return false to prevent default behavior in React. You must call preventDefault explicitly. For example, with plain HTML, to prevent the default link behavior of opening a new page, you can write:</p>
<p>另一个不同是您不能返回false来阻止React中的默认事件。您必须明确地调用preventDefault。例如，在HTML代码中，为了阻止默认点击事件，打开一个新的页面的表现，您可以这么写：</p>
<pre><code>&lt;a href=&quot;#&quot; onclick=&quot;console.log(&#39;The link was clicked.&#39;); return false&quot;&gt;
  Click me
&lt;/a&gt;
</code></pre><p>In React, this could instead be:</p>
<p>在React中，应当是这样的：</p>
<pre><code>function ActionLink() {
  function handleClick(e) {
    e.preventDefault();
    console.log(&#39;The link was clicked.&#39;);
  }

  return (
    &lt;a href=&quot;#&quot; onClick={handleClick}&gt;
      Click me
    &lt;/a&gt;
  );
}
</code></pre><p>Here, e is a synthetic event. React defines these synthetic events according to the <a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C spec</a>, so you don’t need to worry about cross-browser compatibility. See the <a href="https://reactjs.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent</a> reference guide to learn more.</p>
<p>这里，e代表了一个事件。React根据<a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C</a>规范定义了这些事件，因此您不必担心跨浏览器兼容性。 请参阅<a href="https://reactjs.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent</a>参考指南以了解更多信息。</p>
<p>When using React you should generally not need to call addEventListener to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.</p>
<p>在使用React时，通常不需要调用addEventListener在创建DOM元素后向其添加监听器。相反，只需在元素初始呈现时添加监听器。</p>
<p>When you define a component using an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>, a common pattern is for an event handler to be a method on the class. For example, this Toggle component renders a button that lets the user toggle between “ON” and “OFF” states:</p>
<p>当您使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6的类</a>来定义一个组件时，一个常见的模式是让一个事件处理器成为该类的一个方法。 例如，这个Toggle组件呈现一个按钮，让用户在“ON”和“OFF”状态之间切换：</p>
<pre><code>class Toggle extends React.Component {
  constructor(props) {
    super(props);
    this.state = {isToggleOn: true};

    // This binding is necessary to make `this` work in the callback
    this.handleClick = this.handleClick.bind(this);
  }

  handleClick() {
    this.setState(prevState =&gt; ({
      isToggleOn: !prevState.isToggleOn
    }));
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        {this.state.isToggleOn ? &#39;ON&#39; : &#39;OFF&#39;}
      &lt;/button&gt;
    );
  }
}

ReactDOM.render(
  &lt;Toggle /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="http://codepen.io/gaearon/pen/xEmzGg?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>You have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">bound</a> by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called.</p>
<p>您必须在JSX回调中注意这一点的含义。在JavaScript中，类方法默认没有<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">绑定</a>。如果您忘记绑定this.handleClick并将其传递给onClick，则在实际调用该函数时，这将是未定义的。</p>
<p>This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.</p>
<p>这不是React特定的表现; 在JavaScript中它是函数的一部分。一般来说，如果你在它后面引用一个没有()的方法，比如onClick = {this.handleClick}，你就应该绑定该方法。</p>
<p>If calling bind annoys you, there are two ways you can get around this. If you are using the experimental <a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">public class fields syntax</a>, you can use class fields to correctly bind callbacks:</p>
<p>如果调用bind会让你感到困扰，那么有两种方法可以解决这个问题。 如果您使用的是尝试性的<a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">公共类字段语法</a>，则可以使用类字段来正确地绑定回调：</p>
<pre><code>class LoggingButton extends React.Component {
  // This syntax ensures `this` is bound within handleClick.
  // Warning: this is *experimental* syntax.
  handleClick = () =&gt; {
    console.log(&#39;this is:&#39;, this);
  }

  render() {
    return (
      &lt;button onClick={this.handleClick}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}
</code></pre><p>This syntax is enabled by default in <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>.</p>
<p>这种语法在<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>中是默认启用的。</p>
<p>If you aren’t using class fields syntax, you can use an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow function</a> in the callback:</p>
<p>如果您不使用类字段语法，则可以在回调中使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>：</p>
<pre><code>class LoggingButton extends React.Component {
  handleClick() {
    console.log(&#39;this is:&#39;, this);
  }

  render() {
    // This syntax ensures `this` is bound within handleClick
    return (
      &lt;button onClick={(e) =&gt; this.handleClick(e)}&gt;
        Click me
      &lt;/button&gt;
    );
  }
}
</code></pre><p>The problem with this syntax is that a different callback is created each time the LoggingButton renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.</p>
<p>这个语法的问题是每次LoggingButton呈现时都会创建一个不同的回调函数。 在大多数情况下，这没有问题。但是，如果将此回调作为参数传递给较低组件，则这些组件可能会重新渲染。我们通常建议在构造函数中绑定或使用类字段语法来避免此类性能问题。</p>
<h3 id="Passing-Arguments-to-Event-Handlers-将参数传递给事件处理程序"><a href="#Passing-Arguments-to-Event-Handlers-将参数传递给事件处理程序" class="headerlink" title="Passing Arguments to Event Handlers(将参数传递给事件处理程序)"></a>Passing Arguments to Event Handlers(将参数传递给事件处理程序)</h3><p>Inside a loop it is common to want to pass an extra parameter to an event handler. For example, if id is the row ID, either of the following would work:</p>
<p>在循环内部，通常需要将一个额外的参数传递给事件处理程序。 例如，如果id是行ID，则以下任一项都可以工作</p>
<pre><code>&lt;button onClick={(e) =&gt; this.deleteRow(id, e)}&gt;Delete Row&lt;/button&gt;
&lt;button onClick={this.deleteRow.bind(this, id)}&gt;Delete Row&lt;/button&gt;
</code></pre><p>The above two lines are equivalent, and use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow functions</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">Function.prototype.bind</a> respectively.</p>
<p>以上两行都是相等的，分别使用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">Function.prototype.bind</a>。</p>
<p>In both cases, the e argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically forwarded.</p>
<p>在这两种情况下，e参数代表了React事件，并将作为ID之后的第二个参数传递。使用箭头函数，我们必须明确地传递它，但是任何额外的参数都会自动绑定起来，并自动转发。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 05.State and Lifecycle]]></title>
      <url>/2018/05/11/react/02.Quick_Start/05.State_and_Lifecycle/</url>
      <content type="html"><![CDATA[<h2 id="State-and-Lifecycle"><a href="#State-and-Lifecycle" class="headerlink" title="State and Lifecycle"></a>State and Lifecycle</h2><p>Consider the ticking clock example from <a href="https://reactjs.org/docs/rendering-elements.html#updating-the-rendered-element" target="_blank" rel="noopener">one of the previous sections</a>.</p>
<p>考虑在<a href="https://reactjs.org/docs/rendering-elements.html#updating-the-rendered-element" target="_blank" rel="noopener">前几章节</a>中涉及到的秒钟案例。</p>
<p>So far we have only learned one way to update the UI.</p>
<p>直到现在，我们都只学了一种更新UI的方法。</p>
<p>We call ReactDOM.render() to change the rendered output:</p>
<p>我们会调用ReactDOM.render()来更新渲染输出:</p>
<pre><code>function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
  ReactDOM.render(
    element,
    document.getElementById(&#39;root&#39;)
  );
}

setInterval(tick, 1000);
</code></pre><p><a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>In this section, we will learn how to make the Clock component truly reusable and encapsulated. It will set up its own timer and update itself every second.</p>
<p>这一章节中，我们将学到如何构建一个真正可复用和封装良好的Clock组件。它每秒都会被重新设置并更新其本身。</p>
<p>We can start by encapsulating how the clock looks:</p>
<p>我们可以简单的构建出钟表最开始的样式：</p>
<pre><code>function Clock(props) {
  return (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
}

function tick() {
  ReactDOM.render(
    &lt;Clock date={new Date()} /&gt;,
    document.getElementById(&#39;root&#39;)
  );
}

setInterval(tick, 1000);
</code></pre><p><a href="http://codepen.io/gaearon/pen/dpdoYR?editors=0010" target="_blank" rel="noopener">Try it on CodePen</a></p>
<p>However, it misses a crucial requirement: the fact that the Clock sets up a timer and updates the UI every second should be an implementation detail of the Clock.</p>
<p>然而，它忘了一个重要的先决条件：事实就是设置一个计时器并每秒都更新UI是Clock本身应该实现的一个细节。</p>
<p>Ideally we want to write this once and have the Clock update itself:</p>
<p>理想情况下，我们只想写一次Clock并由其本身完成更新：</p>
<pre><code>ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>To implement this, we need to add “state” to the Clock component.</p>
<p>为了实现这个目标，我们应该为Clock组件添加“状态”。</p>
<p>State is similar to props, but it is private and fully controlled by the component.</p>
<p>状态和属性相似，但是它是私密的，并且完全由组件控制。</p>
<p>We <a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">mentioned before</a> that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes.</p>
<p>我们<a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">之前提到</a>，当组件被定义为类时会有一些额外的特性。本地状态就是其中一种：一个只对类有效的特性。</p>
<h3 id="Converting-a-Function-to-a-Class-将一个函数转化为类"><a href="#Converting-a-Function-to-a-Class-将一个函数转化为类" class="headerlink" title="Converting a Function to a Class(将一个函数转化为类)"></a>Converting a Function to a Class(将一个函数转化为类)</h3><p>You can convert a functional component like Clock to a class in five steps:</p>
<p>您可以通过以下五步将一个函数组件转化为类：</p>
<ol>
<li>Create an ES6 class, with the same name, that extends React.Component.</li>
<li>Add a single empty method to it called render().</li>
<li>Move the body of the function into the render() method.</li>
<li>Replace props with this.props in the render() body.</li>
<li>Delete the remaining empty function declaration.</li>
</ol>
<hr>
<ol>
<li>创建一个具有相同名字，由React.Component扩展出来的ES6的类。</li>
<li>添加一个单一的空的方法，并由render()调用。</li>
<li>将函数主体移动到render()方法中。</li>
<li>在render()主体内，用this.props取代props。</li>
<li>删除剩余的空的函数声明。</li>
</ol>
<pre><code>class Clock extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.props.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p><a href="http://codepen.io/gaearon/pen/zKRGpo?editors=001" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Clock is now defined as a class rather than a function.</p>
<p>Clock现在被定义为一个类而不是函数。</p>
<p>This lets us use additional features such as local state and lifecycle hooks.</p>
<p>这样可以让我们添加一些额外的特性，如本地状态和生命周期钩子。</p>
<h3 id="Adding-Local-State-to-a-Class-向一个类中添加本地状态"><a href="#Adding-Local-State-to-a-Class-向一个类中添加本地状态" class="headerlink" title="Adding Local State to a Class(向一个类中添加本地状态)"></a>Adding Local State to a Class(向一个类中添加本地状态)</h3><p>We will move the date from props to state in three steps:</p>
<p>我们将用三步将时间从属性移动到状态里：</p>
<ol>
<li>Replace this.props.date with this.state.date in the render() method:(在render()方法中用this.state.date取代this.props.date)</li>
</ol>
<pre><code>class Clock extends React.Component {
  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><ol>
<li>Add a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor" target="_blank" rel="noopener">class constructor</a> that assigns the initial this.state:(添加一个类的构造函数来初始化this.state)</li>
</ol>
<pre><code>class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>Note how we pass props to the base constructor:</p>
<p>注意我们是如何将参数传给基本的构造函数的：</p>
<pre><code> constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }
</code></pre><p>Class components should always call the base constructor with props.</p>
<p>类组件应该永远由带有参数的基本的构造函数来调用。</p>
<ol>
<li>Remove the date prop from the Clock element:(从Clock中移除时间属性)</li>
</ol>
<pre><code>ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>We will later add the timer code back to the component itself.</p>
<p>我们稍后会将计时器组件代码到这个组件本身中。</p>
<p>The result looks like this:</p>
<p>最后的结果大致如下：</p>
<pre><code>class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="http://codepen.io/gaearon/pen/KgQpJd?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Next, we’ll make the Clock set up its own timer and update itself every second.</p>
<p>接下来，我们将为Clock设置它自己的计时器并每秒都更新它。</p>
<h3 id="Adding-Lifecycle-Methods-to-a-Class-为类添加生命周期方法"><a href="#Adding-Lifecycle-Methods-to-a-Class-为类添加生命周期方法" class="headerlink" title="Adding Lifecycle Methods to a Class(为类添加生命周期方法)"></a>Adding Lifecycle Methods to a Class(为类添加生命周期方法)</h3><p>In applications with many components, it’s very important to free up resources taken by the components when they are destroyed.</p>
<p>在具有多个组件的应用程序中在销毁组件时释放所占用的资源是非常重要的。</p>
<p>We want to <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener">set up a timer</a> whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React.</p>
<p>我们想当Clock在被DOM初次渲染时<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener">设置一个计时器</a>，这在React中叫做“挂载”。</p>
<p>We also want to <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval" target="_blank" rel="noopener">clear that timer</a> whenever the DOM produced by the Clock is removed. This is called “unmounting” in React.</p>
<p>我们也想在Clock在被DOM中移除时<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval" target="_blank" rel="noopener">清除计时器</a>。这在React中叫做“解挂”。</p>
<p>We can declare special methods on the component class to run some code when a component mounts and unmounts:</p>
<p>当组件被挂载和解挂时，我们可以在组件类中声明特殊的方法来运行一些代码：</p>
<pre><code>class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {

  }

  componentWillUnmount() {

  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}
</code></pre><p>These methods are called “lifecycle hooks”.</p>
<p>这些方法叫做“生命周期钩子”。</p>
<p>The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer:</p>
<p>componentDidMount()钩子会在组件输出被渲染到DOM后执行。这是一个好的设置计时器的时间点：</p>
<pre><code> componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      1000
    );
  }
</code></pre><p>Note how we save the timer ID right on this.</p>
<p>现在我们在其上设置计时器的ID。</p>
<p>While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that doesn’t participate in the data flow (like a timer ID).</p>
<p>因为this.props由React自己设置，this.state具有特殊含义，但如果您需要存储不参与数据流的内容（例如计时器ID），则需要手动将其他字段添加到类中）。</p>
<p>We will tear down the timer in the componentWillUnmount() lifecycle hook:</p>
<p>我们将会在componentWillUnmount()生命周期钩子中卸载计时器：</p>
<pre><code>componentWillUnmount() {
    clearInterval(this.timerID);
}
</code></pre><p>Finally, we will implement a method called tick() that the Clock component will run every second.</p>
<p>最后，我们将会应用一个叫做tick()的方法让Clock组件每秒都运行。</p>
<p>It will use this.setState() to schedule updates to the component local state:</p>
<p>它会使用this.setState()来设置更新计时器的本地状态：</p>
<pre><code>class Clock extends React.Component {
  constructor(props) {
    super(props);
    this.state = {date: new Date()};
  }

  componentDidMount() {
    this.timerID = setInterval(
      () =&gt; this.tick(),
      1000
    );
  }

  componentWillUnmount() {
    clearInterval(this.timerID);
  }

  tick() {
    this.setState({
      date: new Date()
    });
  }

  render() {
    return (
      &lt;div&gt;
        &lt;h1&gt;Hello, world!&lt;/h1&gt;
        &lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
      &lt;/div&gt;
    );
  }
}

ReactDOM.render(
  &lt;Clock /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="http://codepen.io/gaearon/pen/amqdNA?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Now the clock ticks every second.</p>
<p>现在，钟表将会每秒都运行。</p>
<p>Let’s quickly recap what’s going on and the order in which the methods are called:</p>
<p>让我们简单回顾一下在这个方法被调用时发生了什么，和它们的次序是什么：</p>
<ol>
<li>When Clock is passed to ReactDOM.render(), React calls the constructor of the Clock component. Since Clock needs to display the current time, it initializes this.state with an object including the current time. We will later update this state.</li>
<li>React then calls the Clock component’s render() method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the Clock’s render output.</li>
<li>When the Clock output is inserted in the DOM, React calls the componentDidMount() lifecycle hook. Inside it, the Clock component asks the browser to set up a timer to call the component’s tick() method once a second.</li>
<li>Every second the browser calls the tick() method. Inside it, the Clock component schedules a UI update by calling setState() with an object containing the current time. Thanks to the setState() call, React knows the state has changed, and calls the render() method again to learn what should be on the screen. This time, this.state.date in the render() method will be different, and so the render output will include the updated time. React updates the DOM accordingly.</li>
<li>If the Clock component is ever removed from the DOM, React calls the componentWillUnmount() lifecycle hook so the timer is stopped.</li>
</ol>
<hr>
<ol>
<li>当Clock传递给ReactDOM.render()时，React调用Clock组件的构造函数。由于Clock需要显示当前时间，因此它会使用包含当前时间的对象初始化this.state。我们稍后将更新这个状态。</li>
<li>然后React调用Clock组件的render()方法。这就是React如何在屏幕上显示对应的内容。然后React更新DOM以匹配时钟的渲染输出。</li>
<li>当时钟输出插入到DOM中时，React调用componentDidMount()生命周期钩子。在它里面，Clock组件要求浏览器设置一个定时器，每秒调用一次该组件的tick（）方法。</li>
<li>浏览器每秒钟都会调用tick()方法。在它里面，Clock组件通过调用setState()和包含当前时间的对象来调度UI更新。因为setState()已经被调用，React知道状态已经改变，并再次调用render()方法在屏幕上显示应有的内容。这一次，render()方法中的this.state.date将会不同，所以渲染的结果包含更新的时间。并且React会相应地更新DOM。</li>
<li>如果Clock组件从DOM中删除，React将调用componentWillUnmount()生命周期钩子，定时器也随之停止。</li>
</ol>
<h3 id="Using-State-Correctly-正确地使用状态"><a href="#Using-State-Correctly-正确地使用状态" class="headerlink" title="Using State Correctly(正确地使用状态)"></a>Using State Correctly(正确地使用状态)</h3><p>There are three things you should know about setState().</p>
<p>您应当知道有关setState()的三个事情。</p>
<h4 id="Do-Not-Modify-State-Directly-不要直接调整状态"><a href="#Do-Not-Modify-State-Directly-不要直接调整状态" class="headerlink" title="Do Not Modify State Directly(不要直接调整状态)"></a>Do Not Modify State Directly(不要直接调整状态)</h4><p>There are three things you should know about setState().</p>
<p>有关setState()，您应当知道三件事情。</p>
<h4 id="Do-Not-Modify-State-Directly-不要直接调整状态-1"><a href="#Do-Not-Modify-State-Directly-不要直接调整状态-1" class="headerlink" title="Do Not Modify State Directly(不要直接调整状态)"></a>Do Not Modify State Directly(不要直接调整状态)</h4><p>For example, this will not re-render a component:</p>
<p>例如，下列代码不会重新渲染组件：</p>
<pre><code>// Wrong
this.state.comment = &#39;Hello&#39;;
</code></pre><p>Instead, use setState():</p>
<p>相反的，您应当使用setState():</p>
<pre><code>// Correct
this.setState({comment: &#39;Hello&#39;});
</code></pre><p>The only place where you can assign this.state is the constructor.</p>
<p>您唯一能设置this.state的地方就是构造函数。</p>
<h4 id="State-Updates-May-Be-Asynchronous-状态更新可能是异步的"><a href="#State-Updates-May-Be-Asynchronous-状态更新可能是异步的" class="headerlink" title="State Updates May Be Asynchronous(状态更新可能是异步的)"></a>State Updates May Be Asynchronous(状态更新可能是异步的)</h4><p>React may batch multiple setState() calls into a single update for performance.</p>
<p>React可能会批量处理多个setState(),以便为单个更新提高性能。</p>
<p>Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.</p>
<p>因为this.props和this.state可能会异步更新，所以不应该依赖它们的值来计算下一个状态。</p>
<p>For example, this code may fail to update the counter:</p>
<p>例如，此代码可能无法更新计数器:</p>
<pre><code>// Wrong
this.setState({
  counter: this.state.counter + this.props.increment,
});
</code></pre><p>To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:</p>
<p>为了修复它，我们可以使用接受函数的setState()而不是一个对象。该函数将接收前一个状态作为第一个参数，并将更新应用时的状态作为第二个参数：</p>
<pre><code>// Correct
this.setState((prevState, props) =&gt; ({
  counter: prevState.counter + props.increment
}));
</code></pre><p>We used an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow function</a> above, but it also works with regular functions:</p>
<p>我们在此使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，但是它也对常规函数起作用：</p>
<pre><code>// Correct
this.setState(function(prevState, props) {
  return {
    counter: prevState.counter + props.increment
  };
});
</code></pre><h4 id="State-Updates-are-Merged-状态更新已合并"><a href="#State-Updates-are-Merged-状态更新已合并" class="headerlink" title="State Updates are Merged(状态更新已合并)"></a>State Updates are Merged(状态更新已合并)</h4><p>When you call setState(), React merges the object you provide into the current state.</p>
<p>当您调用setState()时，React会合并您当前状态下提供的对象。</p>
<p>For example, your state may contain several independent variables:</p>
<p>例如，您的状态可能包含几个相互独立的变量：</p>
<pre><code>constructor(props) {
  super(props);
  this.state = {
  posts: [],
  comments: []
  };
}
</code></pre><p>Then you can update them independently with separate setState() calls:</p>
<p>然后您可以独立地使用setState()调用来更新它们：</p>
<pre><code>componentDidMount() {
    fetchPosts().then(response =&gt; {
      this.setState({
        posts: response.posts
      });
    });

    fetchComments().then(response =&gt; {
      this.setState({
        comments: response.comments
      });
    });
  }
</code></pre><p>The merging is shallow, so this.setState({comments}) leaves this.state.posts intact, but completely replaces this.state.comments.</p>
<p>合并是浅层的，所以this.setState({comments})会完整保留this.state.posts，但完全取代了this.state.comments。</p>
<h3 id="The-Data-Flows-Down-数据流失向下的"><a href="#The-Data-Flows-Down-数据流失向下的" class="headerlink" title="The Data Flows Down(数据流失向下的)"></a>The Data Flows Down(数据流失向下的)</h3><p>Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care whether it is defined as a function or a class.</p>
<p>父组件和孩组件都不知道某个组件是有状态的还是无状态的，并且它们不应该关心它是被定义为一个函数还是一个类。</p>
<p>This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.</p>
<p>这就是为什么状态通常被称作本地的或被封装的。除了包含和设置它的组件之外，其他任何组件都无法访问它。</p>
<p>A component may choose to pass its state down as props to its child components:</p>
<p>组件可以选择将其状态作为参数传递给其子组件：</p>
<pre><code>&lt;h2&gt;It is {this.state.date.toLocaleTimeString()}.&lt;/h2&gt;
</code></pre><p>This also works for user-defined components:</p>
<p>这对用户自定义的组件也有效：</p>
<pre><code>&lt;FormattedDate date={this.state.date} /&gt;
</code></pre><p>The FormattedDate component would receive the date in its props and wouldn’t know whether it came from the Clock’s state, from the Clock’s props, or was typed by hand:</p>
<p>FormattedDate组件应当在它们的属性中接受数据并不会知道它是来自Clock的状态，Clock的属性还是人为输入的。</p>
<pre><code>function FormattedDate(props) {
  return &lt;h2&gt;It is {props.date.toLocaleTimeString()}.&lt;/h2&gt;;
}
</code></pre><p><a href="http://codepen.io/gaearon/pen/zKRqNB?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>This is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components “below” them in the tree.</p>
<p>通常这被称之为“自顶向下”或者“无方向”的数据流。任何状态总是由某个特定组件拥有，并且从该状态派生的任何数据或UI只能影响树中“在其下”的组件。</p>
<p>If you imagine a component tree as a waterfall of props, each component’s state is like an additional water source that joins it at an arbitrary point but also flows down.</p>
<p>如果将组件树想象成参数的瀑布，则每个组件的状态就像是一个额外的水源，它可以在任意点加入它，但也会向下流。</p>
<p>To show that all components are truly isolated, we can create an App component that renders three Clocks:</p>
<p>为了显示所有组件都是真正隔离的，我们可以创建一个呈现三个Clock的App组件：</p>
<pre><code>function App() {
  return (
    &lt;div&gt;
      &lt;Clock /&gt;
      &lt;Clock /&gt;
      &lt;Clock /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="http://codepen.io/gaearon/pen/vXdGmd?editors=0010" target="_blank" rel="noopener">Try it on CondePen.</a></p>
<p>Each Clock sets up its own timer and updates independently.</p>
<p>每个表都会独立地设置它本身的计时器并独立更新。</p>
<p>In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.</p>
<p>在React应用中，无论组件是有状态的还是无状态的，都被视为可能随时间而改变的组件的细节。您可以在有状态组件内使用无状态组件，反之亦然。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git problem -- 1.git&gerrit邮箱不匹配]]></title>
      <url>/2018/05/11/git/git_problem/01.git_problem/</url>
      <content type="html"><![CDATA[<h2 id="git-problem-–-git-amp-gerrit邮箱不匹配"><a href="#git-problem-–-git-amp-gerrit邮箱不匹配" class="headerlink" title="git problem – git&amp;gerrit邮箱不匹配"></a>git problem – git&amp;gerrit邮箱不匹配</h2><p>Git邮箱不匹配问题 does not match your user account</p>
<p>在活动比较多，使用分支开发的时候，从远端拉取分支，在完成fetch-&gt;rebase-&gt;修改代码以后，执行gerrit push指令时，提示用户信息不匹配。类似于下图所示：</p>
<p><img src="/images/git/01.git_account.png"></p>
<pre><code>remote: ERROR:  In commit 024c0bd88da87274f956a10dfa6b41e8c69ebd04
remote: ERROR:  author email address xxxxx@xx.com
remote: ERROR:  does not match your user account.
</code></pre><p>此问题解决方法：（不仅仅限于分支，master分支出现类似问题也可以用此方法）</p>
<pre><code>(1)git  config user.email (email地址)
(2)git checkout -b another_branch（如果已经被占，随便再换一个）
(3)git branch -D pre_branch(删除出现问题的分支)
(4)git checkout --track origin/pre_branch
(5)git push origin/pre_branch:refs/for/pre_branch  此时原先出现问题的分支就可以push成功了
</code></pre>]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git problem </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 04.Components and Props]]></title>
      <url>/2018/05/08/react/02.Quick_Start/04.Components_and_Props/</url>
      <content type="html"><![CDATA[<h2 id="Components-and-Props"><a href="#Components-and-Props" class="headerlink" title="Components and Props"></a>Components and Props</h2><p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.</p>
<p>组件可以让您将用户界面分成独立的，可重复使用的部分，并且每一部分都相互独立。</p>
<p>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.</p>
<p>从概念上讲，组件就像JavaScript的函数一样。他可以接受任意值的输入（我们通常称之为“参数”）并返回显示在屏幕上的React元素。</p>
<h3 id="Functional-and-Class-Components-函数和类组件"><a href="#Functional-and-Class-Components-函数和类组件" class="headerlink" title="Functional and Class Components(函数和类组件)"></a>Functional and Class Components(函数和类组件)</h3><p>The simplest way to define a component is to write a JavaScript function:</p>
<p>定义一个组件最简单的方法是写一个JavaScript函数：</p>
<pre><code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}
</code></pre><p>This function is a valid React component because it accepts a single “props” (which stands for properties) object argument with data and returns a React element. We call such components “functional” because they are literally JavaScript functions.</p>
<p>这个函数是一个有效的React组件，因为它可以接受一个带有数据的单一的“参数”（通常代表着属性）对象并返回一个React元素。我们称这样的组件是“函数化”的，因为它们都是JavaScript字面上的方法。</p>
<p>You can also use an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a> to define a component:</p>
<p>您也可以使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>来定义一个组件：</p>
<pre><code>class Welcome extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}
</code></pre><p>The above two components are equivalent from React’s point of view.</p>
<p>以上两种组件对于React来说是等价的。</p>
<p>Classes have some additional features that we will discuss in the <a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">next sections</a>. Until then, we will use functional components for their conciseness.</p>
<p>类通常有一些额外的特性，我们会在<a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一章节</a>讨论这些内容。在此之前，我们将会使用更为简洁的函数组件。</p>
<h3 id="Rendering-a-Component-渲染一个组件"><a href="#Rendering-a-Component-渲染一个组件" class="headerlink" title="Rendering a Component(渲染一个组件)"></a>Rendering a Component(渲染一个组件)</h3><p>Previously, we only encountered React elements that represent DOM tags:</p>
<p>在此之前，我们仅仅遇到过使用DOM标签表示的React元素：</p>
<pre><code>const element = &lt;div /&gt;;
</code></pre><p>However, elements can also represent user-defined components:</p>
<p>然而，元素也可以代表用户自定义的组件：</p>
<pre><code>const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;
</code></pre><p>When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object “props”.</p>
<p>当React遇到一个用户自定义的组件时，他就会传递JSX属性作为单一的对象给它们的组件。我们称之为对象的“属性”。</p>
<p>For example, this code renders “Hello, Sara” on the page:</p>
<p>例如，以下代码将会把“Hello, Sara”渲染到页面上：</p>
<pre><code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;
ReactDOM.render(
  element,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/rendering-a-component" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Let’s recap what happens in this example:</p>
<p>让我们回顾一下上述代码发生了什么：</p>
<ol>
<li>We call <code>ReactDOM.render()</code> with the <code><welcome name="Sara"></welcome></code> element.</li>
<li>React calls the <code>Welcome</code> component with <code>{name: ‘Sara’}</code> as the props.</li>
<li>Our <code>Welcome</code> component returns a <code>Hello, Sara</code> element as the result.</li>
<li>React DOM efficiently updates the DOM to match <code>Hello, Sara</code>.</li>
</ol>
<hr>
<ol>
<li>我们对<code><welcome name="Sara"></welcome></code>元素调用了<code>ReactDOM.render()</code>。</li>
<li>React调用了<code>Welcome</code>组件，并将<code>{name: ‘Sara’}</code>作为参数。</li>
<li>我们的<code>Welcome</code>返回一个<code>Hello, Sara</code>元素作为结果。</li>
<li>React DOM会很快更新DOM，并显示<code>Hello, Sara</code>。</li>
</ol>
<blockquote>
<p>Note: Always start component names with a capital letter.<br>React treats components starting with lowercase letters as DOM tags. For example, <code>div</code> represents an HTML div tag, but <code>Welcome</code> represents a component and requires Welcome to be in scope.<br>You can read more about the reasoning behind this convention <a href="https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized" target="_blank" rel="noopener">here</a>.</p>
</blockquote>
<hr>
<blockquote>
<p>注意：通常一个组件的命名是以大写字母开始的。<br>React会将以小写字母开头的组件视为DOM标签。例如，<code>div</code>表示一个HTML div标签，但<code>Welcome</code>表示一个组件，并且要求Welcome在作用域内。<br>您可以在<a href="https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized" target="_blank" rel="noopener">这里</a>阅读更多关于背后的内容。</p>
</blockquote>
<h3 id="Composing-Components-构成组件"><a href="#Composing-Components-构成组件" class="headerlink" title="Composing Components(构成组件)"></a>Composing Components(构成组件)</h3><p>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</p>
<p>组件能在它们的输出中引用其他的组件。这让我们可以对任何有相同内容的细节抽象出相同的部分。例如一个按钮，一个表格，一个对话框，一个屏幕：在React应用程序中，所有这些都通常表示为组件。</p>
<p>For example, we can create an App component that renders Welcome many times:</p>
<p>例如，我们可以创建一个App组件来渲染很多遍Welcome：</p>
<pre><code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

function App() {
  return (
    &lt;div&gt;
      &lt;Welcome name=&quot;Sara&quot; /&gt;
      &lt;Welcome name=&quot;Cahal&quot; /&gt;
      &lt;Welcome name=&quot;Edite&quot; /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/composing-components" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Typically, new React apps have a single <code>App</code> component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like <code>Button</code> and gradually work your way to the top of the view hierarchy.</p>
<p>通常情况下，一个新的React<code>APP</code>会在顶层架构上有单一的应用组件。但是，如果您将React集成到现有的应用程序中，则可以使用<code>Button</code>之类的小组件自下而上地嵌入进去，并逐渐转向视图层次结构的顶部。</p>
<h3 id="Extracting-Components-抽象组件"><a href="#Extracting-Components-抽象组件" class="headerlink" title="Extracting Components(抽象组件)"></a>Extracting Components(抽象组件)</h3><p>Don’t be afraid to split components into smaller components.</p>
<p>永远不要担心将组件分成更小的组件。</p>
<p>For example, consider this <code>Comment</code> component:</p>
<p>观看下列例子，考虑<code>Comment</code>组件：</p>
<pre><code>function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;img className=&quot;Avatar&quot;
          src={props.author.avatarUrl}
          alt={props.author.name}
        /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/extracting-components" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>It accepts author (an object), text (a string), and date (a date) as props, and describes a comment on a social media website.</p>
<p>它会接受用户(一个对象)，文本(一个字符串)，和日期(一个时间)作为参数，并且可以描述一个社交媒体平台上的一个评论。</p>
<p>This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let’s extract a few components from it.</p>
<p>因为有大量的嵌套，这个组件可能会变得很棘手，并且它的单一部分也很难复用。让我们将它抽象成一些小的组件。</p>
<p>First, we will extract Avatar:</p>
<p>首先，我们会抽象出Avatar：</p>
<pre><code>function Avatar(props) {
  return (
    &lt;img className=&quot;Avatar&quot;
      src={props.user.avatarUrl}
      alt={props.user.name}
    /&gt;

  );
}
</code></pre><p>The Avatar doesn’t need to know that it is being rendered inside a Comment. This is why we have given its prop a more generic name: user rather than author.</p>
<p>Avatar不需要知道它是否被渲染在一个评论中。这也是为什么我们可以将它的参数设置为一个更符合的名字：使用user而不是author</p>
<p>We recommend naming props from the component’s own point of view rather than the context in which it is being used.</p>
<p>我们建议从组件自身的角度命名参数而不是从它使用的环境下命名。</p>
<p>We can now simplify Comment a tiny bit:</p>
<p>因此我们可以将评论简化一些：</p>
<pre><code>function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;Avatar user={props.author} /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>Next, we will extract a UserInfo component that renders an Avatar next to the user’s name:</p>
<p>接下来，我们将会将UserInfo组件抽象出来，该组件会将Avatar呈现给旁边的用户的姓名出来：</p>
<pre><code>function UserInfo(props) {
  return (
    &lt;div className=&quot;UserInfo&quot;&gt;
      &lt;Avatar user={props.user} /&gt;
      &lt;div className=&quot;UserInfo-name&quot;&gt;
        {props.user.name}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>This lets us simplify Comment even further:</p>
<p>这样Comment比之前更加简化了。</p>
<pre><code>function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;UserInfo user={props.author} /&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/extracting-components-continued" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be a reusable component.</p>
<p>首先提取组件可能看起来像重复工作，但在更大的应用程序中，我们可以提取出可重用的部分。一个好的经验法则是，如果你的用户界面的一部分被多次使用（按钮，面板，头像），或者它本身已经足够复杂，那么它会是一个好的可重用组件的选择。</p>
<h3 id="Props-are-Read-Only-属性是只读的"><a href="#Props-are-Read-Only-属性是只读的" class="headerlink" title="Props are Read-Only(属性是只读的)"></a>Props are Read-Only(属性是只读的)</h3><p>Whether you declare a component as a function or a class, it must never modify its own props. Consider this sum function:</p>
<p>不管您是否是通过函数或者类来声明组件的，它永远都不能修改属于它自己的参数。考虑下面的加法函数：</p>
<pre><code>function sum(a, b) {
  return a + b;
}
</code></pre><p>Such functions are called <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“pure”</a> because they do not attempt to change their inputs, and always return the same result for the same inputs.</p>
<p>这样的函数是<a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“纯函数”</a>，因为它们不会试图改变它们的输入，并总会对于相同的输入返回相同的值。</p>
<p>In contrast, this function is impure because it changes its own input:</p>
<p>相反的，下面这个函数就是动机不纯的，因为它会改变它本身的输入：</p>
<pre><code>function withdraw(account, amount) {
  account.total -= amount;
}
</code></pre><p>React is pretty flexible but it has a single strict rule:</p>
<p>React十分灵活，但是它有一个特别严格的规定：</p>
<p><strong>All React components must act like pure functions with respect to their props.</strong></p>
<p><strong>所有的React组件都必须表现的想一个纯函数一样，并不会修改它们的属性。</strong></p>
<p>Of course, application UIs are dynamic and change over time. In the <a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">next section</a>, we will introduce a new concept of “state”. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.</p>
<p>当然，应用的UI是动态的，并且会随时间的改变而改变。在<a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一章节</a>中，我们会介绍一个新的概念“状态”。状态允许React组件随着用户的动作，网络的反馈和任何其他事情的来随时改变它们的输出，并且不会违背这个规则。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 03.Rendering Elements]]></title>
      <url>/2018/05/04/react/02.Quick_Start/03.Rendering_Elements/</url>
      <content type="html"><![CDATA[<h2 id="Rendering-Elements"><a href="#Rendering-Elements" class="headerlink" title="Rendering Elements"></a>Rendering Elements</h2><p>Elements are the smallest building blocks of React apps.</p>
<p>元素是React 应用中最小的构建组块。</p>
<p>An element describes what you want to see on the screen:</p>
<p>以下是一个描述了您在在屏幕上想看到的元素：</p>
<pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
</code></pre><p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p>
<p>不想浏览器的DOM元素，React元素是普通对象，并且很容易创建。React DOM负责更新DOM以便于匹配React元素。</p>
<blockquote>
<p>Note:<br>One might confuse elements with a more widely known concept of “components”. We will introduce components in the <a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">next section</a>. Elements are what components are “made of”, and we encourage you to read this section before jumping ahead.</p>
<p>注意：<br>人们可能会将元素与更广为人知的“组件”概念混为一谈。 我们将在<a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">下一部分</a>介绍组件。 组件是由元素“组成”的，我们鼓励您在跳过本节之前先阅读本节内容。</p>
</blockquote>
<h3 id="Rendering-an-Element-into-the-DOM-渲染一个在DOM中的元素"><a href="#Rendering-an-Element-into-the-DOM-渲染一个在DOM中的元素" class="headerlink" title="Rendering an Element into the DOM(渲染一个在DOM中的元素)"></a>Rendering an Element into the DOM(渲染一个在DOM中的元素)</h3><p>Let’s say there is a <code><div></div></code> somewhere in your HTML file:</p>
<p>以下是一个在您的HTML文件中的<code><div></div></code></p>
<pre><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre><p>We call this a “root” DOM node because everything inside it will be managed by React DOM.</p>
<p>我们叫它为“root”DOM节点，因为它其中的所有元素都由React DOM控制。</p>
<p>Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.</p>
<p>仅使用React构建的应用程序通常只有单个根DOM节点。如果您将React集成到现有的应用程序中，您可以根据需要选择多个独立的根DOM节点。</p>
<p>To render a React element into a root DOM node, pass both to <code>ReactDOM.render()</code>:</p>
<p>为了将一个React元素渲染到一个根DOM节点，将它们全部传给<code>ReactDOM.render()</code>:</p>
<pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
ReactDOM.render(element, document.getElementById(&#39;root&#39;));
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/rendering-elements/render-an-element" target="_blank" rel="noopener">Try it on CodePen</a></p>
<p>It displays “Hello, world” on the page.</p>
<p>它将会在页面上显示“Hello, world”。</p>
<h3 id="Updating-the-Rendered-Element-更新渲染的元素"><a href="#Updating-the-Rendered-Element-更新渲染的元素" class="headerlink" title="Updating the Rendered Element(更新渲染的元素)"></a>Updating the Rendered Element(更新渲染的元素)</h3><p>React elements are <code>immutable</code>. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</p>
<p>React元素是<code>不可变的</code>。一旦您创建了一个元素，您就不能改变它的子元素或者属性。一个元素就像电影里的一帧：它代表着一个特定时间点的UI。</p>
<p>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to <code>ReactDOM.render()</code>.</p>
<p>以我们目前所有的知识，更新UI的唯一方法就是创建一个新的元素，并将它传给<code>ReactDOM.render()</code>。</p>
<p>Consider this ticking clock example:</p>
<p>考虑以下秒表的例子：</p>
<pre><code>function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
  ReactDOM.render(element, document.getElementById(&#39;root&#39;));
}

setInterval(tick, 1000);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">Try it on CodePen</a></p>
<p>It calls <code>ReactDOM.render()</code> every second from a setInterval() callback.</p>
<p>它会每秒从setInterval()函数的回调函数中调用<code>ReactDOM.render()</code>。</p>
<blockquote>
<p>Note:<br>In practice, most React apps only call <code>ReactDOM.render()</code> once. In the next sections we will learn how such code gets encapsulated into stateful components.<br>We recommend that you don’t skip topics because they build on each other.</p>
<p>注意：<br>在实际使用过程中，大多数的React应用仅仅只调用<code>ReactDOM.render()</code>一次。在接下来的部分中，我们将学习如何将这些代码封装到有状态的组件中。<br>我们建议您不要跳过这些内容，因为它们互相之间都有联系。</p>
</blockquote>
<h3 id="React-Only-Updates-What’s-Necessary-React只有在必须的时候才会更新"><a href="#React-Only-Updates-What’s-Necessary-React只有在必须的时候才会更新" class="headerlink" title="React Only Updates What’s Necessary(React只有在必须的时候才会更新)"></a>React Only Updates What’s Necessary(React只有在必须的时候才会更新)</h3><p>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</p>
<p>React DOM 会将元素和它的子元素与上一个状态的元素和子元素比较，并且只在DOM必须更新的时候才会让DOM变化到期待的状态。</p>
<p>You can verify by inspecting the <a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">last example</a> with the browser tools:</p>
<p>您可以通过浏览器工具监视<a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">最后一个例子</a>。</p>
<p><img src="/images/react_document/02-03-ticking_click.gif"></p>
<p>Even though we create an element describing the whole UI tree on every tick, only the text node whose contents has changed gets updated by React DOM.</p>
<p>尽管我们创建了一个元素来描述在每秒钟的整个结构，但是只有内容改变的文本节点会被React DOM更新。</p>
<p>In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.</p>
<p>根据我们的经验，思考如何在任何特定时刻看到UI，而不是随着时间的推移如何改变，从而消除了一整类错误。根据我们的经验，考率如何在任何特定时刻看到特定的样式，而不是随着时间的推移而变化，只有这样做才能消除了一系列相关的错误。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 02.Introducing JSX]]></title>
      <url>/2018/05/04/react/02.Quick_Start/02.Introducing_JSX/</url>
      <content type="html"><![CDATA[<h2 id="Introducing-JSX"><a href="#Introducing-JSX" class="headerlink" title="Introducing JSX"></a>Introducing JSX</h2><p>Consider this variable declaration:</p>
<p>考虑以下变量声明：</p>
<pre><code>const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
</code></pre><p>This funny tag syntax is neither a string nor HTML.</p>
<p>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</p>
<p>它叫做JSX，并且它是基于JavaScript的语法进行扩展的。我们建议是在React中使用它来描述UI的样式。JSX也许让您想起一些模板语言，但是它具有JavaScript的全部功能。</p>
<p>JSX produces React “elements”. We will explore rendering them to the DOM in the <a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener">next section</a>. Below, you can find the basics of JSX necessary to get you started.</p>
<p>JSX生成了React“元素”。我们将在<a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener">下一章节</a>内探索它是如果将React渲染到DOM上的。除此之外，您还可以学习到使用JSX的基本知识。</p>
<h3 id="Why-JSX-为什么使用JSX"><a href="#Why-JSX-为什么使用JSX" class="headerlink" title="Why JSX?(为什么使用JSX?)"></a>Why JSX?(为什么使用JSX?)</h3><p>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.</p>
<p>React认为渲染逻辑与其他UI逻辑是有耦合的：事件如何处理，状态如何随时间变化以及数据如何准备显示。</p>
<p>Instead of artificially separating technologies by putting markup and logic in separate files, React <a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">separates concerns</a> with loosely coupled units called “components” that contain both. We will come back to components in a <a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">further section</a>, but if you’re not yet comfortable putting markup in JS, <a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank" rel="noopener">this talk</a> might convince you otherwise.</p>
<p>React不再人为地通过将标记和逻辑放在单独的文件中来分离技术，React通过将问题与“组件”–一个松散耦合的单元<a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">分隔开</a>。我们将在<a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">接下来的章节内</a>回到组件中，但如果你不习惯在JS中添加标记，那么<a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank" rel="noopener">这个话题</a>可能会让你习惯这个改变。</p>
<p>React <a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">doesn’t require</a> using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.</p>
<p>React<a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">不需要</a>使用JSX，但是大多数人认为在JavaScript代码中使用它时，有助于从视觉上更清晰地理解代码。它还允许React显示更多有用的错误和警告消息。</p>
<p>With that out of the way, let’s get started!</p>
<p>那就这样，让我们开始吧！</p>
<h3 id="Embedding-Expressions-in-JSX-在JSX中嵌入表达式"><a href="#Embedding-Expressions-in-JSX-在JSX中嵌入表达式" class="headerlink" title="Embedding Expressions in JSX(在JSX中嵌入表达式)"></a>Embedding Expressions in JSX(在JSX中嵌入表达式)</h3><p>You can embed any <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript expression</a> in JSX by wrapping it in curly braces.</p>
<p>您可以用大括号在JSX中包括任何<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript表达式</a>。</p>
<p>For example, <code>2 + 2</code>, <code>user.firstName</code>, and <code>formatName(user)</code> are all valid expressions:</p>
<p>例如，<code>2 + 2</code>, <code>user.firstName</code>, and <code>formatName(user)</code>都是有效的表达式：</p>
<pre><code>function formatName(user) {
  return user.firstName + &#39; &#39; + user.lastName;
}

const user = {
  firstName: &#39;Harper&#39;,
  lastName: &#39;Perez&#39;
};

const element = (
  &lt;h1&gt;
    Hello, {formatName(user)}!
  &lt;/h1&gt;
);

ReactDOM.render(
  element,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/introducing-jsx" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>We split JSX over multiple lines for readability. While it isn’t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of <a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">automatic semicolon insertion</a>.</p>
<p>为了便于阅读，我们将JSX分成多行。虽然这不是必需的，但是我们还建议将其包装在括号内以避免<a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">自动分号插入</a>的缺陷。</p>
<h3 id="JSX-is-an-Expression-Too-JSX也是一个表达式"><a href="#JSX-is-an-Expression-Too-JSX也是一个表达式" class="headerlink" title="JSX is an Expression Too(JSX也是一个表达式)"></a>JSX is an Expression Too(JSX也是一个表达式)</h3><p>After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects.</p>
<p>在编译完后，JSX表达式会变成常规的JavaScript方法的调用，并且会转为JavaScript对象。</p>
<p>This means that you can use JSX inside of <code>if</code> statements and <code>for</code> loops, assign it to variables, accept it as arguments, and return it from functions:</p>
<p>这意味着您可以在if语句和for循环中使用JSX，将其分配给变量，将其作为参数接受，并从函数中返回：</p>
<pre><code>function getGreeting(user) {
  if (user) {
    return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;
  }
  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;
}
</code></pre><h3 id="Specifying-Attributes-with-JSX-使用JSX指定属性"><a href="#Specifying-Attributes-with-JSX-使用JSX指定属性" class="headerlink" title="Specifying Attributes with JSX(使用JSX指定属性)"></a>Specifying Attributes with JSX(使用JSX指定属性)</h3><p>You may use quotes to specify string literals as attributes:</p>
<p>您可以使用引号将字符串文字指定为属性：</p>
<pre><code>const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;
</code></pre><p>You may also use curly braces to embed a JavaScript expression in an attribute:</p>
<p>您也可以使用大括号包裹JavaScript表达式作为属性：</p>
<pre><code>const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;
</code></pre><p>Don’t put quotes around curly braces when embedding a JavaScript expression in an attribute. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.</p>
<p>当将JavaScript表达式作为属性时，不要在大括号外边加引号。您应该要么使用引号（对于字符串的值来说）或者大括号（对于表达式来说）,但是不能两者一起使用。</p>
<blockquote>
<p>Warning:<br>Since JSX is closer to JavaScript than to HTML, React DOM uses camelCase property naming convention instead of HTML attribute names.<br>For example, class becomes className in JSX, and tabindex becomes tabIndex.</p>
<p>警告：<br>因为JSX相对于HTML来说更接近于JavaScript，React Dom使用传统的驼峰命名方法来命名，而不是像HTML属性一样命名。<br>例如，在JSX中，class应该是className，tabindex应该是tabIndex</p>
</blockquote>
<h3 id="Specifying-Children-with-JSX-用JSX指定子元素"><a href="#Specifying-Children-with-JSX-用JSX指定子元素" class="headerlink" title="Specifying Children with JSX(用JSX指定子元素)"></a>Specifying Children with JSX(用JSX指定子元素)</h3><p>If a tag is empty, you may close it immediately with <code>/&gt;</code>, like XML:</p>
<p>如果一个标签是空的，您应该立即使用<code>/&gt;</code>的方式关闭它，像XML一样：</p>
<pre><code>const element = &lt;img src={user.avatarUrl} /&gt;;
</code></pre><p>JSX tags may contain children:</p>
<p>JSX标签可以包含子元素：</p>
<pre><code>const element = (
  &lt;div&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;h2&gt;Good to see you here.&lt;/h2&gt;
  &lt;/div&gt;
);
</code></pre><h3 id="JSX-Prevents-Injection-Attacks-JSX可以防止注入攻击"><a href="#JSX-Prevents-Injection-Attacks-JSX可以防止注入攻击" class="headerlink" title="JSX Prevents Injection Attacks(JSX可以防止注入攻击)"></a>JSX Prevents Injection Attacks(JSX可以防止注入攻击)</h3><p>It is safe to embed user input in JSX:</p>
<p>将用户输入置于JSX中是安全的：</p>
<pre><code>const title = response.potentiallyMaliciousInput;
// This is safe:
const element = &lt;h1&gt;{title}&lt;/h1&gt;;
</code></pre><p>By default, React DOM <a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">escapes</a> any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS (cross-site-scripting)</a> attacks.</p>
<p>默认情况下，React DOM在渲染之前会<a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">转义</a>嵌入在JSX中的任何值。因此它确保您永远不会注入任何未明确的写入应用程序中的内容。在呈现之前，所有内容都会转换为字符串。这有助于防止<a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS(跨站点脚本)</a>攻击。</p>
<h3 id="JSX-Represents-Objects-JSX表示对象"><a href="#JSX-Represents-Objects-JSX表示对象" class="headerlink" title="JSX Represents Objects(JSX表示对象)"></a>JSX Represents Objects(JSX表示对象)</h3><p>Babel compiles JSX down to <code>React.createElement()</code> calls.</p>
<p>Babel会将JSX编译成<code>React.createElement()</code>的调用。</p>
<p>These two examples are identical:</p>
<p>以下两个例子是一样的：</p>
<pre><code>const element = (
  &lt;h1 className=&quot;greeting&quot;&gt;
    Hello, world!
  &lt;/h1&gt;
);
</code></pre><pre><code>const element = React.createElement(
  &#39;h1&#39;,
  {className: &#39;greeting&#39;},
  &#39;Hello, world!&#39;
);
</code></pre><p><code>React.createElement()</code> performs a few checks to help you write bug-free code but essentially it creates an object like this:</p>
<p><code>React.createElement()</code>会执行一些检查来帮助您编写无错代码，但本质上它会创建一个如下所示的对象：</p>
<pre><code>// Note: this structure is simplified
const element = {
  type: &#39;h1&#39;,
  props: {
    className: &#39;greeting&#39;,
    children: &#39;Hello, world!&#39;
  }
};
</code></pre><p>These objects are called “React elements”. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.</p>
<p>这些对象被称为“React元素”。你可以把它们想象成你想要在屏幕上看到的东西。React会读取这些对象并使用它们来构建DOM并使其保持最新状态。</p>
<p>We will explore rendering React elements to the DOM in the next section.</p>
<p>我们将会在下一章里探索如何在DOM中渲染React元素。</p>
<blockquote>
<p>Tip:<br>We recommend using the <a href="http://babeljs.io/docs/editors" target="_blank" rel="noopener">“Babel” language definition</a> for your editor of choice so that both ES6 and JSX code is properly highlighted. This website uses the <a href="https://labs.voronianski.com/oceanic-next-color-scheme/" target="_blank" rel="noopener">Oceanic Next</a> color scheme which is compatible with it.<br>提示：<br>我们将以使用<a href="http://babeljs.io/docs/editors" target="_blank" rel="noopener">“Babel”语言定义</a>作为您的编译器，以便正确突出显示ES6和JSX代码。本网站采用与其兼容的Oceanic Next色彩方案。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 01.Hello World]]></title>
      <url>/2018/05/04/react/02.Quick_Start/01.Hello_World/</url>
      <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h4>The easiest way to get started with React is to use <a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">this Hello World example code on CodePen</a>. You don’t need to install anything; you can just open it in another tab and follow along as we go through examples. If you’d rather use a local development environment, check out the <a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">Installation</a> section.</h4>

<h4>开始学习React最简单的方式是使用<a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">Codepen上的Hello World的例子</a>。您不必安装任何东西；您只需要在另一个窗口打开就能查看我们写下的例子。如果您想在本地搭建环境，请查看<a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">安装</a>章节。</h4>

<hr>
<p>The smallest React example looks like this:</p>
<p>最小的React例子像这个样子：</p>
<pre><code>ReactDOM.render(
  &lt;h1&gt;Hello, world!&lt;/h1&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>It renders a heading saying “Hello, world!” on the page.</p>
<p>它将会在页面上渲染一个写着“Hello World”的标题。</p>
<p>The next few sections will gradually introduce you to using React. We will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.</p>
<p>接下来的章节将会逐渐向您介绍如何使用React。我们将检查React应用程序的构建部分：元素和组件。一旦您掌握了它们，您就可以通过小型可重复使用的部分创建复杂的应用程序。</p>
<h3 id="A-Note-on-JavaScript-一个关于JavaScript的注意点"><a href="#A-Note-on-JavaScript-一个关于JavaScript的注意点" class="headerlink" title="A Note on JavaScript(一个关于JavaScript的注意点)"></a>A Note on JavaScript(一个关于JavaScript的注意点)</h3><p>React is a JavaScript library, and so we’ll assume you have a basic understanding of the JavaScript language. If you don’t feel very confident, we recommend <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">refreshing your JavaScript knowledge</a> so you can follow along more easily.</p>
<p>React是一个JavaScript库，因此我们假设您对于JavaScript语言有一个基本的了解。如果您不是很自信，我们建议您<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">重新回顾JavaScript的相关知识</a>，以便能让您在接下来的内容上更容易。</p>
<p>We also use some of the ES6 syntax in the examples. We try to use it sparingly because it’s still relatively new, but we encourage you to get familiar with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow functions</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">classes</a>, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">template literals</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">let</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener">const</a> statements. You can use the <a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA" target="_blank" rel="noopener">Babel REPL</a> to check what ES6 code compiles to.</p>
<p>我们在案例中也使用了一些ES6的语法。我们尽量少的使用它们，因为它们还相对较新，但是我们还是建议您熟悉<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">类</a>，<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">模板字面量</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">let</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener">const</a>等概念。您可以使用<a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA" target="_blank" rel="noopener">Babel REPL</a>来查看ES6代码编译过后的结果。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 04.CDN Links]]></title>
      <url>/2018/05/03/react/01.Try_React/04.CDN_Links/</url>
      <content type="html"><![CDATA[<h2 id="CDN-Links-CDN链接"><a href="#CDN-Links-CDN链接" class="headerlink" title="CDN Links(CDN链接)"></a>CDN Links(CDN链接)</h2><p>The UMD builds of React and ReactDOM are available over a CDN.</p>
<p>React和ReactDOM的UMD版本可通过CDN获得。</p>
<pre><code>&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;
</code></pre><p>The versions above are only meant for development, and are not suitable for production. </p>
<p>以上版本仅用于开发，不适合生产。</p>
<p>Minified and optimized production versions of React are available at:</p>
<p>缩小和优化的React生产版本可以用以下方式获得：</p>
<pre><code>&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.production.min.js&quot;&gt;&lt;/script&gt;
&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt;
</code></pre><p>To load a specific version of <code>react</code> and <code>react-dom</code>, replace <code>16</code> with the version number.</p>
<p>如果要加载特定版本的<code>react</code>和<code>react-dom</code>，请将<code>16</code>替换为对应的版本号。</p>
<h3 id="Why-the-crossorigin-Attribute-为什么要设置crossorigin属性"><a href="#Why-the-crossorigin-Attribute-为什么要设置crossorigin属性" class="headerlink" title="Why the crossorigin Attribute?(为什么要设置crossorigin属性?)"></a>Why the crossorigin Attribute?(为什么要设置crossorigin属性?)</h3><p>If you serve React from a CDN, we recommend to keep the crossorigin <code>attribute set</code>:</p>
<p>如果您使用基于CDN的React，我们建议保留crossorigin<code>属性集</code>：</p>
<pre><code>&lt;script crossorigin src=&quot;...&quot;&gt;&lt;/script&gt;
</code></pre><p>We also recommend to verify that the CDN you are using sets the <code>Access-Control-Allow-Origin: *</code> HTTP header:</p>
<p>我们还建议验证您使用的CDN是否设置了<code>Access-Control-Allow-Origin：* </code>HTTP标头：</p>
<p><img src="/images/react_document/01-04-access_control_allow_origin.png" alt="Access-Control-Allow-Origin:*HTTP header"></p>
<p>This enables a better <a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">error handling experience</a> in React 16 and later.</p>
<p>这可以保证在React16或更高的版本上有一个更好的<a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">错误处理方法</a>。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 03.Add React to an Existing Application]]></title>
      <url>/2018/05/03/react/01.Try_React/03.Add_React_to_an_Existing_Application/</url>
      <content type="html"><![CDATA[<h2 id="Add-React-to-an-Existing-Application-在一个已存的项目中添加React"><a href="#Add-React-to-an-Existing-Application-在一个已存的项目中添加React" class="headerlink" title="Add React to an Existing Application(在一个已存的项目中添加React)"></a>Add React to an Existing Application(在一个已存的项目中添加React)</h2><p>You don’t need to rewrite your app to start using React.</p>
<p>您不必重写您的应用程序来开始使用React</p>
<p>We recommend adding React to a small part of your application, such as an individual widget, so you can see if it works well for your use case.</p>
<p>我们建议将React添加到应用程序中的一小部分中，例如单个小部件，以便您可以查看它是否适合您的用例。</p>
<p>While React <a href="https://reactjs.org/docs/react-without-es6.html" target="_blank" rel="noopener">can be used</a> without a build pipeline, we recommend setting it up so you can be more productive. A modern build pipeline typically consists of:</p>
<p>虽然<a href="https://reactjs.org/docs/react-without-es6.html" target="_blank" rel="noopener">可以</a>在没有构建通道的情况下使用React，但我们建议设置通道，以此来提高生产力。现代构建通道通常由以下部分组成：</p>
<ul>
<li>A <strong>package manager</strong>, such as <a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a> or <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>. It lets you take advantage of a vast ecosystem of third-party packages, and easily install or update them.</li>
<li>A <strong>bundler</strong>, such as <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> or <a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>. It lets you write modular code and bundle it together into small packages to optimize load time.</li>
<li>A compiler such as <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>. It lets you write modern JavaScript code that still works in older browsers.</li>
</ul>
<hr>
<ul>
<li>一个<strong>包管理器</strong>，如<a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a>或<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>。它可让您充分利用第三方软件包的完整的生态系统，并轻松安装或更新它们。</li>
<li>一个<strong>捆绑器</strong>，如<a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a>或<a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>。它允许您编写模块化代码，并将它们组合在一起成为小包，以优化加载时间。</li>
<li>一个<strong>编辑器</strong>,如<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>。它可以让你在旧版浏览器中仍然可以使用的现代JavaScript代码。</li>
</ul>
<h3 id="Installing-React-安装React"><a href="#Installing-React-安装React" class="headerlink" title="Installing React(安装React)"></a>Installing React(安装React)</h3><blockquote>
<p>Note:  </p>
<h2 id="Once-installed-we-strongly-recommend-setting-up-a-production-build-process-to-ensure-you’re-using-the-fast-version-of-React-in-production"><a href="#Once-installed-we-strongly-recommend-setting-up-a-production-build-process-to-ensure-you’re-using-the-fast-version-of-React-in-production" class="headerlink" title="Once installed, we strongly recommend setting up a production build process to ensure you’re using the fast version of React in production."></a><p style="margin:0px">Once installed, we strongly recommend setting up a production build process to ensure you’re using the fast version of React in production.</p></h2><p>注意:<br>一旦完成安装，我们强烈建议您设置生成的构建流程，以此确保您可以在开发环境中使用更快版本的React。</p>
</blockquote>
<p>We recommend using <a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a> or <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> for managing front-end dependencies. If you’re new to package managers, the <a href="https://yarnpkg.com/en/docs/getting-started" target="_blank" rel="noopener">Yarn documentation</a> is a good place to get started.</p>
<p>我们建议使用<a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a>或者<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>来管理前端依赖。如果您是新接触包管理器的开发者，<a href="https://yarnpkg.com/en/docs/getting-started" target="_blank" rel="noopener">Yarn的文档</a>是一个开始学习的不错的地方。</p>
<p>To install React with Yarn, run:</p>
<p>使用Yarn安装React，请运行：</p>
<pre><code>yarn init
yarn add react react-dom
</code></pre><p>如果使用npm安装React，请运行：</p>
<pre><code>npm init
npm install --save react react-dom
</code></pre><p>Both Yarn and npm download packages from the <a href="http://npmjs.com/" target="_blank" rel="noopener">npm registry</a>.</p>
<p>Yarn和npm都从<a href="http://npmjs.com/" target="_blank" rel="noopener">npm注册表</a>中下载软件包。</p>
<blockquote>
<p>Note:<br>To prevent potential incompatibilities, all react packages should use the same version. (This includes <code>react</code>, <code>react-dom</code>, <code>react-test-renderer</code>, etc.)</p>
</blockquote>
<hr>
<blockquote>
<p>注意：<br>为了避免潜在的不兼容性，所有的react包都应该使用相同的版本。（这包括<code>react</code>, <code>react-dom</code>, <code>react-test-renderer</code>等等。）</p>
</blockquote>
<h3 id="Enabling-ES6-and-JSX-启用ES6和JSX"><a href="#Enabling-ES6-and-JSX-启用ES6和JSX" class="headerlink" title="Enabling ES6 and JSX(启用ES6和JSX)"></a>Enabling ES6 and JSX(启用ES6和JSX)</h3><p>We recommend using React with <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a> to let you use ES6 and JSX in your JavaScript code. ES6 is a set of modern JavaScript features that make development easier, and JSX is an extension to the JavaScript language that works nicely with React.</p>
<p>我们建议在React上使用<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>以便让您在您的JavaScript代码中使用ES6和JSX。ES6包括一系列的现代化JavaScript特性，以便让开发更容易，并且JSX是一个JavaScript语言的扩展，以便让React工作更方便。</p>
<p>The <a href="https://babeljs.io/docs/setup/" target="_blank" rel="noopener">Babel setup instructions</a> explain how to configure Babel in many different build environments. Make sure you install <a href="http://babeljs.io/docs/plugins/preset-react/#basic-setup-with-the-cli-" target="_blank" rel="noopener">babel-preset-react</a> and <a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="noopener">babel-preset-env</a> and enable them in your <a href="http://babeljs.io/docs/usage/babelrc/" target="_blank" rel="noopener">.babelrc configuration</a>, and you’re good to go.</p>
<p><a href="https://babeljs.io/docs/setup/" target="_blank" rel="noopener">Babel设置介绍</a>解释了如何在许多不同的构建环境中配置Babel。以此可以确保您安装了<a href="http://babeljs.io/docs/plugins/preset-react/#basic-setup-with-the-cli-" target="_blank" rel="noopener">babel-preset-react</a>和<a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="noopener">babel-preset-env</a>，并在你的<a href="http://babeljs.io/docs/usage/babelrc/" target="_blank" rel="noopener">.babelrc configuration</a>中启用它们，并且可以方便访问。</p>
<h3 id="Hello-World-with-ES6-and-JSX-使用ES6和JSX编写Hello-World"><a href="#Hello-World-with-ES6-and-JSX-使用ES6和JSX编写Hello-World" class="headerlink" title="Hello World with ES6 and JSX(使用ES6和JSX编写Hello World)"></a>Hello World with ES6 and JSX(使用ES6和JSX编写Hello World)</h3><p>We recommend using a bundler like <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> or <a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>, so you can write modular code and bundle it together into small packages to optimize load time.</p>
<p>我们建议使用像<a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a>或者<a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>这样的捆绑器，这样您就可以编写现代化代码并将他们绑定在小的包上以优化加载时间。</p>
<p>The smallest React example looks like this：</p>
<p>最小的React案例如下：</p>
<pre><code>import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

ReactDOM.render(
  &lt;h1&gt;Hello, world!&lt;/h1&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>This code renders into a DOM element with the id of <code>root</code>, so you need <code><div id="root"></div> </code>somewhere in your HTML file.</p>
<p>这些代码会在一个id为<code>root</code>的DOM元素上渲染，所以您需要在您的HTML文件上有<code><div id="root"></div></code>。</p>
<p>Similarly, you can render a React component inside a DOM element somewhere inside your existing app written with any other JavaScript UI library.</p>
<p>相似的，您可以在现有的，由其他任何JavaScript UI库编写的应用程序内的某个DOM元素内部渲染一个React组件。</p>
<p><a href="https://reactjs.org/docs/integrating-with-other-libraries.html#integrating-with-other-view-libraries" target="_blank" rel="noopener">Learn more about integrating React with existing code.</a></p>
<p><a href="https://reactjs.org/docs/integrating-with-other-libraries.html#integrating-with-other-view-libraries" target="_blank" rel="noopener">了解有关将React与现有代码集成的更多信息。</a></p>
<h3 id="A-Complete-Example-一个完整的例子"><a href="#A-Complete-Example-一个完整的例子" class="headerlink" title="A Complete Example(一个完整的例子)"></a>A Complete Example(一个完整的例子)</h3><p>You can find step-by-step instructions detailing a basic implementation from scratch, including Babel and Webpack setup <a href="https://medium.com/@JedaiSaboteur/creating-a-react-app-from-scratch-f3c693b84658" target="_blank" rel="noopener">here</a>.</p>
<p>您可以从零开始找到详细的说明,<a href="https://medium.com/@JedaiSaboteur/creating-a-react-app-from-scratch-f3c693b84658" target="_blank" rel="noopener">这</a>也包括如何设置Babel和Webpack。</p>
<h3 id="Development-and-Production-Versions-开发和生成环境的版本"><a href="#Development-and-Production-Versions-开发和生成环境的版本" class="headerlink" title="Development and Production Versions(开发和生成环境的版本)"></a>Development and Production Versions(开发和生成环境的版本)</h3><p>By default, React includes many helpful warnings. These warnings are very useful in development.</p>
<p>通常情况下，React包括许多有用的警告。这些警告对于开发非常有用。</p>
<p><strong>However, they make the development version of React larger and slower so you should use the production version when you deploy the app.</strong></p>
<p><strong>但是，它们会使React的开发版本变得更大并且更慢，所以当您部署应用程序时，请使用生产版本</strong></p>
<p>Learn <a href="https://reactjs.org/docs/optimizing-performance.html#use-the-production-build" target="_blank" rel="noopener">how to tell if your website is serving the right version of React</a>, and how to configure the production build process most efficiently:</p>
<p>了解<a href="https://reactjs.org/docs/optimizing-performance.html#use-the-production-build" target="_blank" rel="noopener">如何判断您的网站是否提供正确版本的React</a>，以及如何最有效地配置生产构建过程：</p>
<ul>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#create-react-app" target="_blank" rel="noopener">Creating a Production Build with Create React App</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#single-file-builds" target="_blank" rel="noopener">Creating a Production Build with Single-File Builds</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#brunch" target="_blank" rel="noopener">Creating a Production Build with Brunch</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#browserify" target="_blank" rel="noopener">Creating a Production Build with Browserify</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#rollup" target="_blank" rel="noopener">Creating a Production Build with Rollup</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#webpack" target="_blank" rel="noopener">Creating a Production Build with webpack</a></li>
</ul>
<hr>
<ul>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#create-react-app" target="_blank" rel="noopener">使用Create React App来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#single-file-builds" target="_blank" rel="noopener">使用单个文件构建来实现生产环境构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#brunch" target="_blank" rel="noopener">使用Brunch来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#browserify" target="_blank" rel="noopener">使用Browserify来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#rollup" target="_blank" rel="noopener">使用Rollup来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#webpack" target="_blank" rel="noopener">使用webpack来实现生产环境的构建</a></li>
</ul>
<h3 id="Using-a-CDN-使用CDN"><a href="#Using-a-CDN-使用CDN" class="headerlink" title="Using a CDN(使用CDN)"></a>Using a CDN(使用CDN)</h3><p>If you don’t want to use npm to manage client packages, the <code>react</code> and <code>react-dom</code> npm packages also provide single-file distributions in <code>umd</code> folders. See the <a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">CDN</a> page for links.</p>
<p>如果您不想用npm来管理客户端的包，<code>react</code>和<code>react-dom</code>的npm的包也提供在<code>umd</code>单个文件的发布。请<a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">CDN</a>查看相关链接。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 02.Add React to a New Application]]></title>
      <url>/2018/05/03/react/01.Try_React/02.Add_React_to_a_New_Application/</url>
      <content type="html"><![CDATA[<h2 id="Add-React-to-a-New-Application-在一个新的应用上添加React"><a href="#Add-React-to-a-New-Application-在一个新的应用上添加React" class="headerlink" title="Add React to a New Application(在一个新的应用上添加React)"></a>Add React to a New Application(在一个新的应用上添加React)</h2><p>The easiest way to get started on a new React project is by using a starter kit.</p>
<p>最简单的开始一个新的React项目的方式是使用一个入门套件。</p>
<blockquote>
<p>Note:<br>This page describes setting up a single-page application with everything you need for a comfortable development workflow, including linting, testing, production optimizations, and more. Full-featured tools like these require some time and disk space to install.<br>If you are looking for a lightweight environment to experiment with React, check out the <a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">Try React</a> page instead. <strong>A <a href="https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html" target="_blank" rel="noopener">single HTML file</a> is enough to get you started!</strong><br>Finally, if you’re not building a single-page application, you can either <a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">add React to your existing build pipeline</a> or <a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">use it from CDN</a> and <a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">without a build step</a>.</p>
</blockquote>
<hr>
<blockquote>
<p>注意:<br>本页面介绍如何设置一个单页面应用程序，其中包含您需要的所有功能以实现完整的开发工作流程，包括linting，测试，生产优化等。像这些包括全功能的工具需要一些时间和磁盘空间来安装。<br>如果您在寻找一个轻量级的环境来使用React，请查看<a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">尝试React</a>页面。<strong><a href="https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html" target="_blank" rel="noopener">一个简单的HTML文件</a>足以让您开始入门！</strong><br>最后，如果您不是在搭建一个单页面的应用，您可以查看<a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">将React添加到您现存的环境上</a> or <a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">从CDN使用React</a> and <a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">不适用搭建步骤</a>.</p>
</blockquote>
<h3 id="Create-React-App-创建React应用"><a href="#Create-React-App-创建React应用" class="headerlink" title="Create React App(创建React应用)"></a>Create React App(创建React应用)</h3><p><a href="http://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a> is the best way to start building a new React single page application. It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You’ll need to have Node &gt;= 6 on your machine.</p>
<p><a href="http://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">创建React应用</a>是开始构建新的React单页应用程序的最佳方式。 它为您设置好了开发环境，以便您可以使用最新的JavaScript功能，为开发者提供了良好的体验并从生产环境上优化了您的应用程序。注意您需要保证您的开发机上的node版本大于等于6。</p>
<pre><code>npm install -g create-react-app
create-react-app my-app

cd my-app
npm start
</code></pre><p>If you have npm 5.2.0+ installed, you may use <a href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener">npx</a> instead.</p>
<p>如果您安装的npm版本号为5.2.0+，您也可以使用<a href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener">npx</a>。</p>
<pre><code>npx create-react-app my-app

cd my-app
npm start
</code></pre><p>Create React App doesn’t handle backend logic or databases; it just creates a frontend build pipeline, so you can use it with any backend you want. It uses build tools like <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a> and <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> under the hood, but works with zero configuration.</p>
<p>创建React应用不会处理后端逻辑或者数据库；它只是创建了一个前端构建通道，所以您可以使用任何您相适应的后端语言。它基于钩子上使用像<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>和<a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a>这样的构建工具，但是在使用是时为不需要配置。</p>
<p>When you’re ready to deploy to production, running npm run build will create an optimized build of your app in the build folder. You can learn more about Create React App from its <a href="https://github.com/facebookincubator/create-react-app#create-react-app-" target="_blank" rel="noopener">README</a> and the <a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents" target="_blank" rel="noopener">User Guide</a>.</p>
<p>当您准备部署到生产环境时，您可以运行<code>npm run build</code>，在<code>build</code>文件夹中创建一个优化的应用程序版本。您可以从<a href="https://github.com/facebookincubator/create-react-app#create-react-app-" target="_blank" rel="noopener">README</a>和<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents" target="_blank" rel="noopener">用户指南</a>中了解有关创建React应用程序的更多信息。</p>
<h3 id="Other-Starter-Kits-其他的入门套件"><a href="#Other-Starter-Kits-其他的入门套件" class="headerlink" title="Other Starter Kits(其他的入门套件)"></a>Other Starter Kits(其他的入门套件)</h3><p>We have created <a href="https://reactjs.org/community/starter-kits.html" target="_blank" rel="noopener">a curated list of third-party starter kits that we officially recommend</a>.</p>
<p>我们已经创建了<a href="https://reactjs.org/community/starter-kits.html" target="_blank" rel="noopener">我们正式推荐的第三方入门套件的策划清单</a>。</p>
<p>They slightly differ in their focus but are all production-ready, well-maintained, and don’t require configuration to get started.</p>
<p>他们的重点略有不同，但在生成环境上准备就绪，并且维护良好的，不需要配置即可开始使用。</p>
<p>You can also check out a list of <a href="https://reactjs.org/community/starter-kits.html#other-starter-kits" target="_blank" rel="noopener">other kits</a> contributed by the community.</p>
<p>您还可以查看社区贡献的<a href="https://reactjs.org/community/starter-kits.html#other-starter-kits" target="_blank" rel="noopener">其他工具包列表</a>。</p>
<h3 id="Advanced-高级"><a href="#Advanced-高级" class="headerlink" title="Advanced(高级)"></a>Advanced(高级)</h3><p>If you prefer to configure a project manually, see <a href="https://reactjs.org/docs/add-react-to-an-existing-app.html#installing-react" target="_blank" rel="noopener">Installing React</a> in the next section.</p>
<p>如果您想人工配置一个项目，请在下一章节中查看<a href="https://reactjs.org/docs/add-react-to-an-existing-app.html#installing-react" target="_blank" rel="noopener">安装React</a>。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 01.Add React To A New App]]></title>
      <url>/2018/05/03/react/01.Try_React/01.Add_React_To_A_New_App/</url>
      <content type="html"><![CDATA[<h2 id="Try-React-尝试使用React"><a href="#Try-React-尝试使用React" class="headerlink" title="Try React(尝试使用React)"></a>Try React(尝试使用React)</h2><p>Try React online or set up your local development environment.</p>
<p>设置在线的react或您本地的react环境。</p>
<h3 id="Online-在线"><a href="#Online-在线" class="headerlink" title="Online(在线)"></a>Online(在线)</h3><p>If you’re just interested in playing around with React, you can use an online code playground. Try a Hello World template on <a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">CodePen</a> or <a href="https://codesandbox.io/s/new" target="_blank" rel="noopener">CodeSandbox</a>.</p>
<p>如果您只是对如何使用React有兴趣，您可以使用在线的编码器。您可以在<a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">CodePen</a>或者 <a href="https://codesandbox.io/s/new" target="_blank" rel="noopener">CodeSandbox</a>上尝试Hello World模板。</p>
<h3 id="Minimal-HTML-Template-最小的HTML模板"><a href="#Minimal-HTML-Template-最小的HTML模板" class="headerlink" title="Minimal HTML Template(最小的HTML模板)"></a>Minimal HTML Template(最小的HTML模板)</h3><p>If you prefer to use your own text editor, you can also download this HTML file, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so don’t use it in production.</p>
<p>如果您倾向于使用您自己的文本编辑器，您可以下载该HTML文件，编辑它并用浏览器在您本地文件系统上打开它。它会花费比较长的时间用来进行代码转换，所以不要在应用产品层上使用它。</p>
<h3 id="Next-Steps-下一步"><a href="#Next-Steps-下一步" class="headerlink" title="Next Steps(下一步)"></a>Next Steps(下一步)</h3><h4 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h4><ul>
<li>Head over to the <a href="https://reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">Quick Start</a> section for a step-by-step introduction to React concepts.</li>
<li><p>Try the <a href="https://reactjs.org/tutorial/tutorial.html" target="_blank" rel="noopener">Tutorial</a> for a hands-on practical example.</p>
</li>
<li><p>从<a href="https://reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">快速开始</a>部分，开始一步一步地熟悉React的内容。</p>
</li>
<li>尝试<a href="https://reactjs.org/tutorial/tutorial.html" target="_blank" rel="noopener">教程</a>部分，开始上手的练习。</li>
</ul>
<h4 id="Complete-Development-Environment-完成开发环境"><a href="#Complete-Development-Environment-完成开发环境" class="headerlink" title="Complete Development Environment(完成开发环境)"></a>Complete Development Environment(完成开发环境)</h4><p>The lightweight solutions above are the best fit if you are new to React or just experimenting.</p>
<p>如果您是新接触React，或者只是想尝试一下React的话，这种轻量级解决方案是最适合的。</p>
<p>When you are ready to build your first application with React, check out the install guides below. These setups are designed to get you up and running with a great developer experience and are ready for production. They include linting, testing, and optimizations built-in; however, they require more time and disk space to set up and install.</p>
<p>当您开始准备使用React搭建您第一个应用时，请先阅读下面的安装指南。这些步骤的目的是在让您在开发过程中获得丰富的开发体验，并且可以随时投入生产环境中使用。它们包括linting，测试和内置优化; 但是，它们需要更多时间和磁盘空间来设置和安装。</p>
<ul>
<li><a href="https://reactjs.org/docs/add-react-to-a-new-app.html" target="_blank" rel="noopener">Add React to a New App</a>: Create a new app with a fully-featured starter kit.</li>
<li><p><a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">Add React to an Existing App</a>: Add React to a build system or a larger app.</p>
</li>
<li><p><a href="https://reactjs.org/docs/add-react-to-a-new-app.html" target="_blank" rel="noopener">Add React to a New App</a>:使用包括全套功能的入门套件来创建新应用程序。</p>
</li>
<li><a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">Add React to an Existing App</a>:构建系统或更大的应用程序上添加使用React。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript对象与继承---单一继承.md]]></title>
      <url>/2018/03/16/blog/Javascript_Objects_and_Inheritance/</url>
      <content type="html"><![CDATA[<h2 id="JavaScript对象与继承–单一对象"><a href="#JavaScript对象与继承–单一对象" class="headerlink" title="JavaScript对象与继承–单一对象"></a>JavaScript对象与继承–单一对象</h2><p>说真的，这次的博客我写了三个小时硬是一点都没写出来，洋洋洒洒把自己最近的心情写了1000多字，但是感觉自己太幼稚，又删了;然后打算写大三时候给前女友写的主界面和音乐播放器，想了想，算了吧，往事随风，又删了，现在两手空空，然后纠结了半个小时，只能是写写无关痛痒的问题。</p>
<p>哈哈哈在一小时后我终于找到了这个比较符合我的情况的内容哈哈哈</p>
<p>原文在<a href="http://speakingjs.com/es5/ch17.html#single_objects" target="_blank" rel="noopener">Objects and Inheritance</a>中,不容易呀。</p>
<p>概括的讲所有的js对象都是从字符串到值的映射，一个对象中的某一项（键，值对）称作对象的属性。属性的key始终是一个字符串而值可以是任何js值，包括函数。方法是指值为函数的属性。</p>
<h3 id="属性的种类"><a href="#属性的种类" class="headerlink" title="属性的种类"></a>属性的种类</h3><p>三种属性:</p>
<ol>
<li>属性（Properties，或称为数据属性） 普通属性，在一个对象里面的一个键值对包括方法，最常用属性。</li>
<li>访问器(Accessors，或者叫访问属性) 类似于读写属性的特殊方法。属性值存在普通属性中，而访问属性可以计算他们的值。你可以把他们看作是虚拟的属性，比如（getter 和 setter）.</li>
<li>内置属性(Internal property) 只存在于ECMAscript规范当中，他们不能被js直接访问，但可以间接的方式访问到。规范里规定将这种属性放在[[]]当中，比如[[Property]]吃有一个对象的原型，它可以通过Object.getPrototypeOf() 访问到。</li>
</ol>
<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>JavaScript对象字面量允许你直接的创建简单的对象（Object直接实例）。</p>
<p>EX:</p>
<pre><code>var jane = {
    name: &#39;Jane&#39;,
    describe: function () {
        return &#39;Person named &#39;+this.name;  // (1)
    },  // (2)
};
</code></pre><p>你可能有这样的印象，对象仅仅是字符串到值的映射。事实上远不止这些，有一些真正意义上的通用对象。</p>
<p>比如你可以做对象的继承，还可以保护对象不被修改。直接创建对象的功能是标准的js特性之一：你可以在没有类的前提下创建一个正确的对象，然后再对他进行抽象。</p>
<p>例如：构造函数（constructors）大体和其他语言的类相似，我们在后面会讲到。</p>
<h3 id="点运算符-通过固定值来访问属性"><a href="#点运算符-通过固定值来访问属性" class="headerlink" title="点运算符 (.): 通过固定值来访问属性"></a>点运算符 (.): 通过固定值来访问属性</h3><p>点运算符提供了一种简洁的语法来访问属性,属性的名称必须是合法标识符. 你可以用中括号来读写任意名称的属性.</p>
<pre><code>var jane = {
    name: &#39;Jane&#39;,

    describe: function () {
        return &#39;Person named &#39;+this.name;
    }
};
</code></pre><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>点操作符获取属性 (读值).例如:</p>
<pre><code>&gt; jane.name  // get property `name`
&#39;Jane&#39;
&gt; jane.describe  // get property `describe`
[Function]
</code></pre><p>如果属性不存在则返回 undefined:</p>
<pre><code>&gt; jane.unknownProperty
undefined
</code></pre><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>也可以调用方法:</p>
<pre><code>&gt; jane.describe()  // call method `describe`
&#39;Person named Jane&#39;
</code></pre><h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><p>可以用赋值符=来给.指向的属性赋值:</p>
<pre><code>&gt; jane.name = &#39;John&#39;;  // set property `name`
&gt; jane.describe()
&#39;Person named John&#39;
</code></pre><p>如果设置的属性不存在在赋值的时候就自动创建一个属性.如果存在就修改该属性。</p>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>delete操作符可以完全的从对象里面删除一个属性（键值对）：</p>
<pre><code>&gt; var obj = { hello: &#39;world&#39; };
&gt; delete obj.hello
true
&gt; obj.hello
undefined
</code></pre><p>如果你仅仅给一个属性设置为undefined，这个属性会仍然存在，而且这个对象包含这个键：</p>
<pre><code>&gt; var obj = { foo: &#39;a&#39;, bar: &#39;b&#39; };
&gt; obj.foo = undefined;
&gt; Object.keys(obj)
[ &#39;foo&#39;, &#39;bar&#39; ]
</code></pre><p>但是如果你将属性删除那么他的键就不存在了</p>
<pre><code>&gt; delete obj.foo
true
&gt; Object.keys(obj)
[ &#39;bar&#39; ]
</code></pre><p>delete只影响一个对象的直接属性（非继承的，自有属性）。并不会删除对象的原型。</p>
<p>Tip:慎用delete操作符，大多数现代化js引擎都会针对构造函数的创建实例进行优化，前提是这些实例不会发生形态改变（就是说没有删除或者添加属性的），但是删除属性会破坏这种优化。</p>
<h3 id="delete的返回值"><a href="#delete的返回值" class="headerlink" title="delete的返回值"></a>delete的返回值</h3><p>如果属性是一个自有属性且不能删除，那么delete会反回false，其他情况返回true。<br>例子：<br>作为准备，我们用Object.defineProperty创建一个不被删除自有属性</p>
<pre><code>var obj = {};
Object.defineProperty(obj, &#39;canBeDeleted&#39;, {
    value: 123,
    configurable: true
});
Object.defineProperty(obj, &#39;cannotBeDeleted&#39;, {
    value: 456,
    configurable: false
});
</code></pre><p>delete cannotBeDeleted 时候返回 false :</p>
<pre><code>&gt; delete obj.cannotBeDeleted
false
</code></pre><p>其他情况下delete 返回 true:</p>
<pre><code>&gt; delete obj.doesNotExist
true
&gt; delete obj.canBeDeleted
true
</code></pre><p>即使delete没有起作用也会返回true (继承的属性是不会被移除的):</p>
<pre><code>&gt; delete obj.toString
true
&gt; obj.toString // still there
[Function: toString]
</code></pre><h3 id="特殊属性键"><a href="#特殊属性键" class="headerlink" title="特殊属性键"></a>特殊属性键</h3><p>虽然你不能使用保留字作为变量名，但是你可以把他们作为属性键。</p>
<pre><code>&gt; var obj = { var: &#39;a&#39;, function: &#39;b&#39; };
&gt; obj.var
&#39;a&#39;
&gt; obj.function
&#39;b&#39;
</code></pre><h3 id="数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用-来访问："><a href="#数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用-来访问：" class="headerlink" title="数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用[]来访问："></a>数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用[]来访问：</h3><pre><code>&gt; var obj = { 0.7: &#39;abc&#39; };
&gt; Object.keys(obj)
[ &#39;0.7&#39; ]
&gt; obj[&#39;0.7&#39;]
&#39;abc&#39;
</code></pre><h3 id="对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用-来访问。"><a href="#对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用-来访问。" class="headerlink" title="对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用[]来访问。"></a>对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用[]来访问。</h3><pre><code>&gt; var obj = { &#39;not an identifier&#39;: 123 };
&gt; Object.keys(obj)
[ &#39;not an identifier&#39; ]
&gt; obj[&#39;not an identifier&#39;]
123
</code></pre><p>中括号 ([]): 通过计算出来的键访问属性<br>中括号可以通过表达式引用一个属性。</p>
<h3 id="用中括号获取属性："><a href="#用中括号获取属性：" class="headerlink" title="用中括号获取属性："></a>用中括号获取属性：</h3><pre><code>&gt; var obj = { someProperty: &#39;abc&#39; };

&gt; obj[&#39;some&#39; + &#39;Property&#39;]
&#39;abc&#39;

&gt; var propKey = &#39;someProperty&#39;;
&gt; obj[propKey]
&#39;abc&#39;
</code></pre><h3 id="非标识符"><a href="#非标识符" class="headerlink" title="非标识符:"></a>非标识符:</h3><pre><code>&gt; var obj = { &#39;not an identifier&#39;: 123 };
&gt; obj[&#39;not an identifier&#39;]
123
</code></pre><h3 id="表达式，转换成字符串"><a href="#表达式，转换成字符串" class="headerlink" title="表达式，转换成字符串:"></a>表达式，转换成字符串:</h3><pre><code>&gt; var obj = { &#39;6&#39;: &#39;bar&#39; };
&gt; obj[3+3]  // key: the string &#39;6&#39;
&#39;bar&#39;
</code></pre><h3 id="用中括号调用方法"><a href="#用中括号调用方法" class="headerlink" title="用中括号调用方法"></a>用中括号调用方法</h3><pre><code>&gt; var obj = { myMethod: function () { return true } };
&gt; obj[&#39;myMethod&#39;]()
true
</code></pre><h3 id="用中括号设置属性"><a href="#用中括号设置属性" class="headerlink" title="用中括号设置属性"></a>用中括号设置属性</h3><pre><code>&gt; var obj = {};
&gt; obj[&#39;anotherProperty&#39;] = &#39;def&#39;;
&gt; obj.anotherProperty
&#39;def&#39;
</code></pre><h3 id="用中括号删除属性"><a href="#用中括号删除属性" class="headerlink" title="用中括号删除属性"></a>用中括号删除属性</h3><pre><code>&gt; var obj = { &#39;not an identifier&#39;: 1, prop: 2 };
&gt; Object.keys(obj)
[ &#39;not an identifier&#39;, &#39;prop&#39; ]
&gt; delete obj[&#39;not an identifier&#39;]
true
&gt; Object.keys(obj)
[ &#39;prop&#39; ]
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript闭包及相关问题]]></title>
      <url>/2018/03/09/blog/Javascript%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="Javascript闭包及相关问题"><a href="#Javascript闭包及相关问题" class="headerlink" title="Javascript闭包及相关问题"></a>Javascript闭包及相关问题</h2><p>基本概念：闭包是指有权访问另一个函数作用域中的变量的函数。</p>
<p>当某个函数第一次被调用时，会创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性[[scope]]。然后使用this，arguments和其他的值初始化函数的活动对象。</p>
<pre><code>function compare(value1, value2) {
    if(value1 &lt; value2) {
        return -1;
    } else if(value1 &gt; value2) {
        return 1;
    } else {
        return 0;
    }
}
var result = compare(5,10);
</code></pre><p>在全局作用域中调用了compare函数，会创建一个compare的活动对象，其中会包含this，arguments，value1，value2，而在全局执行环境中，会有this，result，arguments，位于作用域链的第二层。</p>
<p>后台在每个执行环境中都有一个表示变量的对象–变量对象。全局环境的变量对象始终存在，而局部环境的变量对象在函数执行时存在。</p>
<p>在创建compare函数时，会创建一个包含全局变量对象的活动对象，此时活动对象指向作用域链，而作用域链指向[[scope]]属性。当调用compare函数时，会创建一个compare的执行环境，<b>这个执行环境会复制函数的[[scope]]属性中的作用域链</b>，之后这个局部作用域链会被推入执行环境作用域链的前端，所以，对于compare函数而言，其作用域链包含本地活动对象和全局变量对象。因此，<b>作用域链的本质是一个指向变量对象的指针列表，只引用，但不包含变量对象。</b></p>
<p>正常情况下，在函数中访问变量，会沿着作用域链搜索对应名字的变量。一般在函数执行完后，局部活动对象就会被销毁，内存中只有全局作用域。</p>
<p>闭包：在另一个函数内部定义的函数会将包括它的函数的活动对象添加到它的作用域上。</p>
<pre><code>function createComparisonFunction(propertyName) {
    return function(object1, object2) {
        var value1 = object1[propertyName];
        var value2 = object2[propertyName];
        if(value1 &lt; value2) {
            return -1; 
        } else if(value1 &gt; value2) {
            return 1;
        } else {
            return 0;
        }
    };
}
</code></pre><p>注意，在return一个匿名函数后，要添加上’;’</p>
<p>当执行以下两部操作时：</p>
<pre><code>var compareName = createComparisonFunction(&#39;name&#39;);
var result = compare({name:&#39;lpld&#39;}, {name:&#39;plws&#39;});
</code></pre><p>在compare()时，向上面一样，会有全局活动对象和局部活动对象两个作用域链，而根据上面说的闭包的内容：在另一个函数内部定义的函数会将包括它的函数的活动对象添加到它的作用域上。对于result而言，是createComparisonFunction的返回函数，所以也包括了compare的活动对象。所以，当createComparisonFunction返回后，<b>其执行环境的作用域链会被销毁，但是其活动对象会留在内存中。因为在匿名函数中会把其活动对象添加到匿名函数的作用域链上</b>。</p>
<p>因此，在执行compareName = null;相当于解除匿名函数的作用域链，至此该匿名函数作用域链上的活动对象（也包括外部函数内的活动对象）也都会释放。</p>
<p>闭包缺点：闭包会携带包含它的函数的作用域，换句话说，是会保留包括它的函数的活动对象。因此会占用更多的内存。（在外部函数没有被释放时，也会在内部函数的作用域链上生成新的外部函数的活动对象，会产生新的内存）。</p>
<p>this对象：</p>
<p>this永远指向调用它的函数</p>
<pre><code>1.
var name = &#39;The Window&#39;;
var object = {
    name : &#39;My Object&#39;,
    getNameFunc : function(){
        return function() {
            return this.name;
        };
    } 
};
alert(object.getNameFunc()());//The Window

2.
var name = &#39;The Window&#39;;
var object = {
    name : &#39;My Object&#39;,
    getNameFunc : function(){
        var that = this;
        return function(){
            return that.name;
        };
    }
};
alert(object.getNameFunc()());//My Object
</code></pre><p>根据书中的内容，匿名函数的执行环境具有全局性，所以第一个返回的是window，第二个是object，在执行函数时，当执行到object.getNameFunc()时，此时的name对应的是object，这时执行匿名函数，相当于返回全局中的name，即是window。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记（1）]]></title>
      <url>/2018/03/02/blog/JavaScript%E5%9F%BA%E6%9C%AC1/</url>
      <content type="html"><![CDATA[<h2 id="JavaScrip学习笔记（1）"><a href="#JavaScrip学习笔记（1）" class="headerlink" title="JavaScrip学习笔记（1）"></a>JavaScrip学习笔记（1）</h2><h3 id="JavaScript函数表达式和函数声明"><a href="#JavaScript函数表达式和函数声明" class="headerlink" title="JavaScript函数表达式和函数声明"></a>JavaScript函数表达式和函数声明</h3><p>首先，来了解一下函数表达式和函数声明：</p>
<p>在ECMAScript中，创建函数的最常用的两个方法是函数表达式和函数声明，两者还是有一定的区别，在ECMA规范中提到：函数声明必须带有标示符（Identifier）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符，即：</p>
<p>函数声明:</p>
<p>function 函数名称 (参数：可选){ 函数体 }</p>
<p>函数表达式：</p>
<p>function 函数名称（可选）(参数：可选){ 函数体 }</p>
<p>所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称，ECMAScript是通过上下文来区分的，如果function foo(){}是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。</p>
<pre><code> function foo(){} // 声明，因为它是程序的一部分
 var bar = function foo(){}; // 表达式，因为它是赋值表达式的一部分
 new function bar(){}; // 表达式，因为它是new表达式
 (function(){
   function bar(){} // 声明，因为它是函数体的一部分
 })();
</code></pre><p>还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式，我们来看几个例子：</p>
<pre><code>function foo(){} // 函数声明
(function foo(){}); // 函数表达式：包含在分组操作符内

try {
  (var x = 5); // 分组操作符，只能包含表达式而不能包含语句，这里的var就是语句
} catch(err) {
// SyntaxError
}
</code></pre><p>在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：eval(‘(‘ + json + ‘)’)，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。</p>
<pre><code> try {
    { &quot;x&quot;: 5 }; // &quot;{&quot; 和 &quot;}&quot; 做解析成代码块
  } catch(err) {
    // SyntaxError
  }

  ({ &quot;x&quot;: 5 }); // 分组操作符强制将&quot;{&quot; 和 &quot;}&quot;作为对象字面量来解析
</code></pre><p>表达式和声明存在着十分微妙的区别，函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值，也就是所谓的函数提升。参考如下例子，函数fn是在alert之后声明的，但是在alert执行的时候，fn已经有定义了：</p>
<pre><code>alert(fn());
function fn() {  
  return &#39;Hello world!&#39;;
}
</code></pre><p>还有一点，函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式：</p>
<pre><code>// 千万别这样做！
// 因为有的浏览器会返回first的这个function，而有的浏览器返回的却是第二个

if (true) {
  function foo() {
    return &#39;first&#39;;
  }
}
else {
  function foo() {
    return &#39;second&#39;;
  }
}
foo();

// 相反，这样情况，我们要用函数表达式
var foo;
if (true) {
  foo = function() {
    return &#39;first&#39;;
  };
}
else {
  foo = function() {
    return &#39;second&#39;;
  };
}
foo();
</code></pre><p>函数声明的实际规则如下：</p>
<p><b>函数声明只能出现在程序或函数体内。从句法上讲，它们 不能出现在Block（块）（{ … }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含Statement语句， 而不能包含函数声明这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让表达式出现在Block（块）中情形，就是让它作为表达式语句的一部分。但是，规范明确规定了表达式语句不能以关键字function开头。而这实际上就是说，函数表达式同样也不能出现在Statement语句或Block（块）中（因为Block（块）就是由Statement语句构成的）。 </b></p>
<h3 id="函数表达式的命名"><a href="#函数表达式的命名" class="headerlink" title="函数表达式的命名"></a>函数表达式的命名</h3><p>函数表达式在实际应用中还是很常见的，但由于这种方式都是在同一作用域内，所以基本上一定要用函数表达式：</p>
<pre><code>    var contains = (function() {
    var docEl = document.documentElement;

    if (typeof docEl.compareDocumentPosition != &#39;undefined&#39;) {
      return function(el, b) {
        return (el.compareDocumentPosition(b) &amp; 16) !== 0;
      };
    }
    else if (typeof docEl.contains != &#39;undefined&#39;) {
      return function(el, b) {
        return el !== b &amp;&amp; el.contains(b);
      };
    }
    return function(el, b) {
      if (el === b) return false;
      while (el != b &amp;&amp; (b = b.parentNode) != null);
      return el === b;
    };
  })();
</code></pre><p>提到命名函数表达式，理所当然，就是它得有名字，前面的例子var bar = function foo(){};就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效：</p>
<pre><code>  var f = function foo(){
    return typeof foo; // foo是在内部作用域内有效
  };
  // foo在外部用于是不可见的
  typeof foo; // &quot;undefined&quot;
  f(); // &quot;function&quot;
</code></pre><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>首先，我们可以从这几个方面理解：</p>
<p>1.原型使用方式1：</p>
<pre><code>var Calculator = function (decimalDigits, tax) {
   this.decimalDigits = decimalDigits;
   this.tax = tax;
};
//然后，通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象的原型。
Calculator.prototype = {
   add: function (x, y) {
      return x + y;
},
   subtract: function (x, y) {
      return x - y;
   }
};
</code></pre><p>这样，就可以new Calculator对象以后，就可以调用add方法来计算结果了。</p>
<p>2.原型使用方式2：</p>
<pre><code>Calculator.prototype = function () {
   add = function (x, y) {
      return x + y;
   },
   subtract = function (x, y) {
      return x - y;
   }
   return {
      add: add,
      subtract: subtract
   }
} ();
</code></pre><p>这样我们可以new Calculator对象以后调用add方法来计算结果了。</p>
<p>以上有一个限制就是一次性设置了原型对象，我们再来说一下如何分开设置原型的每个属性吧。</p>
<pre><code>var BaseCalculator = function () {
    //为每个实例都声明一个小数位数
    this.decimalDigits = 2;
};

//使用原型给BaseCalculator扩展2个对象方法
BaseCalculator.prototype.add = function (x, y) {
    return x + y;
};

BaseCalculator.prototype.subtract = function (x, y) {
    return x - y;
};
</code></pre><p>首先，声明了一个BaseCalculator对象，构造函数里会初始化一个小数位数的属性decimalDigits，然后通过原型属性设置2个function，分别是add(x,y)和subtract(x,y)，当然你也可以使用前面提到的2种方式的任何一种，我们的主要目的是看如何将BaseCalculator对象设置到真正的Calculator的原型上。</p>
<pre><code>var BaseCalculator = function() {
    this.decimalDigits = 2;
};

BaseCalculator.prototype = {
    add: function(x, y) {
        return x + y;
    },
    subtract: function(x, y) {
        return x - y;
    }
};
</code></pre><p>创建完上述代码以后</p>
<pre><code>var Calculator = function () {
    //为每个实例都声明一个税收数字
    this.tax = 5;
};

Calculator.prototype = new BaseCalculator();
</code></pre><p>我们可以看到Calculator的原型是指向到BaseCalculator的一个实例上，目的是让Calculator集成它的add(x,y)和subtract(x,y)这2个function，还有一点要说的是，由于它的原型是BaseCalculator的一个实例，所以不管你创建多少个Calculator对象实例，他们的原型指向的都是同一个实例。</p>
<pre><code>var calc = new Calculator();
alert(calc.add(1, 1));
//BaseCalculator 里声明的decimalDigits属性，在 Calculator里是可以访问到的
alert(calc.decimalDigits);
</code></pre><p>上面的代码，运行以后，我们可以看到因为Calculator的原型是指向BaseCalculator的实例上的，所以可以访问他的decimalDigits属性值，如果我不想让Calculator访问BaseCalculator的构造函数里声明:</p>
<pre><code>var Calculator = function () {
    this.tax= 5;
};

Calculator.prototype = BaseCalculator.prototype;
</code></pre><p>通过将BaseCalculator的原型赋给Calculator的原型，这样你在Calculator的实例上就访问不到那个decimalDigits值了，如果你访问如下代码，那将会提升出错。</p>
<pre><code>var calc = new Calculator();
alert(calc.add(1, 1));
alert(calc.decimalDigits);
</code></pre><p>先是这部分内容，看的有些部分没有懂还没有写完，等第二版到了读第二版吧。。。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2.5~2.9所遇问题]]></title>
      <url>/2018/02/09/blog/2.5~2.9_questions/</url>
      <content type="html"><![CDATA[<h2 id="2-5-2-9所遇问题"><a href="#2-5-2-9所遇问题" class="headerlink" title="2.5~2.9所遇问题"></a>2.5~2.9所遇问题</h2><h3 id="一-开发所遇问题"><a href="#一-开发所遇问题" class="headerlink" title="一.开发所遇问题"></a>一.开发所遇问题</h3><p>在这次开发过程中，是真正自己做的第一个迭代版本，在开发中主要遇到的问题有：从理清思路到代码的实现；代码的格式规范与模块化；如何与后台人员沟通好。</p>
<p>1.从理清思路到代码的实现</p>
<p>这部分内容主要是因为自己以前写的代码只考虑到最后呈现的效果，没有具体深入探讨如何高效的写代码，拿生庆哥的话讲就是：没有真正明白要做什么。这个做什么不仅仅是你要实现的效果是什么，还包括你对整体项目的思路。之前我写代码都是只想到大概有哪些代码块，但是几个代码块传参是什么，怎么传，情况考虑全不全，整体的逻辑也是只有个大概的印象就开始动手，造成的结果就是每个代码块之间都有一定的耦合，没有全部拆分开，这造成的结果就是会有很多重复的代码，本来能拆分成函数的内容都没有抽象出来，每个函数功能目的不明确，有很多“胶水代码”，归根结底是因为一开始太着急动手，写代码时又没有细究逻辑，功能是完成了，但过不了组内review的关卡，所以总结一句话：解决问题从源头开始，这次实现代码后发现，原本想象的多复杂多复杂的代码，其实并没有想象中那么难，只要逻辑正确，思路正确其实还是很好解决的。</p>
<p>2.代码的格式规范与模块化</p>
<p>这次写代码的过程真真切切的明白了一个道理：良好的命名的重要性，因为一开始想的功能不全，所以在中途添加了不少变量，这就造成了不断添加变量，但是因为函数的功能性不清晰，所以在定义变量的时候又会有代码名称比较接近的结果，一开始还没觉得什么，但是写的稍微多一点就会发现，自己不知道当时为什么要用这个变量名定义了，虽然名称有一定的含义，但是有一个变量名跟预期的函数功能还是有偏差，还得重新看一遍代码的过程，也是一个不好的习惯。</p>
<p>3.如何与后台人员沟通</p>
<p>因为这次的后台是千仪哥提供的，自己刚刚来，总是觉得千仪哥做的肯定没问题，所以在看接口的时候当不满足自己这边的需求时，在检查完对应的接口功能发现有问题时，先自己偷偷的看能不能自己生产这样的过程。在中间造成了不小的麻烦，经过这件事懂得了：尊重规范，按规范办事，这样才是解决问题最有效也是最便捷的方法。</p>
<h3 id="二-如何生成一个比1px更短的边框"><a href="#二-如何生成一个比1px更短的边框" class="headerlink" title="二.如何生成一个比1px更短的边框"></a>二.如何生成一个比1px更短的边框</h3><p>因为css提供最短的就是1px的长度，这也是屏幕的最短像素，所以要生成1px的边框长度也是有一定的技巧的；</p>
<p>1.使用rgba，通过添加透明度来在视觉上减少边框的长度。</p>
<p>这个是没什么好说的，效果虽然有，但是不是一个好的解决方法。</p>
<p>2.利用box-shadow实现窄边框</p>
<pre><code>box-shadow:0 0 1px 0 red
</code></pre><p>利用了盒子阴影绘制。可以用于各种场景。但是最后的颜色会变暗，而且box-shadow不占位置，语义化不符合标准。不是实际意义的边框。</p>
<p>3.多背景渐变实现</p>
<pre><code>background:
linear-gradient(180deg, red, red 50%, transparent 50%) top left / 100% 1px no-repeat, 
linear-gradient(90deg, red, red 50%, transparent 50%) top right / 1px 100% no-repeat, 
linear-gradient(0deg, red, red 50%, transparent 50%) bottom right / 100% 1px no-repeat, 
linear-gradient(-270deg, red, red 50%, transparent 50%) bottom left / 1px 100% no-repeat;
</code></pre><p>可以通过不同的四种角度的渐变，实现边框，颜色可以自定义。缺点是代码比较多，而且不能实现圆角。</p>
<p>4.伪类 + transform 实现</p>
<pre><code>:after{
    content: &#39;&#39;; 
    position: absolute; 
    top: 0; left: 0; 
    border: 1px solid red; 
    -webkit-box-sizing: border-box; 
    box-sizing: border-box; 
    width: 200%; 
    height: 200%; 
    -webkit-transform: scale(0.5); 
    transform: scale(0.5); 
    -webkit-transform-origin: left top; 
    transform-origin: left top; 
}
</code></pre><p>利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半， 然后进行绝对定位，这种方法现在没有发现问题。</p>
<h3 id="三-图的遍历"><a href="#三-图的遍历" class="headerlink" title="三.图的遍历"></a>三.图的遍历</h3><p>这部分是上次分享没有添加的内容：</p>
<p>广度优先 搜索(Breadth-First Search，BFS)和深度优先搜索(Depth-First Search，DFS)。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通等。</p>
<p>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</p>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点。</p>
<p>以下是从顶点v开始的广度优先搜索算法所遵循的步骤。<br>(1) 创建一个队列Q。<br>(2) 将v标注为被发现的(灰色)，并将v入队列Q。<br>(3) 如果Q非空，则运行以下步骤:<br>    (a) 将u从Q中出队列;<br>    (b) 将标注u为被发现的(灰色);<br>    (c) 将u所有未被访问过的邻点(白色)入队列;<br>    (d) 将u标注为已被探索的(黑色)。</p>
<pre><code>var initializeColor = function(){ 
    var color = [];
    for (var i=0; i&lt;vertices.length; i++){
         color[vertices[i]] = &#39;white&#39;; 
    }
    return color; 
};
    this.bfs = function(v, callback){
        var color = initializeColor(),  
        queue = new Queue();
        queue.enqueue(v);
        while (!queue.isEmpty()){
            var u = queue.dequeue(), neighbors = adjList.get(u); 
            color[u] = &#39;grey&#39;;                    
            for (var i=0; i&lt;neighbors.length; i++){ 
            var w = neighbors[i];
            if (color[w] === &#39;white&#39;){
                color[w] = &#39;grey&#39;;
                queue.enqueue(w);
            } }
            color[u] = &#39;black&#39;; 
            if (callback) {    
                callback(u);
            }
        } 
    };
</code></pre><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点。</p>
<pre><code>this.dfs = function(callback){
    var color = initializeColor(); 
    for (var i=0; i&lt;vertices.length; i++){ 
        if (color[vertices[i]] === &#39;white&#39;){ 
            dfsVisit(vertices[i], color, callback); 
        }
    } 
};
var dfsVisit = function(u, color, callback){
    color[u] = &#39;grey&#39;; 
    if (callback) {    }
        callback(u);
    }
    var neighbors = adjList.get(u);
    for (var i=0; i&lt;neighbors.length; i++){ 
        var w = neighbors[i];
        if (color[w] === &#39;white&#39;){
            dfsVisit(w, color, callback);
        }
    }
    color[u] = &#39;black&#39;; 
};
</code></pre><p>以上是两个基本的图的遍历方法。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 23.Missing Number]]></title>
      <url>/2018/02/02/leetCode/23.Missing_Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-23-Missing-Number"><a href="#Problem-23-Missing-Number" class="headerlink" title="Problem 23.Missing Number"></a>Problem 23.Missing Number</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p><strong>Example 1</strong></p>
<blockquote>
<p><strong>Input:</strong> [3,0,1]<br><strong>Output:</strong> 2</p>
</blockquote>
<p><strong>Example 2</strong><br><strong>Input:</strong> [9,6,4,2,3,5,7,0,1]<br><strong>Output:</strong> 8</p>
<p><strong>Note:</strong><br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<p><strong>Credits:</strong><br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p>
<p><strong>solution</strong></p>
<p>1.这道题也是比较简单，只要先对数组排好序，然后跟序数进行对比，返回不相等的下标即可。</p>
<pre><code>var missingNumber = function(nums) {
    nums.sort(function(a,b){return a-b;});
    for (var i = 0; i &lt; nums.length; i++) {
        if(nums[i] != i) {
            return i;
        }
    }
    return nums.length;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 22.Maximum Product of Three Numbers]]></title>
      <url>/2018/02/02/leetCode/22.Maximum_Product_of_Three_Numbers/</url>
      <content type="html"><![CDATA[<h2 id="Problem-22-Maximum-Product-of-Three-Numbers"><a href="#Problem-22-Maximum-Product-of-Three-Numbers" class="headerlink" title="Problem 22.Maximum Product of Three Numbers"></a>Problem 22.Maximum Product of Three Numbers</h2><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,3]<br><strong>Output:</strong> 6</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,3,4]<br><strong>Output:</strong> 24</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The length of the given array will be in range [3,10<sup>4</sup>] and all elements are in the range [-1000, 1000].</li>
<li>Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer.</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.因为最短数组长度为3，所以不要考虑数组长度小于3的情况。本题的元素大小可能为负数，若都为正数或都为负数，则取前三个元素，若有正数有负数，通过查资料可以得到，此时3个数之积的最大值为max(第一大数<em>第二大数</em>第三大数， 第一大数<em>最小数</em>倒数第二小数)。这个方法可以记住。</p>
<pre><code>var maximumProduct = function(nums) {
    nums.sort(function(a,b){return b-a;});
    return Math.max(nums[nums.length - 1] * nums[nums.length - 2] * nums[0], nums[0] * nums[1] * nums[2]);
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 21. Image Smoother]]></title>
      <url>/2018/02/02/leetCode/21.Image_Smoother/</url>
      <content type="html"><![CDATA[<h2 id="Problem-21-Image-Smoother"><a href="#Problem-21-Image-Smoother" class="headerlink" title="Problem 21. Image Smoother"></a>Problem 21. Image Smoother</h2><p>Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>[[1,1,1],<br> [1,0,1],<br> [1,1,1]]<br><strong>Output:</strong><br>[[0, 0, 0],<br> [0, 0, 0],<br> [0, 0, 0]]<br><strong>Explanation:</strong><br>For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0<br>For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0<br>For the point (1,1): floor(8/9) = floor(0.88888889) = 0</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The value in the given matrix is in the range of [0, 255].</li>
<li>The length and width of the given matrix are in the range of [1, 150].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.这道题想了半天没想出什么好点的方法，就用最笨的方法写了，判断周围八个位置是否正常，如果正常，就计算到总额里并得到平均值。注意，js里不满1会向上取整，所以应该用Math.floor()。代码如下：</p>
<pre><code>var imageSmoother = function(M) {
        var nx = M.length;
        var ny = M[0].length;
        var res = new Array(nx);
        for(var n = 0; n &lt; nx; n++){
            res[n] = new Array(ny);
        } ;
        for (var i = 0; i &lt; nx; i++) {
            for (var j = 0; j &lt; ny; j++) {
                res[i][j] = smooth(M, i, j);
            }
        }
        return res;
    }
    var smooth = function(M, x, y) {
        var nx = M.length;
        var ny = M[0].length;
        var sum = 0;
        var count = 0;
        for (var i = -1; i &lt;= 1; i++) {
           for (var j = -1; j &lt;= 1; j++) {
             if (x + i &lt; 0 || x + i &gt;= nx || y + j &lt; 0 || y + j &gt;= ny) {
                 continue;
             }
             count++;
             sum += M[x + i][y + j];
           }
        }
        return Math.floor(sum / count);
    }
</code></pre><p>复杂度分析：<br> Time Complexity：O(r X c),r为M.length,c为M[0].length.</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 20.Contains Duplicate]]></title>
      <url>/2018/01/31/leetCode/20.Contains_Duplicate/</url>
      <content type="html"><![CDATA[<h2 id="Problem-20-Contains-Duplicate"><a href="#Problem-20-Contains-Duplicate" class="headerlink" title="Problem 20:Contains Duplicate"></a>Problem 20:Contains Duplicate</h2><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p><strong>solution:</strong></p>
<p>1.先对数组进行sort，然后除去特殊情况下判断只要元素周围两侧元素有一个相同，就返回true，否则为false。</p>
<pre><code>var containsDuplicate = function(nums) {
    nums.sort(function(a,b){return a-b});
    if(nums.length == 0) return false;
    if(nums.length == 1) return false;
    if(nums.length == 2 &amp;&amp; nums[0] ==nums[1]) return true;
    for(var i = 1; i &lt; nums.length - 1; i++) {
        if(nums[i] == nums[i-1] || nums[i] == nums[i+1]) {
            return true;
        }
    }
    return false;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 19.Degree of an Array]]></title>
      <url>/2018/01/31/leetCode/19.Degree_of_an_Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-19-Degree-of-an-Array"><a href="#Problem-19-Degree-of-an-Array" class="headerlink" title="Problem 19: Degree of an Array"></a>Problem 19: Degree of an Array</h2><p>Given a non-empty array of non-negative integers nums, the <strong>degree</strong> of this array is defined as the maximum frequency of any one of its elements.</p>
<p>Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1, 2, 2, 3, 1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong><br>The input array has a degree of 2 because both elements 1 and 2 appear twice.<br>Of the subarrays that have the same degree:<br>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]<br>The shortest length is 2. So return 2.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,2,3,1,4,2]<br><strong>Output:</strong> 6</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>nums.length will be between 1 and 50,000.</li>
<li>nums[i] will be an integer between 0 and 49,999.</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.本题本来想用数组的方式解决，但感觉比较麻烦，所以选择map来解决</p>
<pre><code>var findShortestSubArray = function(nums) {
    var m = new Map(),
    degree = 1,
    whichDegree = nums[0]
    for (var i = 0; i &lt; nums.length; i++) {
        if (m.has(nums[i])) {
        var pos = m.get(nums[i])
        pos.push(i)
        if (pos.length &gt; degree) {
            degree = pos.length
            whichDegree = nums[i]
        } else if (pos.length == degree &amp;&amp; pos[pos.length - 1] - pos[0] &lt; m.get(whichDegree)[m.get(whichDegree).length - 1] - m.get(whichDegree)[0]) {
        degree = pos.length
        whichDegree = nums[i]
        }
        } else 
            m.set(nums[i], [i])
    }
    return m.get(whichDegree)[m.get(whichDegree).length - 1] - m.get(whichDegree)[0] + 1
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 18.Two Sum II - Input array is sorted]]></title>
      <url>/2018/01/31/leetCode/18.Two_Sum_II_Input_array_is_sorted/</url>
      <content type="html"><![CDATA[<h2 id="Problem-18-Two-Sum-II-Input-array-is-sorted"><a href="#Problem-18-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="Problem 18: Two Sum II - Input array is sorted"></a>Problem 18: Two Sum II - Input array is sorted</h2><p>Given an array of integers that is already <em>sorted in ascending order</em>, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p><strong>Input:</strong> numbers={2, 7, 11, 15}, target=9<br><strong>Output:</strong> index1=1, index2=2</p>
<p><strong>solution:</strong></p>
<p>1.因为已经是升序的，所以只要从数组头尾往中间收拢，就必然会找到对应的两个数。</p>
<pre><code>var twoSum = function(numbers, target) {
    var left = 0, right= numbers.length - 1;
    var sum = 0;
    while (left &lt; right) {
        sum = numbers[left] + numbers[right];
        if (sum == target){return [left + 1, right + 1];}
        else if(sum &lt; target) left++;
        else right--;
    }
    return [];
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 17.Majority Element]]></title>
      <url>/2018/01/30/leetCode/17.Majority_Element/</url>
      <content type="html"><![CDATA[<h2 id="Problem-17-Majority-Element"><a href="#Problem-17-Majority-Element" class="headerlink" title="Problem 17: Majority Element"></a>Problem 17: Majority Element</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears <strong>more than</strong> ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Credits:</strong><br>Special thanks to @ts for adding this problem and creating all test cases.</p>
<p><strong>solution:</strong></p>
<p>1.这里比较取巧，因为内容全部为数字，所以sort按序排序然后选择中位数即可。</p>
<pre><code>var majorityElement = function(nums) {
    nums.sort(function(a,b){return a-b;});
    return nums[Math.floor(nums.length/2)];
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 16.Best Time to Buy and Sell Stock II]]></title>
      <url>/2018/01/30/leetCode/16.Best_Time_to_Buy_and_Sell_Stock_II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-16-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Problem-16-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Problem 16: Best Time to Buy and Sell Stock II"></a>Problem 16: Best Time to Buy and Sell Stock II</h2><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p><strong>solution:</strong></p>
<p>1.题目信息请见之前的题目地址，这道题的思路比较奇特，因为可以选择多次，所以只要后一次大于前一次，即可以在总额上加上差值，因为若后面的数继续大于前面的数，累加的差值等于之后的差值。若后面的小，则可以跳过，因为前面的内容已经得到最多的利润。</p>
<pre><code>var maxProfit = function(prices) {
    var maxprofit = 0;
    for(var i = 0; i &lt; prices.length; i++) {
        if (prices[i] &gt; prices[i - 1])
            maxprofit += prices[i] - prices[i - 1];
    }
    return maxprofit;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 15.1-bit and 2-bit Characters]]></title>
      <url>/2018/01/30/leetCode/15.1_bit_and_2_bit_Characters/</url>
      <content type="html"><![CDATA[<h2 id="Problem-15-1-bit-and-2-bit-Characters"><a href="#Problem-15-1-bit-and-2-bit-Characters" class="headerlink" title="Problem 15: 1-bit and 2-bit Characters"></a>Problem 15: 1-bit and 2-bit Characters</h2><p>We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).</p>
<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>bits = [1, 0, 0]<br><strong>Output:</strong> True<br><strong>Explanation:</strong><br>The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>bits = [1, 1, 1, 0]<br><strong>Output:</strong> False<br><strong>Explanation:</strong><br>The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>1 &lt;= len(bits) &lt;= 1000.</li>
<li>bits[i] is always 0 or 1.</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.近期因为时间比较紧，所以只用一种方法解决。本题选择递归，当前元素若为1，则删掉前两个，当前元素为0，则删除一个，直到最后长度为0或时，返回false或true。</p>
<pre><code>var isOneBitCharacter = function(bits) {
    if(bits.length==0) return false; 
    else if(bits.length==1) return true;
    if(bits[0]==0)bits.splice(0,1); 
    else bits.splice(0,2);
    return isOneBitCharacter(bits)
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 14.Move Zeroes]]></title>
      <url>/2018/01/27/leetCode/14.Move_Zeroes/</url>
      <content type="html"><![CDATA[<h2 id="Problem-14-Move-Zeroes"><a href="#Problem-14-Move-Zeroes" class="headerlink" title="Problem 14: Move Zeroes"></a>Problem 14: Move Zeroes</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p><strong>Note:</strong></p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<p><strong>Credits:</strong></p>
<p>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p>
<p><strong>solution:</strong></p>
<ol>
<li>这跟之前做的题很类似，只要注意在splice之后要对i减一即可。</li>
</ol>
<pre><code>var moveZeroes = function(nums) {
    var sumZero = 0;
    for(var i = 0; i &lt; nums.length; i++) {
        if(nums[i] == 0) {
            nums.splice(i, 1);
            i--;
            sumZero++;
        }
    }
    for(var n = 0; n &lt; sumZero; n++) {
        nums.push(0);
    }
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 13.Find All Numbers Disappeared in an Array]]></title>
      <url>/2018/01/27/leetCode/13.Find_All_Numbers_Disappeared_in_an_Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-13-Find-All-Numbers-Disappeared-in-an-Array"><a href="#Problem-13-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="Problem 13: Find All Numbers Disappeared in an Array"></a>Problem 13: Find All Numbers Disappeared in an Array</h2><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<p><strong>Example:</strong></p>
<p><strong>Input:</strong><br>[4,3,2,7,8,2,3,1]</p>
<p><strong>Output:</strong><br>[5,6]</p>
<p><strong>solution:</strong></p>
<p>1.本来想最简单的方法就是先筛选出1 ≤ a[i] ≤ n 中哪个元素不再数组里，然后push到最后一位在splice之前的内容，但是要求<code>without extra space and in O(n) runtime</code>，所以选择其他的方法。这里选择先将数组排序，然后判断哪个元素不是对应位置上的数字，最后push到数组中。</p>
<pre><code>var findDisappearedNumbers = function(nums) {
     var res = [];
     for (var i = 0; i &lt; nums.length; i++) {
        if (nums[i] != nums[nums[i] - 1]) {
            var inchange = nums[nums[i] - 1];
            nums[nums[i] - 1] = nums[i];
            nums[i] = inchange;
            i--;
        }
    }
    for (var j = 0; j &lt; nums.length; j++) {
        if (nums[j] != j + 1)
            res.push(j + 1);
    }
    return res;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 12.Max Area of Island]]></title>
      <url>/2018/01/27/leetCode/12.Max_Area_of_Island/</url>
      <content type="html"><![CDATA[<h2 id="Problem-12-Max-Area-of-Island"><a href="#Problem-12-Max-Area-of-Island" class="headerlink" title="Problem 12: Max Area of Island"></a>Problem 12: Max Area of Island</h2><p>Given a non-empty 2D array <code>grid</code> of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</p>
</blockquote>
<p>Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.</p>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>[[0,0,0,0,0,0,0,0]]</p>
</blockquote>
<p>Given the above grid, return 0.</p>
<p><strong>Note:</strong> The length of each dimension in the given grid does not exceed 50.</p>
<p><strong>solution:</strong></p>
<ol>
<li>因为选取最多的相邻的1，本来打算遍历一遍，如果当前元素右边和下边为1，则对右下方元素加对应的值，但是边界条件判断比较复杂。所以，选择递归实现，虽然实现很简单，但是时间复杂度相对较高，做了比较多重复的操作。以下为对应代码：</li>
</ol>
<pre><code>var maxAreaOfIsland = function(grid) {
      var res = 0;
      for(var i = 0; i &lt; grid.length; i++){
         for(var j = 0; j &lt; grid[0].length; j++){
                if(grid[i][j] == 1) res = Math.max(res, helper(grid, i, j));
            }
        }
        return res;
};

var helper = function(grid, r, c) {
    if(r &lt; 0 || r &gt;= grid.length || c &lt; 0 || c &gt;= grid[0].length) return 0;
        var res = 0;
        if(grid[r][c] == 1){
            grid[r][c] = 0;
            res = 1 + helper(grid, r-1, c) + helper(grid, r+1, c) + helper(grid, r, c-1) + helper(grid, r, c+1);
        }
        return res;
}
</code></pre><p>复杂度分析：<br>Time Complexity：O(r X c), r为行的个数，c为列的个数。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 11.Shortest Word Distance]]></title>
      <url>/2018/01/27/leetCode/11.Shortest_Word_Distance/</url>
      <content type="html"><![CDATA[<h2 id="Problem-11-Shortest-Word-Distance"><a href="#Problem-11-Shortest-Word-Distance" class="headerlink" title="Problem 11: Shortest Word Distance"></a>Problem 11: Shortest Word Distance</h2><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>For example,<br>Assume that words = <code>[&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]</code>.</p>
<p>Given word1 = <code>&quot;coding&quot;</code>, word2 = <code>&quot;practice&quot;</code>, return 3.<br>Given word1 = <code>&quot;makes&quot;</code>, word2 = <code>&quot;coding&quot;</code>, return 1.</p>
<p><strong>Note:</strong></p>
<p>You may assume that word1 <strong>does not equal to</strong> word2, and word1 and word2 are both in the list.</p>
<p><strong>solution:</strong></p>
<ol>
<li>根据题意，选出最近的两个对应的单词的间距，因为所选单词最短的间距即相邻间距，所以最小的匹配值间距的绝对值即是所求答案。</li>
</ol>
<pre><code>var shortestDistance = function(words, word1, word2) {
    var index1 = -1, index2 = -1;
    var minDistance = words.length;
    var currentDistance;
    for (var i = 0; i &lt; words.length; i++) {
        if (words[i] == word1) {
            index1 = i;
        } else if (words[i] == word2) {
            index2 = i;
        }

        if (index1 != -1 &amp;&amp; index2 != -1) {
            minDistance = Math.min(minDistance, Math.abs(index1 - index2));
        }
    }
    return minDistance;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组的长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 10.Max Consecutive Ones]]></title>
      <url>/2018/01/26/leetCode/10.Max_Consecutive_Ones/</url>
      <content type="html"><![CDATA[<h2 id="Problem-10-Max-Consecutive-Ones"><a href="#Problem-10-Max-Consecutive-Ones" class="headerlink" title="Problem 10: Max Consecutive Ones"></a>Problem 10: Max Consecutive Ones</h2><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,1,0,1,1,1]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The first two digits or the last three digits are consecutive 1s.<br>    The maximum number of consecutive 1s is 3.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The input array will only contain 0 and 1.</li>
<li>The length of input array is a positive integer and will not exceed 10,000</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.这道题算是福利题了，只要确定最长的1的长度就行了，所以直接判断即可：</p>
<pre><code>var findMaxConsecutiveOnes = function(nums) {
    var res = 0;
    var cnt = 0;
    for (var i = 0; i&lt; nums.length; i++) {
        cnt = (nums[i] == 0) ? 0 : cnt + 1;
        res = Math.max(res, cnt);
    }
    return res;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n),n为nums的长度；</p>
<p>2.除此之外还看到一个人的另一种比较有趣的方法，因为是01串，那么连续1的和跟个数相等，所以我们可以计算和，通过加上num，再乘以num来计算，如果当前数字是0，那么sum就被重置为0，还是要更新结果res。</p>
<pre><code>var findMaxConsecutiveOnes = function(nums) {
    var res = 0;
    var cnt = 0;
    for (var i = 0; i&lt; nums.length; i++) {
        cnt = (cnt + nums[i]) * nums[i];
        res = Math.max(res, cnt);
    }
    return res;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n),n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 9.Reshape the Matrix]]></title>
      <url>/2018/01/26/leetCode/9.Reshape_the_Matrix/</url>
      <content type="html"><![CDATA[<h2 id="Problem-9-Reshape-the-Matrix"><a href="#Problem-9-Reshape-the-Matrix" class="headerlink" title="Problem 9:Reshape the Matrix"></a>Problem 9:Reshape the Matrix</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p>
<p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and column number of the wanted reshaped matrix, respectively.</p>
<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p>
<p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>nums =<br>[[1,2],<br> [3,4]]<br>r = 1, c = 4<br><strong>Output:</strong><br>[[1,2,3,4]]<br><strong>Explanation:</strong><br>The <strong>row-traversing</strong> of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>nums =<br>[[1,2],<br> [3,4]]<br>r = 2, c = 4<br><strong>Output:</strong><br>[[1,2],<br> [3,4]]<br><strong>Explanation:</strong><br>There is no way to reshape a 2 X 2 matrix to a 2 X 4 matrix. So output the original matrix.</p>
</blockquote>
<p><strong>Note:</strong><br>The height and width of the given matrix is in range [1, 100].<br>The given r and c are all positive.</p>
<p><strong>solution:</strong></p>
<ol>
<li>做这道题时主要的问题在于如何创建一个二维数组，因为js创建二维数组时出现问题，所以选择设两个一维数组，先判断是否符合要求，不符合返回原数组，然后将元素通过concat添加到一个一维数组中，然后根据所给的r,c一一赋值即可。这道题主要纠结在如何设置一个空的二维数组以及如何对二维数组进行赋值。最后回避了这个问题。</li>
</ol>
<pre><code>var matrixReshape = function(nums, r, c) {
    var result_storage = [];
    var result = []; 
    if(nums.length * nums[0].length != r * c) {
        return nums;
    }    
    for(var i=0; i &lt; nums.length; i++) {  
            result_storage = result_storage.concat(nums[i]);  
    }
    for(var i = 0; i &lt; r; i++) {  
        result.push([]);  
        for(var j = 0; j &lt; c ; j++){  
                result[i][j] = result_storage[i * c + j];  
            }  
    } 
    return result;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(r X c), r为矩阵的横向长度，c为矩阵的纵向长度。</p>
<p>2.经过查询过后，发现二维数组不是通过创建`var result = new Array[][]这样的形式创建，而是通过先创建一个一维数组，再对其中的元素设置为数组的形式创建多维数组。接下来就对数组中的内容进行判断，若没有到下一行，则继续对下一位内容赋值，若倒下一行，则换行输入。</p>
<pre><code>var matrixReshape = function(nums, r, c) {
    var result =  new Array(r);  
    for(var n = 0; n &lt; result.length; n++){  
        result[n] = new Array(c);   
    }  
    var rows = 0; 
    var cols = 0;
    var count = 0;
    if(nums.length == 0 || nums.length * nums[0].length != r * c) 
        return nums;   
    for (var i = 0; i &lt; nums.length; i ++) {
        for (var j = 0; j &lt; nums[0].length; j++) {
            result[rows][cols] = nums[i][j];
            cols++;
            if (cols == c) {
                rows++;
                cols = 0;
            }
        }
    }
    return result;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(num.length X num[0].length), 与上述方法的复杂度类似，不过更直观一些。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 8.Toeplitz Matrix]]></title>
      <url>/2018/01/26/leetCode/8.Toeplitz_Matrix/</url>
      <content type="html"><![CDATA[<h2 id="Problem-8-Toeplitz-Matrix"><a href="#Problem-8-Toeplitz-Matrix" class="headerlink" title="Problem 8: Toeplitz Matrix"></a>Problem 8: Toeplitz Matrix</h2><p>A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.</p>
<p>Now given an <code>M x N</code> matrix, return <code>True</code> if and only if the matrix is Toeplitz.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]<br><strong>Output:</strong> True<br><strong>Explanation:</strong><br>1234<br>5123<br>9512</p>
</blockquote>
<p>In the above grid, the diagonals are “[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”, and in each diagonal all elements are the same, so the answer is True.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> matrix = [[1,2],[2,2]]<br><strong>Output:</strong> False<br><strong>Explanation:</strong><br>The diagonal “[1, 2]” has different elements.</p>
<p><strong>Note:</strong></p>
<ol>
<li>matrix will be a 2D array of integers.</li>
<li>matrix will have a number of rows and columns in range [1, 20].</li>
<li>matrix[i][j] will be integers in range [0, 99].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.通过画图可得，从左上角的元素开始，如果每行（最后一行除外）元素可以与右下方（每行最后一个元素除外）的元素相等，既符合要求，所以可以选择遍历得到答案。</p>
<p>目前就只有这一种比较好的解法，所以就先写一个算法了。</p>
<pre><code>var isToeplitzMatrix = function(matrix) {
    for(var r = 0; r &lt; matrix.length - 1; r++) {
        for(var c = 0; c &lt; matrix[0].length - 1; c++) {
            if(matrix[r][c] != matrix[r+1][c+1]) {
                return false;
            }
        }
    }
    return true;
};
</code></pre><p>复杂度分析：<br>Time Complexity: O(m X n), m为矩阵的横向长度，n为矩阵的纵向长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 7.Array Partition I]]></title>
      <url>/2018/01/26/leetCode/7.array_partition_I/</url>
      <content type="html"><![CDATA[<h2 id="Problem-7-Array-Partition-I"><a href="#Problem-7-Array-Partition-I" class="headerlink" title="Problem 7:Array Partition I"></a>Problem 7:Array Partition I</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,4,3,2]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li>
<li>All the integers in the array will be in the range of [-10000, 10000].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.这道题比较简单的做法是对数组排序，然后隔一个数字取一个，就可以保证数组中所有的每两个数字的最小值的总和是最小值。</p>
<p>目前也没有找到比这个更简单的算法，所以就先写一个算法了。</p>
<pre><code>var arrayPairSum = function(nums) {
    var sum = 0;
    var i = 0;
    nums.sort(function(a, b){return a-b;});
    for(var i = 0; i&lt; nums.length; i+=2) {
        sum+=nums[i];
    }
    return sum;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1.22~1.26所遇问题]]></title>
      <url>/2018/01/25/blog/1.22~1.16_questions/</url>
      <content type="html"><![CDATA[<h2 id="1-22-1-26所遇问题"><a href="#1-22-1-26所遇问题" class="headerlink" title="1.22~1.26所遇问题"></a>1.22~1.26所遇问题</h2><h3 id="1-导入css文件时，import和link的区别"><a href="#1-导入css文件时，import和link的区别" class="headerlink" title="1.导入css文件时，import和link的区别"></a>1.导入css文件时，import和link的区别</h3><ol>
<li><code>&lt;link&gt;</code>标签是html标签，除了可以引入CSS之外还可以定义RSS，定义rel属性等，而@import只能引入CSS样式；</li>
<li><code>&lt;link&gt;</code>标签引用的CSS文件会在页面加载时与html同时加载，而@import引入的CSS文件会等页面全部加载完以后再加载；</li>
<li>@import标签必须放在页面样式表的顶部，而<code>&lt;link&gt;</code>不必；</li>
</ol>
<p>那为什么会有很多人建议使用link标签，而非import呢？在Steve Souders（编写过《高性能网站建设指南》等书）的博客中通过一些实例来说明<strong>don’t use @import</strong>。<br>以下节选部分内容并进行翻译：</p>
<p>原文链接<a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/" target="_blank" rel="noopener">http://www.stevesouders.com/blog/2009/04/09/dont-use-import/</a><br>——————————————————————————————————————<br><strong>LINK vs. @import</strong></p>
<p>There are two ways to include a stylesheet in your web page. You can use the LINK tag:</p>
<p>以下有两种将样式表引入到您的网页中的方式。您可以使用LINK标签：</p>
<pre><code>&lt;link rel=&#39;stylesheet&#39; href=&#39;a.css&#39;&gt;
</code></pre><p>Or you can use the @import rule:</p>
<p>或者您可以使用@import规则：</p>
<pre><code>&lt;style&gt;
@import url(&#39;a.css&#39;);
&lt;/style&gt;
</code></pre><p>I prefer using LINK for simplicity—you have to remember to put @import at the top of the style block or else it won’t work. It turns out that avoiding @import is better for performance, too.</p>
<p>为了简单起见，我更倾向于使用LINK。如果您使用@import的话，您必须将它放在样式内容的顶部，否则它将无法显示。事实证明，处于性能来说，避免使用@import也是一个更好的选择。</p>
<p><strong>@import @import</strong></p>
<p>I’m going to walk through the different ways LINK and @import can be used. In these examples, there are two stylesheets: a.css and b.css. Each stylesheet is configured to take two seconds to download to make it easier to see the performance impact. The first example uses @import to pull in these two stylesheets. In this example, called @import @import, the HTML document contains the following style block:</p>
<p>我将在不同的情况下使用LINK和@import。在这些例子中，有两个样式表：a.css和b.css。每个样式表都需要花费两秒钟的时间下载，以便更容易地观测性能。第一个示例中，我们使用@import来下载这两个样式表。我们叫这个例子为<code>@import @import</code>在这个示例中，HTML文档包含以下样式块：</p>
<pre><code>&lt;style&gt;
@import url(&#39;a.css&#39;);
@import url(&#39;b.css&#39;);
&lt;/style&gt;
</code></pre><p>If you always use @import in this way, there are no performance problems, although we’ll see below it could result in JavaScript errors due to race conditions. The two stylesheets are downloaded in parallel, as shown in Figure 1. (The first tiny request is the HTML document.) The problems arise when @import is embedded in other stylesheets or is used in combination with LINK.</p>
<p>如果您总是使用@import的方式，不会有什么性能方面的问题，尽管可能由于竞争的原因导致JavaScript报错。如图1所示，这两个样式表是并行下载的。（第一个请求时HTML文档），但是，当@import与LINK结合使用引入其他样式表时，问题就出现了。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/import-import.gif" alt="只使用@import"><br>    <figcaption><br>        只使用@import<br>    </figcaption><br></figure>

<p>由此可见，只使用@import是没有问题的。</p>
<p><strong>LINK @import</strong></p>
<p>The LINK @import example uses LINK for a.css, and @import for b.css:</p>
<p>LINK @import示例中使用LINK标签引入a.css，使用@import引入b.css：</p>
<pre><code>&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
&lt;style&gt;
@import url(&#39;b.css&#39;);
&lt;/style&gt;
</code></pre><p>In IE (tested on 6, 7, and 8), this causes the stylesheets to be downloaded sequentially, as shown in Figure 2. Downloading resources in parallel is key to a faster page. As shown here, this behavior in IE causes the page to take a longer time to finish.</p>
<p>在IE（在IE6， 7， 8下测试）中，如下图所示，这将导致样式表按顺序下载，而并行下载资源是让页面加载更快的关键。如图所示，在IE中的这会导致页面花费较长的时间完成渲染。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-import.gif" alt="混合使用@import和link标签"><br>    <figcaption><br>        混合使用@import和link标签<br>    </figcaption><br></figure>

<p><strong>LINK with @import</strong></p>
<p>In the LINK with @import example, a.css is inserted using LINK, and a.css has an @import rule to pull in b.css:</p>
<p>在使用LINK中使用@import的示例中，a.css使用LINK嵌入在DOM中，而a.css中则通过@import导入b.css：</p>
<pre><code>in the HTML document:
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
in a.css:
@import url(&#39;b.css&#39;);
</code></pre><p>This pattern also prevents the stylesheets from loading in parallel, but this time it happens on all browsers. When we stop and think about it, we shouldn’t be too surprised. The browser has to download a.css and parse it. At that point, the browser sees the @import rule and starts to fetch b.css.</p>
<p>这种方式也可以防止样式表的并行加载，但是这次它发生在所有的浏览器上。其实仔细想一想，我们都不应该感到惊讶。浏览器必须先下载a.css并解析它，只有解析它后，浏览器才会看到@import规则并开始加载b.css。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-with-import.gif" alt="在link标签引入@import"><br>    <figcaption><br>       在link标签引入@import<br>    </figcaption><br></figure>

<p><strong>LINK blocks @import</strong></p>
<p>A slight variation on the previous example with surprising results in IE: LINK is used for a.css and for a new stylesheet called proxy.css. proxy.css is configured to return immediately; it contains an @import rule for b.css.</p>
<p>在IE中与上述结果有些许不同：对a.css和名为proxy.css的样式表使用LINK引入。而proxy.css会立即执行并渲染; 注意，它包含一个b.css的@import规则</p>
<pre><code>in the HTML document:
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;proxy.css&#39;&gt;
in proxy.css:
@import url(&#39;b.css&#39;);
</code></pre><p>The results of this example in IE, LINK blocks @import, are shown in Figure 4. The first request is the HTML document. The second request is a.css (two seconds). The third (tiny) request is proxy.css. The fourth request is b.css (two seconds). Surprisingly, IE won’t start downloading b.css until a.css finishes. In all other browsers, this blocking issue doesn’t occur, resulting in a faster page as shown in Figure 5.</p>
<p>在IE中的LINK bock @import例子里，第一个请求时HTML文件，第二个请求是a.css（花费了两秒），第三个请求（很短）是proxy.css。第四个请求时b.css（花费了两秒）。令人惊奇的是，IE不会等到a.css结束后再开始下载b.css。在所有其他的浏览器里，这种加速渲染页面的情况不会发生。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-blocks-import.gif" alt="LINK blocks @import embedded in other stylesheets in IE"><br>     <figcaption><br>        LINK blocks @import embedded in other stylesheets in IE<br>     </figcaption><br></figure>

<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-blocks-import-not-ie.gif" alt=" LINK doesn't block @import embedded stylesheets in browsers other than IE"><br>     <figcaption><br>         LINK doesn’t block @import embedded stylesheets in browsers other than IE<br>     </figcaption><br></figure>

<p><strong>many @imports</strong></p>
<p>The many @imports example shows that using @import in IE causes resources to be downloaded in a different order than specified. This example has six stylesheets (each takes two seconds to download) followed by a script (a four second download).</p>
<p>在many @imports例子中显示了在IE中使用@import会导致不同于指定的顺序下载资源。这个例子有六个样式表（每个需要两秒钟下载），后面是一个脚本（四秒钟的下载）</p>
<pre><code>&lt;style&gt;
@import url(&#39;a.css&#39;);
@import url(&#39;b.css&#39;);
@import url(&#39;c.css&#39;);
@import url(&#39;d.css&#39;);
@import url(&#39;e.css&#39;);
@import url(&#39;f.css&#39;);
&lt;/style&gt;
&lt;script src=&#39;one.js&#39; type=&#39;text/javascript&#39;&gt;&lt;/script&gt;
</code></pre><p>Looking at Figure 6, the longest bar is the four second script. Even though it was listed last, it gets downloaded first in IE. If the script contains code that depends on the styles applied from the stylesheets (a la getElementsByClassName, etc.), then unexpected results may occur because the script is loaded before the stylesheets, despite the developer listing it last.</p>
<p>看下图，最长的一条是一个四秒的脚本。尽管它位于最后，但是它在IE中是最早下载下来的。如果脚本包括依赖于样式表中的样式，会有未知的结果发生，因为脚本不是按照预期的顺序在样式之后加载的。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/many-imports.gif" alt="多个import"><br>     <figcaption><br>        多个import<br>     </figcaption><br></figure>

<p><strong>LINK LINK</strong></p>
<p>It’s simpler and safer to use LINK to pull in stylesheets:</p>
<p>使用LINK加载样式更快捷也更安全：</p>
<pre><code>&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;b.css&#39;&gt;
</code></pre><p>Using LINK ensures that stylesheets will be downloaded in parallel across all browsers. The LINK LINK example demonstrates this, as shown in Figure 7. Using LINK also guarantees resources are downloaded in the order specified by the developer.</p>
<p>使用LINK会确保样式表会在所有的浏览器中都并行下载。这个LINK LINK的例子证明了这点，使用LINk也保证资源会按开发者的顺序加载。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/import-import.gif" alt="使用link加载样式表"><br>     <figcaption><br>        使用link加载样式表<br>     </figcaption><br></figure>

<p>These issues need to be addressed in IE. It’s especially bad that resources can end up getting downloaded in a different order. All browsers should implement a small lookahead when downloading stylesheets to extract any @import rules and start those downloads immediately. Until browsers make these changes, I recommend avoiding @import and instead using LINK for inserting stylesheets.</p>
<p>这些问题在IE中都需要解决。尤其是资源会以不同的顺序下载的问题尤为糟糕。所有的浏览器都应该在下载样式表的时候就提取任何@import规则并立即开始下载。在浏览器进行这些更改之前，我建议避免使用@import，而应使用LINK来引入样式表。</p>
<p>The load times of these resources are exaggerated to make it easy to see what’s happening. But for people with slow connections, especially those in some of the world’s emerging markets, these response times may not be that far from reality. The takeaways are:</p>
<ol>
<li>Using @import within a stylesheet adds one more roundtrip to the overall download time of the page.</li>
<li>Using @import in IE causes the download order to be altered. This may cause stylesheets to take longer to download, which hinders progress rendering making the page feel slower.</li>
</ol>
<p>因为这些资源的加载时间被夸大，所有我们很容易看到发生了什么事情。但是对于那些网速慢的人来说，网络的响应时间也许并不那么块。 原因是：</p>
<ol>
<li>在样式表中使用@import会使得页面的整体下载时间再增加一倍。</li>
<li>在IE中使用@import会导致资源的下载顺序发生改变。这可能会导致样式表花费更长的时间来下载，因此会阻碍渲染，使页面加载的更慢。</li>
</ol>
<h3 id="2-微格式"><a href="#2-微格式" class="headerlink" title="2.微格式"></a>2.微格式</h3><p>对应官网为：<a href="http://microformats.org/" target="_blank" rel="noopener">http://microformats.org/</a></p>
<h4 id="微格式产生背景："><a href="#微格式产生背景：" class="headerlink" title="微格式产生背景："></a>微格式产生背景：</h4><p>由于早期HTML中缺少相应的元素，很难突出显示人、地点或日期等类型的信息。为了解决这个问题，有一组开发人员决定开发一套标准的命名约定盒标记模式来表示这些数据。这些命名约定基于vCard（电子名片）和iCalendar（日历数据交换）等现有的数据格式，现在称为微格式（microformat)。</p>
<h4 id="微格式定义："><a href="#微格式定义：" class="headerlink" title="微格式定义："></a>微格式定义：</h4><p>建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式（microformats.org官方定义）。是把语义嵌入到HTML以便有助于分离式开发而制定的一些简单约定，是兼顾人机可读性设计的数据表达方式，对Web网页进行语义注解的方法。</p>
<h4 id="微格式意义："><a href="#微格式意义：" class="headerlink" title="微格式意义："></a>微格式意义：</h4><p>微格式按照某种已有的被广泛应用的标准，通过对内容块的语义标记，可以让外部应用程序、聚合程序和搜索引擎能够做以下事情：</p>
<ol>
<li>在捉取Web内容时，能够更为准确地识别内容块的语义；</li>
<li>对内容进行操作，包括提供访问、校对，还可以将其转化成其他的相关格式，提供给外部程序和Web服务使用。</li>
</ol>
<p>因此，微格式实际上就是为现有的HTML元素添加元数据和其他属性以增强语义化。</p>
<p>常见的微格式是hCard</p>
<p>hCard是一种微格式，用来发布个人，公司，组织，地点等详细的联系信息。它可以包含在(X)HTML，Atom，RSS等可扩展置标语言中。hCard使用vCard（RFC 2426）的属性和值来实现这些功能。</p>
<p>它可以使分析器（比如其他网站，Firefox的Operator插件）获得详细的信息，并通过别的网站或者地图工具进行显示，或者载入到地址簿等其他程序。</p>
<p>example：</p>
<pre><code>&lt;div&gt;
     &lt;div&gt;Joe Doe&lt;/div&gt;
     &lt;div&gt;The Example Company&lt;/div&gt;
     &lt;div&gt;604-555-1234&lt;/div&gt;
     &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
 &lt;/div&gt;
</code></pre><p> 如下代码添加了微格式后，成为:</p>
<pre><code> &lt;div class=&quot;vcard&quot;&gt;
     &lt;div class=&quot;fn&quot;&gt;Joe Doe&lt;/div&gt;
     &lt;div class=&quot;org&quot;&gt;The Example Company&lt;/div&gt;
     &lt;div class=&quot;tel&quot;&gt;604-555-1234&lt;/div&gt;
     &lt;a class=&quot;url&quot; href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
 &lt;/div&gt;
</code></pre><p> 这里，正式名称（class=”fn”），组织（class=”org”），电话号码（class=”tel”）和url（class=”url”）分别用相应的class标示；同时，所有内容都包含在class=”vcard”里。</p>
<p> 以上就是微格式的大体内容。</p>
<h3 id="外边距叠加"><a href="#外边距叠加" class="headerlink" title="外边距叠加"></a>外边距叠加</h3><p>首先，先说明是什么导致的外边距叠加。</p>
<p>首先，外边距叠加是因为<strong>外边距塌陷(margin collapse)</strong>导致的。实际它也是由于一个缺省值的设定而导致的。在Chrome浏览器里，这个缺省值就是由-webkit-margin-collapse规定的。-webkit-margin-collapse的缺省值就是collapse，所以导致塌陷。这个属性还有另外2个取值：一个是discard，一个是separate。下面我们来具体看一下它们的不同表现形式。</p>
<h4 id="webkit-margin-collapse-collapse"><a href="#webkit-margin-collapse-collapse" class="headerlink" title="-webkit-margin-collapse: collapse"></a>-webkit-margin-collapse: collapse</h4><p>我们先从简单的看起。假定我们有这样一个<code>&lt;div&gt;</code>，这个<code>&lt;div&gt;</code>里面有3个<code>&lt;p&gt;</code>，如果我们什么也不设，它就是这个样子：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/157/537/1575372319-5a5eabae0c326_articlex" alt="未设置-webkit-margin-collapse"></p>
<p>会看到每一个<code>&lt;p&gt;</code>下面都有一个下边距。现在我们加上<code>margin: 20px 0;</code>表示为每一个<code>&lt;p&gt;</code>增加一个20px的上边距和一个20px的下边距，现在再看一下效果：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/537/919/537919608-5a5eac73b8e6c_articlex" alt="-webkit-margin-collapse: collapse"></p>
<p>这时我们看到虽然第一个<code>&lt;p&gt;</code>有20px的上边距，但第2个<code>&lt;p&gt;</code>的20px上边距已经被第一个<code>&lt;p&gt;</code>的下边距『吃掉』了，这就是我们大家所熟知的外边距塌陷。</p>
<h4 id="webkit-margin-collapse-separate"><a href="#webkit-margin-collapse-separate" class="headerlink" title="-webkit-margin-collapse: separate"></a>-webkit-margin-collapse: separate</h4><p>现在我们来看一下第2种情况，如果我们设定<code>-webkit-margin-collapse: separate</code>之后会怎么样：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/164/511/1645114860-5a5eb3d394158_articlex" alt="-webkit-margin-collapse: separate"></p>
<p>现在我们看到塌陷的外边距回来了。</p>
<h4 id="webkit-margin-collapse-discard"><a href="#webkit-margin-collapse-discard" class="headerlink" title="-webkit-margin-collapse: discard"></a>-webkit-margin-collapse: discard</h4><p>那么第3种取值<code>discard</code>是什么作用呢？</p>
<p><img src="https://sfault-image.b0.upaiyun.com/318/356/3183561786-5a5eb42f8c31d_articlex" alt="-webkit-margin-collapse: discard"></p>
<p>外边距完全没有了。</p>
<p>所以，如果我们想强制所有元素边距都不塌陷，那么该怎么办呢？</p>
<p>我们不能再简单地同时设置上下边距为<code>margin: 20px 0;</code>而应该更精确控制，给<code>&lt;p&gt;</code>只设置下边距为20px就可以了，这样我们就实现了在强制不塌陷的情况下依然保持了行与行之间的距离。</p>
<p>Tips:<br>『外边距塌陷』其实是W3C早期标准为了一时方便而引入的一个过度设计，它的设计初衷是为了简化，但结果在CSS高度发展的情况下反倒造成了更大的混乱，使得前端工程师无法一目了然地知道自己的代码结果，不明白自己明明已经设置好的<code>margin-top: 20px;</code>怎么就会没有了？结果被人告知还要学习外边距塌陷这样的知识。这样的错误责任不在于工程师没有好好学习，而根本原因在于CSS本身设计的缺陷，才导致了工程师学习成本的增加，并且还增加了浏览器开发者的工作量，需要特意为外边距塌陷开发额外的代码。无论如何，这是一件各方成本都增加的双输设计。</p>
<p>至于水平方向上为什么没有外边距叠加，我也不知道呀，也许当时就是为了解决垂直方向上外边距累加的问题吧，定义上就是这么定义的。</p>
<p>最后总结一下W3C中外边距叠加的内容</p>
<blockquote>
<p>In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin.</p>
</blockquote>
<p>在CSS中，两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。</p>
<p>我们可以注意定义中的几个关键字：毗邻、两个或多个、垂直方向和普通流。</p>
<h4 id="毗邻"><a href="#毗邻" class="headerlink" title="毗邻"></a>毗邻</h4><p>毗邻说明了他们的位置关系，没有被 padding、border、clear 和 line box 分隔开。</p>
<h4 id="两个或多个"><a href="#两个或多个" class="headerlink" title="两个或多个"></a>两个或多个</h4><p>两个或多个盒子是指元素之间的相互影响，单个元素不会存在外边距叠加的情况。</p>
<h4 id="垂直方向"><a href="#垂直方向" class="headerlink" title="垂直方向"></a>垂直方向</h4><blockquote>
<p>Horizontal margins never collapse.</p>
</blockquote>
<p>只有垂直方向的外边距会发生外边距叠加。水平方向的外边距不存在叠加的情况。</p>
<h4 id="普通流-in-flow"><a href="#普通流-in-flow" class="headerlink" title="普通流(in flow)"></a>普通流(in flow)</h4><p>什么是普通流？W3C 只对 out of flow 作了定义：</p>
<blockquote>
<p>An element is called out of flow if it is floated, absolutely positioned, or is the root element.An element is called in-flow if it is not out-of-flow.</p>
</blockquote>
<p>从定义中我们可以知道只要不是 float、absolutely positioned 和 root element 时就是 in flow。</p>
<h4 id="什么时候会发生外边距叠加"><a href="#什么时候会发生外边距叠加" class="headerlink" title="什么时候会发生外边距叠加"></a>什么时候会发生外边距叠加</h4><p>外边距叠加存在两种情况：一是父子外边距叠加；二是兄弟外边距叠加。</p>
<p>W3C 对于什么是毗邻的外边距也有定义：</p>
<blockquote>
<p>Two margins are adjoining if and only if: - both belong to in-flow block-level boxes that participate in the same block formatting context - no line boxes, no clearance, no padding and no border separate them - both belong to vertically-adjacent box edges, i.e. form one of the following pairs:</p>
<ul>
<li>top margin of a box and top margin of its first in-flow child</li>
<li>bottom margin of box and top margin of its next in-flow following sibling</li>
<li>bottom margin of a last in-flow child and bottom margin of its parent if the &gt; parent has “auto” computed height</li>
<li>top and bottom margins of a box that does not establish a new block formatting context and that has zero computed “min-height”, zero or “auto” computed “height”, and no in-flow children</li>
</ul>
</blockquote>
<p>从定义中我们可以很清楚的知道要符合哪些情况才会发生外边距折叠：</p>
<ul>
<li>都属于普通流的块级盒子且参与到相同的块级格式上下文中</li>
<li>没有被padding、border、clear和line box分隔开</li>
<li>都属于垂直毗邻盒子边缘：<ul>
<li>盒子的top margin和它第一个普通流子元素的top margin</li>
<li>盒子的bottom margin和它下一个普通流兄弟的top margin</li>
<li>盒子的bottom margin和它父元素的bottom margin</li>
<li>盒子的top margin和bottom margin，且没有创建一个新的块级格式上下文，且有被计算为0的min-height，被计算为0或auto的height，且没有普通流子元素</li>
</ul>
</li>
</ul>
<h4 id="如何避免外边距叠加"><a href="#如何避免外边距叠加" class="headerlink" title="如何避免外边距叠加"></a>如何避免外边距叠加</h4><p>上面讲了外边距的叠加，那如何避免呢，其实只要破坏上面讲到的四个条件中的任何一个即可：毗邻、两个或多个、普通流和垂直方向。</p>
<p>W3C也对此做了总结：</p>
<blockquote>
<ul>
<li>Margins between a floated box and any other box do not collapse (not even between a float and its in-flow children).</li>
<li>Margins of elements that establish new block formatting contexts (such as floats and elements with “overflow” other than “visible”) do not collapse with their in-flow children.</li>
<li>Margins of absolutely positioned boxes do not collapse (not even with their in-flow children).</li>
<li>Margins of inline-block boxes do not collapse (not even with their in-flow children).</li>
<li>The bottom margin of an in-flow block-level element always collapses with the top margin of its next in-flow block-level sibling, unless that sibling has clearance.</li>
<li>The top margin of an in-flow block element collapses with its first in-flow block-level child”s top margin if the element has no top border, no top padding, and the child has no clearance.</li>
<li>The bottom margin of an in-flow block box with a “height” of “auto” and a “min-height” of zero collapses with its last in-flow block-level child”s bottom margin if the box has no bottom padding and no bottom border and the child”s bottom margin does not collapse with a top margin that has clearance.</li>
<li>A box”s own margins collapse if the “min-height” property is zero, and it has neither top or bottom borders nor top or bottom padding, and it has a “height” of either 0 or “auto”, and it does not contain a line box, and all of its in-flow children”s margins (if any) collapse.</li>
</ul>
</blockquote>
<ul>
<li>浮动元素不会与任何元素发生叠加，也包括它的子元素</li>
<li>创建了 BFC 的元素不会和它的子元素发生外边距叠加</li>
<li>绝对定位元素和其他任何元素之间不发生外边距叠加，也包括它的子元素</li>
<li>inline-block 元素和其他任何元素之间不发生外边距叠加，也包括它的子元素</li>
<li>普通流中的块级元素的 margin-bottom 永远和它相邻的下一个块级元素的 margin-top 叠加，除非相邻的兄弟元素 clear</li>
<li>普通流中的块级元素（没有 border-top、没有 padding-top）的 margin-top 和它的第一个普通流中的子元素（没有clear）发生 margin-top 叠加</li>
<li>普通流中的块级元素（height为 auto、min-height为0、没有 border-bottom、没有 padding-bottom）和它的最后一个普通流中的子元素（没有自身发生margin叠加或clear）发生 margin-bottom叠加</li>
<li>如果一个元素的 min-height 为0、没有 border、没有padding、高度为0或者auto、不包含子元素，那么它自身的外边距会发生叠加</li>
</ul>
<p>以上就是外边距叠加的主要内容。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array --6.Min Cost Climbing Stairs]]></title>
      <url>/2018/01/25/leetCode/6.Min_Cost_Climbing_Stairs/</url>
      <content type="html"><![CDATA[<h2 id="Problem-six-Min-Cost-Climbing-Stairs"><a href="#Problem-six-Min-Cost-Climbing-Stairs" class="headerlink" title="Problem six: Min Cost Climbing Stairs"></a>Problem six: Min Cost Climbing Stairs</h2><p>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).</p>
<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> cost = [10, 15, 20]<br>  <strong>Output:</strong> 15<br>  <strong>Explanation:</strong> Cheapest is start on cost[1], pay that cost and go to the top.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>  <strong>Output:</strong> 6<br>  <strong>Explanation:</strong> Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>cost will have a length in the range [2, 1000].</li>
<li>Every cost[i] will be an integer in the range [0, 999].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.第一眼看这道题，显然是一道递归题，照着这个思路做很容易就做出来了。</p>
<pre><code>var minCostClimbingStairs = function(cost) {
    for(var i=2;i&lt;=cost.length-1;i++){
        cost[i]=cost[i]+Math.min(cost[i-1],cost[i-2]);
    }

    return Math.min(cost[cost.length-1],cost[cost.length-2]);

};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<ol>
<li>同理，也有一种类似的解法，三个元素三个元素的比较，最后一个元素的最小值就是前两个元素的最小值加上对应的值。<pre><code>var minCostClimbingStairs = function(cost) {
 var firstElement = 0, secondElement = 0, thirdElement = 0;
  for(var i=2;i &lt;= cost.length;i++){
      thirdElement = Math.min(secondElement + cost[i-1], firstElement + cost[i-2]);
      firstElement = secondElement;
      secondElement = thirdElement;
  }
  return thirdElement;
};
</code></pre>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</li>
</ol>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 5.Largest Number At Least Twice of Others]]></title>
      <url>/2018/01/25/leetCode/5.Largest_Number_At_Least_Twice_of_Others/</url>
      <content type="html"><![CDATA[<h2 id="Problem-five-Largest-Number-At-Least-Twice-of-Others"><a href="#Problem-five-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="Problem five: Largest Number At Least Twice of Others"></a>Problem five: Largest Number At Least Twice of Others</h2><p>In a given integer array nums, there is always exactly one largest element.</p>
<p>Find whether the largest element in the array is at least twice as much as every other number in the array.</p>
<p>If it is, return the index of the largest element, otherwise return -1.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [3, 6, 1, 0]<br>  <strong>Output:</strong> 1<br>  <strong>Explanation:</strong> 6 is the largest integer, and for every other number in the array x,<br>    6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [1, 2, 3, 4]<br>  <strong>Output:</strong> -1<br>  <strong>Explanation:</strong> 4 isn’t at least as big as twice the value of 3, so we return -1.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>nums will have a length in the range [1, 50].</li>
<li>Every nums[i] will be an integer in the range [0, 99].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.最开始想到的是用sort()函数来解决这个问题，但是需要注意两点：在sort函数中添加判断数字大小的函数，否则会将数字视为字符串，用最开始的数字进行排序；再一个就是在复制数组时，不能直接使用‘=’进行复制操作，因为这样其实传递的是数组地址，如果这样赋值，在对原先数组进行操作时，其实会对新建的数组进行修改。</p>
<pre><code>function sequence(a,b){
         if (a&gt;b) {
             return 1;
         }else if(a&lt;b){
              return -1
         }else{
             return 0;
        }
};
var dominantIndex = function(nums) {
    var nums_copy;
    nums_copy = [];
    for(var m = 0; m &lt; nums.length; m++) {
        nums_copy[m] = nums[m];
    }
    nums.sort(sequence);
    if(nums.length == 1)
        return 0;
    if(nums[nums.length - 2] &gt; 0) {
        if(nums[nums.length - 1]/nums[nums.length - 2] &gt;= 2) {
            for(var i = 0; i &lt; nums_copy.length; i++) {
                if(nums_copy[i] == nums[nums.length -1])
                    return i;
            }
        } else
            return -1;
    } else {
        for(var n = 0; n &lt; nums_copy.length; n++) {
            if(nums_copy[n] == nums[nums.length -1])
                return n;
        }
    }
};
</code></pre><p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度；</p>
<p>2.一开始以为上述方法比较简单，但实际写下来还有需要细节要注意，因此，先选出数组中的最大值，在与数组中的所有元素进行对比，当有元素大于nums[maxIndex]的1/2时，返回-1，否则返回该最大值下标。</p>
<pre><code>var dominantIndex = function(nums) {
    var maxIndex = 0;
        for (var i = 0; i &lt; nums.length; ++i) {
            if (nums[i] &gt; nums[maxIndex])
                maxIndex = i;
        }
        for (var i = 0; i &lt; nums.length; ++i) {
            if (maxIndex != i &amp;&amp; nums[maxIndex] &lt; 2 * nums[i])
                return -1;
        }
        return maxIndex;
};
</code></pre><p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度;</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 4.longest continuous increasing subsequence]]></title>
      <url>/2018/01/25/leetCode/4.longest_continuous_increasing_subsequence/</url>
      <content type="html"><![CDATA[<h2 id="Problem-four-longest-continuous-increasing-subsequence"><a href="#Problem-four-longest-continuous-increasing-subsequence" class="headerlink" title="Problem four: longest continuous increasing subsequence"></a>Problem four: longest continuous increasing subsequence</h2><p>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,3,5,4,7]<br>  <strong>Output:</strong> 3<br>  <strong>Explanation:</strong> The longest continuous increasing subsequence is [1,3,5], its length is 3.<br>  Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4. </p>
</blockquote>
<p>  <strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [2,2,2,2,2]<br>  <strong>Output:</strong> 1<br>  <strong>Explanation:</strong> The longest continuous increasing subsequence is [2], its length is 1.</p>
</blockquote>
<p><strong>Note:</strong> Length of the array will not exceed 10,000.</p>
<p><strong>solution:</strong></p>
<p>1.直观的想法是遍历数组时，当数字持续增加时用一个数字存储累加的总和，在减少时与另一个初始为0的数字对比，如果大于这个存放之前的最长长度的数字，则替换该值，并重置计数的大小。最后，比较最后一次累加数值的大小，返回最大值。</p>
<pre><code>var findLengthOfLCIS = function(nums) {
    var num = 1;
    var maxLength = 0;
    if(nums.length == 0)
        return 0;
    for(var i = 1; i &lt; nums.length;  i++) {
        if(nums[i] &gt; nums[i-1]) {
            num++;
        } else {
            if(num &gt; maxLength) {
                maxLength = num;
            }
            num = 1;
        }
    }
    if(num &gt; maxLength) 
        return num;
    else
        return maxLength;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.因为累加的子串是在nums[i-1] &gt;= nums[i]时发生变化的，也就是说我们将变化的元素下标记录下来，当前一个元素大于后一个元素时，将当前元素下标赋值给anchor，在累加的过程中，ans会用之前的最长串与现在的累加的串的长度作对比，保留最长串。</p>
<pre><code>var findLengthOfLCIS = function(nums) {
    var ans = 0;
    var anchor = 0;
        for (var i = 0; i &lt; nums.length; ++i) {
            if (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i])
                anchor = i;
            ans = Math.max(ans, i - anchor + 1);
        }
        return ans;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Array -- 3.Best Time to Buy and Sell Stock]]></title>
      <url>/2018/01/23/leetCode/3.Best_Time_to_Buy_and_sell_stock/</url>
      <content type="html"><![CDATA[<h2 id="Problem-three-Best-Time-to-Buy-and-Sell-Stock"><a href="#Problem-three-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Problem three: Best Time to Buy and Sell Stock"></a>Problem three: Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [7, 1, 5, 3, 6, 4]<br><strong>Output:</strong> 5<br>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [7, 6, 4, 3, 1]<br><strong>Output:</strong> 0<br>In this case, no transaction is done, i.e. max profit = 0.</p>
</blockquote>
<p><strong>solution:</strong></p>
<p>1.这道题主要考察的是边界条件的判断，首先，将第二个元素与第一个元素进行对比，如果第二个元素大，则设置maxProfit，minPrice和maxPrice，如果第一个元素大，设置maxPrice，minPrice。若不为前两个元素，需要考虑下一个元素与之前最小的元素比较是否会大于之前的maxProfit，若大于，则设置maxProfit和maxPrice，否则设置minPrice。以此类推，最后返回maxProfit。</p>
<pre><code>var maxProfit = function(prices) {
    var maxProfit = 0;
    var maxPrice = 0;
    var minPrice = 0;
    for(var i = 1; i &lt; prices.length; i++) {
        if(i == 1) {
            if((prices[i] - prices[i-1]) &gt; maxProfit) {
                maxProfit = prices[i] - prices[i-1];
                minPrice = prices[i - 1];
                maxPrice = prices[i];
            } 
            else {
                minPrice = prices[i];
                maxPrice = prices[i-1];
            }
        }else {
            if((prices[i] - minPrice) &gt; maxProfit) {
                maxProfit = prices[i] - minPrice;
                maxPrice = prices[i];
            }
            else{
                if(minPrice &gt; prices[i]) {
                    minPrice = prices[i];  
                }
            }
        }
    }
    return maxProfit;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.接下来换一种思想比较简单的方法，现在需要找到最大的差值，且大的数在后面，小的数在前面，所以，可以两层嵌套，比较元素后面的值并选出最大的值。</p>
<pre><code>var maxProfit = function(prices) {
     var maxprofit = 0;
        for (var i = 0; i &lt; prices.length - 1; i++) {
            for (var j = i + 1; j &lt; prices.length; j++) {
                var profit = prices[j] - prices[i];
                if (profit &gt; maxprofit)
                    maxprofit = profit;
            }
        }
        return maxprofit;
  };
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), 循环n(n-1)/2遍，效果很差。</p>
<p>3.接下来的方法和第一种类似，先去一个特别大的最小值和特别大的最大值，然后进行遍历，若当前元素小于最小值，则替换最小值，否则就与最小值比较，若大于最大差值，则替换最大差值。这个方法与第一种比不需要保存最大值。</p>
<pre><code>var maxProfit = function(prices) {
     var minprice = 9999999;
     var maxprofit = 0;
        for (var i = 0; i &lt; prices.length; i++) {
            if (prices[i] &lt; minprice)
                minprice = prices[i];
            else if (prices[i] - minprice &gt; maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
  };
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Array -- 2.Remove Element]]></title>
      <url>/2018/01/23/leetCode/2.remove_element/</url>
      <content type="html"><![CDATA[<h2 id="Problem-two-Remove-Element"><a href="#Problem-two-Remove-Element" class="headerlink" title="Problem two: Remove Element"></a>Problem two: Remove Element</h2><p>Given an array and a value, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example:</strong></p>
<blockquote>
<p>Given <strong>nums</strong> = [3,2,2,3], val = 3,</p>
</blockquote>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p><strong>solution:</strong></p>
<p>1.最直接的方法是使用数组自带的splice方法，需要注意的是当remove掉相符合的元素后，要将下标减一，不然会造成数组减少一个元素后，原元素后面的元素序号会提前一个，会忽略掉下一个元素。</p>
<pre><code>var removeElement = function(nums, val) {
    for(var i = 0; i&lt; nums.length; i++) {
        if(nums[i] == val) {
            nums.splice(i, 1);
            i -= 1;
        } 
    } 
    return nums.length;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.另一种方法是在遍历数组过程中，如果元素的值等于对应的value，则将当前元素与最后一个元素交换位置，然后将数组长度减1，变相的去除数组的重复项，可惜的是，这种方法和splice()消耗的时间几近相同。</p>
<pre><code>var removeElement = function(nums, val) {
    var i = 0;
    var num = nums.length;
    while (i &lt; num) {
        if (nums[i] == val) {
            nums[i] = nums[num - 1];
            num--;
        } else {
            i++;
        }
    }
    return num;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 1.Find Pivot Index]]></title>
      <url>/2018/01/23/leetCode/1.find_pivot_index/</url>
      <content type="html"><![CDATA[<h2 id="Problem-one-Find-Pivot-Index"><a href="#Problem-one-Find-Pivot-Index" class="headerlink" title="Problem one: Find Pivot Index"></a>Problem one: Find Pivot Index</h2><p>Given an array of integers nums, write a method that returns the “pivot” index of this array.</p>
<p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p>
<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br><strong>nums</strong> = [1, 7, 3, 6, 5, 6]<br><strong>Output</strong>: 3<br><strong>Explanation</strong>:<br>The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.<br>Also, 3 is the first index where this occurs.</p>
</blockquote>
<p><strong>Example</strong> 2:</p>
<blockquote>
<p><strong>Input:</strong><br><strong>nums</strong> = [1, 2, 3]<br><strong>Output</strong>: -1<br><strong>Explanation</strong>:<br>There is no index that satisfies the conditions in the problem statement.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The length of nums will be in the range [0, 10000].</li>
<li>Each element nums[i] will be an integer in the range [-1000, 1000].</li>
</ul>
<p><strong>solution:</strong></p>
<ol>
<li><p>直接想到的是遍历数组，将每个元素左侧的元素和与右侧元素和比较，相同则返回对应元素下标。（若第一个元素右侧和为0，则返回第一个元素下标）。否则返回-1；</p>
<pre><code>var pivotIndex = function(nums) {
 var leftSum = 0;
 var rightSum = 0;
 for(var i = 0; i &lt; nums.length; i++) {
     if(i == 0) {
         leftSum =0;
     }else{
         leftSum += nums[i-1];
     }
     for(var n = i+1; n &lt; nums.length; n++) {
         rightSum += nums[n];    
     }
     if(leftSum == rightSum) 
         return i;
     rightSum = 0;
 }
 return -1;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为nums的长度；</p>
</li>
<li><p>上一种方法的问题在于要用两遍for循环，时间复杂度过高，所以尽量减少嵌套：</p>
<pre><code class="javascript">var pivotIndex = function(nums) {
 var leftSum =0;
 var sum = 0;
 for(var i = 0; i&lt; nums.length; i++) 
     sum += nums[i];
  for (var n = 0; n &lt; nums.length; n++) {
     if (leftSum == (sum - leftSum - nums[n])) 
         return n;
     leftSum += nums[n];
 }
 return -1;
}
</code></pre>
<p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度；</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建github博客]]></title>
      <url>/2018/01/12/blog/%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="搭建github博客-amp-使用hexo博客框架-amp-使用material主题"><a href="#搭建github博客-amp-使用hexo博客框架-amp-使用material主题" class="headerlink" title="搭建github博客&amp;使用hexo博客框架&amp;使用material主题"></a>搭建github博客&amp;使用hexo博客框架&amp;使用material主题</h2><p>因为原先在CSDN上有各种各样的限制和难言之隐，所以在生庆哥的帮助和怂恿下，选择使用github搭建博客并个性化设置，主要说一下大体过程和期间的问题。主要的内容可以分为以下三类：</p>
<ul>
<li>搭建github博客</li>
<li>使用hexo框架</li>
<li>使用material主题</li>
</ul>
<h3 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h3><p>其实之前在学校的时候一直知道github看可以搭建博客，还可以直接使用对应的域名，但是出于各种原因一直没有自己搭建一个博客尝试尝试，终于，现在正好有时间和精力可以试试。<br>在个人github首页上，创建一个github.io的框架，即个人账户+仓库名，如：lpldplws.github.io。因为此仓库就是用来放博客的，所以在master分支上开发，然后在setting页面中选择launch automatic page generator生成博客项目。然后将该项目clone到本地，最初的博客就搭建成了~</p>
<p>个人博客地址是<a href="https://github.com/lpldplws/lpldplws.github.io" target="_blank" rel="noopener">lpldplws.github.io</a>。<br>接下来要做的就是redirect到自己的域名，在阿里上买了一个29一年的域名，名字是<a href="http://www.lpldplws.cn">lpldplws.cn</a>,需要做的是在clone下的项目的根目录下建立好映射，创建一个”CNAME”（没有后缀名）的文件，之后访问lpldplws.github.io就会redirect到此域名，或者您在对应的域名服务商上面修改CNAME到对应的github仓库地址也是可以的。<br>注意：此处因为是直接在master分支上创建的，之后也是在master分支上使用的框架和主题，导致最后hexo generate的内容保存到了github.io中，这部分是接下来一周需要解决的问题之一。</p>
<h3 id="使用hexo框架"><a href="#使用hexo框架" class="headerlink" title="使用hexo框架"></a>使用hexo框架</h3><p>之所以知道这个框架是因为咱们的FE团队的翻译框架就是这个，所以此处借鉴了以下，嘿嘿。<br>在<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>上,介绍了这是一个简单高效的博客框架，在github.io仓库中，使用npm安装即可。虽然可以支持markdown的格式，但是其自带的tag也是非常方便的，我看还可以使用youtube视频，厉害了，这理所当然的成为下周需要学习的内容之一了。<br>还有一个比较深的体会是使用hexo的感觉就像开发机一样，通过hexo server相当于在开发机上查看效果，使用hexo generate和hexo deploy相当于部署在线上环境，就是少了review的部分，不过对于一个个人博客来说还是比较完善的了。</p>
<h3 id="使用material主题"><a href="#使用material主题" class="headerlink" title="使用material主题"></a>使用material主题</h3><p>使用hexo默认界面当然不能满足自己的审美了，在一番选择（选择恐惧症）后，终于选(sui)择(ji)了一个比较好看的theme，这就是<a href="https://material.viosey.com/" target="_blank" rel="noopener">material</a>，这个主题比较素雅，正好很吸引我~以下主要说明material主题配置中遇到的问题。其中主要的配置文件在<code>config.template.yaml</code>中，不过需要先将其改名为<code>config.yaml</code>。在页面配置中，按照流程可以选择对应的插件和效果，比较吸引人的是它的背景可以从必应上选择，后来因为颜色不匹配主题就去掉了，个人打算通过对选项加一个filter或者下到对应文件随机加载是个不错的选择，所以下周又新加了一项任务。还有一点就是评论系统和统计系统，个人选择的是<code>Valine</code>，因为考虑到可以使用对应后台查看信息，不过缺点就是有点丑。。。后来生庆哥说Google的后台数据处理用的人很多，所以打算抛弃当前评论系统，投入其他评论系统的怀抱。<br>对于独立页面部分还没有怎么看，下周来吧，除此之外，除了在mobile上效果还行，pc上两端有点空，所以想加一个音乐播放器，这部分打算选择网易云的api，实现一个音乐播放的效果。其他的内容就慢慢补全吧，这周过的虽然很累但还是很充实，个人也应该静下心来，虽然很多不会，但是相信通过付出比别人更多的努力，一定快速达到可以帮助到胡老师和FE团队的地步，fighting！</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
  
</search>
