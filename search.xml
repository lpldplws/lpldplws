<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[git problem -- 1.git&gerrit邮箱不匹配]]></title>
      <url>/2018/05/11/git/git_problem/01.git_problem/</url>
      <content type="html"><![CDATA[<h2 id="git-problem-–-git-amp-gerrit邮箱不匹配"><a href="#git-problem-–-git-amp-gerrit邮箱不匹配" class="headerlink" title="git problem – git&amp;gerrit邮箱不匹配"></a>git problem – git&amp;gerrit邮箱不匹配</h2><p>Git邮箱不匹配问题 does not match your user account</p>
<p>在活动比较多，使用分支开发的时候，从远端拉取分支，在完成fetch-&gt;rebase-&gt;修改代码以后，执行gerrit push指令时，提示用户信息不匹配。类似于下图所示：</p>
<p><img src="/images/git/01.git_account.png"></p>
<pre><code>remote: ERROR:  In commit 024c0bd88da87274f956a10dfa6b41e8c69ebd04
remote: ERROR:  author email address xxxxx@xx.com
remote: ERROR:  does not match your user account.
</code></pre><p>此问题解决方法：（不仅仅限于分支，master分支出现类似问题也可以用此方法）</p>
<pre><code>(1)git  config user.email (email地址)
(2)git checkout -b another_branch（如果已经被占，随便再换一个）
(3)git branch -D pre_branch(删除出现问题的分支)
(4)git checkout --track origin/pre_branch
(5)git push origin/pre_branch:refs/for/pre_branch  此时原先出现问题的分支就可以push成功了
</code></pre>]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git problem </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 04.Components and Props]]></title>
      <url>/2018/05/08/react/02.Quick_Start/04.Components_and_Props/</url>
      <content type="html"><![CDATA[<h2 id="Components-and-Props"><a href="#Components-and-Props" class="headerlink" title="Components and Props"></a>Components and Props</h2><p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.</p>
<p>组件可以让您将用户界面分成独立的，可重复使用的部分，并且每一部分都相互独立。</p>
<p>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.</p>
<p>从概念上讲，组件就像JavaScript的函数一样。他可以接受任意值的输入（我们通常称之为“参数”）并返回显示在屏幕上的React元素。</p>
<h3 id="Functional-and-Class-Components-函数和类组件"><a href="#Functional-and-Class-Components-函数和类组件" class="headerlink" title="Functional and Class Components(函数和类组件)"></a>Functional and Class Components(函数和类组件)</h3><p>The simplest way to define a component is to write a JavaScript function:</p>
<p>定义一个组件最简单的方法是写一个JavaScript函数：</p>
<pre><code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}
</code></pre><p>This function is a valid React component because it accepts a single “props” (which stands for properties) object argument with data and returns a React element. We call such components “functional” because they are literally JavaScript functions.</p>
<p>这个函数是一个有效的React组件，因为它可以接受一个带有数据的单一的“参数”（通常代表着属性）对象并返回一个React元素。我们称这样的组件是“函数化”的，因为它们都是JavaScript字面上的方法。</p>
<p>You can also use an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a> to define a component:</p>
<p>您也可以使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>来定义一个组件：</p>
<pre><code>class Welcome extends React.Component {
  render() {
    return &lt;h1&gt;Hello, {this.props.name}&lt;/h1&gt;;
  }
}
</code></pre><p>The above two components are equivalent from React’s point of view.</p>
<p>以上两种组件对于React来说是等价的。</p>
<p>Classes have some additional features that we will discuss in the <a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">next sections</a>. Until then, we will use functional components for their conciseness.</p>
<p>类通常有一些额外的特性，我们会在<a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一章节</a>讨论这些内容。在此之前，我们将会使用更为简洁的函数组件。</p>
<h3 id="Rendering-a-Component-渲染一个组件"><a href="#Rendering-a-Component-渲染一个组件" class="headerlink" title="Rendering a Component(渲染一个组件)"></a>Rendering a Component(渲染一个组件)</h3><p>Previously, we only encountered React elements that represent DOM tags:</p>
<p>在此之前，我们仅仅遇到过使用DOM标签表示的React元素：</p>
<pre><code>const element = &lt;div /&gt;;
</code></pre><p>However, elements can also represent user-defined components:</p>
<p>然而，元素也可以代表用户自定义的组件：</p>
<pre><code>const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;
</code></pre><p>When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object “props”.</p>
<p>当React遇到一个用户自定义的组件时，他就会传递JSX属性作为单一的对象给它们的组件。我们称之为对象的“属性”。</p>
<p>For example, this code renders “Hello, Sara” on the page:</p>
<p>例如，以下代码将会把“Hello, Sara”渲染到页面上：</p>
<pre><code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

const element = &lt;Welcome name=&quot;Sara&quot; /&gt;;
ReactDOM.render(
  element,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/rendering-a-component" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Let’s recap what happens in this example:</p>
<p>让我们回顾一下上述代码发生了什么：</p>
<ol>
<li>We call <code>ReactDOM.render()</code> with the <code><welcome name="Sara"></welcome></code> element.</li>
<li>React calls the <code>Welcome</code> component with <code>{name: ‘Sara’}</code> as the props.</li>
<li>Our <code>Welcome</code> component returns a <code>Hello, Sara</code> element as the result.</li>
<li>React DOM efficiently updates the DOM to match <code>Hello, Sara</code>.</li>
</ol>
<hr>
<ol>
<li>我们对<code><welcome name="Sara"></welcome></code>元素调用了<code>ReactDOM.render()</code>。</li>
<li>React调用了<code>Welcome</code>组件，并将<code>{name: ‘Sara’}</code>作为参数。</li>
<li>我们的<code>Welcome</code>返回一个<code>Hello, Sara</code>元素作为结果。</li>
<li>React DOM会很快更新DOM，并显示<code>Hello, Sara</code>。</li>
</ol>
<blockquote>
<p>Note: Always start component names with a capital letter.<br>React treats components starting with lowercase letters as DOM tags. For example, <code>div</code> represents an HTML div tag, but <code>Welcome</code> represents a component and requires Welcome to be in scope.<br>You can read more about the reasoning behind this convention <a href="https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized" target="_blank" rel="noopener">here</a>.</p>
</blockquote>
<hr>
<blockquote>
<p>注意：通常一个组件的命名是以大写字母开始的。<br>React会将以小写字母开头的组件视为DOM标签。例如，<code>div</code>表示一个HTML div标签，但<code>Welcome</code>表示一个组件，并且要求Welcome在作用域内。<br>您可以在<a href="https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized" target="_blank" rel="noopener">这里</a>阅读更多关于背后的内容。</p>
</blockquote>
<h3 id="Composing-Components-构成组件"><a href="#Composing-Components-构成组件" class="headerlink" title="Composing Components(构成组件)"></a>Composing Components(构成组件)</h3><p>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</p>
<p>组件能在它们的输出中引用其他的组件。这让我们可以对任何有相同内容的细节抽象出相同的部分。例如一个按钮，一个表格，一个对话框，一个屏幕：在React应用程序中，所有这些都通常表示为组件。</p>
<p>For example, we can create an App component that renders Welcome many times:</p>
<p>例如，我们可以创建一个App组件来渲染很多遍Welcome：</p>
<pre><code>function Welcome(props) {
  return &lt;h1&gt;Hello, {props.name}&lt;/h1&gt;;
}

function App() {
  return (
    &lt;div&gt;
      &lt;Welcome name=&quot;Sara&quot; /&gt;
      &lt;Welcome name=&quot;Cahal&quot; /&gt;
      &lt;Welcome name=&quot;Edite&quot; /&gt;
    &lt;/div&gt;
  );
}

ReactDOM.render(
  &lt;App /&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/composing-components" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Typically, new React apps have a single <code>App</code> component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like <code>Button</code> and gradually work your way to the top of the view hierarchy.</p>
<p>通常情况下，一个新的React<code>APP</code>会在顶层架构上有单一的应用组件。但是，如果您将React集成到现有的应用程序中，则可以使用<code>Button</code>之类的小组件自下而上地嵌入进去，并逐渐转向视图层次结构的顶部。</p>
<h3 id="Extracting-Components-抽象组件"><a href="#Extracting-Components-抽象组件" class="headerlink" title="Extracting Components(抽象组件)"></a>Extracting Components(抽象组件)</h3><p>Don’t be afraid to split components into smaller components.</p>
<p>永远不要担心将组件分成更小的组件。</p>
<p>For example, consider this <code>Comment</code> component:</p>
<p>观看下列例子，考虑<code>Comment</code>组件：</p>
<pre><code>function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;img className=&quot;Avatar&quot;
          src={props.author.avatarUrl}
          alt={props.author.name}
        /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/extracting-components" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>It accepts author (an object), text (a string), and date (a date) as props, and describes a comment on a social media website.</p>
<p>它会接受用户(一个对象)，文本(一个字符串)，和日期(一个时间)作为参数，并且可以描述一个社交媒体平台上的一个评论。</p>
<p>This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let’s extract a few components from it.</p>
<p>因为有大量的嵌套，这个组件可能会变得很棘手，并且它的单一部分也很难复用。让我们将它抽象成一些小的组件。</p>
<p>First, we will extract Avatar:</p>
<p>首先，我们会抽象出Avatar：</p>
<pre><code>function Avatar(props) {
  return (
    &lt;img className=&quot;Avatar&quot;
      src={props.user.avatarUrl}
      alt={props.user.name}
    /&gt;

  );
}
</code></pre><p>The Avatar doesn’t need to know that it is being rendered inside a Comment. This is why we have given its prop a more generic name: user rather than author.</p>
<p>Avatar不需要知道它是否被渲染在一个评论中。这也是为什么我们可以将它的参数设置为一个更符合的名字：使用user而不是author</p>
<p>We recommend naming props from the component’s own point of view rather than the context in which it is being used.</p>
<p>我们建议从组件自身的角度命名参数而不是从它使用的环境下命名。</p>
<p>We can now simplify Comment a tiny bit:</p>
<p>因此我们可以将评论简化一些：</p>
<pre><code>function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;div className=&quot;UserInfo&quot;&gt;
        &lt;Avatar user={props.author} /&gt;
        &lt;div className=&quot;UserInfo-name&quot;&gt;
          {props.author.name}
        &lt;/div&gt;
      &lt;/div&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>Next, we will extract a UserInfo component that renders an Avatar next to the user’s name:</p>
<p>接下来，我们将会将UserInfo组件抽象出来，该组件会将Avatar呈现给旁边的用户的姓名出来：</p>
<pre><code>function UserInfo(props) {
  return (
    &lt;div className=&quot;UserInfo&quot;&gt;
      &lt;Avatar user={props.user} /&gt;
      &lt;div className=&quot;UserInfo-name&quot;&gt;
        {props.user.name}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p>This lets us simplify Comment even further:</p>
<p>这样Comment比之前更加简化了。</p>
<pre><code>function Comment(props) {
  return (
    &lt;div className=&quot;Comment&quot;&gt;
      &lt;UserInfo user={props.author} /&gt;
      &lt;div className=&quot;Comment-text&quot;&gt;
        {props.text}
      &lt;/div&gt;
      &lt;div className=&quot;Comment-date&quot;&gt;
        {formatDate(props.date)}
      &lt;/div&gt;
    &lt;/div&gt;
  );
}
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/extracting-components-continued" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be a reusable component.</p>
<p>首先提取组件可能看起来像重复工作，但在更大的应用程序中，我们可以提取出可重用的部分。一个好的经验法则是，如果你的用户界面的一部分被多次使用（按钮，面板，头像），或者它本身已经足够复杂，那么它会是一个好的可重用组件的选择。</p>
<h3 id="Props-are-Read-Only-属性是只读的"><a href="#Props-are-Read-Only-属性是只读的" class="headerlink" title="Props are Read-Only(属性是只读的)"></a>Props are Read-Only(属性是只读的)</h3><p>Whether you declare a component as a function or a class, it must never modify its own props. Consider this sum function:</p>
<p>不管您是否是通过函数或者类来声明组件的，它永远都不能修改属于它自己的参数。考虑下面的加法函数：</p>
<pre><code>function sum(a, b) {
  return a + b;
}
</code></pre><p>Such functions are called <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“pure”</a> because they do not attempt to change their inputs, and always return the same result for the same inputs.</p>
<p>这样的函数是<a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“纯函数”</a>，因为它们不会试图改变它们的输入，并总会对于相同的输入返回相同的值。</p>
<p>In contrast, this function is impure because it changes its own input:</p>
<p>相反的，下面这个函数就是动机不纯的，因为它会改变它本身的输入：</p>
<pre><code>function withdraw(account, amount) {
  account.total -= amount;
}
</code></pre><p>React is pretty flexible but it has a single strict rule:</p>
<p>React十分灵活，但是它有一个特别严格的规定：</p>
<p><strong>All React components must act like pure functions with respect to their props.</strong></p>
<p><strong>所有的React组件都必须表现的想一个纯函数一样，并不会修改它们的属性。</strong></p>
<p>Of course, application UIs are dynamic and change over time. In the <a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">next section</a>, we will introduce a new concept of “state”. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.</p>
<p>当然，应用的UI是动态的，并且会随时间的改变而改变。在<a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一章节</a>中，我们会介绍一个新的概念“状态”。状态允许React组件随着用户的动作，网络的反馈和任何其他事情的来随时改变它们的输出，并且不会违背这个规则。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 03.Rendering Elements]]></title>
      <url>/2018/05/04/react/02.Quick_Start/03.Rendering_Elements/</url>
      <content type="html"><![CDATA[<h2 id="Rendering-Elements"><a href="#Rendering-Elements" class="headerlink" title="Rendering Elements"></a>Rendering Elements</h2><p>Elements are the smallest building blocks of React apps.</p>
<p>元素是React 应用中最小的构建组块。</p>
<p>An element describes what you want to see on the screen:</p>
<p>以下是一个描述了您在在屏幕上想看到的元素：</p>
<pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
</code></pre><p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p>
<p>不想浏览器的DOM元素，React元素是普通对象，并且很容易创建。React DOM负责更新DOM以便于匹配React元素。</p>
<blockquote>
<p>Note:<br>One might confuse elements with a more widely known concept of “components”. We will introduce components in the <a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">next section</a>. Elements are what components are “made of”, and we encourage you to read this section before jumping ahead.</p>
<p>注意：<br>人们可能会将元素与更广为人知的“组件”概念混为一谈。 我们将在<a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">下一部分</a>介绍组件。 组件是由元素“组成”的，我们鼓励您在跳过本节之前先阅读本节内容。</p>
</blockquote>
<h3 id="Rendering-an-Element-into-the-DOM-渲染一个在DOM中的元素"><a href="#Rendering-an-Element-into-the-DOM-渲染一个在DOM中的元素" class="headerlink" title="Rendering an Element into the DOM(渲染一个在DOM中的元素)"></a>Rendering an Element into the DOM(渲染一个在DOM中的元素)</h3><p>Let’s say there is a <code><div></div></code> somewhere in your HTML file:</p>
<p>以下是一个在您的HTML文件中的<code><div></div></code></p>
<pre><code>&lt;div id=&quot;root&quot;&gt;&lt;/div&gt;
</code></pre><p>We call this a “root” DOM node because everything inside it will be managed by React DOM.</p>
<p>我们叫它为“root”DOM节点，因为它其中的所有元素都由React DOM控制。</p>
<p>Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.</p>
<p>仅使用React构建的应用程序通常只有单个根DOM节点。如果您将React集成到现有的应用程序中，您可以根据需要选择多个独立的根DOM节点。</p>
<p>To render a React element into a root DOM node, pass both to <code>ReactDOM.render()</code>:</p>
<p>为了将一个React元素渲染到一个根DOM节点，将它们全部传给<code>ReactDOM.render()</code>:</p>
<pre><code>const element = &lt;h1&gt;Hello, world&lt;/h1&gt;;
ReactDOM.render(element, document.getElementById(&#39;root&#39;));
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/rendering-elements/render-an-element" target="_blank" rel="noopener">Try it on CodePen</a></p>
<p>It displays “Hello, world” on the page.</p>
<p>它将会在页面上显示“Hello, world”。</p>
<h3 id="Updating-the-Rendered-Element-更新渲染的元素"><a href="#Updating-the-Rendered-Element-更新渲染的元素" class="headerlink" title="Updating the Rendered Element(更新渲染的元素)"></a>Updating the Rendered Element(更新渲染的元素)</h3><p>React elements are <code>immutable</code>. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</p>
<p>React元素是<code>不可变的</code>。一旦您创建了一个元素，您就不能改变它的子元素或者属性。一个元素就像电影里的一帧：它代表着一个特定时间点的UI。</p>
<p>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to <code>ReactDOM.render()</code>.</p>
<p>以我们目前所有的知识，更新UI的唯一方法就是创建一个新的元素，并将它传给<code>ReactDOM.render()</code>。</p>
<p>Consider this ticking clock example:</p>
<p>考虑以下秒表的例子：</p>
<pre><code>function tick() {
  const element = (
    &lt;div&gt;
      &lt;h1&gt;Hello, world!&lt;/h1&gt;
      &lt;h2&gt;It is {new Date().toLocaleTimeString()}.&lt;/h2&gt;
    &lt;/div&gt;
  );
  ReactDOM.render(element, document.getElementById(&#39;root&#39;));
}

setInterval(tick, 1000);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">Try it on CodePen</a></p>
<p>It calls <code>ReactDOM.render()</code> every second from a setInterval() callback.</p>
<p>它会每秒从setInterval()函数的回调函数中调用<code>ReactDOM.render()</code>。</p>
<blockquote>
<p>Note:<br>In practice, most React apps only call <code>ReactDOM.render()</code> once. In the next sections we will learn how such code gets encapsulated into stateful components.<br>We recommend that you don’t skip topics because they build on each other.</p>
<p>注意：<br>在实际使用过程中，大多数的React应用仅仅只调用<code>ReactDOM.render()</code>一次。在接下来的部分中，我们将学习如何将这些代码封装到有状态的组件中。<br>我们建议您不要跳过这些内容，因为它们互相之间都有联系。</p>
</blockquote>
<h3 id="React-Only-Updates-What’s-Necessary-React只有在必须的时候才会更新"><a href="#React-Only-Updates-What’s-Necessary-React只有在必须的时候才会更新" class="headerlink" title="React Only Updates What’s Necessary(React只有在必须的时候才会更新)"></a>React Only Updates What’s Necessary(React只有在必须的时候才会更新)</h3><p>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</p>
<p>React DOM 会将元素和它的子元素与上一个状态的元素和子元素比较，并且只在DOM必须更新的时候才会让DOM变化到期待的状态。</p>
<p>You can verify by inspecting the <a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">last example</a> with the browser tools:</p>
<p>您可以通过浏览器工具监视<a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">最后一个例子</a>。</p>
<p><img src="/images/react_document/02-03-ticking_click.gif"></p>
<p>Even though we create an element describing the whole UI tree on every tick, only the text node whose contents has changed gets updated by React DOM.</p>
<p>尽管我们创建了一个元素来描述在每秒钟的整个结构，但是只有内容改变的文本节点会被React DOM更新。</p>
<p>In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.</p>
<p>根据我们的经验，思考如何在任何特定时刻看到UI，而不是随着时间的推移如何改变，从而消除了一整类错误。根据我们的经验，考率如何在任何特定时刻看到特定的样式，而不是随着时间的推移而变化，只有这样做才能消除了一系列相关的错误。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 02.Introducing JSX]]></title>
      <url>/2018/05/04/react/02.Quick_Start/02.Introducing_JSX/</url>
      <content type="html"><![CDATA[<h2 id="Introducing-JSX"><a href="#Introducing-JSX" class="headerlink" title="Introducing JSX"></a>Introducing JSX</h2><p>Consider this variable declaration:</p>
<p>考虑以下变量声明：</p>
<pre><code>const element = &lt;h1&gt;Hello, world!&lt;/h1&gt;;
</code></pre><p>This funny tag syntax is neither a string nor HTML.</p>
<p>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</p>
<p>它叫做JSX，并且它是基于JavaScript的语法进行扩展的。我们建议是在React中使用它来描述UI的样式。JSX也许让您想起一些模板语言，但是它具有JavaScript的全部功能。</p>
<p>JSX produces React “elements”. We will explore rendering them to the DOM in the <a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener">next section</a>. Below, you can find the basics of JSX necessary to get you started.</p>
<p>JSX生成了React“元素”。我们将在<a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener">下一章节</a>内探索它是如果将React渲染到DOM上的。除此之外，您还可以学习到使用JSX的基本知识。</p>
<h3 id="Why-JSX-为什么使用JSX"><a href="#Why-JSX-为什么使用JSX" class="headerlink" title="Why JSX?(为什么使用JSX?)"></a>Why JSX?(为什么使用JSX?)</h3><p>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.</p>
<p>React认为渲染逻辑与其他UI逻辑是有耦合的：事件如何处理，状态如何随时间变化以及数据如何准备显示。</p>
<p>Instead of artificially separating technologies by putting markup and logic in separate files, React <a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">separates concerns</a> with loosely coupled units called “components” that contain both. We will come back to components in a <a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">further section</a>, but if you’re not yet comfortable putting markup in JS, <a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank" rel="noopener">this talk</a> might convince you otherwise.</p>
<p>React不再人为地通过将标记和逻辑放在单独的文件中来分离技术，React通过将问题与“组件”–一个松散耦合的单元<a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">分隔开</a>。我们将在<a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">接下来的章节内</a>回到组件中，但如果你不习惯在JS中添加标记，那么<a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank" rel="noopener">这个话题</a>可能会让你习惯这个改变。</p>
<p>React <a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">doesn’t require</a> using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.</p>
<p>React<a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">不需要</a>使用JSX，但是大多数人认为在JavaScript代码中使用它时，有助于从视觉上更清晰地理解代码。它还允许React显示更多有用的错误和警告消息。</p>
<p>With that out of the way, let’s get started!</p>
<p>那就这样，让我们开始吧！</p>
<h3 id="Embedding-Expressions-in-JSX-在JSX中嵌入表达式"><a href="#Embedding-Expressions-in-JSX-在JSX中嵌入表达式" class="headerlink" title="Embedding Expressions in JSX(在JSX中嵌入表达式)"></a>Embedding Expressions in JSX(在JSX中嵌入表达式)</h3><p>You can embed any <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript expression</a> in JSX by wrapping it in curly braces.</p>
<p>您可以用大括号在JSX中包括任何<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript表达式</a>。</p>
<p>For example, <code>2 + 2</code>, <code>user.firstName</code>, and <code>formatName(user)</code> are all valid expressions:</p>
<p>例如，<code>2 + 2</code>, <code>user.firstName</code>, and <code>formatName(user)</code>都是有效的表达式：</p>
<pre><code>function formatName(user) {
  return user.firstName + &#39; &#39; + user.lastName;
}

const user = {
  firstName: &#39;Harper&#39;,
  lastName: &#39;Perez&#39;
};

const element = (
  &lt;h1&gt;
    Hello, {formatName(user)}!
  &lt;/h1&gt;
);

ReactDOM.render(
  element,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p><a href="https://reactjs.org/redirect-to-codepen/introducing-jsx" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>We split JSX over multiple lines for readability. While it isn’t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of <a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">automatic semicolon insertion</a>.</p>
<p>为了便于阅读，我们将JSX分成多行。虽然这不是必需的，但是我们还建议将其包装在括号内以避免<a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">自动分号插入</a>的缺陷。</p>
<h3 id="JSX-is-an-Expression-Too-JSX也是一个表达式"><a href="#JSX-is-an-Expression-Too-JSX也是一个表达式" class="headerlink" title="JSX is an Expression Too(JSX也是一个表达式)"></a>JSX is an Expression Too(JSX也是一个表达式)</h3><p>After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects.</p>
<p>在编译完后，JSX表达式会变成常规的JavaScript方法的调用，并且会转为JavaScript对象。</p>
<p>This means that you can use JSX inside of <code>if</code> statements and <code>for</code> loops, assign it to variables, accept it as arguments, and return it from functions:</p>
<p>这意味着您可以在if语句和for循环中使用JSX，将其分配给变量，将其作为参数接受，并从函数中返回：</p>
<pre><code>function getGreeting(user) {
  if (user) {
    return &lt;h1&gt;Hello, {formatName(user)}!&lt;/h1&gt;;
  }
  return &lt;h1&gt;Hello, Stranger.&lt;/h1&gt;;
}
</code></pre><h3 id="Specifying-Attributes-with-JSX-使用JSX指定属性"><a href="#Specifying-Attributes-with-JSX-使用JSX指定属性" class="headerlink" title="Specifying Attributes with JSX(使用JSX指定属性)"></a>Specifying Attributes with JSX(使用JSX指定属性)</h3><p>You may use quotes to specify string literals as attributes:</p>
<p>您可以使用引号将字符串文字指定为属性：</p>
<pre><code>const element = &lt;div tabIndex=&quot;0&quot;&gt;&lt;/div&gt;;
</code></pre><p>You may also use curly braces to embed a JavaScript expression in an attribute:</p>
<p>您也可以使用大括号包裹JavaScript表达式作为属性：</p>
<pre><code>const element = &lt;img src={user.avatarUrl}&gt;&lt;/img&gt;;
</code></pre><p>Don’t put quotes around curly braces when embedding a JavaScript expression in an attribute. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.</p>
<p>当将JavaScript表达式作为属性时，不要在大括号外边加引号。您应该要么使用引号（对于字符串的值来说）或者大括号（对于表达式来说）,但是不能两者一起使用。</p>
<blockquote>
<p>Warning:<br>Since JSX is closer to JavaScript than to HTML, React DOM uses camelCase property naming convention instead of HTML attribute names.<br>For example, class becomes className in JSX, and tabindex becomes tabIndex.</p>
<p>警告：<br>因为JSX相对于HTML来说更接近于JavaScript，React Dom使用传统的驼峰命名方法来命名，而不是像HTML属性一样命名。<br>例如，在JSX中，class应该是className，tabindex应该是tabIndex</p>
</blockquote>
<h3 id="Specifying-Children-with-JSX-用JSX指定子元素"><a href="#Specifying-Children-with-JSX-用JSX指定子元素" class="headerlink" title="Specifying Children with JSX(用JSX指定子元素)"></a>Specifying Children with JSX(用JSX指定子元素)</h3><p>If a tag is empty, you may close it immediately with <code>/&gt;</code>, like XML:</p>
<p>如果一个标签是空的，您应该立即使用<code>/&gt;</code>的方式关闭它，像XML一样：</p>
<pre><code>const element = &lt;img src={user.avatarUrl} /&gt;;
</code></pre><p>JSX tags may contain children:</p>
<p>JSX标签可以包含子元素：</p>
<pre><code>const element = (
  &lt;div&gt;
    &lt;h1&gt;Hello!&lt;/h1&gt;
    &lt;h2&gt;Good to see you here.&lt;/h2&gt;
  &lt;/div&gt;
);
</code></pre><h3 id="JSX-Prevents-Injection-Attacks-JSX可以防止注入攻击"><a href="#JSX-Prevents-Injection-Attacks-JSX可以防止注入攻击" class="headerlink" title="JSX Prevents Injection Attacks(JSX可以防止注入攻击)"></a>JSX Prevents Injection Attacks(JSX可以防止注入攻击)</h3><p>It is safe to embed user input in JSX:</p>
<p>将用户输入置于JSX中是安全的：</p>
<pre><code>const title = response.potentiallyMaliciousInput;
// This is safe:
const element = &lt;h1&gt;{title}&lt;/h1&gt;;
</code></pre><p>By default, React DOM <a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">escapes</a> any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS (cross-site-scripting)</a> attacks.</p>
<p>默认情况下，React DOM在渲染之前会<a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">转义</a>嵌入在JSX中的任何值。因此它确保您永远不会注入任何未明确的写入应用程序中的内容。在呈现之前，所有内容都会转换为字符串。这有助于防止<a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS(跨站点脚本)</a>攻击。</p>
<h3 id="JSX-Represents-Objects-JSX表示对象"><a href="#JSX-Represents-Objects-JSX表示对象" class="headerlink" title="JSX Represents Objects(JSX表示对象)"></a>JSX Represents Objects(JSX表示对象)</h3><p>Babel compiles JSX down to <code>React.createElement()</code> calls.</p>
<p>Babel会将JSX编译成<code>React.createElement()</code>的调用。</p>
<p>These two examples are identical:</p>
<p>以下两个例子是一样的：</p>
<pre><code>const element = (
  &lt;h1 className=&quot;greeting&quot;&gt;
    Hello, world!
  &lt;/h1&gt;
);
</code></pre><pre><code>const element = React.createElement(
  &#39;h1&#39;,
  {className: &#39;greeting&#39;},
  &#39;Hello, world!&#39;
);
</code></pre><p><code>React.createElement()</code> performs a few checks to help you write bug-free code but essentially it creates an object like this:</p>
<p><code>React.createElement()</code>会执行一些检查来帮助您编写无错代码，但本质上它会创建一个如下所示的对象：</p>
<pre><code>// Note: this structure is simplified
const element = {
  type: &#39;h1&#39;,
  props: {
    className: &#39;greeting&#39;,
    children: &#39;Hello, world!&#39;
  }
};
</code></pre><p>These objects are called “React elements”. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.</p>
<p>这些对象被称为“React元素”。你可以把它们想象成你想要在屏幕上看到的东西。React会读取这些对象并使用它们来构建DOM并使其保持最新状态。</p>
<p>We will explore rendering React elements to the DOM in the next section.</p>
<p>我们将会在下一章里探索如何在DOM中渲染React元素。</p>
<blockquote>
<p>Tip:<br>We recommend using the <a href="http://babeljs.io/docs/editors" target="_blank" rel="noopener">“Babel” language definition</a> for your editor of choice so that both ES6 and JSX code is properly highlighted. This website uses the <a href="https://labs.voronianski.com/oceanic-next-color-scheme/" target="_blank" rel="noopener">Oceanic Next</a> color scheme which is compatible with it.<br>提示：<br>我们将以使用<a href="http://babeljs.io/docs/editors" target="_blank" rel="noopener">“Babel”语言定义</a>作为您的编译器，以便正确突出显示ES6和JSX代码。本网站采用与其兼容的Oceanic Next色彩方案。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 01.Hello World]]></title>
      <url>/2018/05/04/react/02.Quick_Start/01.Hello_World/</url>
      <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h4>The easiest way to get started with React is to use <a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">this Hello World example code on CodePen</a>. You don’t need to install anything; you can just open it in another tab and follow along as we go through examples. If you’d rather use a local development environment, check out the <a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">Installation</a> section.</h4>

<h4>开始学习React最简单的方式是使用<a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">Codepen上的Hello World的例子</a>。您不必安装任何东西；您只需要在另一个窗口打开就能查看我们写下的例子。如果您想在本地搭建环境，请查看<a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">安装</a>章节。</h4>

<hr>
<p>The smallest React example looks like this:</p>
<p>最小的React例子像这个样子：</p>
<pre><code>ReactDOM.render(
  &lt;h1&gt;Hello, world!&lt;/h1&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>It renders a heading saying “Hello, world!” on the page.</p>
<p>它将会在页面上渲染一个写着“Hello World”的标题。</p>
<p>The next few sections will gradually introduce you to using React. We will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.</p>
<p>接下来的章节将会逐渐向您介绍如何使用React。我们将检查React应用程序的构建部分：元素和组件。一旦您掌握了它们，您就可以通过小型可重复使用的部分创建复杂的应用程序。</p>
<h3 id="A-Note-on-JavaScript-一个关于JavaScript的注意点"><a href="#A-Note-on-JavaScript-一个关于JavaScript的注意点" class="headerlink" title="A Note on JavaScript(一个关于JavaScript的注意点)"></a>A Note on JavaScript(一个关于JavaScript的注意点)</h3><p>React is a JavaScript library, and so we’ll assume you have a basic understanding of the JavaScript language. If you don’t feel very confident, we recommend <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">refreshing your JavaScript knowledge</a> so you can follow along more easily.</p>
<p>React是一个JavaScript库，因此我们假设您对于JavaScript语言有一个基本的了解。如果您不是很自信，我们建议您<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">重新回顾JavaScript的相关知识</a>，以便能让您在接下来的内容上更容易。</p>
<p>We also use some of the ES6 syntax in the examples. We try to use it sparingly because it’s still relatively new, but we encourage you to get familiar with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow functions</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">classes</a>, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">template literals</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">let</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener">const</a> statements. You can use the <a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA" target="_blank" rel="noopener">Babel REPL</a> to check what ES6 code compiles to.</p>
<p>我们在案例中也使用了一些ES6的语法。我们尽量少的使用它们，因为它们还相对较新，但是我们还是建议您熟悉<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">类</a>，<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">模板字面量</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">let</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener">const</a>等概念。您可以使用<a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA" target="_blank" rel="noopener">Babel REPL</a>来查看ES6代码编译过后的结果。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 04.CDN Links]]></title>
      <url>/2018/05/03/react/01.Try_React/04.CDN_Links/</url>
      <content type="html"><![CDATA[<h2 id="CDN-Links-CDN链接"><a href="#CDN-Links-CDN链接" class="headerlink" title="CDN Links(CDN链接)"></a>CDN Links(CDN链接)</h2><p>The UMD builds of React and ReactDOM are available over a CDN.</p>
<p>React和ReactDOM的UMD版本可通过CDN获得。</p>
<pre><code>&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.development.js&quot;&gt;&lt;/script&gt;
&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.development.js&quot;&gt;&lt;/script&gt;
</code></pre><p>The versions above are only meant for development, and are not suitable for production. </p>
<p>以上版本仅用于开发，不适合生产。</p>
<p>Minified and optimized production versions of React are available at:</p>
<p>缩小和优化的React生产版本可以用以下方式获得：</p>
<pre><code>&lt;script crossorigin src=&quot;https://unpkg.com/react@16/umd/react.production.min.js&quot;&gt;&lt;/script&gt;
&lt;script crossorigin src=&quot;https://unpkg.com/react-dom@16/umd/react-dom.production.min.js&quot;&gt;&lt;/script&gt;
</code></pre><p>To load a specific version of <code>react</code> and <code>react-dom</code>, replace <code>16</code> with the version number.</p>
<p>如果要加载特定版本的<code>react</code>和<code>react-dom</code>，请将<code>16</code>替换为对应的版本号。</p>
<h3 id="Why-the-crossorigin-Attribute-为什么要设置crossorigin属性"><a href="#Why-the-crossorigin-Attribute-为什么要设置crossorigin属性" class="headerlink" title="Why the crossorigin Attribute?(为什么要设置crossorigin属性?)"></a>Why the crossorigin Attribute?(为什么要设置crossorigin属性?)</h3><p>If you serve React from a CDN, we recommend to keep the crossorigin <code>attribute set</code>:</p>
<p>如果您使用基于CDN的React，我们建议保留crossorigin<code>属性集</code>：</p>
<pre><code>&lt;script crossorigin src=&quot;...&quot;&gt;&lt;/script&gt;
</code></pre><p>We also recommend to verify that the CDN you are using sets the <code>Access-Control-Allow-Origin: *</code> HTTP header:</p>
<p>我们还建议验证您使用的CDN是否设置了<code>Access-Control-Allow-Origin：* </code>HTTP标头：</p>
<p><img src="/images/react_document/01-04-access_control_allow_origin.png" alt="Access-Control-Allow-Origin:*HTTP header"></p>
<p>This enables a better <a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">error handling experience</a> in React 16 and later.</p>
<p>这可以保证在React16或更高的版本上有一个更好的<a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">错误处理方法</a>。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 03.Add React to an Existing Application]]></title>
      <url>/2018/05/03/react/01.Try_React/03.Add_React_to_an_Existing_Application/</url>
      <content type="html"><![CDATA[<h2 id="Add-React-to-an-Existing-Application-在一个已存的项目中添加React"><a href="#Add-React-to-an-Existing-Application-在一个已存的项目中添加React" class="headerlink" title="Add React to an Existing Application(在一个已存的项目中添加React)"></a>Add React to an Existing Application(在一个已存的项目中添加React)</h2><p>You don’t need to rewrite your app to start using React.</p>
<p>您不必重写您的应用程序来开始使用React</p>
<p>We recommend adding React to a small part of your application, such as an individual widget, so you can see if it works well for your use case.</p>
<p>我们建议将React添加到应用程序中的一小部分中，例如单个小部件，以便您可以查看它是否适合您的用例。</p>
<p>While React <a href="https://reactjs.org/docs/react-without-es6.html" target="_blank" rel="noopener">can be used</a> without a build pipeline, we recommend setting it up so you can be more productive. A modern build pipeline typically consists of:</p>
<p>虽然<a href="https://reactjs.org/docs/react-without-es6.html" target="_blank" rel="noopener">可以</a>在没有构建通道的情况下使用React，但我们建议设置通道，以此来提高生产力。现代构建通道通常由以下部分组成：</p>
<ul>
<li>A <strong>package manager</strong>, such as <a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a> or <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>. It lets you take advantage of a vast ecosystem of third-party packages, and easily install or update them.</li>
<li>A <strong>bundler</strong>, such as <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> or <a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>. It lets you write modular code and bundle it together into small packages to optimize load time.</li>
<li>A compiler such as <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>. It lets you write modern JavaScript code that still works in older browsers.</li>
</ul>
<hr>
<ul>
<li>一个<strong>包管理器</strong>，如<a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a>或<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>。它可让您充分利用第三方软件包的完整的生态系统，并轻松安装或更新它们。</li>
<li>一个<strong>捆绑器</strong>，如<a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a>或<a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>。它允许您编写模块化代码，并将它们组合在一起成为小包，以优化加载时间。</li>
<li>一个<strong>编辑器</strong>,如<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>。它可以让你在旧版浏览器中仍然可以使用的现代JavaScript代码。</li>
</ul>
<h3 id="Installing-React-安装React"><a href="#Installing-React-安装React" class="headerlink" title="Installing React(安装React)"></a>Installing React(安装React)</h3><blockquote>
<p>Note:  </p>
<h2 id="Once-installed-we-strongly-recommend-setting-up-a-production-build-process-to-ensure-you’re-using-the-fast-version-of-React-in-production"><a href="#Once-installed-we-strongly-recommend-setting-up-a-production-build-process-to-ensure-you’re-using-the-fast-version-of-React-in-production" class="headerlink" title="Once installed, we strongly recommend setting up a production build process to ensure you’re using the fast version of React in production."></a><p style="margin:0px">Once installed, we strongly recommend setting up a production build process to ensure you’re using the fast version of React in production.</p></h2><p>注意:<br>一旦完成安装，我们强烈建议您设置生成的构建流程，以此确保您可以在开发环境中使用更快版本的React。</p>
</blockquote>
<p>We recommend using <a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a> or <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> for managing front-end dependencies. If you’re new to package managers, the <a href="https://yarnpkg.com/en/docs/getting-started" target="_blank" rel="noopener">Yarn documentation</a> is a good place to get started.</p>
<p>我们建议使用<a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a>或者<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>来管理前端依赖。如果您是新接触包管理器的开发者，<a href="https://yarnpkg.com/en/docs/getting-started" target="_blank" rel="noopener">Yarn的文档</a>是一个开始学习的不错的地方。</p>
<p>To install React with Yarn, run:</p>
<p>使用Yarn安装React，请运行：</p>
<pre><code>yarn init
yarn add react react-dom
</code></pre><p>如果使用npm安装React，请运行：</p>
<pre><code>npm init
npm install --save react react-dom
</code></pre><p>Both Yarn and npm download packages from the <a href="http://npmjs.com/" target="_blank" rel="noopener">npm registry</a>.</p>
<p>Yarn和npm都从<a href="http://npmjs.com/" target="_blank" rel="noopener">npm注册表</a>中下载软件包。</p>
<blockquote>
<p>Note:<br>To prevent potential incompatibilities, all react packages should use the same version. (This includes <code>react</code>, <code>react-dom</code>, <code>react-test-renderer</code>, etc.)</p>
</blockquote>
<hr>
<blockquote>
<p>注意：<br>为了避免潜在的不兼容性，所有的react包都应该使用相同的版本。（这包括<code>react</code>, <code>react-dom</code>, <code>react-test-renderer</code>等等。）</p>
</blockquote>
<h3 id="Enabling-ES6-and-JSX-启用ES6和JSX"><a href="#Enabling-ES6-and-JSX-启用ES6和JSX" class="headerlink" title="Enabling ES6 and JSX(启用ES6和JSX)"></a>Enabling ES6 and JSX(启用ES6和JSX)</h3><p>We recommend using React with <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a> to let you use ES6 and JSX in your JavaScript code. ES6 is a set of modern JavaScript features that make development easier, and JSX is an extension to the JavaScript language that works nicely with React.</p>
<p>我们建议在React上使用<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>以便让您在您的JavaScript代码中使用ES6和JSX。ES6包括一系列的现代化JavaScript特性，以便让开发更容易，并且JSX是一个JavaScript语言的扩展，以便让React工作更方便。</p>
<p>The <a href="https://babeljs.io/docs/setup/" target="_blank" rel="noopener">Babel setup instructions</a> explain how to configure Babel in many different build environments. Make sure you install <a href="http://babeljs.io/docs/plugins/preset-react/#basic-setup-with-the-cli-" target="_blank" rel="noopener">babel-preset-react</a> and <a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="noopener">babel-preset-env</a> and enable them in your <a href="http://babeljs.io/docs/usage/babelrc/" target="_blank" rel="noopener">.babelrc configuration</a>, and you’re good to go.</p>
<p><a href="https://babeljs.io/docs/setup/" target="_blank" rel="noopener">Babel设置介绍</a>解释了如何在许多不同的构建环境中配置Babel。以此可以确保您安装了<a href="http://babeljs.io/docs/plugins/preset-react/#basic-setup-with-the-cli-" target="_blank" rel="noopener">babel-preset-react</a>和<a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="noopener">babel-preset-env</a>，并在你的<a href="http://babeljs.io/docs/usage/babelrc/" target="_blank" rel="noopener">.babelrc configuration</a>中启用它们，并且可以方便访问。</p>
<h3 id="Hello-World-with-ES6-and-JSX-使用ES6和JSX编写Hello-World"><a href="#Hello-World-with-ES6-and-JSX-使用ES6和JSX编写Hello-World" class="headerlink" title="Hello World with ES6 and JSX(使用ES6和JSX编写Hello World)"></a>Hello World with ES6 and JSX(使用ES6和JSX编写Hello World)</h3><p>We recommend using a bundler like <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> or <a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>, so you can write modular code and bundle it together into small packages to optimize load time.</p>
<p>我们建议使用像<a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a>或者<a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>这样的捆绑器，这样您就可以编写现代化代码并将他们绑定在小的包上以优化加载时间。</p>
<p>The smallest React example looks like this：</p>
<p>最小的React案例如下：</p>
<pre><code>import React from &#39;react&#39;;
import ReactDOM from &#39;react-dom&#39;;

ReactDOM.render(
  &lt;h1&gt;Hello, world!&lt;/h1&gt;,
  document.getElementById(&#39;root&#39;)
);
</code></pre><p>This code renders into a DOM element with the id of <code>root</code>, so you need <code><div id="root"></div> </code>somewhere in your HTML file.</p>
<p>这些代码会在一个id为<code>root</code>的DOM元素上渲染，所以您需要在您的HTML文件上有<code><div id="root"></div></code>。</p>
<p>Similarly, you can render a React component inside a DOM element somewhere inside your existing app written with any other JavaScript UI library.</p>
<p>相似的，您可以在现有的，由其他任何JavaScript UI库编写的应用程序内的某个DOM元素内部渲染一个React组件。</p>
<p><a href="https://reactjs.org/docs/integrating-with-other-libraries.html#integrating-with-other-view-libraries" target="_blank" rel="noopener">Learn more about integrating React with existing code.</a></p>
<p><a href="https://reactjs.org/docs/integrating-with-other-libraries.html#integrating-with-other-view-libraries" target="_blank" rel="noopener">了解有关将React与现有代码集成的更多信息。</a></p>
<h3 id="A-Complete-Example-一个完整的例子"><a href="#A-Complete-Example-一个完整的例子" class="headerlink" title="A Complete Example(一个完整的例子)"></a>A Complete Example(一个完整的例子)</h3><p>You can find step-by-step instructions detailing a basic implementation from scratch, including Babel and Webpack setup <a href="https://medium.com/@JedaiSaboteur/creating-a-react-app-from-scratch-f3c693b84658" target="_blank" rel="noopener">here</a>.</p>
<p>您可以从零开始找到详细的说明,<a href="https://medium.com/@JedaiSaboteur/creating-a-react-app-from-scratch-f3c693b84658" target="_blank" rel="noopener">这</a>也包括如何设置Babel和Webpack。</p>
<h3 id="Development-and-Production-Versions-开发和生成环境的版本"><a href="#Development-and-Production-Versions-开发和生成环境的版本" class="headerlink" title="Development and Production Versions(开发和生成环境的版本)"></a>Development and Production Versions(开发和生成环境的版本)</h3><p>By default, React includes many helpful warnings. These warnings are very useful in development.</p>
<p>通常情况下，React包括许多有用的警告。这些警告对于开发非常有用。</p>
<p><strong>However, they make the development version of React larger and slower so you should use the production version when you deploy the app.</strong></p>
<p><strong>但是，它们会使React的开发版本变得更大并且更慢，所以当您部署应用程序时，请使用生产版本</strong></p>
<p>Learn <a href="https://reactjs.org/docs/optimizing-performance.html#use-the-production-build" target="_blank" rel="noopener">how to tell if your website is serving the right version of React</a>, and how to configure the production build process most efficiently:</p>
<p>了解<a href="https://reactjs.org/docs/optimizing-performance.html#use-the-production-build" target="_blank" rel="noopener">如何判断您的网站是否提供正确版本的React</a>，以及如何最有效地配置生产构建过程：</p>
<ul>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#create-react-app" target="_blank" rel="noopener">Creating a Production Build with Create React App</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#single-file-builds" target="_blank" rel="noopener">Creating a Production Build with Single-File Builds</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#brunch" target="_blank" rel="noopener">Creating a Production Build with Brunch</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#browserify" target="_blank" rel="noopener">Creating a Production Build with Browserify</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#rollup" target="_blank" rel="noopener">Creating a Production Build with Rollup</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#webpack" target="_blank" rel="noopener">Creating a Production Build with webpack</a></li>
</ul>
<hr>
<ul>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#create-react-app" target="_blank" rel="noopener">使用Create React App来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#single-file-builds" target="_blank" rel="noopener">使用单个文件构建来实现生产环境构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#brunch" target="_blank" rel="noopener">使用Brunch来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#browserify" target="_blank" rel="noopener">使用Browserify来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#rollup" target="_blank" rel="noopener">使用Rollup来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#webpack" target="_blank" rel="noopener">使用webpack来实现生产环境的构建</a></li>
</ul>
<h3 id="Using-a-CDN-使用CDN"><a href="#Using-a-CDN-使用CDN" class="headerlink" title="Using a CDN(使用CDN)"></a>Using a CDN(使用CDN)</h3><p>If you don’t want to use npm to manage client packages, the <code>react</code> and <code>react-dom</code> npm packages also provide single-file distributions in <code>umd</code> folders. See the <a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">CDN</a> page for links.</p>
<p>如果您不想用npm来管理客户端的包，<code>react</code>和<code>react-dom</code>的npm的包也提供在<code>umd</code>单个文件的发布。请<a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">CDN</a>查看相关链接。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 02.Add React to a New Application]]></title>
      <url>/2018/05/03/react/01.Try_React/02.Add_React_to_a_New_Application/</url>
      <content type="html"><![CDATA[<h2 id="Add-React-to-a-New-Application-在一个新的应用上添加React"><a href="#Add-React-to-a-New-Application-在一个新的应用上添加React" class="headerlink" title="Add React to a New Application(在一个新的应用上添加React)"></a>Add React to a New Application(在一个新的应用上添加React)</h2><p>The easiest way to get started on a new React project is by using a starter kit.</p>
<p>最简单的开始一个新的React项目的方式是使用一个入门套件。</p>
<blockquote>
<p>Note:<br>This page describes setting up a single-page application with everything you need for a comfortable development workflow, including linting, testing, production optimizations, and more. Full-featured tools like these require some time and disk space to install.<br>If you are looking for a lightweight environment to experiment with React, check out the <a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">Try React</a> page instead. <strong>A <a href="https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html" target="_blank" rel="noopener">single HTML file</a> is enough to get you started!</strong><br>Finally, if you’re not building a single-page application, you can either <a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">add React to your existing build pipeline</a> or <a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">use it from CDN</a> and <a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">without a build step</a>.</p>
</blockquote>
<hr>
<blockquote>
<p>注意:<br>本页面介绍如何设置一个单页面应用程序，其中包含您需要的所有功能以实现完整的开发工作流程，包括linting，测试，生产优化等。像这些包括全功能的工具需要一些时间和磁盘空间来安装。<br>如果您在寻找一个轻量级的环境来使用React，请查看<a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">尝试React</a>页面。<strong><a href="https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html" target="_blank" rel="noopener">一个简单的HTML文件</a>足以让您开始入门！</strong><br>最后，如果您不是在搭建一个单页面的应用，您可以查看<a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">将React添加到您现存的环境上</a> or <a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">从CDN使用React</a> and <a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">不适用搭建步骤</a>.</p>
</blockquote>
<h3 id="Create-React-App-创建React应用"><a href="#Create-React-App-创建React应用" class="headerlink" title="Create React App(创建React应用)"></a>Create React App(创建React应用)</h3><p><a href="http://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a> is the best way to start building a new React single page application. It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You’ll need to have Node &gt;= 6 on your machine.</p>
<p><a href="http://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">创建React应用</a>是开始构建新的React单页应用程序的最佳方式。 它为您设置好了开发环境，以便您可以使用最新的JavaScript功能，为开发者提供了良好的体验并从生产环境上优化了您的应用程序。注意您需要保证您的开发机上的node版本大于等于6。</p>
<pre><code>npm install -g create-react-app
create-react-app my-app

cd my-app
npm start
</code></pre><p>If you have npm 5.2.0+ installed, you may use <a href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener">npx</a> instead.</p>
<p>如果您安装的npm版本号为5.2.0+，您也可以使用<a href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener">npx</a>。</p>
<pre><code>npx create-react-app my-app

cd my-app
npm start
</code></pre><p>Create React App doesn’t handle backend logic or databases; it just creates a frontend build pipeline, so you can use it with any backend you want. It uses build tools like <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a> and <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> under the hood, but works with zero configuration.</p>
<p>创建React应用不会处理后端逻辑或者数据库；它只是创建了一个前端构建通道，所以您可以使用任何您相适应的后端语言。它基于钩子上使用像<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>和<a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a>这样的构建工具，但是在使用是时为不需要配置。</p>
<p>When you’re ready to deploy to production, running npm run build will create an optimized build of your app in the build folder. You can learn more about Create React App from its <a href="https://github.com/facebookincubator/create-react-app#create-react-app-" target="_blank" rel="noopener">README</a> and the <a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents" target="_blank" rel="noopener">User Guide</a>.</p>
<p>当您准备部署到生产环境时，您可以运行<code>npm run build</code>，在<code>build</code>文件夹中创建一个优化的应用程序版本。您可以从<a href="https://github.com/facebookincubator/create-react-app#create-react-app-" target="_blank" rel="noopener">README</a>和<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents" target="_blank" rel="noopener">用户指南</a>中了解有关创建React应用程序的更多信息。</p>
<h3 id="Other-Starter-Kits-其他的入门套件"><a href="#Other-Starter-Kits-其他的入门套件" class="headerlink" title="Other Starter Kits(其他的入门套件)"></a>Other Starter Kits(其他的入门套件)</h3><p>We have created <a href="https://reactjs.org/community/starter-kits.html" target="_blank" rel="noopener">a curated list of third-party starter kits that we officially recommend</a>.</p>
<p>我们已经创建了<a href="https://reactjs.org/community/starter-kits.html" target="_blank" rel="noopener">我们正式推荐的第三方入门套件的策划清单</a>。</p>
<p>They slightly differ in their focus but are all production-ready, well-maintained, and don’t require configuration to get started.</p>
<p>他们的重点略有不同，但在生成环境上准备就绪，并且维护良好的，不需要配置即可开始使用。</p>
<p>You can also check out a list of <a href="https://reactjs.org/community/starter-kits.html#other-starter-kits" target="_blank" rel="noopener">other kits</a> contributed by the community.</p>
<p>您还可以查看社区贡献的<a href="https://reactjs.org/community/starter-kits.html#other-starter-kits" target="_blank" rel="noopener">其他工具包列表</a>。</p>
<h3 id="Advanced-高级"><a href="#Advanced-高级" class="headerlink" title="Advanced(高级)"></a>Advanced(高级)</h3><p>If you prefer to configure a project manually, see <a href="https://reactjs.org/docs/add-react-to-an-existing-app.html#installing-react" target="_blank" rel="noopener">Installing React</a> in the next section.</p>
<p>如果您想人工配置一个项目，请在下一章节中查看<a href="https://reactjs.org/docs/add-react-to-an-existing-app.html#installing-react" target="_blank" rel="noopener">安装React</a>。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 01.Add React To A New App]]></title>
      <url>/2018/05/03/react/01.Try_React/01.Add_React_To_A_New_App/</url>
      <content type="html"><![CDATA[<h2 id="Try-React-尝试使用React"><a href="#Try-React-尝试使用React" class="headerlink" title="Try React(尝试使用React)"></a>Try React(尝试使用React)</h2><p>Try React online or set up your local development environment.</p>
<p>设置在线的react或您本地的react环境。</p>
<h3 id="Online-在线"><a href="#Online-在线" class="headerlink" title="Online(在线)"></a>Online(在线)</h3><p>If you’re just interested in playing around with React, you can use an online code playground. Try a Hello World template on <a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">CodePen</a> or <a href="https://codesandbox.io/s/new" target="_blank" rel="noopener">CodeSandbox</a>.</p>
<p>如果您只是对如何使用React有兴趣，您可以使用在线的编码器。您可以在<a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">CodePen</a>或者 <a href="https://codesandbox.io/s/new" target="_blank" rel="noopener">CodeSandbox</a>上尝试Hello World模板。</p>
<h3 id="Minimal-HTML-Template-最小的HTML模板"><a href="#Minimal-HTML-Template-最小的HTML模板" class="headerlink" title="Minimal HTML Template(最小的HTML模板)"></a>Minimal HTML Template(最小的HTML模板)</h3><p>If you prefer to use your own text editor, you can also download this HTML file, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so don’t use it in production.</p>
<p>如果您倾向于使用您自己的文本编辑器，您可以下载该HTML文件，编辑它并用浏览器在您本地文件系统上打开它。它会花费比较长的时间用来进行代码转换，所以不要在应用产品层上使用它。</p>
<h3 id="Next-Steps-下一步"><a href="#Next-Steps-下一步" class="headerlink" title="Next Steps(下一步)"></a>Next Steps(下一步)</h3><h4 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h4><ul>
<li>Head over to the <a href="https://reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">Quick Start</a> section for a step-by-step introduction to React concepts.</li>
<li><p>Try the <a href="https://reactjs.org/tutorial/tutorial.html" target="_blank" rel="noopener">Tutorial</a> for a hands-on practical example.</p>
</li>
<li><p>从<a href="https://reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">快速开始</a>部分，开始一步一步地熟悉React的内容。</p>
</li>
<li>尝试<a href="https://reactjs.org/tutorial/tutorial.html" target="_blank" rel="noopener">教程</a>部分，开始上手的练习。</li>
</ul>
<h4 id="Complete-Development-Environment-完成开发环境"><a href="#Complete-Development-Environment-完成开发环境" class="headerlink" title="Complete Development Environment(完成开发环境)"></a>Complete Development Environment(完成开发环境)</h4><p>The lightweight solutions above are the best fit if you are new to React or just experimenting.</p>
<p>如果您是新接触React，或者只是想尝试一下React的话，这种轻量级解决方案是最适合的。</p>
<p>When you are ready to build your first application with React, check out the install guides below. These setups are designed to get you up and running with a great developer experience and are ready for production. They include linting, testing, and optimizations built-in; however, they require more time and disk space to set up and install.</p>
<p>当您开始准备使用React搭建您第一个应用时，请先阅读下面的安装指南。这些步骤的目的是在让您在开发过程中获得丰富的开发体验，并且可以随时投入生产环境中使用。它们包括linting，测试和内置优化; 但是，它们需要更多时间和磁盘空间来设置和安装。</p>
<ul>
<li><a href="https://reactjs.org/docs/add-react-to-a-new-app.html" target="_blank" rel="noopener">Add React to a New App</a>: Create a new app with a fully-featured starter kit.</li>
<li><p><a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">Add React to an Existing App</a>: Add React to a build system or a larger app.</p>
</li>
<li><p><a href="https://reactjs.org/docs/add-react-to-a-new-app.html" target="_blank" rel="noopener">Add React to a New App</a>:使用包括全套功能的入门套件来创建新应用程序。</p>
</li>
<li><a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">Add React to an Existing App</a>:构建系统或更大的应用程序上添加使用React。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript对象与继承---单一继承.md]]></title>
      <url>/2018/03/16/blog/Javascript_Objects_and_Inheritance/</url>
      <content type="html"><![CDATA[<h2 id="JavaScript对象与继承–单一对象"><a href="#JavaScript对象与继承–单一对象" class="headerlink" title="JavaScript对象与继承–单一对象"></a>JavaScript对象与继承–单一对象</h2><p>说真的，这次的博客我写了三个小时硬是一点都没写出来，洋洋洒洒把自己最近的心情写了1000多字，但是感觉自己太幼稚，又删了;然后打算写大三时候给前女友写的主界面和音乐播放器，想了想，算了吧，往事随风，又删了，现在两手空空，然后纠结了半个小时，只能是写写无关痛痒的问题。</p>
<p>哈哈哈在一小时后我终于找到了这个比较符合我的情况的内容哈哈哈</p>
<p>原文在<a href="http://speakingjs.com/es5/ch17.html#single_objects" target="_blank" rel="noopener">Objects and Inheritance</a>中,不容易呀。</p>
<p>概括的讲所有的js对象都是从字符串到值的映射，一个对象中的某一项（键，值对）称作对象的属性。属性的key始终是一个字符串而值可以是任何js值，包括函数。方法是指值为函数的属性。</p>
<h3 id="属性的种类"><a href="#属性的种类" class="headerlink" title="属性的种类"></a>属性的种类</h3><p>三种属性:</p>
<ol>
<li>属性（Properties，或称为数据属性） 普通属性，在一个对象里面的一个键值对包括方法，最常用属性。</li>
<li>访问器(Accessors，或者叫访问属性) 类似于读写属性的特殊方法。属性值存在普通属性中，而访问属性可以计算他们的值。你可以把他们看作是虚拟的属性，比如（getter 和 setter）.</li>
<li>内置属性(Internal property) 只存在于ECMAscript规范当中，他们不能被js直接访问，但可以间接的方式访问到。规范里规定将这种属性放在[[]]当中，比如[[Property]]吃有一个对象的原型，它可以通过Object.getPrototypeOf() 访问到。</li>
</ol>
<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>JavaScript对象字面量允许你直接的创建简单的对象（Object直接实例）。</p>
<p>EX:</p>
<pre><code>var jane = {
    name: &#39;Jane&#39;,
    describe: function () {
        return &#39;Person named &#39;+this.name;  // (1)
    },  // (2)
};
</code></pre><p>你可能有这样的印象，对象仅仅是字符串到值的映射。事实上远不止这些，有一些真正意义上的通用对象。</p>
<p>比如你可以做对象的继承，还可以保护对象不被修改。直接创建对象的功能是标准的js特性之一：你可以在没有类的前提下创建一个正确的对象，然后再对他进行抽象。</p>
<p>例如：构造函数（constructors）大体和其他语言的类相似，我们在后面会讲到。</p>
<h3 id="点运算符-通过固定值来访问属性"><a href="#点运算符-通过固定值来访问属性" class="headerlink" title="点运算符 (.): 通过固定值来访问属性"></a>点运算符 (.): 通过固定值来访问属性</h3><p>点运算符提供了一种简洁的语法来访问属性,属性的名称必须是合法标识符. 你可以用中括号来读写任意名称的属性.</p>
<pre><code>var jane = {
    name: &#39;Jane&#39;,

    describe: function () {
        return &#39;Person named &#39;+this.name;
    }
};
</code></pre><h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>点操作符获取属性 (读值).例如:</p>
<pre><code>&gt; jane.name  // get property `name`
&#39;Jane&#39;
&gt; jane.describe  // get property `describe`
[Function]
</code></pre><p>如果属性不存在则返回 undefined:</p>
<pre><code>&gt; jane.unknownProperty
undefined
</code></pre><h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>也可以调用方法:</p>
<pre><code>&gt; jane.describe()  // call method `describe`
&#39;Person named Jane&#39;
</code></pre><h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><p>可以用赋值符=来给.指向的属性赋值:</p>
<pre><code>&gt; jane.name = &#39;John&#39;;  // set property `name`
&gt; jane.describe()
&#39;Person named John&#39;
</code></pre><p>如果设置的属性不存在在赋值的时候就自动创建一个属性.如果存在就修改该属性。</p>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>delete操作符可以完全的从对象里面删除一个属性（键值对）：</p>
<pre><code>&gt; var obj = { hello: &#39;world&#39; };
&gt; delete obj.hello
true
&gt; obj.hello
undefined
</code></pre><p>如果你仅仅给一个属性设置为undefined，这个属性会仍然存在，而且这个对象包含这个键：</p>
<pre><code>&gt; var obj = { foo: &#39;a&#39;, bar: &#39;b&#39; };
&gt; obj.foo = undefined;
&gt; Object.keys(obj)
[ &#39;foo&#39;, &#39;bar&#39; ]
</code></pre><p>但是如果你将属性删除那么他的键就不存在了</p>
<pre><code>&gt; delete obj.foo
true
&gt; Object.keys(obj)
[ &#39;bar&#39; ]
</code></pre><p>delete只影响一个对象的直接属性（非继承的，自有属性）。并不会删除对象的原型。</p>
<p>Tip:慎用delete操作符，大多数现代化js引擎都会针对构造函数的创建实例进行优化，前提是这些实例不会发生形态改变（就是说没有删除或者添加属性的），但是删除属性会破坏这种优化。</p>
<h3 id="delete的返回值"><a href="#delete的返回值" class="headerlink" title="delete的返回值"></a>delete的返回值</h3><p>如果属性是一个自有属性且不能删除，那么delete会反回false，其他情况返回true。<br>例子：<br>作为准备，我们用Object.defineProperty创建一个不被删除自有属性</p>
<pre><code>var obj = {};
Object.defineProperty(obj, &#39;canBeDeleted&#39;, {
    value: 123,
    configurable: true
});
Object.defineProperty(obj, &#39;cannotBeDeleted&#39;, {
    value: 456,
    configurable: false
});
</code></pre><p>delete cannotBeDeleted 时候返回 false :</p>
<pre><code>&gt; delete obj.cannotBeDeleted
false
</code></pre><p>其他情况下delete 返回 true:</p>
<pre><code>&gt; delete obj.doesNotExist
true
&gt; delete obj.canBeDeleted
true
</code></pre><p>即使delete没有起作用也会返回true (继承的属性是不会被移除的):</p>
<pre><code>&gt; delete obj.toString
true
&gt; obj.toString // still there
[Function: toString]
</code></pre><h3 id="特殊属性键"><a href="#特殊属性键" class="headerlink" title="特殊属性键"></a>特殊属性键</h3><p>虽然你不能使用保留字作为变量名，但是你可以把他们作为属性键。</p>
<pre><code>&gt; var obj = { var: &#39;a&#39;, function: &#39;b&#39; };
&gt; obj.var
&#39;a&#39;
&gt; obj.function
&#39;b&#39;
</code></pre><h3 id="数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用-来访问："><a href="#数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用-来访问：" class="headerlink" title="数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用[]来访问："></a>数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用[]来访问：</h3><pre><code>&gt; var obj = { 0.7: &#39;abc&#39; };
&gt; Object.keys(obj)
[ &#39;0.7&#39; ]
&gt; obj[&#39;0.7&#39;]
&#39;abc&#39;
</code></pre><h3 id="对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用-来访问。"><a href="#对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用-来访问。" class="headerlink" title="对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用[]来访问。"></a>对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用[]来访问。</h3><pre><code>&gt; var obj = { &#39;not an identifier&#39;: 123 };
&gt; Object.keys(obj)
[ &#39;not an identifier&#39; ]
&gt; obj[&#39;not an identifier&#39;]
123
</code></pre><p>中括号 ([]): 通过计算出来的键访问属性<br>中括号可以通过表达式引用一个属性。</p>
<h3 id="用中括号获取属性："><a href="#用中括号获取属性：" class="headerlink" title="用中括号获取属性："></a>用中括号获取属性：</h3><pre><code>&gt; var obj = { someProperty: &#39;abc&#39; };

&gt; obj[&#39;some&#39; + &#39;Property&#39;]
&#39;abc&#39;

&gt; var propKey = &#39;someProperty&#39;;
&gt; obj[propKey]
&#39;abc&#39;
</code></pre><h3 id="非标识符"><a href="#非标识符" class="headerlink" title="非标识符:"></a>非标识符:</h3><pre><code>&gt; var obj = { &#39;not an identifier&#39;: 123 };
&gt; obj[&#39;not an identifier&#39;]
123
</code></pre><h3 id="表达式，转换成字符串"><a href="#表达式，转换成字符串" class="headerlink" title="表达式，转换成字符串:"></a>表达式，转换成字符串:</h3><pre><code>&gt; var obj = { &#39;6&#39;: &#39;bar&#39; };
&gt; obj[3+3]  // key: the string &#39;6&#39;
&#39;bar&#39;
</code></pre><h3 id="用中括号调用方法"><a href="#用中括号调用方法" class="headerlink" title="用中括号调用方法"></a>用中括号调用方法</h3><pre><code>&gt; var obj = { myMethod: function () { return true } };
&gt; obj[&#39;myMethod&#39;]()
true
</code></pre><h3 id="用中括号设置属性"><a href="#用中括号设置属性" class="headerlink" title="用中括号设置属性"></a>用中括号设置属性</h3><pre><code>&gt; var obj = {};
&gt; obj[&#39;anotherProperty&#39;] = &#39;def&#39;;
&gt; obj.anotherProperty
&#39;def&#39;
</code></pre><h3 id="用中括号删除属性"><a href="#用中括号删除属性" class="headerlink" title="用中括号删除属性"></a>用中括号删除属性</h3><pre><code>&gt; var obj = { &#39;not an identifier&#39;: 1, prop: 2 };
&gt; Object.keys(obj)
[ &#39;not an identifier&#39;, &#39;prop&#39; ]
&gt; delete obj[&#39;not an identifier&#39;]
true
&gt; Object.keys(obj)
[ &#39;prop&#39; ]
</code></pre>]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript闭包及相关问题]]></title>
      <url>/2018/03/09/blog/Javascript%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="Javascript闭包及相关问题"><a href="#Javascript闭包及相关问题" class="headerlink" title="Javascript闭包及相关问题"></a>Javascript闭包及相关问题</h2><p>基本概念：闭包是指有权访问另一个函数作用域中的变量的函数。</p>
<p>当某个函数第一次被调用时，会创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性[[scope]]。然后使用this，arguments和其他的值初始化函数的活动对象。</p>
<pre><code>function compare(value1, value2) {
    if(value1 &lt; value2) {
        return -1;
    } else if(value1 &gt; value2) {
        return 1;
    } else {
        return 0;
    }
}
var result = compare(5,10);
</code></pre><p>在全局作用域中调用了compare函数，会创建一个compare的活动对象，其中会包含this，arguments，value1，value2，而在全局执行环境中，会有this，result，arguments，位于作用域链的第二层。</p>
<p>后台在每个执行环境中都有一个表示变量的对象–变量对象。全局环境的变量对象始终存在，而局部环境的变量对象在函数执行时存在。</p>
<p>在创建compare函数时，会创建一个包含全局变量对象的活动对象，此时活动对象指向作用域链，而作用域链指向[[scope]]属性。当调用compare函数时，会创建一个compare的执行环境，<b>这个执行环境会复制函数的[[scope]]属性中的作用域链</b>，之后这个局部作用域链会被推入执行环境作用域链的前端，所以，对于compare函数而言，其作用域链包含本地活动对象和全局变量对象。因此，<b>作用域链的本质是一个指向变量对象的指针列表，只引用，但不包含变量对象。</b></p>
<p>正常情况下，在函数中访问变量，会沿着作用域链搜索对应名字的变量。一般在函数执行完后，局部活动对象就会被销毁，内存中只有全局作用域。</p>
<p>闭包：在另一个函数内部定义的函数会将包括它的函数的活动对象添加到它的作用域上。</p>
<pre><code>function createComparisonFunction(propertyName) {
    return function(object1, object2) {
        var value1 = object1[propertyName];
        var value2 = object2[propertyName];
        if(value1 &lt; value2) {
            return -1; 
        } else if(value1 &gt; value2) {
            return 1;
        } else {
            return 0;
        }
    };
}
</code></pre><p>注意，在return一个匿名函数后，要添加上’;’</p>
<p>当执行以下两部操作时：</p>
<pre><code>var compareName = createComparisonFunction(&#39;name&#39;);
var result = compare({name:&#39;lpld&#39;}, {name:&#39;plws&#39;});
</code></pre><p>在compare()时，向上面一样，会有全局活动对象和局部活动对象两个作用域链，而根据上面说的闭包的内容：在另一个函数内部定义的函数会将包括它的函数的活动对象添加到它的作用域上。对于result而言，是createComparisonFunction的返回函数，所以也包括了compare的活动对象。所以，当createComparisonFunction返回后，<b>其执行环境的作用域链会被销毁，但是其活动对象会留在内存中。因为在匿名函数中会把其活动对象添加到匿名函数的作用域链上</b>。</p>
<p>因此，在执行compareName = null;相当于解除匿名函数的作用域链，至此该匿名函数作用域链上的活动对象（也包括外部函数内的活动对象）也都会释放。</p>
<p>闭包缺点：闭包会携带包含它的函数的作用域，换句话说，是会保留包括它的函数的活动对象。因此会占用更多的内存。（在外部函数没有被释放时，也会在内部函数的作用域链上生成新的外部函数的活动对象，会产生新的内存）。</p>
<p>this对象：</p>
<p>this永远指向调用它的函数</p>
<pre><code>1.
var name = &#39;The Window&#39;;
var object = {
    name : &#39;My Object&#39;,
    getNameFunc : function(){
        return function() {
            return this.name;
        };
    } 
};
alert(object.getNameFunc()());//The Window

2.
var name = &#39;The Window&#39;;
var object = {
    name : &#39;My Object&#39;,
    getNameFunc : function(){
        var that = this;
        return function(){
            return that.name;
        };
    }
};
alert(object.getNameFunc()());//My Object
</code></pre><p>根据书中的内容，匿名函数的执行环境具有全局性，所以第一个返回的是window，第二个是object，在执行函数时，当执行到object.getNameFunc()时，此时的name对应的是object，这时执行匿名函数，相当于返回全局中的name，即是window。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记（1）]]></title>
      <url>/2018/03/02/blog/JavaScript%E5%9F%BA%E6%9C%AC1/</url>
      <content type="html"><![CDATA[<h2 id="JavaScrip学习笔记（1）"><a href="#JavaScrip学习笔记（1）" class="headerlink" title="JavaScrip学习笔记（1）"></a>JavaScrip学习笔记（1）</h2><h3 id="JavaScript函数表达式和函数声明"><a href="#JavaScript函数表达式和函数声明" class="headerlink" title="JavaScript函数表达式和函数声明"></a>JavaScript函数表达式和函数声明</h3><p>首先，来了解一下函数表达式和函数声明：</p>
<p>在ECMAScript中，创建函数的最常用的两个方法是函数表达式和函数声明，两者还是有一定的区别，在ECMA规范中提到：函数声明必须带有标示符（Identifier）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符，即：</p>
<p>函数声明:</p>
<p>function 函数名称 (参数：可选){ 函数体 }</p>
<p>函数表达式：</p>
<p>function 函数名称（可选）(参数：可选){ 函数体 }</p>
<p>所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称，ECMAScript是通过上下文来区分的，如果function foo(){}是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。</p>
<pre><code> function foo(){} // 声明，因为它是程序的一部分
 var bar = function foo(){}; // 表达式，因为它是赋值表达式的一部分
 new function bar(){}; // 表达式，因为它是new表达式
 (function(){
   function bar(){} // 声明，因为它是函数体的一部分
 })();
</code></pre><p>还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式，我们来看几个例子：</p>
<pre><code>function foo(){} // 函数声明
(function foo(){}); // 函数表达式：包含在分组操作符内

try {
  (var x = 5); // 分组操作符，只能包含表达式而不能包含语句，这里的var就是语句
} catch(err) {
// SyntaxError
}
</code></pre><p>在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：eval(‘(‘ + json + ‘)’)，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。</p>
<pre><code> try {
    { &quot;x&quot;: 5 }; // &quot;{&quot; 和 &quot;}&quot; 做解析成代码块
  } catch(err) {
    // SyntaxError
  }

  ({ &quot;x&quot;: 5 }); // 分组操作符强制将&quot;{&quot; 和 &quot;}&quot;作为对象字面量来解析
</code></pre><p>表达式和声明存在着十分微妙的区别，函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值，也就是所谓的函数提升。参考如下例子，函数fn是在alert之后声明的，但是在alert执行的时候，fn已经有定义了：</p>
<pre><code>alert(fn());
function fn() {  
  return &#39;Hello world!&#39;;
}
</code></pre><p>还有一点，函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式：</p>
<pre><code>// 千万别这样做！
// 因为有的浏览器会返回first的这个function，而有的浏览器返回的却是第二个

if (true) {
  function foo() {
    return &#39;first&#39;;
  }
}
else {
  function foo() {
    return &#39;second&#39;;
  }
}
foo();

// 相反，这样情况，我们要用函数表达式
var foo;
if (true) {
  foo = function() {
    return &#39;first&#39;;
  };
}
else {
  foo = function() {
    return &#39;second&#39;;
  };
}
foo();
</code></pre><p>函数声明的实际规则如下：</p>
<p><b>函数声明只能出现在程序或函数体内。从句法上讲，它们 不能出现在Block（块）（{ … }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含Statement语句， 而不能包含函数声明这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让表达式出现在Block（块）中情形，就是让它作为表达式语句的一部分。但是，规范明确规定了表达式语句不能以关键字function开头。而这实际上就是说，函数表达式同样也不能出现在Statement语句或Block（块）中（因为Block（块）就是由Statement语句构成的）。 </b></p>
<h3 id="函数表达式的命名"><a href="#函数表达式的命名" class="headerlink" title="函数表达式的命名"></a>函数表达式的命名</h3><p>函数表达式在实际应用中还是很常见的，但由于这种方式都是在同一作用域内，所以基本上一定要用函数表达式：</p>
<pre><code>    var contains = (function() {
    var docEl = document.documentElement;

    if (typeof docEl.compareDocumentPosition != &#39;undefined&#39;) {
      return function(el, b) {
        return (el.compareDocumentPosition(b) &amp; 16) !== 0;
      };
    }
    else if (typeof docEl.contains != &#39;undefined&#39;) {
      return function(el, b) {
        return el !== b &amp;&amp; el.contains(b);
      };
    }
    return function(el, b) {
      if (el === b) return false;
      while (el != b &amp;&amp; (b = b.parentNode) != null);
      return el === b;
    };
  })();
</code></pre><p>提到命名函数表达式，理所当然，就是它得有名字，前面的例子var bar = function foo(){};就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效：</p>
<pre><code>  var f = function foo(){
    return typeof foo; // foo是在内部作用域内有效
  };
  // foo在外部用于是不可见的
  typeof foo; // &quot;undefined&quot;
  f(); // &quot;function&quot;
</code></pre><h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>首先，我们可以从这几个方面理解：</p>
<p>1.原型使用方式1：</p>
<pre><code>var Calculator = function (decimalDigits, tax) {
   this.decimalDigits = decimalDigits;
   this.tax = tax;
};
//然后，通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象的原型。
Calculator.prototype = {
   add: function (x, y) {
      return x + y;
},
   subtract: function (x, y) {
      return x - y;
   }
};
</code></pre><p>这样，就可以new Calculator对象以后，就可以调用add方法来计算结果了。</p>
<p>2.原型使用方式2：</p>
<pre><code>Calculator.prototype = function () {
   add = function (x, y) {
      return x + y;
   },
   subtract = function (x, y) {
      return x - y;
   }
   return {
      add: add,
      subtract: subtract
   }
} ();
</code></pre><p>这样我们可以new Calculator对象以后调用add方法来计算结果了。</p>
<p>以上有一个限制就是一次性设置了原型对象，我们再来说一下如何分开设置原型的每个属性吧。</p>
<pre><code>var BaseCalculator = function () {
    //为每个实例都声明一个小数位数
    this.decimalDigits = 2;
};

//使用原型给BaseCalculator扩展2个对象方法
BaseCalculator.prototype.add = function (x, y) {
    return x + y;
};

BaseCalculator.prototype.subtract = function (x, y) {
    return x - y;
};
</code></pre><p>首先，声明了一个BaseCalculator对象，构造函数里会初始化一个小数位数的属性decimalDigits，然后通过原型属性设置2个function，分别是add(x,y)和subtract(x,y)，当然你也可以使用前面提到的2种方式的任何一种，我们的主要目的是看如何将BaseCalculator对象设置到真正的Calculator的原型上。</p>
<pre><code>var BaseCalculator = function() {
    this.decimalDigits = 2;
};

BaseCalculator.prototype = {
    add: function(x, y) {
        return x + y;
    },
    subtract: function(x, y) {
        return x - y;
    }
};
</code></pre><p>创建完上述代码以后</p>
<pre><code>var Calculator = function () {
    //为每个实例都声明一个税收数字
    this.tax = 5;
};

Calculator.prototype = new BaseCalculator();
</code></pre><p>我们可以看到Calculator的原型是指向到BaseCalculator的一个实例上，目的是让Calculator集成它的add(x,y)和subtract(x,y)这2个function，还有一点要说的是，由于它的原型是BaseCalculator的一个实例，所以不管你创建多少个Calculator对象实例，他们的原型指向的都是同一个实例。</p>
<pre><code>var calc = new Calculator();
alert(calc.add(1, 1));
//BaseCalculator 里声明的decimalDigits属性，在 Calculator里是可以访问到的
alert(calc.decimalDigits);
</code></pre><p>上面的代码，运行以后，我们可以看到因为Calculator的原型是指向BaseCalculator的实例上的，所以可以访问他的decimalDigits属性值，如果我不想让Calculator访问BaseCalculator的构造函数里声明:</p>
<pre><code>var Calculator = function () {
    this.tax= 5;
};

Calculator.prototype = BaseCalculator.prototype;
</code></pre><p>通过将BaseCalculator的原型赋给Calculator的原型，这样你在Calculator的实例上就访问不到那个decimalDigits值了，如果你访问如下代码，那将会提升出错。</p>
<pre><code>var calc = new Calculator();
alert(calc.add(1, 1));
alert(calc.decimalDigits);
</code></pre><p>先是这部分内容，看的有些部分没有懂还没有写完，等第二版到了读第二版吧。。。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2.5~2.9所遇问题]]></title>
      <url>/2018/02/09/blog/2.5~2.9_questions/</url>
      <content type="html"><![CDATA[<h2 id="2-5-2-9所遇问题"><a href="#2-5-2-9所遇问题" class="headerlink" title="2.5~2.9所遇问题"></a>2.5~2.9所遇问题</h2><h3 id="一-开发所遇问题"><a href="#一-开发所遇问题" class="headerlink" title="一.开发所遇问题"></a>一.开发所遇问题</h3><p>在这次开发过程中，是真正自己做的第一个迭代版本，在开发中主要遇到的问题有：从理清思路到代码的实现；代码的格式规范与模块化；如何与后台人员沟通好。</p>
<p>1.从理清思路到代码的实现</p>
<p>这部分内容主要是因为自己以前写的代码只考虑到最后呈现的效果，没有具体深入探讨如何高效的写代码，拿生庆哥的话讲就是：没有真正明白要做什么。这个做什么不仅仅是你要实现的效果是什么，还包括你对整体项目的思路。之前我写代码都是只想到大概有哪些代码块，但是几个代码块传参是什么，怎么传，情况考虑全不全，整体的逻辑也是只有个大概的印象就开始动手，造成的结果就是每个代码块之间都有一定的耦合，没有全部拆分开，这造成的结果就是会有很多重复的代码，本来能拆分成函数的内容都没有抽象出来，每个函数功能目的不明确，有很多“胶水代码”，归根结底是因为一开始太着急动手，写代码时又没有细究逻辑，功能是完成了，但过不了组内review的关卡，所以总结一句话：解决问题从源头开始，这次实现代码后发现，原本想象的多复杂多复杂的代码，其实并没有想象中那么难，只要逻辑正确，思路正确其实还是很好解决的。</p>
<p>2.代码的格式规范与模块化</p>
<p>这次写代码的过程真真切切的明白了一个道理：良好的命名的重要性，因为一开始想的功能不全，所以在中途添加了不少变量，这就造成了不断添加变量，但是因为函数的功能性不清晰，所以在定义变量的时候又会有代码名称比较接近的结果，一开始还没觉得什么，但是写的稍微多一点就会发现，自己不知道当时为什么要用这个变量名定义了，虽然名称有一定的含义，但是有一个变量名跟预期的函数功能还是有偏差，还得重新看一遍代码的过程，也是一个不好的习惯。</p>
<p>3.如何与后台人员沟通</p>
<p>因为这次的后台是千仪哥提供的，自己刚刚来，总是觉得千仪哥做的肯定没问题，所以在看接口的时候当不满足自己这边的需求时，在检查完对应的接口功能发现有问题时，先自己偷偷的看能不能自己生产这样的过程。在中间造成了不小的麻烦，经过这件事懂得了：尊重规范，按规范办事，这样才是解决问题最有效也是最便捷的方法。</p>
<h3 id="二-如何生成一个比1px更短的边框"><a href="#二-如何生成一个比1px更短的边框" class="headerlink" title="二.如何生成一个比1px更短的边框"></a>二.如何生成一个比1px更短的边框</h3><p>因为css提供最短的就是1px的长度，这也是屏幕的最短像素，所以要生成1px的边框长度也是有一定的技巧的；</p>
<p>1.使用rgba，通过添加透明度来在视觉上减少边框的长度。</p>
<p>这个是没什么好说的，效果虽然有，但是不是一个好的解决方法。</p>
<p>2.利用box-shadow实现窄边框</p>
<pre><code>box-shadow:0 0 1px 0 red
</code></pre><p>利用了盒子阴影绘制。可以用于各种场景。但是最后的颜色会变暗，而且box-shadow不占位置，语义化不符合标准。不是实际意义的边框。</p>
<p>3.多背景渐变实现</p>
<pre><code>background:
linear-gradient(180deg, red, red 50%, transparent 50%) top left / 100% 1px no-repeat, 
linear-gradient(90deg, red, red 50%, transparent 50%) top right / 1px 100% no-repeat, 
linear-gradient(0deg, red, red 50%, transparent 50%) bottom right / 100% 1px no-repeat, 
linear-gradient(-270deg, red, red 50%, transparent 50%) bottom left / 1px 100% no-repeat;
</code></pre><p>可以通过不同的四种角度的渐变，实现边框，颜色可以自定义。缺点是代码比较多，而且不能实现圆角。</p>
<p>4.伪类 + transform 实现</p>
<pre><code>:after{
    content: &#39;&#39;; 
    position: absolute; 
    top: 0; left: 0; 
    border: 1px solid red; 
    -webkit-box-sizing: border-box; 
    box-sizing: border-box; 
    width: 200%; 
    height: 200%; 
    -webkit-transform: scale(0.5); 
    transform: scale(0.5); 
    -webkit-transform-origin: left top; 
    transform-origin: left top; 
}
</code></pre><p>利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半， 然后进行绝对定位，这种方法现在没有发现问题。</p>
<h3 id="三-图的遍历"><a href="#三-图的遍历" class="headerlink" title="三.图的遍历"></a>三.图的遍历</h3><p>这部分是上次分享没有添加的内容：</p>
<p>广度优先 搜索(Breadth-First Search，BFS)和深度优先搜索(Depth-First Search，DFS)。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通等。</p>
<p>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</p>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点。</p>
<p>以下是从顶点v开始的广度优先搜索算法所遵循的步骤。<br>(1) 创建一个队列Q。<br>(2) 将v标注为被发现的(灰色)，并将v入队列Q。<br>(3) 如果Q非空，则运行以下步骤:<br>    (a) 将u从Q中出队列;<br>    (b) 将标注u为被发现的(灰色);<br>    (c) 将u所有未被访问过的邻点(白色)入队列;<br>    (d) 将u标注为已被探索的(黑色)。</p>
<pre><code>var initializeColor = function(){ 
    var color = [];
    for (var i=0; i&lt;vertices.length; i++){
         color[vertices[i]] = &#39;white&#39;; 
    }
    return color; 
};
    this.bfs = function(v, callback){
        var color = initializeColor(),  
        queue = new Queue();
        queue.enqueue(v);
        while (!queue.isEmpty()){
            var u = queue.dequeue(), neighbors = adjList.get(u); 
            color[u] = &#39;grey&#39;;                    
            for (var i=0; i&lt;neighbors.length; i++){ 
            var w = neighbors[i];
            if (color[w] === &#39;white&#39;){
                color[w] = &#39;grey&#39;;
                queue.enqueue(w);
            } }
            color[u] = &#39;black&#39;; 
            if (callback) {    
                callback(u);
            }
        } 
    };
</code></pre><h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点。</p>
<pre><code>this.dfs = function(callback){
    var color = initializeColor(); 
    for (var i=0; i&lt;vertices.length; i++){ 
        if (color[vertices[i]] === &#39;white&#39;){ 
            dfsVisit(vertices[i], color, callback); 
        }
    } 
};
var dfsVisit = function(u, color, callback){
    color[u] = &#39;grey&#39;; 
    if (callback) {    }
        callback(u);
    }
    var neighbors = adjList.get(u);
    for (var i=0; i&lt;neighbors.length; i++){ 
        var w = neighbors[i];
        if (color[w] === &#39;white&#39;){
            dfsVisit(w, color, callback);
        }
    }
    color[u] = &#39;black&#39;; 
};
</code></pre><p>以上是两个基本的图的遍历方法。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 23.Missing Number]]></title>
      <url>/2018/02/02/leetCode/23.Missing_Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-23-Missing-Number"><a href="#Problem-23-Missing-Number" class="headerlink" title="Problem 23.Missing Number"></a>Problem 23.Missing Number</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p><strong>Example 1</strong></p>
<blockquote>
<p><strong>Input:</strong> [3,0,1]<br><strong>Output:</strong> 2</p>
</blockquote>
<p><strong>Example 2</strong><br><strong>Input:</strong> [9,6,4,2,3,5,7,0,1]<br><strong>Output:</strong> 8</p>
<p><strong>Note:</strong><br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<p><strong>Credits:</strong><br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p>
<p><strong>solution</strong></p>
<p>1.这道题也是比较简单，只要先对数组排好序，然后跟序数进行对比，返回不相等的下标即可。</p>
<pre><code>var missingNumber = function(nums) {
    nums.sort(function(a,b){return a-b;});
    for (var i = 0; i &lt; nums.length; i++) {
        if(nums[i] != i) {
            return i;
        }
    }
    return nums.length;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 22.Maximum Product of Three Numbers]]></title>
      <url>/2018/02/02/leetCode/22.Maximum_Product_of_Three_Numbers/</url>
      <content type="html"><![CDATA[<h2 id="Problem-22-Maximum-Product-of-Three-Numbers"><a href="#Problem-22-Maximum-Product-of-Three-Numbers" class="headerlink" title="Problem 22.Maximum Product of Three Numbers"></a>Problem 22.Maximum Product of Three Numbers</h2><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,3]<br><strong>Output:</strong> 6</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,3,4]<br><strong>Output:</strong> 24</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The length of the given array will be in range [3,10<sup>4</sup>] and all elements are in the range [-1000, 1000].</li>
<li>Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer.</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.因为最短数组长度为3，所以不要考虑数组长度小于3的情况。本题的元素大小可能为负数，若都为正数或都为负数，则取前三个元素，若有正数有负数，通过查资料可以得到，此时3个数之积的最大值为max(第一大数<em>第二大数</em>第三大数， 第一大数<em>最小数</em>倒数第二小数)。这个方法可以记住。</p>
<pre><code>var maximumProduct = function(nums) {
    nums.sort(function(a,b){return b-a;});
    return Math.max(nums[nums.length - 1] * nums[nums.length - 2] * nums[0], nums[0] * nums[1] * nums[2]);
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 21. Image Smoother]]></title>
      <url>/2018/02/02/leetCode/21.Image_Smoother/</url>
      <content type="html"><![CDATA[<h2 id="Problem-21-Image-Smoother"><a href="#Problem-21-Image-Smoother" class="headerlink" title="Problem 21. Image Smoother"></a>Problem 21. Image Smoother</h2><p>Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>[[1,1,1],<br> [1,0,1],<br> [1,1,1]]<br><strong>Output:</strong><br>[[0, 0, 0],<br> [0, 0, 0],<br> [0, 0, 0]]<br><strong>Explanation:</strong><br>For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0<br>For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0<br>For the point (1,1): floor(8/9) = floor(0.88888889) = 0</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The value in the given matrix is in the range of [0, 255].</li>
<li>The length and width of the given matrix are in the range of [1, 150].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.这道题想了半天没想出什么好点的方法，就用最笨的方法写了，判断周围八个位置是否正常，如果正常，就计算到总额里并得到平均值。注意，js里不满1会向上取整，所以应该用Math.floor()。代码如下：</p>
<pre><code>var imageSmoother = function(M) {
        var nx = M.length;
        var ny = M[0].length;
        var res = new Array(nx);
        for(var n = 0; n &lt; nx; n++){
            res[n] = new Array(ny);
        } ;
        for (var i = 0; i &lt; nx; i++) {
            for (var j = 0; j &lt; ny; j++) {
                res[i][j] = smooth(M, i, j);
            }
        }
        return res;
    }
    var smooth = function(M, x, y) {
        var nx = M.length;
        var ny = M[0].length;
        var sum = 0;
        var count = 0;
        for (var i = -1; i &lt;= 1; i++) {
           for (var j = -1; j &lt;= 1; j++) {
             if (x + i &lt; 0 || x + i &gt;= nx || y + j &lt; 0 || y + j &gt;= ny) {
                 continue;
             }
             count++;
             sum += M[x + i][y + j];
           }
        }
        return Math.floor(sum / count);
    }
</code></pre><p>复杂度分析：<br> Time Complexity：O(r X c),r为M.length,c为M[0].length.</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 20.Contains Duplicate]]></title>
      <url>/2018/01/31/leetCode/20.Contains_Duplicate/</url>
      <content type="html"><![CDATA[<h2 id="Problem-20-Contains-Duplicate"><a href="#Problem-20-Contains-Duplicate" class="headerlink" title="Problem 20:Contains Duplicate"></a>Problem 20:Contains Duplicate</h2><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p><strong>solution:</strong></p>
<p>1.先对数组进行sort，然后除去特殊情况下判断只要元素周围两侧元素有一个相同，就返回true，否则为false。</p>
<pre><code>var containsDuplicate = function(nums) {
    nums.sort(function(a,b){return a-b});
    if(nums.length == 0) return false;
    if(nums.length == 1) return false;
    if(nums.length == 2 &amp;&amp; nums[0] ==nums[1]) return true;
    for(var i = 1; i &lt; nums.length - 1; i++) {
        if(nums[i] == nums[i-1] || nums[i] == nums[i+1]) {
            return true;
        }
    }
    return false;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 19.Degree of an Array]]></title>
      <url>/2018/01/31/leetCode/19.Degree_of_an_Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-19-Degree-of-an-Array"><a href="#Problem-19-Degree-of-an-Array" class="headerlink" title="Problem 19: Degree of an Array"></a>Problem 19: Degree of an Array</h2><p>Given a non-empty array of non-negative integers nums, the <strong>degree</strong> of this array is defined as the maximum frequency of any one of its elements.</p>
<p>Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1, 2, 2, 3, 1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong><br>The input array has a degree of 2 because both elements 1 and 2 appear twice.<br>Of the subarrays that have the same degree:<br>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]<br>The shortest length is 2. So return 2.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,2,3,1,4,2]<br><strong>Output:</strong> 6</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>nums.length will be between 1 and 50,000.</li>
<li>nums[i] will be an integer between 0 and 49,999.</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.本题本来想用数组的方式解决，但感觉比较麻烦，所以选择map来解决</p>
<pre><code>var findShortestSubArray = function(nums) {
    var m = new Map(),
    degree = 1,
    whichDegree = nums[0]
    for (var i = 0; i &lt; nums.length; i++) {
        if (m.has(nums[i])) {
        var pos = m.get(nums[i])
        pos.push(i)
        if (pos.length &gt; degree) {
            degree = pos.length
            whichDegree = nums[i]
        } else if (pos.length == degree &amp;&amp; pos[pos.length - 1] - pos[0] &lt; m.get(whichDegree)[m.get(whichDegree).length - 1] - m.get(whichDegree)[0]) {
        degree = pos.length
        whichDegree = nums[i]
        }
        } else 
            m.set(nums[i], [i])
    }
    return m.get(whichDegree)[m.get(whichDegree).length - 1] - m.get(whichDegree)[0] + 1
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 18.Two Sum II - Input array is sorted]]></title>
      <url>/2018/01/31/leetCode/18.Two_Sum_II_Input_array_is_sorted/</url>
      <content type="html"><![CDATA[<h2 id="Problem-18-Two-Sum-II-Input-array-is-sorted"><a href="#Problem-18-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="Problem 18: Two Sum II - Input array is sorted"></a>Problem 18: Two Sum II - Input array is sorted</h2><p>Given an array of integers that is already <em>sorted in ascending order</em>, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p><strong>Input:</strong> numbers={2, 7, 11, 15}, target=9<br><strong>Output:</strong> index1=1, index2=2</p>
<p><strong>solution:</strong></p>
<p>1.因为已经是升序的，所以只要从数组头尾往中间收拢，就必然会找到对应的两个数。</p>
<pre><code>var twoSum = function(numbers, target) {
    var left = 0, right= numbers.length - 1;
    var sum = 0;
    while (left &lt; right) {
        sum = numbers[left] + numbers[right];
        if (sum == target){return [left + 1, right + 1];}
        else if(sum &lt; target) left++;
        else right--;
    }
    return [];
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 17.Majority Element]]></title>
      <url>/2018/01/30/leetCode/17.Majority_Element/</url>
      <content type="html"><![CDATA[<h2 id="Problem-17-Majority-Element"><a href="#Problem-17-Majority-Element" class="headerlink" title="Problem 17: Majority Element"></a>Problem 17: Majority Element</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears <strong>more than</strong> ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Credits:</strong><br>Special thanks to @ts for adding this problem and creating all test cases.</p>
<p><strong>solution:</strong></p>
<p>1.这里比较取巧，因为内容全部为数字，所以sort按序排序然后选择中位数即可。</p>
<pre><code>var majorityElement = function(nums) {
    nums.sort(function(a,b){return a-b;});
    return nums[Math.floor(nums.length/2)];
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 16.Best Time to Buy and Sell Stock II]]></title>
      <url>/2018/01/30/leetCode/16.Best_Time_to_Buy_and_Sell_Stock_II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-16-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Problem-16-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Problem 16: Best Time to Buy and Sell Stock II"></a>Problem 16: Best Time to Buy and Sell Stock II</h2><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p><strong>solution:</strong></p>
<p>1.题目信息请见之前的题目地址，这道题的思路比较奇特，因为可以选择多次，所以只要后一次大于前一次，即可以在总额上加上差值，因为若后面的数继续大于前面的数，累加的差值等于之后的差值。若后面的小，则可以跳过，因为前面的内容已经得到最多的利润。</p>
<pre><code>var maxProfit = function(prices) {
    var maxprofit = 0;
    for(var i = 0; i &lt; prices.length; i++) {
        if (prices[i] &gt; prices[i - 1])
            maxprofit += prices[i] - prices[i - 1];
    }
    return maxprofit;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 15.1-bit and 2-bit Characters]]></title>
      <url>/2018/01/30/leetCode/15.1_bit_and_2_bit_Characters/</url>
      <content type="html"><![CDATA[<h2 id="Problem-15-1-bit-and-2-bit-Characters"><a href="#Problem-15-1-bit-and-2-bit-Characters" class="headerlink" title="Problem 15: 1-bit and 2-bit Characters"></a>Problem 15: 1-bit and 2-bit Characters</h2><p>We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).</p>
<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>bits = [1, 0, 0]<br><strong>Output:</strong> True<br><strong>Explanation:</strong><br>The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>bits = [1, 1, 1, 0]<br><strong>Output:</strong> False<br><strong>Explanation:</strong><br>The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>1 &lt;= len(bits) &lt;= 1000.</li>
<li>bits[i] is always 0 or 1.</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.近期因为时间比较紧，所以只用一种方法解决。本题选择递归，当前元素若为1，则删掉前两个，当前元素为0，则删除一个，直到最后长度为0或时，返回false或true。</p>
<pre><code>var isOneBitCharacter = function(bits) {
    if(bits.length==0) return false; 
    else if(bits.length==1) return true;
    if(bits[0]==0)bits.splice(0,1); 
    else bits.splice(0,2);
    return isOneBitCharacter(bits)
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 14.Move Zeroes]]></title>
      <url>/2018/01/27/leetCode/14.Move_Zeroes/</url>
      <content type="html"><![CDATA[<h2 id="Problem-14-Move-Zeroes"><a href="#Problem-14-Move-Zeroes" class="headerlink" title="Problem 14: Move Zeroes"></a>Problem 14: Move Zeroes</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p><strong>Note:</strong></p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<p><strong>Credits:</strong></p>
<p>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p>
<p><strong>solution:</strong></p>
<ol>
<li>这跟之前做的题很类似，只要注意在splice之后要对i减一即可。</li>
</ol>
<pre><code>var moveZeroes = function(nums) {
    var sumZero = 0;
    for(var i = 0; i &lt; nums.length; i++) {
        if(nums[i] == 0) {
            nums.splice(i, 1);
            i--;
            sumZero++;
        }
    }
    for(var n = 0; n &lt; sumZero; n++) {
        nums.push(0);
    }
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 13.Find All Numbers Disappeared in an Array]]></title>
      <url>/2018/01/27/leetCode/13.Find_All_Numbers_Disappeared_in_an_Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-13-Find-All-Numbers-Disappeared-in-an-Array"><a href="#Problem-13-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="Problem 13: Find All Numbers Disappeared in an Array"></a>Problem 13: Find All Numbers Disappeared in an Array</h2><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<p><strong>Example:</strong></p>
<p><strong>Input:</strong><br>[4,3,2,7,8,2,3,1]</p>
<p><strong>Output:</strong><br>[5,6]</p>
<p><strong>solution:</strong></p>
<p>1.本来想最简单的方法就是先筛选出1 ≤ a[i] ≤ n 中哪个元素不再数组里，然后push到最后一位在splice之前的内容，但是要求<code>without extra space and in O(n) runtime</code>，所以选择其他的方法。这里选择先将数组排序，然后判断哪个元素不是对应位置上的数字，最后push到数组中。</p>
<pre><code>var findDisappearedNumbers = function(nums) {
     var res = [];
     for (var i = 0; i &lt; nums.length; i++) {
        if (nums[i] != nums[nums[i] - 1]) {
            var inchange = nums[nums[i] - 1];
            nums[nums[i] - 1] = nums[i];
            nums[i] = inchange;
            i--;
        }
    }
    for (var j = 0; j &lt; nums.length; j++) {
        if (nums[j] != j + 1)
            res.push(j + 1);
    }
    return res;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 12.Max Area of Island]]></title>
      <url>/2018/01/27/leetCode/12.Max_Area_of_Island/</url>
      <content type="html"><![CDATA[<h2 id="Problem-12-Max-Area-of-Island"><a href="#Problem-12-Max-Area-of-Island" class="headerlink" title="Problem 12: Max Area of Island"></a>Problem 12: Max Area of Island</h2><p>Given a non-empty 2D array <code>grid</code> of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</p>
</blockquote>
<p>Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.</p>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>[[0,0,0,0,0,0,0,0]]</p>
</blockquote>
<p>Given the above grid, return 0.</p>
<p><strong>Note:</strong> The length of each dimension in the given grid does not exceed 50.</p>
<p><strong>solution:</strong></p>
<ol>
<li>因为选取最多的相邻的1，本来打算遍历一遍，如果当前元素右边和下边为1，则对右下方元素加对应的值，但是边界条件判断比较复杂。所以，选择递归实现，虽然实现很简单，但是时间复杂度相对较高，做了比较多重复的操作。以下为对应代码：</li>
</ol>
<pre><code>var maxAreaOfIsland = function(grid) {
      var res = 0;
      for(var i = 0; i &lt; grid.length; i++){
         for(var j = 0; j &lt; grid[0].length; j++){
                if(grid[i][j] == 1) res = Math.max(res, helper(grid, i, j));
            }
        }
        return res;
};

var helper = function(grid, r, c) {
    if(r &lt; 0 || r &gt;= grid.length || c &lt; 0 || c &gt;= grid[0].length) return 0;
        var res = 0;
        if(grid[r][c] == 1){
            grid[r][c] = 0;
            res = 1 + helper(grid, r-1, c) + helper(grid, r+1, c) + helper(grid, r, c-1) + helper(grid, r, c+1);
        }
        return res;
}
</code></pre><p>复杂度分析：<br>Time Complexity：O(r X c), r为行的个数，c为列的个数。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 11.Shortest Word Distance]]></title>
      <url>/2018/01/27/leetCode/11.Shortest_Word_Distance/</url>
      <content type="html"><![CDATA[<h2 id="Problem-11-Shortest-Word-Distance"><a href="#Problem-11-Shortest-Word-Distance" class="headerlink" title="Problem 11: Shortest Word Distance"></a>Problem 11: Shortest Word Distance</h2><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>For example,<br>Assume that words = <code>[&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]</code>.</p>
<p>Given word1 = <code>&quot;coding&quot;</code>, word2 = <code>&quot;practice&quot;</code>, return 3.<br>Given word1 = <code>&quot;makes&quot;</code>, word2 = <code>&quot;coding&quot;</code>, return 1.</p>
<p><strong>Note:</strong></p>
<p>You may assume that word1 <strong>does not equal to</strong> word2, and word1 and word2 are both in the list.</p>
<p><strong>solution:</strong></p>
<ol>
<li>根据题意，选出最近的两个对应的单词的间距，因为所选单词最短的间距即相邻间距，所以最小的匹配值间距的绝对值即是所求答案。</li>
</ol>
<pre><code>var shortestDistance = function(words, word1, word2) {
    var index1 = -1, index2 = -1;
    var minDistance = words.length;
    var currentDistance;
    for (var i = 0; i &lt; words.length; i++) {
        if (words[i] == word1) {
            index1 = i;
        } else if (words[i] == word2) {
            index2 = i;
        }

        if (index1 != -1 &amp;&amp; index2 != -1) {
            minDistance = Math.min(minDistance, Math.abs(index1 - index2));
        }
    }
    return minDistance;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为数组的长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 10.Max Consecutive Ones]]></title>
      <url>/2018/01/26/leetCode/10.Max_Consecutive_Ones/</url>
      <content type="html"><![CDATA[<h2 id="Problem-10-Max-Consecutive-Ones"><a href="#Problem-10-Max-Consecutive-Ones" class="headerlink" title="Problem 10: Max Consecutive Ones"></a>Problem 10: Max Consecutive Ones</h2><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,1,0,1,1,1]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The first two digits or the last three digits are consecutive 1s.<br>    The maximum number of consecutive 1s is 3.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The input array will only contain 0 and 1.</li>
<li>The length of input array is a positive integer and will not exceed 10,000</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.这道题算是福利题了，只要确定最长的1的长度就行了，所以直接判断即可：</p>
<pre><code>var findMaxConsecutiveOnes = function(nums) {
    var res = 0;
    var cnt = 0;
    for (var i = 0; i&lt; nums.length; i++) {
        cnt = (nums[i] == 0) ? 0 : cnt + 1;
        res = Math.max(res, cnt);
    }
    return res;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n),n为nums的长度；</p>
<p>2.除此之外还看到一个人的另一种比较有趣的方法，因为是01串，那么连续1的和跟个数相等，所以我们可以计算和，通过加上num，再乘以num来计算，如果当前数字是0，那么sum就被重置为0，还是要更新结果res。</p>
<pre><code>var findMaxConsecutiveOnes = function(nums) {
    var res = 0;
    var cnt = 0;
    for (var i = 0; i&lt; nums.length; i++) {
        cnt = (cnt + nums[i]) * nums[i];
        res = Math.max(res, cnt);
    }
    return res;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n),n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 9.Reshape the Matrix]]></title>
      <url>/2018/01/26/leetCode/9.Reshape_the_Matrix/</url>
      <content type="html"><![CDATA[<h2 id="Problem-9-Reshape-the-Matrix"><a href="#Problem-9-Reshape-the-Matrix" class="headerlink" title="Problem 9:Reshape the Matrix"></a>Problem 9:Reshape the Matrix</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p>
<p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and column number of the wanted reshaped matrix, respectively.</p>
<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p>
<p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>nums =<br>[[1,2],<br> [3,4]]<br>r = 1, c = 4<br><strong>Output:</strong><br>[[1,2,3,4]]<br><strong>Explanation:</strong><br>The <strong>row-traversing</strong> of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>nums =<br>[[1,2],<br> [3,4]]<br>r = 2, c = 4<br><strong>Output:</strong><br>[[1,2],<br> [3,4]]<br><strong>Explanation:</strong><br>There is no way to reshape a 2 X 2 matrix to a 2 X 4 matrix. So output the original matrix.</p>
</blockquote>
<p><strong>Note:</strong><br>The height and width of the given matrix is in range [1, 100].<br>The given r and c are all positive.</p>
<p><strong>solution:</strong></p>
<ol>
<li>做这道题时主要的问题在于如何创建一个二维数组，因为js创建二维数组时出现问题，所以选择设两个一维数组，先判断是否符合要求，不符合返回原数组，然后将元素通过concat添加到一个一维数组中，然后根据所给的r,c一一赋值即可。这道题主要纠结在如何设置一个空的二维数组以及如何对二维数组进行赋值。最后回避了这个问题。</li>
</ol>
<pre><code>var matrixReshape = function(nums, r, c) {
    var result_storage = [];
    var result = []; 
    if(nums.length * nums[0].length != r * c) {
        return nums;
    }    
    for(var i=0; i &lt; nums.length; i++) {  
            result_storage = result_storage.concat(nums[i]);  
    }
    for(var i = 0; i &lt; r; i++) {  
        result.push([]);  
        for(var j = 0; j &lt; c ; j++){  
                result[i][j] = result_storage[i * c + j];  
            }  
    } 
    return result;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(r X c), r为矩阵的横向长度，c为矩阵的纵向长度。</p>
<p>2.经过查询过后，发现二维数组不是通过创建`var result = new Array[][]这样的形式创建，而是通过先创建一个一维数组，再对其中的元素设置为数组的形式创建多维数组。接下来就对数组中的内容进行判断，若没有到下一行，则继续对下一位内容赋值，若倒下一行，则换行输入。</p>
<pre><code>var matrixReshape = function(nums, r, c) {
    var result =  new Array(r);  
    for(var n = 0; n &lt; result.length; n++){  
        result[n] = new Array(c);   
    }  
    var rows = 0; 
    var cols = 0;
    var count = 0;
    if(nums.length == 0 || nums.length * nums[0].length != r * c) 
        return nums;   
    for (var i = 0; i &lt; nums.length; i ++) {
        for (var j = 0; j &lt; nums[0].length; j++) {
            result[rows][cols] = nums[i][j];
            cols++;
            if (cols == c) {
                rows++;
                cols = 0;
            }
        }
    }
    return result;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(num.length X num[0].length), 与上述方法的复杂度类似，不过更直观一些。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 8.Toeplitz Matrix]]></title>
      <url>/2018/01/26/leetCode/8.Toeplitz_Matrix/</url>
      <content type="html"><![CDATA[<h2 id="Problem-8-Toeplitz-Matrix"><a href="#Problem-8-Toeplitz-Matrix" class="headerlink" title="Problem 8: Toeplitz Matrix"></a>Problem 8: Toeplitz Matrix</h2><p>A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.</p>
<p>Now given an <code>M x N</code> matrix, return <code>True</code> if and only if the matrix is Toeplitz.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]<br><strong>Output:</strong> True<br><strong>Explanation:</strong><br>1234<br>5123<br>9512</p>
</blockquote>
<p>In the above grid, the diagonals are “[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”, and in each diagonal all elements are the same, so the answer is True.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> matrix = [[1,2],[2,2]]<br><strong>Output:</strong> False<br><strong>Explanation:</strong><br>The diagonal “[1, 2]” has different elements.</p>
<p><strong>Note:</strong></p>
<ol>
<li>matrix will be a 2D array of integers.</li>
<li>matrix will have a number of rows and columns in range [1, 20].</li>
<li>matrix[i][j] will be integers in range [0, 99].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.通过画图可得，从左上角的元素开始，如果每行（最后一行除外）元素可以与右下方（每行最后一个元素除外）的元素相等，既符合要求，所以可以选择遍历得到答案。</p>
<p>目前就只有这一种比较好的解法，所以就先写一个算法了。</p>
<pre><code>var isToeplitzMatrix = function(matrix) {
    for(var r = 0; r &lt; matrix.length - 1; r++) {
        for(var c = 0; c &lt; matrix[0].length - 1; c++) {
            if(matrix[r][c] != matrix[r+1][c+1]) {
                return false;
            }
        }
    }
    return true;
};
</code></pre><p>复杂度分析：<br>Time Complexity: O(m X n), m为矩阵的横向长度，n为矩阵的纵向长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 7.Array Partition I]]></title>
      <url>/2018/01/26/leetCode/7.array_partition_I/</url>
      <content type="html"><![CDATA[<h2 id="Problem-7-Array-Partition-I"><a href="#Problem-7-Array-Partition-I" class="headerlink" title="Problem 7:Array Partition I"></a>Problem 7:Array Partition I</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,4,3,2]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li>
<li>All the integers in the array will be in the range of [-10000, 10000].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.这道题比较简单的做法是对数组排序，然后隔一个数字取一个，就可以保证数组中所有的每两个数字的最小值的总和是最小值。</p>
<p>目前也没有找到比这个更简单的算法，所以就先写一个算法了。</p>
<pre><code>var arrayPairSum = function(nums) {
    var sum = 0;
    var i = 0;
    nums.sort(function(a, b){return a-b;});
    for(var i = 0; i&lt; nums.length; i+=2) {
        sum+=nums[i];
    }
    return sum;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1.22~1.26所遇问题]]></title>
      <url>/2018/01/25/blog/1.22~1.16_questions/</url>
      <content type="html"><![CDATA[<h2 id="1-22-1-26所遇问题"><a href="#1-22-1-26所遇问题" class="headerlink" title="1.22~1.26所遇问题"></a>1.22~1.26所遇问题</h2><h3 id="1-导入css文件时，import和link的区别"><a href="#1-导入css文件时，import和link的区别" class="headerlink" title="1.导入css文件时，import和link的区别"></a>1.导入css文件时，import和link的区别</h3><ol>
<li><code>&lt;link&gt;</code>标签是html标签，除了可以引入CSS之外还可以定义RSS，定义rel属性等，而@import只能引入CSS样式；</li>
<li><code>&lt;link&gt;</code>标签引用的CSS文件会在页面加载时与html同时加载，而@import引入的CSS文件会等页面全部加载完以后再加载；</li>
<li>@import标签必须放在页面样式表的顶部，而<code>&lt;link&gt;</code>不必；</li>
</ol>
<p>那为什么会有很多人建议使用link标签，而非import呢？在Steve Souders（编写过《高性能网站建设指南》等书）的博客中通过一些实例来说明<strong>don’t use @import</strong>。<br>以下节选部分内容并进行翻译：</p>
<p>原文链接<a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/" target="_blank" rel="noopener">http://www.stevesouders.com/blog/2009/04/09/dont-use-import/</a><br>——————————————————————————————————————<br><strong>LINK vs. @import</strong></p>
<p>There are two ways to include a stylesheet in your web page. You can use the LINK tag:</p>
<p>以下有两种将样式表引入到您的网页中的方式。您可以使用LINK标签：</p>
<pre><code>&lt;link rel=&#39;stylesheet&#39; href=&#39;a.css&#39;&gt;
</code></pre><p>Or you can use the @import rule:</p>
<p>或者您可以使用@import规则：</p>
<pre><code>&lt;style&gt;
@import url(&#39;a.css&#39;);
&lt;/style&gt;
</code></pre><p>I prefer using LINK for simplicity—you have to remember to put @import at the top of the style block or else it won’t work. It turns out that avoiding @import is better for performance, too.</p>
<p>为了简单起见，我更倾向于使用LINK。如果您使用@import的话，您必须将它放在样式内容的顶部，否则它将无法显示。事实证明，处于性能来说，避免使用@import也是一个更好的选择。</p>
<p><strong>@import @import</strong></p>
<p>I’m going to walk through the different ways LINK and @import can be used. In these examples, there are two stylesheets: a.css and b.css. Each stylesheet is configured to take two seconds to download to make it easier to see the performance impact. The first example uses @import to pull in these two stylesheets. In this example, called @import @import, the HTML document contains the following style block:</p>
<p>我将在不同的情况下使用LINK和@import。在这些例子中，有两个样式表：a.css和b.css。每个样式表都需要花费两秒钟的时间下载，以便更容易地观测性能。第一个示例中，我们使用@import来下载这两个样式表。我们叫这个例子为<code>@import @import</code>在这个示例中，HTML文档包含以下样式块：</p>
<pre><code>&lt;style&gt;
@import url(&#39;a.css&#39;);
@import url(&#39;b.css&#39;);
&lt;/style&gt;
</code></pre><p>If you always use @import in this way, there are no performance problems, although we’ll see below it could result in JavaScript errors due to race conditions. The two stylesheets are downloaded in parallel, as shown in Figure 1. (The first tiny request is the HTML document.) The problems arise when @import is embedded in other stylesheets or is used in combination with LINK.</p>
<p>如果您总是使用@import的方式，不会有什么性能方面的问题，尽管可能由于竞争的原因导致JavaScript报错。如图1所示，这两个样式表是并行下载的。（第一个请求时HTML文档），但是，当@import与LINK结合使用引入其他样式表时，问题就出现了。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/import-import.gif" alt="只使用@import"><br>    <figcaption><br>        只使用@import<br>    </figcaption><br></figure>

<p>由此可见，只使用@import是没有问题的。</p>
<p><strong>LINK @import</strong></p>
<p>The LINK @import example uses LINK for a.css, and @import for b.css:</p>
<p>LINK @import示例中使用LINK标签引入a.css，使用@import引入b.css：</p>
<pre><code>&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
&lt;style&gt;
@import url(&#39;b.css&#39;);
&lt;/style&gt;
</code></pre><p>In IE (tested on 6, 7, and 8), this causes the stylesheets to be downloaded sequentially, as shown in Figure 2. Downloading resources in parallel is key to a faster page. As shown here, this behavior in IE causes the page to take a longer time to finish.</p>
<p>在IE（在IE6， 7， 8下测试）中，如下图所示，这将导致样式表按顺序下载，而并行下载资源是让页面加载更快的关键。如图所示，在IE中的这会导致页面花费较长的时间完成渲染。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-import.gif" alt="混合使用@import和link标签"><br>    <figcaption><br>        混合使用@import和link标签<br>    </figcaption><br></figure>

<p><strong>LINK with @import</strong></p>
<p>In the LINK with @import example, a.css is inserted using LINK, and a.css has an @import rule to pull in b.css:</p>
<p>在使用LINK中使用@import的示例中，a.css使用LINK嵌入在DOM中，而a.css中则通过@import导入b.css：</p>
<pre><code>in the HTML document:
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
in a.css:
@import url(&#39;b.css&#39;);
</code></pre><p>This pattern also prevents the stylesheets from loading in parallel, but this time it happens on all browsers. When we stop and think about it, we shouldn’t be too surprised. The browser has to download a.css and parse it. At that point, the browser sees the @import rule and starts to fetch b.css.</p>
<p>这种方式也可以防止样式表的并行加载，但是这次它发生在所有的浏览器上。其实仔细想一想，我们都不应该感到惊讶。浏览器必须先下载a.css并解析它，只有解析它后，浏览器才会看到@import规则并开始加载b.css。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-with-import.gif" alt="在link标签引入@import"><br>    <figcaption><br>       在link标签引入@import<br>    </figcaption><br></figure>

<p><strong>LINK blocks @import</strong></p>
<p>A slight variation on the previous example with surprising results in IE: LINK is used for a.css and for a new stylesheet called proxy.css. proxy.css is configured to return immediately; it contains an @import rule for b.css.</p>
<p>在IE中与上述结果有些许不同：对a.css和名为proxy.css的样式表使用LINK引入。而proxy.css会立即执行并渲染; 注意，它包含一个b.css的@import规则</p>
<pre><code>in the HTML document:
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;proxy.css&#39;&gt;
in proxy.css:
@import url(&#39;b.css&#39;);
</code></pre><p>The results of this example in IE, LINK blocks @import, are shown in Figure 4. The first request is the HTML document. The second request is a.css (two seconds). The third (tiny) request is proxy.css. The fourth request is b.css (two seconds). Surprisingly, IE won’t start downloading b.css until a.css finishes. In all other browsers, this blocking issue doesn’t occur, resulting in a faster page as shown in Figure 5.</p>
<p>在IE中的LINK bock @import例子里，第一个请求时HTML文件，第二个请求是a.css（花费了两秒），第三个请求（很短）是proxy.css。第四个请求时b.css（花费了两秒）。令人惊奇的是，IE不会等到a.css结束后再开始下载b.css。在所有其他的浏览器里，这种加速渲染页面的情况不会发生。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-blocks-import.gif" alt="LINK blocks @import embedded in other stylesheets in IE"><br>     <figcaption><br>        LINK blocks @import embedded in other stylesheets in IE<br>     </figcaption><br></figure>

<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-blocks-import-not-ie.gif" alt=" LINK doesn't block @import embedded stylesheets in browsers other than IE"><br>     <figcaption><br>         LINK doesn’t block @import embedded stylesheets in browsers other than IE<br>     </figcaption><br></figure>

<p><strong>many @imports</strong></p>
<p>The many @imports example shows that using @import in IE causes resources to be downloaded in a different order than specified. This example has six stylesheets (each takes two seconds to download) followed by a script (a four second download).</p>
<p>在many @imports例子中显示了在IE中使用@import会导致不同于指定的顺序下载资源。这个例子有六个样式表（每个需要两秒钟下载），后面是一个脚本（四秒钟的下载）</p>
<pre><code>&lt;style&gt;
@import url(&#39;a.css&#39;);
@import url(&#39;b.css&#39;);
@import url(&#39;c.css&#39;);
@import url(&#39;d.css&#39;);
@import url(&#39;e.css&#39;);
@import url(&#39;f.css&#39;);
&lt;/style&gt;
&lt;script src=&#39;one.js&#39; type=&#39;text/javascript&#39;&gt;&lt;/script&gt;
</code></pre><p>Looking at Figure 6, the longest bar is the four second script. Even though it was listed last, it gets downloaded first in IE. If the script contains code that depends on the styles applied from the stylesheets (a la getElementsByClassName, etc.), then unexpected results may occur because the script is loaded before the stylesheets, despite the developer listing it last.</p>
<p>看下图，最长的一条是一个四秒的脚本。尽管它位于最后，但是它在IE中是最早下载下来的。如果脚本包括依赖于样式表中的样式，会有未知的结果发生，因为脚本不是按照预期的顺序在样式之后加载的。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/many-imports.gif" alt="多个import"><br>     <figcaption><br>        多个import<br>     </figcaption><br></figure>

<p><strong>LINK LINK</strong></p>
<p>It’s simpler and safer to use LINK to pull in stylesheets:</p>
<p>使用LINK加载样式更快捷也更安全：</p>
<pre><code>&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;a.css&#39;&gt;
&lt;link rel=&#39;stylesheet&#39; type=&#39;text/css&#39; href=&#39;b.css&#39;&gt;
</code></pre><p>Using LINK ensures that stylesheets will be downloaded in parallel across all browsers. The LINK LINK example demonstrates this, as shown in Figure 7. Using LINK also guarantees resources are downloaded in the order specified by the developer.</p>
<p>使用LINK会确保样式表会在所有的浏览器中都并行下载。这个LINK LINK的例子证明了这点，使用LINk也保证资源会按开发者的顺序加载。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/import-import.gif" alt="使用link加载样式表"><br>     <figcaption><br>        使用link加载样式表<br>     </figcaption><br></figure>

<p>These issues need to be addressed in IE. It’s especially bad that resources can end up getting downloaded in a different order. All browsers should implement a small lookahead when downloading stylesheets to extract any @import rules and start those downloads immediately. Until browsers make these changes, I recommend avoiding @import and instead using LINK for inserting stylesheets.</p>
<p>这些问题在IE中都需要解决。尤其是资源会以不同的顺序下载的问题尤为糟糕。所有的浏览器都应该在下载样式表的时候就提取任何@import规则并立即开始下载。在浏览器进行这些更改之前，我建议避免使用@import，而应使用LINK来引入样式表。</p>
<p>The load times of these resources are exaggerated to make it easy to see what’s happening. But for people with slow connections, especially those in some of the world’s emerging markets, these response times may not be that far from reality. The takeaways are:</p>
<ol>
<li>Using @import within a stylesheet adds one more roundtrip to the overall download time of the page.</li>
<li>Using @import in IE causes the download order to be altered. This may cause stylesheets to take longer to download, which hinders progress rendering making the page feel slower.</li>
</ol>
<p>因为这些资源的加载时间被夸大，所有我们很容易看到发生了什么事情。但是对于那些网速慢的人来说，网络的响应时间也许并不那么块。 原因是：</p>
<ol>
<li>在样式表中使用@import会使得页面的整体下载时间再增加一倍。</li>
<li>在IE中使用@import会导致资源的下载顺序发生改变。这可能会导致样式表花费更长的时间来下载，因此会阻碍渲染，使页面加载的更慢。</li>
</ol>
<h3 id="2-微格式"><a href="#2-微格式" class="headerlink" title="2.微格式"></a>2.微格式</h3><p>对应官网为：<a href="http://microformats.org/" target="_blank" rel="noopener">http://microformats.org/</a></p>
<h4 id="微格式产生背景："><a href="#微格式产生背景：" class="headerlink" title="微格式产生背景："></a>微格式产生背景：</h4><p>由于早期HTML中缺少相应的元素，很难突出显示人、地点或日期等类型的信息。为了解决这个问题，有一组开发人员决定开发一套标准的命名约定盒标记模式来表示这些数据。这些命名约定基于vCard（电子名片）和iCalendar（日历数据交换）等现有的数据格式，现在称为微格式（microformat)。</p>
<h4 id="微格式定义："><a href="#微格式定义：" class="headerlink" title="微格式定义："></a>微格式定义：</h4><p>建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式（microformats.org官方定义）。是把语义嵌入到HTML以便有助于分离式开发而制定的一些简单约定，是兼顾人机可读性设计的数据表达方式，对Web网页进行语义注解的方法。</p>
<h4 id="微格式意义："><a href="#微格式意义：" class="headerlink" title="微格式意义："></a>微格式意义：</h4><p>微格式按照某种已有的被广泛应用的标准，通过对内容块的语义标记，可以让外部应用程序、聚合程序和搜索引擎能够做以下事情：</p>
<ol>
<li>在捉取Web内容时，能够更为准确地识别内容块的语义；</li>
<li>对内容进行操作，包括提供访问、校对，还可以将其转化成其他的相关格式，提供给外部程序和Web服务使用。</li>
</ol>
<p>因此，微格式实际上就是为现有的HTML元素添加元数据和其他属性以增强语义化。</p>
<p>常见的微格式是hCard</p>
<p>hCard是一种微格式，用来发布个人，公司，组织，地点等详细的联系信息。它可以包含在(X)HTML，Atom，RSS等可扩展置标语言中。hCard使用vCard（RFC 2426）的属性和值来实现这些功能。</p>
<p>它可以使分析器（比如其他网站，Firefox的Operator插件）获得详细的信息，并通过别的网站或者地图工具进行显示，或者载入到地址簿等其他程序。</p>
<p>example：</p>
<pre><code>&lt;div&gt;
     &lt;div&gt;Joe Doe&lt;/div&gt;
     &lt;div&gt;The Example Company&lt;/div&gt;
     &lt;div&gt;604-555-1234&lt;/div&gt;
     &lt;a href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
 &lt;/div&gt;
</code></pre><p> 如下代码添加了微格式后，成为:</p>
<pre><code> &lt;div class=&quot;vcard&quot;&gt;
     &lt;div class=&quot;fn&quot;&gt;Joe Doe&lt;/div&gt;
     &lt;div class=&quot;org&quot;&gt;The Example Company&lt;/div&gt;
     &lt;div class=&quot;tel&quot;&gt;604-555-1234&lt;/div&gt;
     &lt;a class=&quot;url&quot; href=&quot;http://example.com/&quot;&gt;http://example.com/&lt;/a&gt;
 &lt;/div&gt;
</code></pre><p> 这里，正式名称（class=”fn”），组织（class=”org”），电话号码（class=”tel”）和url（class=”url”）分别用相应的class标示；同时，所有内容都包含在class=”vcard”里。</p>
<p> 以上就是微格式的大体内容。</p>
<h3 id="外边距叠加"><a href="#外边距叠加" class="headerlink" title="外边距叠加"></a>外边距叠加</h3><p>首先，先说明是什么导致的外边距叠加。</p>
<p>首先，外边距叠加是因为<strong>外边距塌陷(margin collapse)</strong>导致的。实际它也是由于一个缺省值的设定而导致的。在Chrome浏览器里，这个缺省值就是由-webkit-margin-collapse规定的。-webkit-margin-collapse的缺省值就是collapse，所以导致塌陷。这个属性还有另外2个取值：一个是discard，一个是separate。下面我们来具体看一下它们的不同表现形式。</p>
<h4 id="webkit-margin-collapse-collapse"><a href="#webkit-margin-collapse-collapse" class="headerlink" title="-webkit-margin-collapse: collapse"></a>-webkit-margin-collapse: collapse</h4><p>我们先从简单的看起。假定我们有这样一个<code>&lt;div&gt;</code>，这个<code>&lt;div&gt;</code>里面有3个<code>&lt;p&gt;</code>，如果我们什么也不设，它就是这个样子：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/157/537/1575372319-5a5eabae0c326_articlex" alt="未设置-webkit-margin-collapse"></p>
<p>会看到每一个<code>&lt;p&gt;</code>下面都有一个下边距。现在我们加上<code>margin: 20px 0;</code>表示为每一个<code>&lt;p&gt;</code>增加一个20px的上边距和一个20px的下边距，现在再看一下效果：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/537/919/537919608-5a5eac73b8e6c_articlex" alt="-webkit-margin-collapse: collapse"></p>
<p>这时我们看到虽然第一个<code>&lt;p&gt;</code>有20px的上边距，但第2个<code>&lt;p&gt;</code>的20px上边距已经被第一个<code>&lt;p&gt;</code>的下边距『吃掉』了，这就是我们大家所熟知的外边距塌陷。</p>
<h4 id="webkit-margin-collapse-separate"><a href="#webkit-margin-collapse-separate" class="headerlink" title="-webkit-margin-collapse: separate"></a>-webkit-margin-collapse: separate</h4><p>现在我们来看一下第2种情况，如果我们设定<code>-webkit-margin-collapse: separate</code>之后会怎么样：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/164/511/1645114860-5a5eb3d394158_articlex" alt="-webkit-margin-collapse: separate"></p>
<p>现在我们看到塌陷的外边距回来了。</p>
<h4 id="webkit-margin-collapse-discard"><a href="#webkit-margin-collapse-discard" class="headerlink" title="-webkit-margin-collapse: discard"></a>-webkit-margin-collapse: discard</h4><p>那么第3种取值<code>discard</code>是什么作用呢？</p>
<p><img src="https://sfault-image.b0.upaiyun.com/318/356/3183561786-5a5eb42f8c31d_articlex" alt="-webkit-margin-collapse: discard"></p>
<p>外边距完全没有了。</p>
<p>所以，如果我们想强制所有元素边距都不塌陷，那么该怎么办呢？</p>
<p>我们不能再简单地同时设置上下边距为<code>margin: 20px 0;</code>而应该更精确控制，给<code>&lt;p&gt;</code>只设置下边距为20px就可以了，这样我们就实现了在强制不塌陷的情况下依然保持了行与行之间的距离。</p>
<p>Tips:<br>『外边距塌陷』其实是W3C早期标准为了一时方便而引入的一个过度设计，它的设计初衷是为了简化，但结果在CSS高度发展的情况下反倒造成了更大的混乱，使得前端工程师无法一目了然地知道自己的代码结果，不明白自己明明已经设置好的<code>margin-top: 20px;</code>怎么就会没有了？结果被人告知还要学习外边距塌陷这样的知识。这样的错误责任不在于工程师没有好好学习，而根本原因在于CSS本身设计的缺陷，才导致了工程师学习成本的增加，并且还增加了浏览器开发者的工作量，需要特意为外边距塌陷开发额外的代码。无论如何，这是一件各方成本都增加的双输设计。</p>
<p>至于水平方向上为什么没有外边距叠加，我也不知道呀，也许当时就是为了解决垂直方向上外边距累加的问题吧，定义上就是这么定义的。</p>
<p>最后总结一下W3C中外边距叠加的内容</p>
<blockquote>
<p>In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin.</p>
</blockquote>
<p>在CSS中，两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。</p>
<p>我们可以注意定义中的几个关键字：毗邻、两个或多个、垂直方向和普通流。</p>
<h4 id="毗邻"><a href="#毗邻" class="headerlink" title="毗邻"></a>毗邻</h4><p>毗邻说明了他们的位置关系，没有被 padding、border、clear 和 line box 分隔开。</p>
<h4 id="两个或多个"><a href="#两个或多个" class="headerlink" title="两个或多个"></a>两个或多个</h4><p>两个或多个盒子是指元素之间的相互影响，单个元素不会存在外边距叠加的情况。</p>
<h4 id="垂直方向"><a href="#垂直方向" class="headerlink" title="垂直方向"></a>垂直方向</h4><blockquote>
<p>Horizontal margins never collapse.</p>
</blockquote>
<p>只有垂直方向的外边距会发生外边距叠加。水平方向的外边距不存在叠加的情况。</p>
<h4 id="普通流-in-flow"><a href="#普通流-in-flow" class="headerlink" title="普通流(in flow)"></a>普通流(in flow)</h4><p>什么是普通流？W3C 只对 out of flow 作了定义：</p>
<blockquote>
<p>An element is called out of flow if it is floated, absolutely positioned, or is the root element.An element is called in-flow if it is not out-of-flow.</p>
</blockquote>
<p>从定义中我们可以知道只要不是 float、absolutely positioned 和 root element 时就是 in flow。</p>
<h4 id="什么时候会发生外边距叠加"><a href="#什么时候会发生外边距叠加" class="headerlink" title="什么时候会发生外边距叠加"></a>什么时候会发生外边距叠加</h4><p>外边距叠加存在两种情况：一是父子外边距叠加；二是兄弟外边距叠加。</p>
<p>W3C 对于什么是毗邻的外边距也有定义：</p>
<blockquote>
<p>Two margins are adjoining if and only if: - both belong to in-flow block-level boxes that participate in the same block formatting context - no line boxes, no clearance, no padding and no border separate them - both belong to vertically-adjacent box edges, i.e. form one of the following pairs:</p>
<ul>
<li>top margin of a box and top margin of its first in-flow child</li>
<li>bottom margin of box and top margin of its next in-flow following sibling</li>
<li>bottom margin of a last in-flow child and bottom margin of its parent if the &gt; parent has “auto” computed height</li>
<li>top and bottom margins of a box that does not establish a new block formatting context and that has zero computed “min-height”, zero or “auto” computed “height”, and no in-flow children</li>
</ul>
</blockquote>
<p>从定义中我们可以很清楚的知道要符合哪些情况才会发生外边距折叠：</p>
<ul>
<li>都属于普通流的块级盒子且参与到相同的块级格式上下文中</li>
<li>没有被padding、border、clear和line box分隔开</li>
<li>都属于垂直毗邻盒子边缘：<ul>
<li>盒子的top margin和它第一个普通流子元素的top margin</li>
<li>盒子的bottom margin和它下一个普通流兄弟的top margin</li>
<li>盒子的bottom margin和它父元素的bottom margin</li>
<li>盒子的top margin和bottom margin，且没有创建一个新的块级格式上下文，且有被计算为0的min-height，被计算为0或auto的height，且没有普通流子元素</li>
</ul>
</li>
</ul>
<h4 id="如何避免外边距叠加"><a href="#如何避免外边距叠加" class="headerlink" title="如何避免外边距叠加"></a>如何避免外边距叠加</h4><p>上面讲了外边距的叠加，那如何避免呢，其实只要破坏上面讲到的四个条件中的任何一个即可：毗邻、两个或多个、普通流和垂直方向。</p>
<p>W3C也对此做了总结：</p>
<blockquote>
<ul>
<li>Margins between a floated box and any other box do not collapse (not even between a float and its in-flow children).</li>
<li>Margins of elements that establish new block formatting contexts (such as floats and elements with “overflow” other than “visible”) do not collapse with their in-flow children.</li>
<li>Margins of absolutely positioned boxes do not collapse (not even with their in-flow children).</li>
<li>Margins of inline-block boxes do not collapse (not even with their in-flow children).</li>
<li>The bottom margin of an in-flow block-level element always collapses with the top margin of its next in-flow block-level sibling, unless that sibling has clearance.</li>
<li>The top margin of an in-flow block element collapses with its first in-flow block-level child”s top margin if the element has no top border, no top padding, and the child has no clearance.</li>
<li>The bottom margin of an in-flow block box with a “height” of “auto” and a “min-height” of zero collapses with its last in-flow block-level child”s bottom margin if the box has no bottom padding and no bottom border and the child”s bottom margin does not collapse with a top margin that has clearance.</li>
<li>A box”s own margins collapse if the “min-height” property is zero, and it has neither top or bottom borders nor top or bottom padding, and it has a “height” of either 0 or “auto”, and it does not contain a line box, and all of its in-flow children”s margins (if any) collapse.</li>
</ul>
</blockquote>
<ul>
<li>浮动元素不会与任何元素发生叠加，也包括它的子元素</li>
<li>创建了 BFC 的元素不会和它的子元素发生外边距叠加</li>
<li>绝对定位元素和其他任何元素之间不发生外边距叠加，也包括它的子元素</li>
<li>inline-block 元素和其他任何元素之间不发生外边距叠加，也包括它的子元素</li>
<li>普通流中的块级元素的 margin-bottom 永远和它相邻的下一个块级元素的 margin-top 叠加，除非相邻的兄弟元素 clear</li>
<li>普通流中的块级元素（没有 border-top、没有 padding-top）的 margin-top 和它的第一个普通流中的子元素（没有clear）发生 margin-top 叠加</li>
<li>普通流中的块级元素（height为 auto、min-height为0、没有 border-bottom、没有 padding-bottom）和它的最后一个普通流中的子元素（没有自身发生margin叠加或clear）发生 margin-bottom叠加</li>
<li>如果一个元素的 min-height 为0、没有 border、没有padding、高度为0或者auto、不包含子元素，那么它自身的外边距会发生叠加</li>
</ul>
<p>以上就是外边距叠加的主要内容。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array --6.Min Cost Climbing Stairs]]></title>
      <url>/2018/01/25/leetCode/6.Min_Cost_Climbing_Stairs/</url>
      <content type="html"><![CDATA[<h2 id="Problem-six-Min-Cost-Climbing-Stairs"><a href="#Problem-six-Min-Cost-Climbing-Stairs" class="headerlink" title="Problem six: Min Cost Climbing Stairs"></a>Problem six: Min Cost Climbing Stairs</h2><p>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).</p>
<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> cost = [10, 15, 20]<br>  <strong>Output:</strong> 15<br>  <strong>Explanation:</strong> Cheapest is start on cost[1], pay that cost and go to the top.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>  <strong>Output:</strong> 6<br>  <strong>Explanation:</strong> Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>cost will have a length in the range [2, 1000].</li>
<li>Every cost[i] will be an integer in the range [0, 999].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.第一眼看这道题，显然是一道递归题，照着这个思路做很容易就做出来了。</p>
<pre><code>var minCostClimbingStairs = function(cost) {
    for(var i=2;i&lt;=cost.length-1;i++){
        cost[i]=cost[i]+Math.min(cost[i-1],cost[i-2]);
    }

    return Math.min(cost[cost.length-1],cost[cost.length-2]);

};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<ol>
<li>同理，也有一种类似的解法，三个元素三个元素的比较，最后一个元素的最小值就是前两个元素的最小值加上对应的值。<pre><code>var minCostClimbingStairs = function(cost) {
 var firstElement = 0, secondElement = 0, thirdElement = 0;
  for(var i=2;i &lt;= cost.length;i++){
      thirdElement = Math.min(secondElement + cost[i-1], firstElement + cost[i-2]);
      firstElement = secondElement;
      secondElement = thirdElement;
  }
  return thirdElement;
};
</code></pre>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</li>
</ol>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 5.Largest Number At Least Twice of Others]]></title>
      <url>/2018/01/25/leetCode/5.Largest_Number_At_Least_Twice_of_Others/</url>
      <content type="html"><![CDATA[<h2 id="Problem-five-Largest-Number-At-Least-Twice-of-Others"><a href="#Problem-five-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="Problem five: Largest Number At Least Twice of Others"></a>Problem five: Largest Number At Least Twice of Others</h2><p>In a given integer array nums, there is always exactly one largest element.</p>
<p>Find whether the largest element in the array is at least twice as much as every other number in the array.</p>
<p>If it is, return the index of the largest element, otherwise return -1.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [3, 6, 1, 0]<br>  <strong>Output:</strong> 1<br>  <strong>Explanation:</strong> 6 is the largest integer, and for every other number in the array x,<br>    6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [1, 2, 3, 4]<br>  <strong>Output:</strong> -1<br>  <strong>Explanation:</strong> 4 isn’t at least as big as twice the value of 3, so we return -1.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>nums will have a length in the range [1, 50].</li>
<li>Every nums[i] will be an integer in the range [0, 99].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.最开始想到的是用sort()函数来解决这个问题，但是需要注意两点：在sort函数中添加判断数字大小的函数，否则会将数字视为字符串，用最开始的数字进行排序；再一个就是在复制数组时，不能直接使用‘=’进行复制操作，因为这样其实传递的是数组地址，如果这样赋值，在对原先数组进行操作时，其实会对新建的数组进行修改。</p>
<pre><code>function sequence(a,b){
         if (a&gt;b) {
             return 1;
         }else if(a&lt;b){
              return -1
         }else{
             return 0;
        }
};
var dominantIndex = function(nums) {
    var nums_copy;
    nums_copy = [];
    for(var m = 0; m &lt; nums.length; m++) {
        nums_copy[m] = nums[m];
    }
    nums.sort(sequence);
    if(nums.length == 1)
        return 0;
    if(nums[nums.length - 2] &gt; 0) {
        if(nums[nums.length - 1]/nums[nums.length - 2] &gt;= 2) {
            for(var i = 0; i &lt; nums_copy.length; i++) {
                if(nums_copy[i] == nums[nums.length -1])
                    return i;
            }
        } else
            return -1;
    } else {
        for(var n = 0; n &lt; nums_copy.length; n++) {
            if(nums_copy[n] == nums[nums.length -1])
                return n;
        }
    }
};
</code></pre><p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度；</p>
<p>2.一开始以为上述方法比较简单，但实际写下来还有需要细节要注意，因此，先选出数组中的最大值，在与数组中的所有元素进行对比，当有元素大于nums[maxIndex]的1/2时，返回-1，否则返回该最大值下标。</p>
<pre><code>var dominantIndex = function(nums) {
    var maxIndex = 0;
        for (var i = 0; i &lt; nums.length; ++i) {
            if (nums[i] &gt; nums[maxIndex])
                maxIndex = i;
        }
        for (var i = 0; i &lt; nums.length; ++i) {
            if (maxIndex != i &amp;&amp; nums[maxIndex] &lt; 2 * nums[i])
                return -1;
        }
        return maxIndex;
};
</code></pre><p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度;</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 4.longest continuous increasing subsequence]]></title>
      <url>/2018/01/25/leetCode/4.longest_continuous_increasing_subsequence/</url>
      <content type="html"><![CDATA[<h2 id="Problem-four-longest-continuous-increasing-subsequence"><a href="#Problem-four-longest-continuous-increasing-subsequence" class="headerlink" title="Problem four: longest continuous increasing subsequence"></a>Problem four: longest continuous increasing subsequence</h2><p>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,3,5,4,7]<br>  <strong>Output:</strong> 3<br>  <strong>Explanation:</strong> The longest continuous increasing subsequence is [1,3,5], its length is 3.<br>  Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4. </p>
</blockquote>
<p>  <strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [2,2,2,2,2]<br>  <strong>Output:</strong> 1<br>  <strong>Explanation:</strong> The longest continuous increasing subsequence is [2], its length is 1.</p>
</blockquote>
<p><strong>Note:</strong> Length of the array will not exceed 10,000.</p>
<p><strong>solution:</strong></p>
<p>1.直观的想法是遍历数组时，当数字持续增加时用一个数字存储累加的总和，在减少时与另一个初始为0的数字对比，如果大于这个存放之前的最长长度的数字，则替换该值，并重置计数的大小。最后，比较最后一次累加数值的大小，返回最大值。</p>
<pre><code>var findLengthOfLCIS = function(nums) {
    var num = 1;
    var maxLength = 0;
    if(nums.length == 0)
        return 0;
    for(var i = 1; i &lt; nums.length;  i++) {
        if(nums[i] &gt; nums[i-1]) {
            num++;
        } else {
            if(num &gt; maxLength) {
                maxLength = num;
            }
            num = 1;
        }
    }
    if(num &gt; maxLength) 
        return num;
    else
        return maxLength;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.因为累加的子串是在nums[i-1] &gt;= nums[i]时发生变化的，也就是说我们将变化的元素下标记录下来，当前一个元素大于后一个元素时，将当前元素下标赋值给anchor，在累加的过程中，ans会用之前的最长串与现在的累加的串的长度作对比，保留最长串。</p>
<pre><code>var findLengthOfLCIS = function(nums) {
    var ans = 0;
    var anchor = 0;
        for (var i = 0; i &lt; nums.length; ++i) {
            if (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i])
                anchor = i;
            ans = Math.max(ans, i - anchor + 1);
        }
        return ans;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Array -- 3.Best Time to Buy and Sell Stock]]></title>
      <url>/2018/01/23/leetCode/3.Best_Time_to_Buy_and_sell_stock/</url>
      <content type="html"><![CDATA[<h2 id="Problem-three-Best-Time-to-Buy-and-Sell-Stock"><a href="#Problem-three-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Problem three: Best Time to Buy and Sell Stock"></a>Problem three: Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [7, 1, 5, 3, 6, 4]<br><strong>Output:</strong> 5<br>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [7, 6, 4, 3, 1]<br><strong>Output:</strong> 0<br>In this case, no transaction is done, i.e. max profit = 0.</p>
</blockquote>
<p><strong>solution:</strong></p>
<p>1.这道题主要考察的是边界条件的判断，首先，将第二个元素与第一个元素进行对比，如果第二个元素大，则设置maxProfit，minPrice和maxPrice，如果第一个元素大，设置maxPrice，minPrice。若不为前两个元素，需要考虑下一个元素与之前最小的元素比较是否会大于之前的maxProfit，若大于，则设置maxProfit和maxPrice，否则设置minPrice。以此类推，最后返回maxProfit。</p>
<pre><code>var maxProfit = function(prices) {
    var maxProfit = 0;
    var maxPrice = 0;
    var minPrice = 0;
    for(var i = 1; i &lt; prices.length; i++) {
        if(i == 1) {
            if((prices[i] - prices[i-1]) &gt; maxProfit) {
                maxProfit = prices[i] - prices[i-1];
                minPrice = prices[i - 1];
                maxPrice = prices[i];
            } 
            else {
                minPrice = prices[i];
                maxPrice = prices[i-1];
            }
        }else {
            if((prices[i] - minPrice) &gt; maxProfit) {
                maxProfit = prices[i] - minPrice;
                maxPrice = prices[i];
            }
            else{
                if(minPrice &gt; prices[i]) {
                    minPrice = prices[i];  
                }
            }
        }
    }
    return maxProfit;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.接下来换一种思想比较简单的方法，现在需要找到最大的差值，且大的数在后面，小的数在前面，所以，可以两层嵌套，比较元素后面的值并选出最大的值。</p>
<pre><code>var maxProfit = function(prices) {
     var maxprofit = 0;
        for (var i = 0; i &lt; prices.length - 1; i++) {
            for (var j = i + 1; j &lt; prices.length; j++) {
                var profit = prices[j] - prices[i];
                if (profit &gt; maxprofit)
                    maxprofit = profit;
            }
        }
        return maxprofit;
  };
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), 循环n(n-1)/2遍，效果很差。</p>
<p>3.接下来的方法和第一种类似，先去一个特别大的最小值和特别大的最大值，然后进行遍历，若当前元素小于最小值，则替换最小值，否则就与最小值比较，若大于最大差值，则替换最大差值。这个方法与第一种比不需要保存最大值。</p>
<pre><code>var maxProfit = function(prices) {
     var minprice = 9999999;
     var maxprofit = 0;
        for (var i = 0; i &lt; prices.length; i++) {
            if (prices[i] &lt; minprice)
                minprice = prices[i];
            else if (prices[i] - minprice &gt; maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
  };
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Array -- 2.Remove Element]]></title>
      <url>/2018/01/23/leetCode/2.remove_element/</url>
      <content type="html"><![CDATA[<h2 id="Problem-two-Remove-Element"><a href="#Problem-two-Remove-Element" class="headerlink" title="Problem two: Remove Element"></a>Problem two: Remove Element</h2><p>Given an array and a value, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example:</strong></p>
<blockquote>
<p>Given <strong>nums</strong> = [3,2,2,3], val = 3,</p>
</blockquote>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p><strong>solution:</strong></p>
<p>1.最直接的方法是使用数组自带的splice方法，需要注意的是当remove掉相符合的元素后，要将下标减一，不然会造成数组减少一个元素后，原元素后面的元素序号会提前一个，会忽略掉下一个元素。</p>
<pre><code>var removeElement = function(nums, val) {
    for(var i = 0; i&lt; nums.length; i++) {
        if(nums[i] == val) {
            nums.splice(i, 1);
            i -= 1;
        } 
    } 
    return nums.length;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.另一种方法是在遍历数组过程中，如果元素的值等于对应的value，则将当前元素与最后一个元素交换位置，然后将数组长度减1，变相的去除数组的重复项，可惜的是，这种方法和splice()消耗的时间几近相同。</p>
<pre><code>var removeElement = function(nums, val) {
    var i = 0;
    var num = nums.length;
    while (i &lt; num) {
        if (nums[i] == val) {
            nums[i] = nums[num - 1];
            num--;
        } else {
            i++;
        }
    }
    return num;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 1.Find Pivot Index]]></title>
      <url>/2018/01/23/leetCode/1.find_pivot_index/</url>
      <content type="html"><![CDATA[<h2 id="Problem-one-Find-Pivot-Index"><a href="#Problem-one-Find-Pivot-Index" class="headerlink" title="Problem one: Find Pivot Index"></a>Problem one: Find Pivot Index</h2><p>Given an array of integers nums, write a method that returns the “pivot” index of this array.</p>
<p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p>
<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br><strong>nums</strong> = [1, 7, 3, 6, 5, 6]<br><strong>Output</strong>: 3<br><strong>Explanation</strong>:<br>The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.<br>Also, 3 is the first index where this occurs.</p>
</blockquote>
<p><strong>Example</strong> 2:</p>
<blockquote>
<p><strong>Input:</strong><br><strong>nums</strong> = [1, 2, 3]<br><strong>Output</strong>: -1<br><strong>Explanation</strong>:<br>There is no index that satisfies the conditions in the problem statement.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The length of nums will be in the range [0, 10000].</li>
<li>Each element nums[i] will be an integer in the range [-1000, 1000].</li>
</ul>
<p><strong>solution:</strong></p>
<ol>
<li><p>直接想到的是遍历数组，将每个元素左侧的元素和与右侧元素和比较，相同则返回对应元素下标。（若第一个元素右侧和为0，则返回第一个元素下标）。否则返回-1；</p>
<pre><code>var pivotIndex = function(nums) {
 var leftSum = 0;
 var rightSum = 0;
 for(var i = 0; i &lt; nums.length; i++) {
     if(i == 0) {
         leftSum =0;
     }else{
         leftSum += nums[i-1];
     }
     for(var n = i+1; n &lt; nums.length; n++) {
         rightSum += nums[n];    
     }
     if(leftSum == rightSum) 
         return i;
     rightSum = 0;
 }
 return -1;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为nums的长度；</p>
</li>
<li><p>上一种方法的问题在于要用两遍for循环，时间复杂度过高，所以尽量减少嵌套：</p>
<pre><code class="javascript">var pivotIndex = function(nums) {
 var leftSum =0;
 var sum = 0;
 for(var i = 0; i&lt; nums.length; i++) 
     sum += nums[i];
  for (var n = 0; n &lt; nums.length; n++) {
     if (leftSum == (sum - leftSum - nums[n])) 
         return n;
     leftSum += nums[n];
 }
 return -1;
}
</code></pre>
<p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度；</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建github博客]]></title>
      <url>/2018/01/12/blog/%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="搭建github博客-amp-使用hexo博客框架-amp-使用material主题"><a href="#搭建github博客-amp-使用hexo博客框架-amp-使用material主题" class="headerlink" title="搭建github博客&amp;使用hexo博客框架&amp;使用material主题"></a>搭建github博客&amp;使用hexo博客框架&amp;使用material主题</h2><p>因为原先在CSDN上有各种各样的限制和难言之隐，所以在生庆哥的帮助和怂恿下，选择使用github搭建博客并个性化设置，主要说一下大体过程和期间的问题。主要的内容可以分为以下三类：</p>
<ul>
<li>搭建github博客</li>
<li>使用hexo框架</li>
<li>使用material主题</li>
</ul>
<h3 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h3><p>其实之前在学校的时候一直知道github看可以搭建博客，还可以直接使用对应的域名，但是出于各种原因一直没有自己搭建一个博客尝试尝试，终于，现在正好有时间和精力可以试试。<br>在个人github首页上，创建一个github.io的框架，即个人账户+仓库名，如：lpldplws.github.io。因为此仓库就是用来放博客的，所以在master分支上开发，然后在setting页面中选择launch automatic page generator生成博客项目。然后将该项目clone到本地，最初的博客就搭建成了~</p>
<p>个人博客地址是<a href="https://github.com/lpldplws/lpldplws.github.io" target="_blank" rel="noopener">lpldplws.github.io</a>。<br>接下来要做的就是redirect到自己的域名，在阿里上买了一个29一年的域名，名字是<a href="http://www.lpldplws.cn">lpldplws.cn</a>,需要做的是在clone下的项目的根目录下建立好映射，创建一个”CNAME”（没有后缀名）的文件，之后访问lpldplws.github.io就会redirect到此域名，或者您在对应的域名服务商上面修改CNAME到对应的github仓库地址也是可以的。<br>注意：此处因为是直接在master分支上创建的，之后也是在master分支上使用的框架和主题，导致最后hexo generate的内容保存到了github.io中，这部分是接下来一周需要解决的问题之一。</p>
<h3 id="使用hexo框架"><a href="#使用hexo框架" class="headerlink" title="使用hexo框架"></a>使用hexo框架</h3><p>之所以知道这个框架是因为咱们的FE团队的翻译框架就是这个，所以此处借鉴了以下，嘿嘿。<br>在<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>上,介绍了这是一个简单高效的博客框架，在github.io仓库中，使用npm安装即可。虽然可以支持markdown的格式，但是其自带的tag也是非常方便的，我看还可以使用youtube视频，厉害了，这理所当然的成为下周需要学习的内容之一了。<br>还有一个比较深的体会是使用hexo的感觉就像开发机一样，通过hexo server相当于在开发机上查看效果，使用hexo generate和hexo deploy相当于部署在线上环境，就是少了review的部分，不过对于一个个人博客来说还是比较完善的了。</p>
<h3 id="使用material主题"><a href="#使用material主题" class="headerlink" title="使用material主题"></a>使用material主题</h3><p>使用hexo默认界面当然不能满足自己的审美了，在一番选择（选择恐惧症）后，终于选(sui)择(ji)了一个比较好看的theme，这就是<a href="https://material.viosey.com/" target="_blank" rel="noopener">material</a>，这个主题比较素雅，正好很吸引我~以下主要说明material主题配置中遇到的问题。其中主要的配置文件在<code>config.template.yaml</code>中，不过需要先将其改名为<code>config.yaml</code>。在页面配置中，按照流程可以选择对应的插件和效果，比较吸引人的是它的背景可以从必应上选择，后来因为颜色不匹配主题就去掉了，个人打算通过对选项加一个filter或者下到对应文件随机加载是个不错的选择，所以下周又新加了一项任务。还有一点就是评论系统和统计系统，个人选择的是<code>Valine</code>，因为考虑到可以使用对应后台查看信息，不过缺点就是有点丑。。。后来生庆哥说Google的后台数据处理用的人很多，所以打算抛弃当前评论系统，投入其他评论系统的怀抱。<br>对于独立页面部分还没有怎么看，下周来吧，除此之外，除了在mobile上效果还行，pc上两端有点空，所以想加一个音乐播放器，这部分打算选择网易云的api，实现一个音乐播放的效果。其他的内容就慢慢补全吧，这周过的虽然很累但还是很充实，个人也应该静下心来，虽然很多不会，但是相信通过付出比别人更多的努力，一定快速达到可以帮助到胡老师和FE团队的地步，fighting！</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
  
</search>
