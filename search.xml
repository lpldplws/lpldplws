<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[leetCode Array --6.Min Cost Climbing Stairs]]></title>
      <url>/2018/01/25/leetCode/6.Min_Cost_Climbing_Stairs/</url>
      <content type="html"><![CDATA[<h2 id="Problem-six-Min-Cost-Climbing-Stairs"><a href="#Problem-six-Min-Cost-Climbing-Stairs" class="headerlink" title="Problem six: Min Cost Climbing Stairs"></a>Problem six: Min Cost Climbing Stairs</h2><p>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).</p>
<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> cost = [10, 15, 20]<br>  <strong>Output:</strong> 15<br>  <strong>Explanation:</strong> Cheapest is start on cost[1], pay that cost and go to the top.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>  <strong>Output:</strong> 6<br>  <strong>Explanation:</strong> Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>cost will have a length in the range [2, 1000].</li>
<li>Every cost[i] will be an integer in the range [0, 999].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.第一眼看这道题，显然是一道递归题，照着这个思路做很容易就做出来了。</p>
<pre><code>var minCostClimbingStairs = function(cost) {
    for(var i=2;i&lt;=cost.length-1;i++){
        cost[i]=cost[i]+Math.min(cost[i-1],cost[i-2]);
    }

    return Math.min(cost[cost.length-1],cost[cost.length-2]);

};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<ol>
<li>同理，也有一种类似的解法，三个元素三个元素的比较，最后一个元素的最小值就是前两个元素的最小值加上对应的值。<pre><code>var minCostClimbingStairs = function(cost) {
 var firstElement = 0, secondElement = 0, thirdElement = 0;
  for(var i=2;i &lt;= cost.length;i++){
      thirdElement = Math.min(secondElement + cost[i-1], firstElement + cost[i-2]);
      firstElement = secondElement;
      secondElement = thirdElement;
  }
  return thirdElement;
};
</code></pre>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</li>
</ol>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 5.Largest Number At Least Twice of Others]]></title>
      <url>/2018/01/25/leetCode/5.Largest_Number_At_Least_Twice_of_Others/</url>
      <content type="html"><![CDATA[<h2 id="Problem-five-Largest-Number-At-Least-Twice-of-Others"><a href="#Problem-five-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="Problem five: Largest Number At Least Twice of Others"></a>Problem five: Largest Number At Least Twice of Others</h2><p>In a given integer array nums, there is always exactly one largest element.</p>
<p>Find whether the largest element in the array is at least twice as much as every other number in the array.</p>
<p>If it is, return the index of the largest element, otherwise return -1.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [3, 6, 1, 0]<br>  <strong>Output:</strong> 1<br>  <strong>Explanation:</strong> 6 is the largest integer, and for every other number in the array x,<br>    6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [1, 2, 3, 4]<br>  <strong>Output:</strong> -1<br>  <strong>Explanation:</strong> 4 isn’t at least as big as twice the value of 3, so we return -1.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>nums will have a length in the range [1, 50].</li>
<li>Every nums[i] will be an integer in the range [0, 99].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.最开始想到的是用sort()函数来解决这个问题，但是需要注意两点：在sort函数中添加判断数字大小的函数，否则会将数字视为字符串，用最开始的数字进行排序；再一个就是在复制数组时，不能直接使用‘=’进行复制操作，因为这样其实传递的是数组地址，如果这样赋值，在对原先数组进行操作时，其实会对新建的数组进行修改。</p>
<pre><code>function sequence(a,b){
         if (a&gt;b) {
             return 1;
         }else if(a&lt;b){
              return -1
         }else{
             return 0;
        }
};
var dominantIndex = function(nums) {
    var nums_copy;
    nums_copy = [];
    for(var m = 0; m &lt; nums.length; m++) {
        nums_copy[m] = nums[m];
    }
    nums.sort(sequence);
    if(nums.length == 1)
        return 0;
    if(nums[nums.length - 2] &gt; 0) {
        if(nums[nums.length - 1]/nums[nums.length - 2] &gt;= 2) {
            for(var i = 0; i &lt; nums_copy.length; i++) {
                if(nums_copy[i] == nums[nums.length -1])
                    return i;
            }
        } else
            return -1;
    } else {
        for(var n = 0; n &lt; nums_copy.length; n++) {
            if(nums_copy[n] == nums[nums.length -1])
                return n;
        }
    }
};
</code></pre><p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度；</p>
<p>2.一开始以为上述方法比较简单，但实际写下来还有需要细节要注意，因此，先选出数组中的最大值，在与数组中的所有元素进行对比，当有元素大于nums[maxIndex]的1/2时，返回-1，否则返回该最大值下标。</p>
<pre><code>var dominantIndex = function(nums) {
    var maxIndex = 0;
        for (var i = 0; i &lt; nums.length; ++i) {
            if (nums[i] &gt; nums[maxIndex])
                maxIndex = i;
        }
        for (var i = 0; i &lt; nums.length; ++i) {
            if (maxIndex != i &amp;&amp; nums[maxIndex] &lt; 2 * nums[i])
                return -1;
        }
        return maxIndex;
};
</code></pre><p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度;</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 4.longest continuous increasing subsequence]]></title>
      <url>/2018/01/25/leetCode/4.longest_continuous_increasing_subsequence/</url>
      <content type="html"><![CDATA[<h2 id="Problem-four-longest-continuous-increasing-subsequence"><a href="#Problem-four-longest-continuous-increasing-subsequence" class="headerlink" title="Problem four: longest continuous increasing subsequence"></a>Problem four: longest continuous increasing subsequence</h2><p>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,3,5,4,7]<br>  <strong>Output:</strong> 3<br>  <strong>Explanation:</strong> The longest continuous increasing subsequence is [1,3,5], its length is 3.<br>  Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4. </p>
</blockquote>
<p>  <strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [2,2,2,2,2]<br>  <strong>Output:</strong> 1<br>  <strong>Explanation:</strong> The longest continuous increasing subsequence is [2], its length is 1.</p>
</blockquote>
<p><strong>Note:</strong> Length of the array will not exceed 10,000.</p>
<p><strong>solution:</strong></p>
<p>1.直观的想法是遍历数组时，当数字持续增加时用一个数字存储累加的总和，在减少时与另一个初始为0的数字对比，如果大于这个存放之前的最长长度的数字，则替换该值，并重置计数的大小。最后，比较最后一次累加数值的大小，返回最大值。</p>
<pre><code>var findLengthOfLCIS = function(nums) {
    var num = 1;
    var maxLength = 0;
    if(nums.length == 0)
        return 0;
    for(var i = 1; i &lt; nums.length;  i++) {
        if(nums[i] &gt; nums[i-1]) {
            num++;
        } else {
            if(num &gt; maxLength) {
                maxLength = num;
            }
            num = 1;
        }
    }
    if(num &gt; maxLength) 
        return num;
    else
        return maxLength;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.因为累加的子串是在nums[i-1] &gt;= nums[i]时发生变化的，也就是说我们将变化的元素下标记录下来，当前一个元素大于后一个元素时，将当前元素下标赋值给anchor，在累加的过程中，ans会用之前的最长串与现在的累加的串的长度作对比，保留最长串。</p>
<pre><code>var findLengthOfLCIS = function(nums) {
    var ans = 0;
    var anchor = 0;
        for (var i = 0; i &lt; nums.length; ++i) {
            if (i &gt; 0 &amp;&amp; nums[i-1] &gt;= nums[i])
                anchor = i;
            ans = Math.max(ans, i - anchor + 1);
        }
        return ans;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Array -- 3.Best Time to Buy and Sell Stock]]></title>
      <url>/2018/01/23/leetCode/3.Best_Time_to_Buy_and_sell_stock/</url>
      <content type="html"><![CDATA[<h2 id="Problem-three-Best-Time-to-Buy-and-Sell-Stock"><a href="#Problem-three-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Problem three: Best Time to Buy and Sell Stock"></a>Problem three: Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [7, 1, 5, 3, 6, 4]<br><strong>Output:</strong> 5<br>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [7, 6, 4, 3, 1]<br><strong>Output:</strong> 0<br>In this case, no transaction is done, i.e. max profit = 0.</p>
</blockquote>
<p><strong>solution:</strong></p>
<p>1.这道题主要考察的是边界条件的判断，首先，将第二个元素与第一个元素进行对比，如果第二个元素大，则设置maxProfit，minPrice和maxPrice，如果第一个元素大，设置maxPrice，minPrice。若不为前两个元素，需要考虑下一个元素与之前最小的元素比较是否会大于之前的maxProfit，若大于，则设置maxProfit和maxPrice，否则设置minPrice。以此类推，最后返回maxProfit。</p>
<pre><code>var maxProfit = function(prices) {
    var maxProfit = 0;
    var maxPrice = 0;
    var minPrice = 0;
    for(var i = 1; i &lt; prices.length; i++) {
        if(i == 1) {
            if((prices[i] - prices[i-1]) &gt; maxProfit) {
                maxProfit = prices[i] - prices[i-1];
                minPrice = prices[i - 1];
                maxPrice = prices[i];
            } 
            else {
                minPrice = prices[i];
                maxPrice = prices[i-1];
            }
        }else {
            if((prices[i] - minPrice) &gt; maxProfit) {
                maxProfit = prices[i] - minPrice;
                maxPrice = prices[i];
            }
            else{
                if(minPrice &gt; prices[i]) {
                    minPrice = prices[i];  
                }
            }
        }
    }
    return maxProfit;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.接下来换一种思想比较简单的方法，现在需要找到最大的差值，且大的数在后面，小的数在前面，所以，可以两层嵌套，比较元素后面的值并选出最大的值。</p>
<pre><code>var maxProfit = function(prices) {
     var maxprofit = 0;
        for (var i = 0; i &lt; prices.length - 1; i++) {
            for (var j = i + 1; j &lt; prices.length; j++) {
                var profit = prices[j] - prices[i];
                if (profit &gt; maxprofit)
                    maxprofit = profit;
            }
        }
        return maxprofit;
  };
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), 循环n(n-1)/2遍，效果很差。</p>
<p>3.接下来的方法和第一种类似，先去一个特别大的最小值和特别大的最大值，然后进行遍历，若当前元素小于最小值，则替换最小值，否则就与最小值比较，若大于最大差值，则替换最大差值。这个方法与第一种比不需要保存最大值。</p>
<pre><code>var maxProfit = function(prices) {
     var minprice = 9999999;
     var maxprofit = 0;
        for (var i = 0; i &lt; prices.length; i++) {
            if (prices[i] &lt; minprice)
                minprice = prices[i];
            else if (prices[i] - minprice &gt; maxprofit)
                maxprofit = prices[i] - minprice;
        }
        return maxprofit;
  };
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Array -- 2.Remove Element]]></title>
      <url>/2018/01/23/leetCode/2.remove_element/</url>
      <content type="html"><![CDATA[<h2 id="Problem-two-Remove-Element"><a href="#Problem-two-Remove-Element" class="headerlink" title="Problem two: Remove Element"></a>Problem two: Remove Element</h2><p>Given an array and a value, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example:</strong></p>
<blockquote>
<p>Given <strong>nums</strong> = [3,2,2,3], val = 3,</p>
</blockquote>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p><strong>solution:</strong></p>
<p>1.最直接的方法是使用数组自带的splice方法，需要注意的是当remove掉相符合的元素后，要将下标减一，不然会造成数组减少一个元素后，原元素后面的元素序号会提前一个，会忽略掉下一个元素。</p>
<pre><code>var removeElement = function(nums, val) {
    for(var i = 0; i&lt; nums.length; i++) {
        if(nums[i] == val) {
            nums.splice(i, 1);
            i -= 1;
        } 
    } 
    return nums.length;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.另一种方法是在遍历数组过程中，如果元素的值等于对应的value，则将当前元素与最后一个元素交换位置，然后将数组长度减1，变相的去除数组的重复项，可惜的是，这种方法和splice()消耗的时间几近相同。</p>
<pre><code>var removeElement = function(nums, val) {
    var i = 0;
    var num = nums.length;
    while (i &lt; num) {
        if (nums[i] == val) {
            nums[i] = nums[num - 1];
            num--;
        } else {
            i++;
        }
    }
    return num;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 1.Find Pivot Index]]></title>
      <url>/2018/01/23/leetCode/1.find_pivot_index/</url>
      <content type="html"><![CDATA[<h2 id="Problem-one-Find-Pivot-Index"><a href="#Problem-one-Find-Pivot-Index" class="headerlink" title="Problem one: Find Pivot Index"></a>Problem one: Find Pivot Index</h2><p>Given an array of integers nums, write a method that returns the “pivot” index of this array.</p>
<p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p>
<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br><strong>nums</strong> = [1, 7, 3, 6, 5, 6]<br><strong>Output</strong>: 3<br><strong>Explanation</strong>:<br>The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.<br>Also, 3 is the first index where this occurs.</p>
</blockquote>
<p><strong>Example</strong> 2:</p>
<blockquote>
<p><strong>Input:</strong><br><strong>nums</strong> = [1, 2, 3]<br><strong>Output</strong>: -1<br><strong>Explanation</strong>:<br>There is no index that satisfies the conditions in the problem statement.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The length of nums will be in the range [0, 10000].</li>
<li>Each element nums[i] will be an integer in the range [-1000, 1000].</li>
</ul>
<p><strong>solution:</strong></p>
<ol>
<li><p>直接想到的是遍历数组，将每个元素左侧的元素和与右侧元素和比较，相同则返回对应元素下标。（若第一个元素右侧和为0，则返回第一个元素下标）。否则返回-1；</p>
<pre><code>var pivotIndex = function(nums) {
 var leftSum = 0;
 var rightSum = 0;
 for(var i = 0; i &lt; nums.length; i++) {
     if(i == 0) {
         leftSum =0;
     }else{
         leftSum += nums[i-1];
     }
     for(var n = i+1; n &lt; nums.length; n++) {
         rightSum += nums[n];    
     }
     if(leftSum == rightSum) 
         return i;
     rightSum = 0;
 }
 return -1;
};
</code></pre><p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为nums的长度；</p>
</li>
<li><p>上一种方法的问题在于要用两遍for循环，时间复杂度过高，所以尽量减少嵌套：</p>
<pre><code class="javascript">var pivotIndex = function(nums) {
 var leftSum =0;
 var sum = 0;
 for(var i = 0; i&lt; nums.length; i++) 
     sum += nums[i];
  for (var n = 0; n &lt; nums.length; n++) {
     if (leftSum == (sum - leftSum - nums[n])) 
         return n;
     leftSum += nums[n];
 }
 return -1;
}
</code></pre>
<p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度；</p>
</li>
</ol>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode array </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建github博客]]></title>
      <url>/2018/01/12/%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="搭建github博客-amp-使用hexo博客框架-amp-使用material主题"><a href="#搭建github博客-amp-使用hexo博客框架-amp-使用material主题" class="headerlink" title="搭建github博客&amp;使用hexo博客框架&amp;使用material主题"></a>搭建github博客&amp;使用hexo博客框架&amp;使用material主题</h2><p>因为原先在CSDN上有各种各样的限制和难言之隐，所以在生庆哥的帮助和怂恿下，选择使用github搭建博客并个性化设置，主要说一下大体过程和期间的问题。主要的内容可以分为以下三类：</p>
<ul>
<li>搭建github博客</li>
<li>使用hexo框架</li>
<li>使用material主题</li>
</ul>
<h3 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h3><p>其实之前在学校的时候一直知道github看可以搭建博客，还可以直接使用对应的域名，但是出于各种原因一直没有自己搭建一个博客尝试尝试，终于，现在正好有时间和精力可以试试。<br>在个人github首页上，创建一个github.io的框架，即个人账户+仓库名，如：lpldplws.github.io。因为此仓库就是用来放博客的，所以在master分支上开发，然后在setting页面中选择launch automatic page generator生成博客项目。然后将该项目clone到本地，最初的博客就搭建成了~</p>
<p>个人博客地址是<a href="https://github.com/lpldplws/lpldplws.github.io" target="_blank" rel="noopener">lpldplws.github.io</a>。<br>接下来要做的就是redirect到自己的域名，在阿里上买了一个29一年的域名，名字是<a href="http://www.lpldplws.cn">lpldplws.cn</a>,需要做的是在clone下的项目的根目录下建立好映射，创建一个”CNAME”（没有后缀名）的文件，之后访问lpldplws.github.io就会redirect到此域名，或者您在对应的域名服务商上面修改CNAME到对应的github仓库地址也是可以的。<br>注意：此处因为是直接在master分支上创建的，之后也是在master分支上使用的框架和主题，导致最后hexo generate的内容保存到了github.io中，这部分是接下来一周需要解决的问题之一。</p>
<h3 id="使用hexo框架"><a href="#使用hexo框架" class="headerlink" title="使用hexo框架"></a>使用hexo框架</h3><p>之所以知道这个框架是因为咱们的FE团队的翻译框架就是这个，所以此处借鉴了以下，嘿嘿。<br>在<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>上,介绍了这是一个简单高效的博客框架，在github.io仓库中，使用npm安装即可。虽然可以支持markdown的格式，但是其自带的tag也是非常方便的，我看还可以使用youtube视频，厉害了，这理所当然的成为下周需要学习的内容之一了。<br>还有一个比较深的体会是使用hexo的感觉就像开发机一样，通过hexo server相当于在开发机上查看效果，使用hexo generate和hexo deploy相当于部署在线上环境，就是少了review的部分，不过对于一个个人博客来说还是比较完善的了。</p>
<h3 id="使用material主题"><a href="#使用material主题" class="headerlink" title="使用material主题"></a>使用material主题</h3><p>使用hexo默认界面当然不能满足自己的审美了，在一番选择（选择恐惧症）后，终于选(sui)择(ji)了一个比较好看的theme，这就是<a href="https://material.viosey.com/" target="_blank" rel="noopener">material</a>，这个主题比较素雅，正好很吸引我~以下主要说明material主题配置中遇到的问题。其中主要的配置文件在<code>config.template.yaml</code>中，不过需要先将其改名为<code>config.yaml</code>。在页面配置中，按照流程可以选择对应的插件和效果，比较吸引人的是它的背景可以从必应上选择，后来因为颜色不匹配主题就去掉了，个人打算通过对选项加一个filter或者下到对应文件随机加载是个不错的选择，所以下周又新加了一项任务。还有一点就是评论系统和统计系统，个人选择的是<code>Valine</code>，因为考虑到可以使用对应后台查看信息，不过缺点就是有点丑。。。后来生庆哥说Google的后台数据处理用的人很多，所以打算抛弃当前评论系统，投入其他评论系统的怀抱。<br>对于独立页面部分还没有怎么看，下周来吧，除此之外，除了在mobile上效果还行，pc上两端有点空，所以想加一个音乐播放器，这部分打算选择网易云的api，实现一个音乐播放的效果。其他的内容就慢慢补全吧，这周过的虽然很累但还是很充实，个人也应该静下心来，虽然很多不会，但是相信通过付出比别人更多的努力，一定快速达到可以帮助到胡老师和FE团队的地步，fighting！</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
  
  
    
  
</search>
