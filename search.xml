<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[14.weakmap]]></title>
      <url>/2018/08/01/pureMaterial/14.weakMaps/</url>
      <content type="html"><![CDATA[<h2 id="weakmap"><a href="#weakmap" class="headerlink" title="weakmap"></a>weakmap</h2><h1 id="ES6-WeakMaps"><a href="#ES6-WeakMaps" class="headerlink" title="ES6 WeakMaps"></a><a href="#es6-weakmaps">ES6 WeakMaps</a></h1><p>You can think of <code>WeakMap</code> as a subset of <a href="/articles/es6-maps-in-depth"><code>Map</code></a>. There are a few limitations on <code>WeakMap</code> that we didn’t find in <code>Map</code>. The biggest limitation is that <code>WeakMap</code> is not iterable, as opposed to <code>Map</code> – that means there is no <a href="/articles/es6-iterators-in-depth"><em>iterable</em></a> protocol, no <code>.entries()</code>, no <code>.keys()</code>, no <code>.values()</code>, no <code>.forEach()</code> and no <code>.clear()</code>.</p>
<p>Another <em>“limitation”</em> found in <code>WeakMap</code> as opposed to <code>Map</code> is that every <code>key</code> must be an object, and <strong>value types are not admitted as keys</strong>. Note that <code>Symbol</code> is a value type as well, and they’re not allowed either.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">map</span> = <span class="literal">new</span> WeakMap()</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: 1 is not an object!</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(Symbol(), <span class="number">2</span>)</span><br><span class="line"><span class="comment">// TypeError: Invalid value used as weak map key</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>This is more of a feature than an issue, though, as it enables map keys to be garbage collected when they’re only being referenced as <code>WeakMap</code> keys. Usually you want this behavior when storing metadata related to something like a DOM node, and now you can keep that metadata in a <code>WeakMap</code>. If you want all of those you could always <a href="/articles/es6-maps-in-depth">use a regular <code>Map</code> as we explored earlier</a>.</p>
</blockquote>
<p>You are still able to pass an iterable to populate a <code>WeakMap</code> through its constructor.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="string">'foo'</span>], [<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'bar'</span>, <span class="string">'baz'</span>]])</span><br></pre></td></tr></table></figure>
<p>Just like with <code>Map</code>, you can use <code>.has</code>, <code>.get</code>, and <code>.delete</code> too.</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="built_in">date</span> = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">WeakMap</span>([[<span class="built_in">date</span>, <span class="string">'foo'</span>], [() =&gt; <span class="string">'bar'</span>, <span class="string">'baz'</span>]])</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="built_in">date</span>))</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.get(<span class="built_in">date</span>))</span><br><span class="line"><span class="comment">// &lt;- 'foo'</span></span><br><span class="line">map.delete(<span class="built_in">date</span>)</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="built_in">date</span>))</span><br><span class="line"><span class="comment">// &lt;- false</span></span><br></pre></td></tr></table></figure>
<h2 id="Is-This-a-Strictly-Worse-Map"><a href="#Is-This-a-Strictly-Worse-Map" class="headerlink" title="Is This a Strictly Worse Map?"></a><a href="#is-this-a-strictly-worse-map">Is This a Strictly Worse Map?</a></h2><p>I know! You must be wondering – why the hell would I use <code>WeakMap</code> when it has so many limitations when compared to <code>Map</code>?</p>
<p>The difference that may make <code>WeakMap</code> worth it is in its name. <code>WeakMap</code> holds references to its keys <em>weakly</em>, meaning that if there are no other references to one of its keys, the object is subject to <strong>garbage collection</strong>.</p>
<p>Use cases for <code>WeakMap</code> generally revolve around the need to specify metadata or extend an object while still being able to garbage collect it if nobody else cares about it. A perfect example might be the underlying implementation for <a href="https://iojs.org/api/process.html#process_event_unhandledrejection" target="_blank" rel="noopener"><code>process.on(&#39;unhandledRejection&#39;)</code></a> which <a href="https://github.com/petkaantonov/io.js/commit/f46874357ee7b909ae54304c6791f2a4baddf613#diff-6ff379484cbabad48301d485db111c08R269" target="_blank" rel="noopener">uses a <code>WeakMap</code></a> to keep track of promises that were rejected but <em>no error handlers dealt with the rejection</em> within a tick.</p>
<p>Keeping data about DOM elements that should be released from memory when they’re no longer of interest is another very important use case, and in this regard using <code>WeakMap</code> is probably an even better solution to the DOM-related <a href="/articles/es6-maps-in-depth#hash-maps-and-the-dom">API caching solution</a> we wrote about earlier using <code>Map</code>.</p>
<p>In so many words then, <strong>no</strong>. <code>WeakMap</code> is not strictly worse than <code>Map</code> <em>– they just cater to different use cases.</em></p>
<h2 id="ES6-Sets"><a href="#ES6-Sets" class="headerlink" title="ES6 Sets"></a><a href="#es6-sets">ES6 Sets</a></h2><p>Sets are <em>yet another</em> collection type in ES6. Sets are <em>very</em> similar to <code>Map</code>. To wit:</p>
<ul>
<li><code>Set</code> is also <a href="/articles/es6-iterators-in-depth"><em>iterable</em></a></li>
<li><code>Set</code> constructor also accepts an <em>iterable</em></li>
<li><code>Set</code> also has a <code>.size</code> property</li>
<li>Keys can also be arbitrary values</li>
<li>Keys must be unique</li>
<li><code>NaN</code> equals <code>NaN</code> when it comes to <code>Set</code> too</li>
<li>All of <code>.keys</code>, <code>.values</code>, <code>.entries</code>, <code>.forEach</code>, <code>.get</code>, <code>.set</code>, <code>.has</code>, <code>.delete</code>, and <code>.clear</code></li>
</ul>
<p>However, there’s a few differences as well!</p>
<ul>
<li>Sets only have <code>values</code></li>
<li>No <code>set.get</code> – but <strong>why</strong> would you want <code>get(value) =&gt; value</code>?</li>
<li>Having <code>set.set</code> would be weird, so we have <code>set.add</code> instead</li>
<li><code>set[Symbol.iterator] !== set.entries</code></li>
<li><code>set[Symbol.iterator] === set.values</code></li>
<li><code>set.keys === set.values</code></li>
<li><code>set.entries()</code> returns an iterator on a sequence of items like <code>[value, value]</code></li>
</ul>
<p>In the example below you can note how it takes an iterable with duplicate values, it can be spread over an <code>Array</code> using the <a href="/articles/es6-spread-and-butter-in-depth">spread operator</a>, and how the duplicate value <em>has been ignored</em>.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>])</span><br><span class="line">console.log([...<span class="keyword">set</span>])</span><br><span class="line"><span class="comment">// &lt;- [1, 2, 3, 4]</span></span><br></pre></td></tr></table></figure>
<p>Sets may be a great alternative to work with DOM elements. The following piece of code creates a <code>Set</code> with all the <code>&lt;div&gt;</code> elements on a page and then prints how many it found. Then, we query the DOM <em>again</em> and call <code>set.add</code> again for every DOM element. Since they’re all already in the <code>set</code>, the <code>.size</code> property won’t change, meaning the <code>set</code> remains the same.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">divs</span> () &#123;</span></span><br><span class="line">  <span class="literal">return</span> [...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line">&#125;</span><br><span class="line">var <span class="built_in">set</span> = <span class="built_in">new</span> Set(divs())</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">set</span>.size)</span><br><span class="line">// &lt;- <span class="number">56</span></span><br><span class="line">divs().forEach(<span class="keyword">div</span> =&gt; <span class="built_in">set</span>.<span class="built_in">add</span>(<span class="keyword">div</span>))</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">set</span>.size)</span><br><span class="line">// &lt;- <span class="number">56</span></span><br><span class="line">// &lt;- look <span class="keyword">at</span> that, no duplicates!</span><br></pre></td></tr></table></figure>
<h1 id="ES6-WeakSets"><a href="#ES6-WeakSets" class="headerlink" title="ES6 WeakSets"></a><a href="#es6-weaksets">ES6 WeakSets</a></h1><p>Much like with <code>WeakMap</code> and <code>Map</code>, <code>WeakSet</code> is <strong><code>Set</code> plus weakness</strong> minus the <em>iterability</em> <em>– I just made that term up, didn’t I?</em></p>
<p>That means you can’t iterate over <code>WeakSet</code>. Its values must be <strong>unique object references</strong>. If nothing else is referencing a <code>value</code> found in a <code>WeakSet</code>, it’ll be subject to garbage collection.</p>
<p>Much like in <code>WeakMap</code>, you can only <code>.add</code>, <code>.has</code>, and <code>.delete</code> values from a <code>WeakSet</code>. And just like in <code>Set</code>, there’s no <code>.get</code>.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = <span class="keyword">new</span> WeakSet()</span><br><span class="line"><span class="keyword">set</span>.<span class="keyword">add</span>(&#123;&#125;)</span><br><span class="line"><span class="keyword">set</span>.<span class="keyword">add</span>(<span class="keyword">new</span> Date())</span><br></pre></td></tr></table></figure>
<p>As we know, we can’t use primitive values.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = <span class="keyword">new</span> WeakSet()</span><br><span class="line"><span class="keyword">set</span>.<span class="keyword">add</span>(Symbol())</span><br><span class="line"><span class="comment">// TypeError: invalid value used in weak set</span></span><br></pre></td></tr></table></figure>
<p>Just like with <code>WeakMap</code>, passing iterators to the constructor is still allowed even though a <code>WeakSet</code> instance is not iterable itself.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="keyword">set</span> = <span class="keyword">new</span> WeakSet([<span class="keyword">new</span> <span class="built_in">Date</span>(), &#123;&#125;, <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;, [<span class="number">1</span>]])</span><br></pre></td></tr></table></figure>
<p>Use cases for <code>WeakSet</code> vary, and here’s one from <a href="https://esdiscuss.org/topic/actual-weakset-use-cases#content-1" target="_blank" rel="noopener">a thread on <em>es-discuss</em></a> – the mailing list for the ECMAScript-262 specification of JavaScript.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foos = <span class="keyword">new</span> <span class="built_in">WeakSet</span>()</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Foo</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    foos.add(<span class="keyword">this</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  method () &#123;</span><br><span class="line">    <span class="keyword">if</span> (!foos.has(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">'Foo.prototype.method called on incompatible object!'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>As a general rule of thumb, you can also try and figure out whether a <code>WeakSet</code> will do when you’re considering to use a <code>WeakMap</code> as some use cases may overlap. Particularly, if all you need to check for is whether a reference value is in the <code>WeakSet</code> or not.</p>
<blockquote>
<p>Next week we’ll be having <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener"><code>Proxy</code></a> for brunch :)</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[13.map]]></title>
      <url>/2018/08/01/pureMaterial/13.map/</url>
      <content type="html"><![CDATA[<h2 id="map"><a href="#map" class="headerlink" title="map"></a>map</h2><h1 id="Before-ES6-There-Were-Hash-Maps"><a href="#Before-ES6-There-Were-Hash-Maps" class="headerlink" title="Before ES6, There Were Hash-Maps"></a><a href="#before-es6-there-were-hash-maps">Before ES6, There Were Hash-Maps</a></h1><p>A very common _ab_use case of JavaScript objects is hash-maps, where we map string keys to arbitrary values. For example, one might use an object to map <code>npm</code> package names to their metadata, like so:</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var registry = &#123;&#125;</span><br><span class="line">function <span class="keyword">add</span><span class="bash"> (name, meta) &#123;</span></span><br><span class="line"><span class="bash">  registry[name] = meta</span></span><br><span class="line"><span class="bash">&#125;</span></span><br><span class="line"><span class="bash"><span class="keyword">function</span> get (name) &#123;</span></span><br><span class="line"><span class="bash">  <span class="built_in">return</span> registry[name]</span></span><br><span class="line"><span class="bash">&#125;</span></span><br><span class="line"><span class="bash">add(<span class="string">'contra'</span>, &#123; description: <span class="string">'Asynchronous flow control'</span> &#125;)</span></span><br><span class="line"><span class="bash">add(<span class="string">'dragula'</span>, &#123; description: <span class="string">'Drag and drop'</span> &#125;)</span></span><br><span class="line"><span class="bash">add(<span class="string">'woofmark'</span>, &#123; description: <span class="string">'Markdown and WYSIWYG editor'</span> &#125;)</span></span><br></pre></td></tr></table></figure>
<p>There’s several issues with this approach, to wit:</p>
<ul>
<li><strong>Security issues</strong> where user-provided keys like <code>__proto__</code>, <code>toString</code>, or anything in <code>Object.prototype</code> break expectations and make interaction with these kinds of <em>hash-map</em> data structures more cumbersome</li>
<li>Iteration over list items is verbose with <code>Object.keys(registry).forEach</code> or implementing the <a href="/articles/es6-iterators-in-depth"><em>iterable</em> protocol</a> on the <code>registry</code></li>
<li>Keys are limited to strings, making it hard to create hash-maps where you’d like to index values by DOM elements or other non-string references</li>
</ul>
<p>The first problem could be fixed using a prefix, and being careful to always get or set values in the hash-map through methods. It would be even better to use <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Proxy" target="_blank" rel="noopener">ES6 proxies</a>, but we <em>won’t be covering those until tomorrow!</em></p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var registry = &#123;&#125;</span><br><span class="line">function <span class="keyword">add</span><span class="bash"> (name, meta) &#123;</span></span><br><span class="line"><span class="bash">  registry[<span class="string">'map:'</span> + name] = meta</span></span><br><span class="line"><span class="bash">&#125;</span></span><br><span class="line"><span class="bash"><span class="keyword">function</span> get (name) &#123;</span></span><br><span class="line"><span class="bash">  <span class="built_in">return</span> registry[<span class="string">'map:'</span> + name]</span></span><br><span class="line"><span class="bash">&#125;</span></span><br><span class="line"><span class="bash">add(<span class="string">'contra'</span>, &#123; description: <span class="string">'Asynchronous flow control'</span> &#125;)</span></span><br><span class="line"><span class="bash">add(<span class="string">'dragula'</span>, &#123; description: <span class="string">'Drag and drop'</span> &#125;)</span></span><br><span class="line"><span class="bash">add(<span class="string">'woofmark'</span>, &#123; description: <span class="string">'Markdown and WYSIWYG editor'</span> &#125;)</span></span><br></pre></td></tr></table></figure>
<p>Luckily for us, though, <em>ES6 maps</em> provide us with an even better solution to the key-naming security issue. At the same time they facilitate collection behaviors out the box that may also come in handy. Let’s plunge into their practical usage and inner workings.</p>
<h1 id="ES6-Maps"><a href="#ES6-Maps" class="headerlink" title="ES6 Maps"></a><a href="#es6-maps">ES6 Maps</a></h1><p>Map is a key/value data structure in ES6. It provides a better data structure to be used for hash-maps. Here’s how what we had earlier looks like with ES6 maps.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'contra'</span>, &#123; description: <span class="string">'Asynchronous flow control'</span> &#125;)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'dragula'</span>, &#123; description: <span class="string">'Drag and drop'</span> &#125;)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'woofmark'</span>, &#123; description: <span class="string">'Markdown and WYSIWYG editor'</span> &#125;)</span><br></pre></td></tr></table></figure>
<p>One of the important differences is also that you’re able to use anything for the keys. You’re not just limited to primitive values like symbols, numbers, or strings, but you can even use functions, objects and dates – too. Keys won’t be casted to strings like with regular objects, either.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="literal">new</span> <span class="built_in">Date</span>(), function today () &#123;&#125;)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(() =&gt; <span class="string">'key'</span>, &#123; pony: <span class="string">'foo'</span> &#125;)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(Symbol(<span class="string">'items'</span>), <span class="meta">[</span><span class="number">1</span>, <span class="number">2</span><span class="meta">]</span>)</span><br></pre></td></tr></table></figure>
<p>You can also provide <code>Map</code> objects with any object that follows the <a href="/articles/es6-iterators-in-depth"><em>iterable</em> protocol</a> and produces a collection such as <code>[[&#39;key&#39;, &#39;value&#39;], [&#39;key&#39;, &#39;value&#39;]]</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([</span><br><span class="line">  [<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="function"><span class="keyword">function</span> <span class="title">today</span> (<span class="params"></span>) </span>&#123;&#125;],</span><br><span class="line">  [<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'key'</span>, &#123; <span class="attr">pony</span>: <span class="string">'foo'</span> &#125;],</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'items'</span>), [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">])</span><br></pre></td></tr></table></figure>
<p>The above would be effectively the same as the following. Note how we’re using destructuring in the parameters of <code>items.forEach</code> to <em>effortlessly</em> pull the <code>key</code> and <code>value</code> out of the two-dimensional <code>item</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> items = [</span><br><span class="line">  [<span class="keyword">new</span> <span class="built_in">Date</span>(), <span class="function"><span class="keyword">function</span> <span class="title">today</span> (<span class="params"></span>) </span>&#123;&#125;],</span><br><span class="line">  [<span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'key'</span>, &#123; <span class="attr">pony</span>: <span class="string">'foo'</span> &#125;],</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'items'</span>), [<span class="number">1</span>, <span class="number">2</span>]]</span><br><span class="line">]</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line">items.forEach(<span class="function">(<span class="params">[key, value]</span>) =&gt;</span> map.set(key, value))</span><br></pre></td></tr></table></figure>
<p>Of course, it’s kind of silly to go through the trouble of adding items one by one when you can just feed an iterable to your <code>Map</code>. Speaking of iterables – <code>Map</code> adheres to the <a href="/articles/es6-iterators-in-depth"><em>iterable</em></a> protocol. It’s very easy to pull a key-value pair collection much like the ones you can feed to the <code>Map</code> constructor.</p>
<p>Naturally, we can use the spread operator to this effect.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'p'</span>, <span class="string">'o'</span>)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'n'</span>, <span class="string">'y'</span>)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'f'</span>, <span class="string">'o'</span>)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'o'</span>, <span class="string">'!'</span>)</span><br><span class="line">console.<span class="keyword">log</span>(<span class="meta">[</span><span class="params">...</span><span class="built_in">map</span><span class="meta">]</span>)</span><br><span class="line">// &lt;- <span class="meta">[</span><span class="meta">[</span><span class="string">'p'</span>, <span class="string">'o'</span><span class="meta">]</span>, <span class="meta">[</span><span class="string">'n'</span>, <span class="string">'y'</span><span class="meta">]</span>, <span class="meta">[</span><span class="string">'f'</span>, <span class="string">'o'</span><span class="meta">]</span>, <span class="meta">[</span><span class="string">'o'</span>, <span class="string">'!'</span><span class="meta">]</span>]</span><br></pre></td></tr></table></figure>
<p>You could also use a <code>for..of</code> loop, and we could combine that with <a href="/articles/es6-destructuring-in-depth">destructuring</a> to make it seriously terse. Also, remember <a href="/articles/es6-template-strings-in-depth">template literals</a>?</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map()</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'p'</span>, <span class="string">'o'</span>)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'n'</span>, <span class="string">'y'</span>)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'f'</span>, <span class="string">'o'</span>)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'o'</span>, <span class="string">'!'</span>)</span><br><span class="line"><span class="keyword">for</span> (let [<span class="built_in">key</span>, value] of <span class="built_in">map</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(`$&#123;<span class="built_in">key</span>&#125;: $&#123;value&#125;`)</span><br><span class="line">  <span class="comment">// &lt;- 'p: o'</span></span><br><span class="line">  <span class="comment">// &lt;- 'n: y'</span></span><br><span class="line">  <span class="comment">// &lt;- 'f: o'</span></span><br><span class="line">  <span class="comment">// &lt;- 'o: !'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Even though maps have a programmatic API to add items, keys are unique, just like with hash-maps. Setting a key over and over again will only overwrite its value.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'a'</span>, <span class="string">'a'</span>)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'a'</span>, <span class="string">'b'</span>)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'a'</span>, <span class="string">'c'</span>)</span><br><span class="line">console.<span class="keyword">log</span>(<span class="meta">[</span><span class="params">...</span><span class="built_in">map</span><span class="meta">]</span>)</span><br><span class="line">// &lt;- <span class="meta">[</span><span class="meta">[</span><span class="string">'a'</span>, <span class="string">'c'</span><span class="meta">]</span>]</span><br></pre></td></tr></table></figure>
<p>In ES6 <code>Map</code>, <code>NaN</code> becomes a “corner-case” that gets <strong>treated as a value that’s equal to itself</strong> even though the following expression actually evaluates to <code>true</code> – <code>NaN !== NaN</code>.</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="keyword">log</span>(<span class="number">NaN</span> === <span class="number">NaN</span>)</span><br><span class="line"><span class="comment">// &lt;- false</span></span><br><span class="line"><span class="built_in">var</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="number">NaN</span>, <span class="string">'foo'</span>)</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="number">NaN</span>, <span class="string">'bar'</span>)</span><br><span class="line">console.<span class="keyword">log</span>(<span class="meta">[</span><span class="params">...</span><span class="built_in">map</span><span class="meta">]</span>)</span><br><span class="line">// &lt;- <span class="meta">[</span><span class="meta">[</span><span class="number">NaN</span>, <span class="string">'bar'</span><span class="meta">]</span>]</span><br></pre></td></tr></table></figure>
<h2 id="Hash-Maps-and-the-DOM"><a href="#Hash-Maps-and-the-DOM" class="headerlink" title="Hash-Maps and the DOM"></a><a href="#hash-maps-and-the-dom">Hash-Maps and the DOM</a></h2><p>In ES5, whenever we had a DOM element we wanted to associate with an API object for some library, we had to follow a verbose and slow pattern like the one below. The following piece of code just returns an API object with a bunch of methods for a given DOM element, allowing us to put and remove DOM elements from the cache, and also allowing us to retrieve the API object for a DOM element – if one already exists.</p>
<figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line">var cache = []</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put</span> <span class="params">(el, api)</span> &#123;</span></span><br><span class="line">  cache.push(&#123; el: el, api: api &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span> <span class="params">(el)</span> &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; cache.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    if (cache[i].el === el) &#123;</span><br><span class="line">      return cache[i].api</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroy</span> <span class="params">(el)</span> &#123;</span></span><br><span class="line">  <span class="keyword">for</span> (<span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; cache.<span class="built_in">length</span>; <span class="built_in">i</span>++) &#123;</span><br><span class="line">    if (cache[i].el === el) &#123;</span><br><span class="line">      cache.splice(i, <span class="number">1</span>)</span><br><span class="line">      return</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thing</span> <span class="params">(el)</span> &#123;</span></span><br><span class="line">  var api = <span class="built_in">find</span>(el)</span><br><span class="line">  <span class="keyword">if</span> (api) &#123;</span><br><span class="line">    return api</span><br><span class="line">  &#125;</span><br><span class="line">  api = &#123;</span><br><span class="line">    method: method,</span><br><span class="line">    method2: method2,</span><br><span class="line">    method3: method3,</span><br><span class="line">    destroy: destroy.bind(null, el)</span><br><span class="line">  &#125;</span><br><span class="line">  put(el, api)</span><br><span class="line">  <span class="keyword">return</span> api</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One of the coolest aspects of <code>Map</code>, <em>as I’ve previously mentioned</em>, is the ability to index by DOM elements. The fact that <code>Map</code> also has collection manipulation abilities also greatly simplifies things.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line">var cache = <span class="keyword">new</span> Map()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">put</span> <span class="params">(el, api)</span> &#123;</span></span><br><span class="line">  cache.<span class="keyword">set</span>(<span class="keyword">el</span>, api)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">find</span> <span class="params">(el)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> cache.<span class="built_in">get</span>(<span class="keyword">el</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">destroy</span> <span class="params">(el)</span> &#123;</span></span><br><span class="line">  cache.<span class="keyword">delete</span>(<span class="keyword">el</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thing</span> <span class="params">(el)</span> &#123;</span></span><br><span class="line">  var api = <span class="keyword">find</span>(<span class="keyword">el</span>)</span><br><span class="line">  <span class="keyword">if</span> (api) &#123;</span><br><span class="line">    <span class="keyword">return</span> api</span><br><span class="line">  &#125;</span><br><span class="line">  api = &#123;</span><br><span class="line">    method: method,</span><br><span class="line">    method2: method2,</span><br><span class="line">    method3: method3,</span><br><span class="line">    destroy: destroy.bind(null, <span class="keyword">el</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">put</span>(<span class="keyword">el</span>, api)</span><br><span class="line">  <span class="keyword">return</span> api</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The fact that these methods have now become one liners means we can just inline them, as readability is no longer an issue. We just went from <em>~30 LOC</em> to <strong>half that amount</strong>. Needless to say, at some point in the future this will also perform <em>much</em> faster than the haystack alternative.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cache = <span class="keyword">new</span> <span class="built_in">Map</span>()</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">thing</span> (<span class="params">el</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> api = cache.get(el)</span><br><span class="line">  <span class="keyword">if</span> (api) &#123;</span><br><span class="line">    <span class="keyword">return</span> api</span><br><span class="line">  &#125;</span><br><span class="line">  api = &#123;</span><br><span class="line">    method: method,</span><br><span class="line">    method2: method2,</span><br><span class="line">    method3: method3,</span><br><span class="line">    destroy: <span class="function"><span class="params">()</span> =&gt;</span> cache.delete(el)</span><br><span class="line">  &#125;</span><br><span class="line">  cache.set(el, api)</span><br><span class="line">  <span class="keyword">return</span> api</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The simplicity of <code>Map</code> is amazing. If you ask me, we desperately needed this feature in JavaScript. Being to index a collection by arbitrary objects is <strong>super important</strong>.</p>
<blockquote>
<p>What else can we do with <code>Map</code>?</p>
</blockquote>
<h2 id="Collection-Methods-in-Map"><a href="#Collection-Methods-in-Map" class="headerlink" title="Collection Methods in Map"></a><a href="#collection-methods-in-map">Collection Methods in <code>Map</code></a></h2><p>Maps make it very easy to probe the collection and figure out whether a <code>key</code> is defined in the <code>Map</code>. As we noted earlier, <code>NaN</code> equals <code>NaN</code> as far as <code>Map</code> is concerned. However, <code>Symbol</code> values are always different, so you’ll have to use them by value!</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="literal">NaN</span>, <span class="number">1</span>], [<span class="built_in">Symbol</span>(), <span class="number">2</span>], [<span class="string">'foo'</span>, <span class="string">'bar'</span>]])</span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="literal">NaN</span>))</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="built_in">Symbol</span>()))</span><br><span class="line"><span class="comment">// &lt;- false</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'foo'</span>))</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br><span class="line"><span class="built_in">console</span>.log(map.has(<span class="string">'bar'</span>))</span><br><span class="line"><span class="comment">// &lt;- false</span></span><br></pre></td></tr></table></figure>
<p>As long as you keep a <code>Symbol</code> reference around, you’ll be okay. <em>Keep your references close, and your <code>Symbol</code>s closer?</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> sym = <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="literal">NaN</span>, <span class="number">1</span>], [sym, <span class="number">2</span>], [<span class="string">'foo'</span>, <span class="string">'bar'</span>]])</span><br><span class="line"><span class="built_in">console</span>.log(map.has(sym))</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br></pre></td></tr></table></figure>
<p>Also, remember the <strong>no key-casting</strong> thing? <em>Beware!</em> We are so used to objects casting keys to strings that this may bite you if you’re not careful.</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map([[<span class="number">1</span>, <span class="string">'a'</span>]])</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">map</span>.has(<span class="number">1</span>))</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">map</span>.has(<span class="string">'1'</span>))</span><br><span class="line"><span class="comment">// &lt;- false</span></span><br></pre></td></tr></table></figure>
<p>You can also clear a <code>Map</code> entirely of entries without losing a reference to it. This can be very handy sometimes.</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">clear</span>()</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">map</span>.has(<span class="number">1</span>))</span><br><span class="line"><span class="comment">// &lt;- false</span></span><br><span class="line">console.<span class="built_in">log</span>([...<span class="built_in">map</span>])</span><br><span class="line"><span class="comment">// &lt;- []</span></span><br></pre></td></tr></table></figure>
<p>When you use <code>Map</code> as an iterable, you are actually looping over its <code>.entries()</code>. That means that you don’t need to <strong>explicitly</strong> iterate over <code>.entries()</code>. It’ll be done on your behalf anyways. You do remember <a href="/articles/es6-iterators-in-depth"><code>Symbol.iterator</code></a>, right?</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.<span class="built_in">log</span>(<span class="built_in">map</span>[Symbol.iterator] === <span class="built_in">map</span>.entries)</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br></pre></td></tr></table></figure>
<p>Just like <code>.entries()</code>, <code>Map</code> has two other iterators you can leverage. These are <code>.keys()</code> and <code>.values()</code>. I’m sure you guessed what sequences of values they yield, but here’s a code snippet anyways.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> map = new Map([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">console.log([..<span class="selector-class">.map</span><span class="selector-class">.keys</span>()])</span><br><span class="line"><span class="comment">// &lt;- [1, 3, 5]</span></span><br><span class="line">console.log([..<span class="selector-class">.map</span><span class="selector-class">.values</span>()])</span><br><span class="line"><span class="comment">// &lt;- [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<p>Maps also come with a <em>read-only</em> <code>.size</code> property that behaves sort of like <code>Array.prototype.length</code> – at any point in time it gives you the current amount of entries in the map.</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">map</span> = <span class="keyword">new</span> Map([[<span class="number">1</span>, <span class="number">2</span>], [<span class="number">3</span>, <span class="number">4</span>], [<span class="number">5</span>, <span class="number">6</span>]])</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">map</span>.<span class="built_in">size</span>)</span><br><span class="line"><span class="comment">// &lt;- 3</span></span><br><span class="line"><span class="built_in">map</span>.delete(<span class="number">3</span>)</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">map</span>.<span class="built_in">size</span>)</span><br><span class="line"><span class="comment">// &lt;- 2</span></span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">clear</span>()</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">map</span>.<span class="built_in">size</span>)</span><br><span class="line"><span class="comment">// &lt;- 0</span></span><br></pre></td></tr></table></figure>
<p>One more aspect of <code>Map</code> that’s worth mentioning is that their entries are always iterated in <strong>insertion order</strong>. This is in contrast with <code>Object.keys</code> loops which follow <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="noopener">an arbitrary order</a>.</p>
<blockquote>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/for...in" target="_blank" rel="noopener"><code>for..in</code></a> statement iterates over the enumerable properties of an object, in arbitrary order.</p>
</blockquote>
<p>Maps also have a <code>.forEach</code> method that’s identical in <em>behavior</em> to that in ES5 <code>Array</code> objects. Once again, keys do not get casted into strings here.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="literal">NaN</span>, <span class="number">1</span>], [<span class="built_in">Symbol</span>(), <span class="number">2</span>], [<span class="string">'foo'</span>, <span class="string">'bar'</span>]])</span><br><span class="line">map.forEach(<span class="function">(<span class="params">value, key</span>) =&gt;</span> <span class="built_in">console</span>.log(key, value))</span><br><span class="line"><span class="comment">// &lt;- NaN 1</span></span><br><span class="line"><span class="comment">// &lt;- Symbol() 2</span></span><br><span class="line"><span class="comment">// &lt;- 'foo' 'bar'</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Get up early tomorrow morning, we’ll be having <a href="http://ponyfoo.com/articles/es6-weakmaps-sets-and-weaksets-in-depth" target="_blank" rel="noopener"><code>WeakMap</code>, <code>Set</code>, and <code>WeakSet</code></a> for breakfast :)</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode String -- 7.Longest Uncommon Subsequence I]]></title>
      <url>/2018/08/01/leetCode/string/07.longest_uncommon_subsequence_I/</url>
      <content type="html"><![CDATA[<h2 id="Longest-Uncommon-Subsequence-I"><a href="#Longest-Uncommon-Subsequence-I" class="headerlink" title="Longest Uncommon Subsequence I"></a>Longest Uncommon Subsequence I</h2><p>Given a group of two strings, you need to find the longest uncommon subsequence of this group of two strings. The longest uncommon subsequence is defined as the longest subsequence of one of these strings and this subsequence should not be any subsequence of the other strings.</p>
<p><strong>A subsequence</strong> is a sequence that can be derived from one sequence by deleting some characters without changing the order of the remaining elements. Trivially, any string is a subsequence of itself and an empty string is a subsequence of any string.</p>
<p>The input will be two strings, and the output needs to be the length of the longest uncommon subsequence. If the longest uncommon subsequence doesn’t exist, return -1.</p>
<blockquote>
<p>Example 1:<br>Input: “aba”, “cdc”<br>Output: 3<br>Explanation: The longest uncommon subsequence is “aba” (or “cdc”),<br>because “aba” is a subsequence of “aba”,<br>but not a subsequence of any other strings in the group of two strings.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>Both strings’ lengths will not exceed 100.</li>
<li>Only letters from a ~ z will appear in input strings.</li>
</ul>
<p><strong>solutions:</strong></p>
<ol>
<li>这就是个文字游戏。。。取两个字符串之间的最大值即可,毕竟是最长的非公共子串：</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;string&#125; a</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;string&#125; b</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> findLUSlength = <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (a === b) <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">return</span> Math.max(a.length, b.length);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode String -- 6.flip game]]></title>
      <url>/2018/08/01/leetCode/string/06.flip_game/</url>
      <content type="html"><![CDATA[<p>You are playing the following Flip Game with your friend: Given a string that contains only these two characters: + and -, you and your friend take turns to flip twoconsecutive “++” into “–”. The game ends when a person can no longer make a move and therefore the other person will be the winner.</p>
<p>Write a function to compute all possible states of the string after one valid move.</p>
<p>For example, given s = “++++”, after one move, it may become one of the following states:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[</span><br><span class="line">  <span class="string">"--++"</span>,</span><br><span class="line">  <span class="string">"+--+"</span>,</span><br><span class="line">  <span class="string">"++--"</span></span><br><span class="line">]</span><br></pre></td></tr></table></figure>
<p>If there is no valid move, return an empty list [].</p>
<p><strong>solution：</strong></p>
<ol>
<li>感觉没有特别好的办法，只能遍历，当下一个元素跟上一个元素相等时，可以输出一个表达式：</li>
</ol>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* <span class="doctag">@param</span> &#123;string&#125; s</span></span><br><span class="line"><span class="comment">* <span class="doctag">@return</span> &#123;string&#125;</span></span><br><span class="line"><span class="comment">**/</span></span><br><span class="line"><span class="keyword">var</span> generatePossibleNextMoves = <span class="function"><span class="keyword">function</span><span class="params">(s)</span> </span>&#123;    </span><br><span class="line">    <span class="keyword">let</span> b = [],</span><br><span class="line">        c = s.split(<span class="string">''</span>);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">let</span> i = <span class="number">1</span>; i&lt; c.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(c[i] === <span class="string">'+'</span> &amp;&amp; c[i - <span class="number">1</span>] === <span class="string">'+'</span>) &#123;</span><br><span class="line">            b.push(s.substr(<span class="number">0</span>,i<span class="number">-1</span>) + <span class="string">'--'</span> + s.substr(i+<span class="number">1</span>));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> b;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[12.promises]]></title>
      <url>/2018/08/01/pureMaterial/12.promises/</url>
      <content type="html"><![CDATA[<h2 id="promises"><a href="#promises" class="headerlink" title="promises"></a>promises</h2><blockquote>
<p>Promises are a very involved paradigm, so we’ll take it slow.</p>
</blockquote>
<p>Here’s a table of contents with the topics we’ll cover in this article. Feel free to skip topics you’re comfortable about.</p>
<ul>
<li><a href="#what-is-a-promise">What is a Promise?</a> – we define <code>Promise</code> and look at a simple example in JavaScript<ul>
<li><a href="#callbacks-and-events">Callbacks and Events</a> – alternative ways to handle asynchronous code flows</li>
<li><a href="#gist-of-a-promise">Gist of a <code>Promise</code></a> – a first glimpse at how promises work</li>
</ul>
</li>
<li><a href="#promises-in-time">Promises in Time</a> – a brief history of promises</li>
<li><a href="#then-again">Then, Again</a> – an analysis of <code>.then</code> and <code>.catch</code></li>
<li><a href="#creating-a-promise-from-scratch">Creating a Promise From Scratch</a></li>
<li><a href="#settling-a-promise">Settling a Promise</a> – discusses states of a <code>Promise</code></li>
<li><a href="#paying-a-promise-with-another-promise">Paying a Promise with another Promise</a> – explains promise chaining</li>
<li><a href="#transforming-values-in-promises">Transforming Values in Promises</a> – shows how to turn a result into something else in the context of promises</li>
<li><a href="#leveraging-promiseall-and-promiserace">Leveraging <code>Promise.all</code> and <code>Promise.race</code></a></li>
</ul>
<p>Shall we?</p>
<h1 id="What-is-a-Promise"><a href="#What-is-a-Promise" class="headerlink" title="What is a Promise?"></a><a href="#what-is-a-promise">What is a <code>Promise</code>?</a></h1><p>Promises are usually vaguely defined as <em>“a proxy for a value that will eventually become available”</em>. They can be used for both synchronous and asynchronous code flows, although they make asynchronous flows easier to reason about – once you’ve mastered promises, that is.</p>
<p>Consider as an example the <em>upcoming</em> <a href="https://developer.mozilla.org/en-US/docs/Web/API/GlobalFetch/fetch#Syntax" target="_blank" rel="noopener"><code>fetch</code></a> API. This API is a simplification of <code>XMLHttpRequest</code>. It aims to be super simple to use for the most basic use cases: making a <code>GET</code> request against a resource relative to the current page over <code>http(s)</code> – it also provides a comprehensive API that caters to advanced use cases as well, but that’s not our focus for now. In it’s most basic incarnation, you can make a request for <code>GET foo</code> like so.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fetch</span><span class="params">(<span class="string">'foo'</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>The <code>fetch(&#39;foo&#39;)</code> statement doesn’t seem <a href="http://buff.ly/1NRZf70" target="_blank" rel="noopener">all that exciting</a>. It makes a <em>“fire-and-forget”</em> <code>GET</code> request against <code>foo</code> relative to the resource we’re currently on. The <code>fetch</code> method returns a <code>Promise</code>. You can chain a <code>.then</code> callback that will be executed once the <code>foo</code> resource finishes loading.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fetch</span><span class="params">(<span class="string">'foo'</span>)</span></span>.then(response =&gt; <span class="comment">/* do something */</span>)</span><br></pre></td></tr></table></figure>
<p>Promises offer an alternative to callbacks and events.</p>
<h2 id="Callbacks-and-Events"><a href="#Callbacks-and-Events" class="headerlink" title="Callbacks and Events"></a><a href="#callbacks-and-events">Callbacks and Events</a></h2><p>If the <code>fetch</code> API used callbacks, you’d get one last parameter that then gets executed whenever fetching ends. Typical asynchronous code flow conventions dictate that we allocate the first parameter for errors <em>(that may or may not occur)</em> during the <em>fetching process</em>. The rest of the parameters can be used to pass in resulting data. Often, a single parameter is used.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fetch</span><span class="params">(<span class="string">'foo'</span>, (err, res)</span></span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">if</span> (err) &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// handle response</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>The callback wouldn’t be invoked until the <code>foo</code> resource has been fetched, so its execution remains asynchronous and non-blocking. Note that in this model you could only specify <strong>a single callback</strong>, and that callback would be responsible for <em>all functionality</em> derived from the response.</p>
<p>Another option might have been to use an <em>event-driven</em> API model. In this model the object returned by <code>fetch</code> would be able to listen <code>.on</code> events, binding as many event handlers as needed for any events. Typically there’s an <code>error</code> event for when things go awry and a <code>data</code> event that’s called when the operation completes successfully.</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">fetch</span>(<span class="string">'foo'</span>)</span><br><span class="line">  <span class="selector-class">.on</span>(<span class="string">'error'</span>, err =&gt; &#123;</span><br><span class="line">    <span class="comment">// handle error</span></span><br><span class="line">  &#125;)</span><br><span class="line">  <span class="selector-class">.on</span>(<span class="string">'data'</span>, res =&gt; &#123;</span><br><span class="line">    <span class="comment">// handle response</span></span><br><span class="line">  &#125;)</span><br></pre></td></tr></table></figure>
<p>In this case, errors usually end up in hard exceptions if no event listener is attached – but that depends on what event emitter implementation is used. Promises are a bit different.</p>
<h2 id="Gist-of-a-Promise"><a href="#Gist-of-a-Promise" class="headerlink" title="Gist of a Promise"></a><a href="#gist-of-a-promise">Gist of a <code>Promise</code></a></h2><p>Instead of binding event listeners through <code>.on</code>, promises offer a slightly different API. The snippet of code shown below displays the actual API of the <code>fetch</code> method, which returns a <code>Promise</code> object. Much like with events, you can bind as many listeners as you’d like with both <code>.catch</code> and <code>.then</code>. Note how there’s no need for an event type anymore with the declarative methods used by promises.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = fetch(<span class="string">'foo'</span>)</span><br><span class="line"><span class="selector-tag">p</span>.then(res =&gt; &#123;</span><br><span class="line">  <span class="comment">// handle response</span></span><br><span class="line">&#125;)</span><br><span class="line"><span class="selector-tag">p</span>.catch(error =&gt; &#123;</span><br><span class="line">  <span class="comment">// handle error</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>See [this example][(<a href="http://buff.ly/1KtWGUD" target="_blank" rel="noopener">http://buff.ly/1KtWGUD</a>)] on Promisees</p>
<p>Also note that <code>.then</code> is able to register a reaction to rejections as its second argument. The above could be expressed as the following piece of code.</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">fetch</span>(<span class="string">'foo'</span>)</span><br><span class="line">  <span class="selector-class">.then</span>(</span><br><span class="line">    res =&gt; &#123;</span><br><span class="line">      <span class="comment">// handle response</span></span><br><span class="line">    &#125;,</span><br><span class="line">    err =&gt; &#123;</span><br><span class="line">      <span class="comment">// handle error</span></span><br><span class="line">    &#125;</span><br><span class="line">  )</span><br></pre></td></tr></table></figure>
<p>See [this example][(<a href="http://buff.ly/1V8xpHI" target="_blank" rel="noopener">http://buff.ly/1V8xpHI</a>)] on Promisees</p>
<p>Just like you can omit the error reaction in <code>.then(fulfillment)</code>, you can also omit the reaction to <em>fulfillment</em>. Using <code>.then(null, rejection)</code> is equivalent to <code>.catch(rejection)</code>. Note that <code>.then</code> and <code>.catch</code> return <strong>a new promise every time</strong>. That’s important because chaining can have wildly different results depending on where you append a <code>.then</code> or a <code>.catch</code> call onto. See the <a href="http://buff.ly/1Pqh5ex" target="_blank" rel="noopener">following example</a> to understand the difference.</p>
<p><img src="https://i.imgur.com/uwWnUq4.png" alt="Differences when chaining promises"></p>
<p>We’ll get more in depth into these two methods in a bit. Let’s look at a brief history of promises before doing that.</p>
<h1 id="Promises-in-Time"><a href="#Promises-in-Time" class="headerlink" title="Promises in Time"></a><a href="#promises-in-time">Promises in Time</a></h1><p>Promises aren’t all that new. Like <em>most things in computer science</em>, the earliest mention of Promises can be traced all the way back to the <a href="https://en.wikipedia.org/wiki/Futures_and_promises" target="_blank" rel="noopener">late seventies</a>. According to the <em>Internet</em>, they made their first appearance in JavaScript in 2007 – in a library called <code>MochiKit</code>. Then <code>Dojo</code> adopted it, and <code>jQuery</code> followed shortly after that.</p>
<p>Then the <a href="https://promisesaplus.com/" target="_blank" rel="noopener">Promises/A+</a> specification came out from the CommonJS group <em>(now famous for their CommonJS module specification)</em>. In its earliest incarnations, Node.js shipped with promises. Some time later, they were removed from core and everyone switched over to callbacks. Now, promises ship with the ES6 standard and V8 has already implemented them a while back.</p>
<blockquote>
<p>The ES6 standard implements <strong>Promises/A+</strong> natively. In the latest versions of Node.js you can use promises without any libraries. They’re also available on Chrome 32+, Firefox 29+, and Safari 7.1+.</p>
</blockquote>
<p>Shall we go back to the <code>Promise</code> API?</p>
<h1 id="Then-Again"><a href="#Then-Again" class="headerlink" title="Then, Again"></a><a href="#then-again">Then, Again</a></h1><p>Going back to our example – here’s some of the code we had. In the simplest use case, this is all we wanted.</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">fetch</span>(<span class="string">'foo'</span>)<span class="selector-class">.then</span>(res =&gt; &#123;</span><br><span class="line">  <span class="comment">// handle response</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>What if an error happens in one of the reactions passed to <code>.then</code>? You can catch those with <code>.catch</code>. The example in the snippet below <a href="http://buff.ly/1Jo8NyJ" target="_blank" rel="noopener">logs the error</a> caught when trying to access <code>prop</code> from the <em>undefined <code>a</code> property</em> in <code>res</code>.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fetch</span><span class="params">(<span class="string">'foo'</span>)</span></span></span><br><span class="line">  .then(res =&gt; res<span class="selector-class">.a</span><span class="selector-class">.prop</span><span class="selector-class">.that</span><span class="selector-class">.does</span><span class="selector-class">.not</span><span class="selector-class">.exist</span>)</span><br><span class="line">  .catch(err =&gt; console.error(err.message))</span><br><span class="line"><span class="comment">// &lt;- 'Cannot read property "prop" of undefined'</span></span><br></pre></td></tr></table></figure>
<p>Note that <em>where</em> you tack your reactions onto matters. The following example <strong>won’t</strong> print the <code>err.message</code> twice – only once. That’s because no errors happened in the first <code>.catch</code>, so the rejection branch for that promise wasn’t executed. Check out <a href="http://buff.ly/1gLqKjU" target="_blank" rel="noopener">the Promisee</a> for a visual explanation of the code below.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fetch</span><span class="params">(<span class="string">'foo'</span>)</span></span></span><br><span class="line">  .then(res =&gt; res<span class="selector-class">.a</span><span class="selector-class">.prop</span><span class="selector-class">.that</span><span class="selector-class">.does</span><span class="selector-class">.not</span><span class="selector-class">.exist</span>)</span><br><span class="line">  .catch(err =&gt; console.error(err.message))</span><br><span class="line">  .catch(err =&gt; console.error(err.message))</span><br><span class="line"><span class="comment">// &lt;- 'Cannot read property "prop" of undefined'</span></span><br></pre></td></tr></table></figure>
<p>In contrast, the snippet found below <em>will</em> <a href="http://buff.ly/1PqlHS2" target="_blank" rel="noopener">print the <code>err.message</code> twice</a>. It works by saving a reference to the promise returned by <code>.then</code>, and then tacking two <code>.catch</code> reactions onto it. The second <code>.catch</code> in the previous example was capturing errors produced in the promise returned from the first <code>.catch</code>, while in this case both <code>.catch</code> branch off of <code>p</code>.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">p</span> = fetch(<span class="string">'foo'</span>).then(res =&gt; res<span class="selector-class">.a</span><span class="selector-class">.prop</span><span class="selector-class">.that</span><span class="selector-class">.does</span><span class="selector-class">.not</span><span class="selector-class">.exist</span>)</span><br><span class="line"><span class="selector-tag">p</span>.catch(err =&gt; console.error(err.message))</span><br><span class="line"><span class="selector-tag">p</span>.catch(err =&gt; console.error(err.message))</span><br><span class="line"><span class="comment">// &lt;- 'Cannot read property "prop" of undefined'</span></span><br><span class="line"><span class="comment">// &lt;- 'Cannot read property "prop" of undefined'</span></span><br></pre></td></tr></table></figure>
<p>Here’s another example that puts that difference the spotlight. The second catch is triggered this time because it’s <a href="http://buff.ly/1Jo9KHf" target="_blank" rel="noopener">bound to the rejection branch</a> on the first <code>.catch</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'foo'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">res</span> =&gt;</span> res.a.prop.that.does.not.exist)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(err.message) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">err</span> =&gt;</span> <span class="built_in">console</span>.error(err.message))</span><br><span class="line"><span class="comment">// &lt;- 'Cannot read property "prop" of undefined'</span></span><br></pre></td></tr></table></figure>
<p>If the first <code>.catch</code> call didn’t return anything, then <a href="http://buff.ly/1Jo9KHf" target="_blank" rel="noopener">nothing would be printed</a>.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fetch</span><span class="params">(<span class="string">'foo'</span>)</span></span></span><br><span class="line">  .then(res =&gt; res<span class="selector-class">.a</span><span class="selector-class">.prop</span><span class="selector-class">.that</span><span class="selector-class">.does</span><span class="selector-class">.not</span><span class="selector-class">.exist</span>)</span><br><span class="line">  .catch(err =&gt; &#123;&#125;)</span><br><span class="line">  .catch(err =&gt; console.error(err.message))</span><br><span class="line"><span class="comment">// nothing happens</span></span><br></pre></td></tr></table></figure>
<p>We should observe, then, that promises can be chained “arbitrarily”, that is to say: as we just saw, you can save a reference to any point in the promise chain and then tack more promises on top of it. This is one of the fundamental points to understanding promises.</p>
<blockquote>
<p>You can save a reference to any point in the promise chain.</p>
</blockquote>
<p>In fact, the last example can be represented as shown below. This snippet makes it much easier to understand what we’ve discussed so far. Glance over it and then I’ll give you some bullet points.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> p1 = fetch(<span class="string">'foo'</span>)</span><br><span class="line"><span class="selector-tag">var</span> p2 = p1.then(res =&gt; res<span class="selector-class">.a</span><span class="selector-class">.prop</span><span class="selector-class">.that</span><span class="selector-class">.does</span><span class="selector-class">.not</span><span class="selector-class">.exist</span>)</span><br><span class="line"><span class="selector-tag">var</span> p3 = p2.catch(err =&gt; &#123;&#125;)</span><br><span class="line"><span class="selector-tag">var</span> p4 = p3.catch(err =&gt; console.error(err.message))</span><br></pre></td></tr></table></figure>
<p>Good boy! Have some bullet points. Or you could just look at the <a href="http://buff.ly/1NS1Uxl" target="_blank" rel="noopener">Promisees visualization</a>.</p>
<ol>
<li><code>fetch</code> returns a <strong>brand new</strong> <code>p1</code> promise</li>
<li><code>p1.then</code> returns a <strong>brand new</strong> <code>p2</code> promise</li>
<li><code>p2.catch</code> returns a <strong>brand new</strong> <code>p3</code> promise</li>
<li><code>p3.catch</code> returns a <strong>brand new</strong> <code>p4</code> promise</li>
<li>When <code>p1</code> is settled <em>(fulfilled)</em>, the <code>p1.then</code> reaction is executed</li>
<li>After that <code>p2</code>, which is awaiting the pending result of <code>p1.then</code> is settled</li>
<li>Since <code>p2</code> was <em>rejected</em>, <code>p2.catch</code> reactions are executed <em>(instead of the <code>p2.then</code> branch)</em></li>
<li>The <code>p3</code> promise from <code>p2.catch</code> is <em>fulfilled</em>, even though it doesn’t produce any value nor an error</li>
<li>Because <code>p3</code> succeeded, <code>p3.catch</code> is never executed – the <code>p3.then</code> branch would’ve been used instead</li>
</ol>
<p>You should think of promises as <strong>a tree structure</strong>. It all starts with a single promise, which we’ll later see how to construct. You then add a branch with <code>.then</code> or <code>.catch</code>. You can tack as many <code>.then</code> or <code>.catch</code> calls as you want onto each branch, creating new branches, and so on.</p>
<h1 id="Creating-a-Promise-From-Scratch"><a href="#Creating-a-Promise-From-Scratch" class="headerlink" title="Creating a Promise From Scratch"></a><a href="#creating-a-promise-from-scratch">Creating a Promise From Scratch</a></h1><p>You should now understand how promises work like a tree where you can add branches where you need them, as you need them. But how do you create a promise from scratch? Writing these kinds of <code>Promise</code> tutorials is hard because its a chicken and egg situation. People hardly have a need to create a promise from scratch, since libraries usually take care of that. In this article, for instance, I purposely started explaining things using <code>fetch</code>, which internally creates a new promise object. Then, each call to <code>.then</code> or <code>.catch</code> on the promise created by fetch also creates a promise internally, and those promises depend on their parent when it comes to deciding whether the fulfillment branch or the rejection branch should be executed.</p>
<p>Promises can be created from scratch by using <code>new Promise(resolver)</code>. The <code>resolver</code> parameter is a method that will be used to resolve the promise. It takes two arguments, a <code>resolve</code> method and a <code>reject</code> method. These promises are fulfilled and rejected, respectively, on the next tick – as <a href="http://buff.ly/1LzF6k8" target="_blank" rel="noopener">seen on Promisees</a>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve()) <span class="comment">// promise is fulfilled</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span> reject()) <span class="comment">// promise is rejected</span></span><br></pre></td></tr></table></figure>
<p>Resolving and rejecting promises without a value isn’t that useful, though. Usually promises will resolve to some <code>result</code>, like the response from an AJAX call as we saw with <code>fetch</code>. Similarly, you’ll probably want to state the <code>reason</code> for your rejections – typically using an <code>Error</code> object. The code below codifies what you’ve just read (see the <a href="http://buff.ly/1KxmM9p" target="_blank" rel="noopener">visualization</a>, too).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(&#123; <span class="attr">foo</span>: <span class="string">'bar'</span> &#125;))</span><br><span class="line">  .then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">  <span class="comment">// &lt;- &#123; foo: 'bar' &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function">(<span class="params">resolve, reject</span>) =&gt;</span></span><br><span class="line">  reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'failed to deliver on my promise to you'</span>)))</span><br><span class="line">  .catch(<span class="function"><span class="params">reason</span> =&gt;</span> <span class="built_in">console</span>.log(reason))</span><br><span class="line">  <span class="comment">// &lt;- Error: failed to deliver on my promise to you</span></span><br></pre></td></tr></table></figure>
<p>As you may have guessed, there’s nothing inherently synchronous about promises. Fulfillment and rejection can both be completely asynchronous. That’s the whole point of promises! The promise below is fulfilled <a href="http://buff.ly/1PxIwmX" target="_blank" rel="noopener">after two seconds</a> elapse.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> setTimeout(resolve, <span class="number">2000</span>))</span><br></pre></td></tr></table></figure>
<p>It’s important to note that only the first call made to either of these methods will have an impact – once a promise is settled, it’s result can’t change. The example below creates a promise that’s fulfilled in the alloted time or rejected after a generous timeout <a href="http://buff.ly/1Owr5po" target="_blank" rel="noopener">(visualization)</a>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">resolveUnderThreeSeconds</span> (<span class="params">delay</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(resolve, delay)</span><br><span class="line">    setTimeout(reject, <span class="number">3000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line">resolveUnderThreeSeconds(<span class="number">2000</span>) <span class="comment">// resolves!</span></span><br><span class="line">resolveUnderThreeSeconds(<span class="number">7000</span>) <span class="comment">// fulfillment took so long, it was rejected.</span></span><br></pre></td></tr></table></figure>
<p><img src="https://i.imgur.com/JiIrWWg.gif" alt="See the promises unfold with this animation."></p>
<p>Besides returning resolution values, you could also resolve with <em>another promise</em>. What happens in those cases? In the following snippet we create a promise <code>p</code> that will be rejected in three seconds. We also create a promise <code>p2</code> that will be resolved with <code>p</code> in a second. Since <code>p</code> is still two seconds out, resolving <code>p2</code> won’t have an immediate effect. Two seconds later, when <code>p</code> is rejected, <code>p2</code> will be rejected as well, with the same rejection reason that was provided to <code>p</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'fail'</span>)), <span class="number">3000</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="keyword">var</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(p), <span class="number">1000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p2.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line">p2.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br><span class="line"><span class="comment">// &lt;- Error: fail</span></span><br></pre></td></tr></table></figure>
<p>In the <a href="http://bit.ly/2c2n5hx" target="_blank" rel="noopener">animation</a> shown below we can observe how <code>p2</code> becomes blocked <em>– marked in yellow –</em> waiting for a settlement in <code>p</code>.</p>
<p><img src="https://i.imgur.com/dIdrAcK.gif" alt="Animation of a promise blocking another one."></p>
<p>Note that this behavior is only possible for fulfillment branches using <code>resolve</code>. If you try to replicate the same behavior with <code>reject</code> you’ll find that the <code>p2</code> promise is just rejected with the <code>p</code> promise as the rejection <code>reason</code>.</p>
<h1 id="Using-Promise-resolve-and-Promise-reject"><a href="#Using-Promise-resolve-and-Promise-reject" class="headerlink" title="Using Promise.resolve and Promise.reject"></a><a href="#using-promiseresolve-and-promisereject">Using <code>Promise.resolve</code> and <code>Promise.reject</code></a></h1><p>Sometimes you want to create a Promise but you don’t want to go through the trouble of using the constructor. The following statement creates a promise that’s fulfilled with a result of <code>&#39;foo&#39;</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="params">resolve</span> =&gt;</span> resolve(<span class="string">'foo'</span>))</span><br></pre></td></tr></table></figure>
<p>If you already know the value a promise should be fulfilled with, you can use <code>Promise.resolve</code> instead. The following statement is equivalent to the previous one.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve(<span class="string">'foo'</span>)</span><br></pre></td></tr></table></figure>
<p>Similarly, if you already know the rejection reason, you can use <code>Promise.reject</code>. The next statement creates a promise that’s going to settle into a rejection, with <code>reason</code>.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Promise</span><span class="selector-class">.reject</span>(<span class="selector-tag">reason</span>)</span><br></pre></td></tr></table></figure>
<p>What else should we know about settling a promise?</p>
<h1 id="Settling-a-Promise"><a href="#Settling-a-Promise" class="headerlink" title="Settling a Promise"></a><a href="#settling-a-promise">Settling a Promise</a></h1><p>Promises can exist in three states: pending, fulfilled, and rejected. Pending is the default state. From there, a promise can be <em>“settled”</em> into either fulfillment or rejection. Once a promise is settled, all reactions that are waiting on it are evaluated. Those on the correct branch <em>– <code>.then</code> for fulfillment and <code>.catch</code> for rejections –</em> are executed.</p>
<p>From this point on, the promise is <em>settled</em>. If at a later point in time another reaction is chained onto the settled promise, the appropriate branch for that reaction is executed in the next tick of the program. In the example below, <code>p</code> is resolved with a value of <code>100</code> after two seconds. Then, <code>100</code> is printed onto the screen. Two seconds later, another <code>.then</code> branch is added onto <code>p</code>, but since <code>p</code> has already fulfilled, the new branch gets executed right away.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> resolve(<span class="number">100</span>), <span class="number">2000</span>)</span><br><span class="line">&#125;)</span><br><span class="line">p.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result))</span><br><span class="line"><span class="comment">// &lt;- 100</span></span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> p.then(<span class="function"><span class="params">result</span> =&gt;</span> <span class="built_in">console</span>.log(result * <span class="number">20</span>)), <span class="number">4000</span>)</span><br><span class="line"><span class="comment">// &lt;- 2000</span></span><br></pre></td></tr></table></figure>
<p>A promise can return another promise – this is what enables and powers most of their asynchronous behavior. In the <a href="#creating-a-promise-from-scratch">previous section</a>, when creating a promise from scratch, we saw that we can <code>resolve</code> with another promise. We can also return promises when calling <code>.then</code>.</p>
<h1 id="Paying-a-Promise-with-another-Promise"><a href="#Paying-a-Promise-with-another-Promise" class="headerlink" title="Paying a Promise with another Promise"></a><a href="#paying-a-promise-with-another-promise">Paying a Promise with another Promise</a></h1><p>The example below shows how we use a promise and <code>.then</code> another promise that will only be settled once the returned promise also settles. Once that happens, we get back the response from the wrapped promise, and we use the <code>res.url</code> to figure out what random article we were graced with.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">fetch(<span class="string">'foo'</span>)</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> fetch(<span class="string">'/articles/random'</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response.url))</span><br><span class="line"><span class="comment">// &lt;- 'http://ponyfoo.com/articles/es6-symbols-in-depth'</span></span><br></pre></td></tr></table></figure>
<p>Obviously, in the real world, your second <code>fetch</code> would probably depend on the response from the first one. Here’s another example of returning a promise, where we <a href="http://buff.ly/1VbxElo" target="_blank" rel="noopener">randomly <code>fulfill</code> or <code>reject</code></a> after a second.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.resolve()</span><br><span class="line">  .then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="built_in">Math</span>.random() &gt; <span class="number">0.5</span> ? resolve : reject, <span class="number">1000</span>)</span><br><span class="line">  &#125;))</span><br><span class="line"></span><br><span class="line">p.then(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'okay!'</span>))</span><br><span class="line">p.catch(<span class="function"><span class="params">data</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'boo!'</span>))</span><br></pre></td></tr></table></figure>
<p>The animation for this one is super fun!</p>
<p><img src="https://i.imgur.com/3NNoO38.gif" alt="Animation of the code shown right above"></p>
<p>Okay it’s <strong>not</strong> <em>that fun</em>. I did have fun making the Promisees tool itself!</p>
<h1 id="Transforming-Values-in-Promises"><a href="#Transforming-Values-in-Promises" class="headerlink" title="Transforming Values in Promises"></a><a href="#transforming-values-in-promises">Transforming Values in Promises</a></h1><p>You’re not just limited to returning other promises from your <code>.then</code> and <code>.catch</code> callbacks. You could also return values, transforming what you had. The example below first creates a promise fulfilled with <code>[1, 2, 3]</code> and then has a fulfillment branch on top of that which maps thoes values into <code>[2, 4, 6]</code>. Calling <code>.then</code> on that branch of the promise will produce the doubled values.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.resolve([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line">  .then(<span class="function"><span class="params">values</span> =&gt;</span> values.map(<span class="function"><span class="params">value</span> =&gt;</span> value * <span class="number">2</span>))</span><br><span class="line">  .then(<span class="function"><span class="params">values</span> =&gt;</span> <span class="built_in">console</span>.log(values))</span><br><span class="line">  <span class="comment">// &lt;- [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<p>Note that you can do the same thing in rejection branches. An interesting fact that may catch your eye is that if a <code>.catch</code> branch goes smoothly without errors, then it will be fulfilled with the returned value. That means that if you still want to have an error for that branch, you should <code>throw</code> again. The following piece of code takes an internal error and <strong>masks it</strong> behind a generic <em>“Internal Server Error”</em> message as to not leak off potentially dangerous information to its clients <a href="http://buff.ly/1LA2FcS" target="_blank" rel="noopener">(visualization)</a>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Database ds.214.53.4.12 connection timeout!'</span>))</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> &#123; <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Internal Server Error'</span>) &#125;)</span><br><span class="line">  .catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.info(error))</span><br><span class="line">  <span class="comment">// &lt;- Error: Internal Server Error</span></span><br></pre></td></tr></table></figure>
<p>Mapping promise results is particularly useful when dealing with multiple concurrent promises. Let’s see how that looks like.</p>
<h1 id="Leveraging-Promise-all-and-Promise-race"><a href="#Leveraging-Promise-all-and-Promise-race" class="headerlink" title="Leveraging Promise.all and Promise.race"></a><a href="#leveraging-promiseall-and-promiserace">Leveraging <code>Promise.all</code> and <code>Promise.race</code></a></h1><p>A tremendously common scenario – even more so for those used to Node.js – is to have a dependency on things A and B before being able to do thing C. I’ll proceed that lousy description of the scenario with multiple code snippets. Suppose you wanted to pull the homepage for both Google and Twitter, and then print out the length of each of their responses. Here’s how that looks in the most näive approach possible, with a hypothetical <code>request(url, done)</code> method.</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">request('https<span class="symbol">://google</span>.com', function (<span class="name">err</span>, goog) &#123;</span><br><span class="line">  request('https<span class="symbol">://twitter</span>.com', function (<span class="name">err</span>, twit) &#123;</span><br><span class="line">    console.log(<span class="name">goog</span>.length, twit.length)</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Of course, that’s going to run in series you say! Why would we wait on Google’s response before pulling Twitter’s? The following piece fixes the problem. It’s also ridiculously long, though, right?</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> results = &#123;&#125;</span><br><span class="line"><span class="function"><span class="title">request</span><span class="params">(<span class="string">'https://google.com'</span>, function (err, goog)</span></span> &#123;</span><br><span class="line">  results<span class="selector-class">.goog</span> = goog</span><br><span class="line">  done()</span><br><span class="line">&#125;)</span><br><span class="line"><span class="function"><span class="title">request</span><span class="params">(<span class="string">'https://twitter.com'</span>, function (err, twit)</span></span> &#123;</span><br><span class="line">  results<span class="selector-class">.twit</span> = twit</span><br><span class="line">  done()</span><br><span class="line">&#125;)</span><br><span class="line">function done () &#123;</span><br><span class="line">  <span class="keyword">if</span> (Object.keys(results)<span class="selector-class">.length</span> &lt; <span class="number">2</span>) &#123;</span><br><span class="line">    return</span><br><span class="line">  &#125;</span><br><span class="line">  console.log(results<span class="selector-class">.goog</span><span class="selector-class">.length</span>, results<span class="selector-class">.twit</span><span class="selector-class">.length</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Since nobody wants to be writing code like that, utility libraries like <code>async</code> and <code>contra</code> make this much shorter for you. You can use <code>contra.concurrent</code> to run these methods at the same time and execute a callback once they all ended. Here’s how that’d look like.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">contra.concurrent(&#123;</span><br><span class="line">  goog: <span class="function"><span class="keyword">function</span> <span class="params">(next)</span></span> &#123;</span><br><span class="line">    request(<span class="string">'https://google.com'</span>, <span class="built_in">next</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  twit: <span class="function"><span class="keyword">function</span> <span class="params">(next)</span></span> &#123;</span><br><span class="line">    request(<span class="string">'https://twitter.com'</span>, <span class="built_in">next</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;, <span class="function"><span class="keyword">function</span> <span class="params">(err, results)</span></span> &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(results.goog.length, results.twit.length)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>For the very common <em>“I just want a method that appends that magical <code>next</code> parameter at the end”</em> use case, there’s also <code>contra.curry</code> <em>(equivalent of <code>async.apply</code>)</em> to make the code even shorter.</p>
<figure class="highlight roboconf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">contra.concurrent(&#123;</span><br><span class="line">  <span class="attribute">goog</span>: contra<span class="variable">.curry</span>(request, 'https://google<span class="variable">.com</span>'),</span><br><span class="line">  twit: contra<span class="variable">.curry</span>(request, 'https://twitter<span class="variable">.com</span>')</span><br><span class="line">&#125;, function (err, results) &#123;</span><br><span class="line">  console<span class="variable">.log</span>(results<span class="variable">.goog</span><span class="variable">.length</span>, results<span class="variable">.twit</span><span class="variable">.length</span>)</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Promises already make the “run this after this other thing in series” use case very easy, using <code>.then</code> as we saw in several examples earlier. For the <em>“run these things concurrently”</em> use case, we can use <code>Promise.all</code> <a href="http://buff.ly/1Pyen6L" target="_blank" rel="noopener">(visualization here)</a>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  fetch(<span class="string">'/'</span>),</span><br><span class="line">  fetch(<span class="string">'foo'</span>)</span><br><span class="line">])</span><br><span class="line">  .then(<span class="function"><span class="params">responses</span> =&gt;</span> responses.map(<span class="function"><span class="params">response</span> =&gt;</span> response.statusText))</span><br><span class="line">  .then(<span class="function"><span class="params">status</span> =&gt;</span> <span class="built_in">console</span>.log(status.join(<span class="string">', '</span>)))</span><br><span class="line">  <span class="comment">// &lt;- 'OK, Not Found'</span></span><br></pre></td></tr></table></figure>
<p>Note that even if a single dependency is rejected, the <code>Promise.all</code> method will be rejected entirely as well.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Promise</span>.all([</span><br><span class="line">  <span class="built_in">Promise</span>.reject(),</span><br><span class="line">  fetch(<span class="string">'/'</span>),</span><br><span class="line">  fetch(<span class="string">'foo'</span>)</span><br><span class="line">])</span><br><span class="line">  .then(<span class="function"><span class="params">responses</span> =&gt;</span> responses.map(<span class="function"><span class="params">response</span> =&gt;</span> response.statusText))</span><br><span class="line">  .then(<span class="function"><span class="params">status</span> =&gt;</span> <span class="built_in">console</span>.log(status.join(<span class="string">', '</span>)))</span><br><span class="line">  <span class="comment">// nothing happens</span></span><br></pre></td></tr></table></figure>
<p>In summary, <code>Promise.all</code> has two possible outcomes.</p>
<ul>
<li>Settle with <em>a single</em> rejection <code>reason</code> as soon as one of its dependencies is rejected</li>
<li>Settle with <em>all</em> fulfillment <code>results</code> as soon as all of its dependencies are fulfilled</li>
</ul>
<p>Then there’s <code>Promise.race</code>. This is a similar method to <code>Promise.all</code>, except the first promise to settle will “win” the race, and its value will be passed along to branches of the race. If you run the <a href="http://buff.ly/1gRYr3p" target="_blank" rel="noopener">visualization</a> for the following piece of code a few times, you’ll notice that this race doesn’t have a clear winner. It depends on the server and the network!</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">Promise.race([</span><br><span class="line">  fetch(<span class="string">'/'</span>),</span><br><span class="line">  fetch(<span class="string">'foo'</span>)</span><br><span class="line">])</span><br><span class="line">  .<span class="keyword">then</span>(response =&gt; console.<span class="built_in">log</span>(response.statusText))</span><br><span class="line">  // &lt;- <span class="string">'OK'</span>, <span class="literal">or</span> maybe <span class="string">'Not Found'</span>.</span><br></pre></td></tr></table></figure>
<p>Rejections will also finish the race, and the race promise will be rejected. As a closing note we may indicate that this could be useful for scenarios where we want to time out a promise we otherwise have no control over. For instance, the following race does make sense.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> p = <span class="built_in">Promise</span>.race([</span><br><span class="line">  fetch(<span class="string">'/resource-that-may-take-a-while'</span>),</span><br><span class="line">  <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> (<span class="params">resolve, reject</span>) </span>&#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> reject(<span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'request timeout'</span>)), <span class="number">5000</span>)</span><br><span class="line">  &#125;)</span><br><span class="line">])</span><br><span class="line">p.then(<span class="function"><span class="params">response</span> =&gt;</span> <span class="built_in">console</span>.log(response))</span><br><span class="line">p.catch(<span class="function"><span class="params">error</span> =&gt;</span> <span class="built_in">console</span>.log(error))</span><br></pre></td></tr></table></figure>
<p>To close this article, I’ll leave you with <a href="http://buff.ly/1PyhnQC" target="_blank" rel="noopener">a visualization</a>. It shows the race between a resource and a timeout as shown in the code above.</p>
<p><img src="https://i.imgur.com/9OoMVfo.gif" alt="Race between a resource and a timeout"></p>
<p>Race between a resource and a timeout</p>
<p>Here’s hoping I didn’t make promises even harder to understand for you!</p>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode String -- 5.Reverse Words in a String III]]></title>
      <url>/2018/08/01/leetCode/string/05.reverse_words_in_a_string_III/</url>
      <content type="html"><![CDATA[<h2 id="Reverse-Words-in-a-String-III"><a href="#Reverse-Words-in-a-String-III" class="headerlink" title="Reverse Words in a String III"></a>Reverse Words in a String III</h2><p>Given a string, you need to reverse the order of characters in each word within a sentence while still preserving whitespace and initial word order.</p>
<blockquote>
<p>Example 1:<br>Input: “Let’s take LeetCode contest”<br>Output: “s’teL ekat edoCteeL tsetnoc”</p>
</blockquote>
<p>Note: In the string, each word is separated by single space and there will not be any extra space in the string.</p>
<p><strong>solution：</strong></p>
<p>1.与上题类似，使用对应方法即可：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;string&#125; s</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> reverseWords = <span class="function"><span class="keyword">function</span><span class="params">(s)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">' '</span>).map((value) =&gt; value.split(<span class="string">''</span>).reverse().join(<span class="string">''</span>)).join(<span class="string">' '</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[11.generators]]></title>
      <url>/2018/08/01/pureMaterial/11.generators/</url>
      <content type="html"><![CDATA[<h2 id="generators"><a href="#generators" class="headerlink" title="generators"></a>generators</h2><h2 id="Generator-Functions-and-Generator-Objects"><a href="#Generator-Functions-and-Generator-Objects" class="headerlink" title="Generator Functions and Generator Objects"></a><a href="#generator-functions-and-generator-objects">Generator Functions and Generator Objects</a></h2><p>Generators are a new feature in ES6. You declare a <em>generator function</em> which returns generator objects <code>g</code> that can then be iterated using any of <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/from" target="_blank" rel="noopener"><code>Array.from(g)</code></a>, <a href="/articles/es6-spread-and-butter-in-depth"><code>[...g]</code></a>, or <a href="/articles/es6-iterators-in-depth"><code>for value of g</code></a> loops. Generator functions allow you to declare a special kind of <em>iterator</em>. These iterators can suspend execution while retaining their context. We already examined iterators in <a href="/articles/es6-iterators-in-depth">the previous article</a> and how their <code>.next()</code> method is called once at a time to pull values from a sequence.</p>
<p>Here is an example generator function. Note the <code>*</code> after <code>function</code>. That’s not a typo, that’s how you mark a generator function as a <em>generator</em>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'f'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'o'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'o'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Generator objects conform to both the <em>iterable</em> protocol and the <em>iterator</em> protocol. This means…</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> g = generator()</span><br><span class="line"><span class="comment">// a generator object g is built using the generator function</span></span><br><span class="line"><span class="keyword">typeof</span> g[<span class="built_in">Symbol</span>.iterator] === <span class="string">'function'</span></span><br><span class="line"><span class="comment">// it's an iterable because it has an @@iterator</span></span><br><span class="line"><span class="keyword">typeof</span> g.next === <span class="string">'function'</span></span><br><span class="line"><span class="comment">// it's also an iterator because it has a .next method</span></span><br><span class="line">g[<span class="built_in">Symbol</span>.iterator]() === g</span><br><span class="line"><span class="comment">// the iterator for a generator object is the generator object itself</span></span><br><span class="line"><span class="built_in">console</span>.log([...g])</span><br><span class="line"><span class="comment">// &lt;- ['f', 'o', 'o']</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(g))</span><br><span class="line"><span class="comment">// &lt;- ['f', 'o', 'o']</span></span><br></pre></td></tr></table></figure>
<p><em>(This article is starting to sound an awful lot like a Math course…)</em></p>
<p>When you create a generator object <em>(I’ll just call them “generator” from here on out)</em>, you’ll get an <em>iterator</em> that uses the generator to produce its <em>sequence</em>. Whenever a <code>yield</code> expression is reached, that value is emitted by the iterator and <strong>function execution is suspended</strong>.</p>
<p>Let’s use a different example, this time with some other statements mixed in between <code>yield</code> expressions. This is a simple generator but it behaves in an interesting enough way for our purposes here.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'p'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'o'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'n'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'y'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'f'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'o'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'o'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'!'</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>If we use a <code>for..of</code> loop, this will print <code>ponyfoo!</code> one character at a time, as expected.</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var foo = generator()</span><br><span class="line"><span class="keyword">for</span> (let pony of foo) &#123;</span><br><span class="line">  console.log(pony)</span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'p'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'o'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'n'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'y'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'f'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'o'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'o'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'!'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>What about using the spread <code>[...foo]</code> syntax? Things turn out a little different here. This might be a little unexpected, but that’s how generators work, everything that’s not yielded ends up becoming <strong>a side effect</strong>. As the sequence is being constructed, the <code>console.log</code> statements in between <code>yield</code> calls are executed, and they print characters to the console before <code>foo</code> is spread over an array. The previous example worked because we were printing characters as soon as they were pulled from the sequence, instead of waiting to construct a range for the entire sequence first.</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var foo = generator()</span><br><span class="line">console.log([...foo])</span><br><span class="line"><span class="regexp">//</span> &lt;- <span class="string">'o'</span></span><br><span class="line"><span class="regexp">//</span> &lt;- <span class="string">'y'</span></span><br><span class="line"><span class="regexp">//</span> &lt;- <span class="string">'o'</span></span><br><span class="line"><span class="regexp">//</span> &lt;- <span class="string">'!'</span></span><br><span class="line"><span class="regexp">//</span> &lt;- [<span class="string">'p'</span>, <span class="string">'n'</span>, <span class="string">'f'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure>
<p>A neat aspect of generator functions is that you can also use <code>yield*</code> to delegate to another generator function. Want a very contrived way to split <code>&#39;ponyfoo&#39;</code> into individual characters? Since strings in ES6 adhere to the <em>iterable</em> protocol, you could do the following.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">yield</span>* <span class="string">'ponyfoo'</span></span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>([...generator()])</span><br><span class="line">// &lt;- [<span class="string">'p'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>, <span class="string">'y'</span>, <span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure>
<p>Of course, in the real world you could just do <code>[...&#39;ponyfoo&#39;]</code>, since spread supports iterables just fine. Just like you could <code>yield*</code> a string, you can <code>yield*</code> anything that adheres to the iterable protocol. That includes other generators, arrays, and come ES6 – <em>just about anything.</em></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123;</span><br><span class="line">  [Symbol.iterator]: () =&gt; (&#123;</span><br><span class="line">    items: [<span class="string">'p'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>, <span class="string">'y'</span>, <span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>],</span><br><span class="line">    <span class="built_in">next</span>: <span class="function"><span class="keyword">function</span> <span class="title">next</span> <span class="params">()</span></span> &#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: this.items.length === <span class="number">0</span>,</span><br><span class="line">        value: this.items.shift()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">multiplier</span> <span class="params">(value)</span></span> &#123;</span><br><span class="line">  <span class="built_in">yield</span> value * <span class="number">2</span></span><br><span class="line">  <span class="built_in">yield</span> value * <span class="number">3</span></span><br><span class="line">  <span class="built_in">yield</span> value * <span class="number">4</span></span><br><span class="line">  <span class="built_in">yield</span> value * <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">trailmix</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">yield</span> <span class="number">0</span></span><br><span class="line">  <span class="built_in">yield</span>* [<span class="number">1</span>, <span class="number">2</span>]</span><br><span class="line">  <span class="built_in">yield</span>* [...multiplier(<span class="number">2</span>)]</span><br><span class="line">  <span class="built_in">yield</span>* multiplier(<span class="number">3</span>)</span><br><span class="line">  <span class="built_in">yield</span>* foo</span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>([...trailmix()])</span><br><span class="line">// &lt;- [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>, <span class="number">10</span>, <span class="number">6</span>, <span class="number">9</span>, <span class="number">12</span>, <span class="number">15</span>, <span class="string">'p'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>, <span class="string">'y'</span>, <span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure>
<p>You could also iterate the sequence by hand, calling <code>.next()</code>. This approach gives you the most control over the iteration, but it’s also the most involved. There’s a few features you can leverage here that give you even more control over the iteration.</p>
<h2 id="Iterating-Over-Generators-by-Hand"><a href="#Iterating-Over-Generators-by-Hand" class="headerlink" title="Iterating Over Generators by Hand"></a><a href="#iterating-over-generators-by-hand">Iterating Over Generators by Hand</a></h2><p>Besides iterating over <code>trailmix</code> as we’ve already covered, using <code>[...trailmix()]</code>, <code>for value of trailmix()</code>, and <code>Array.from(trailmix())</code>, we could use the generator returned by <code>trailmix()</code> directly, and iterate over that. But <code>trailmix</code> was an overcomplicated showcase of <code>yield*</code>, let’s go back to the <em>side-effects</em> <code>generator</code> for this one.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'p'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'o'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'n'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'y'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'f'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'o'</span>)</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'o'</span></span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'!'</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = generator()</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> item = g.next()</span><br><span class="line">  <span class="keyword">if</span> (item.done) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(item.value)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Just like we <a href="/articles/es6-iterators-in-depth">learned yesterday</a>, any items returned by an iterator will have a <code>done</code> property that indicates whether the sequence has reached its end, and a <code>value</code> indicating the current value in the sequence.</p>
<blockquote>
<p>If you’re confused as to <strong>why the <code>&#39;!&#39;</code> is printed</strong> even though there are no more <code>yield</code> expressions after it, that’s because <code>g.next()</code> doesn’t know that. The way it works is that each time its called, it executes the method until a <code>yield</code> expression is reached, emits its value and <em>suspends execution</em>. The next time <code>g.next()</code> is called, _execution is resumed _from where it left off <em>(the last <code>yield</code> expression)</em>, until the next <code>yield</code> expression is reached. When no <code>yield</code> expression is reached, the generator returns <code>{ done: true }</code>, signaling that the sequence has ended. At this point, the <code>console.log(&#39;!&#39;)</code> statement has been already executed, though.</p>
<p>It’s also worth noting that <strong>context is preserved</strong> across suspensions and resumptions. That means generators can be stateful. Generators are, in fact, the underlying implementation for <code>async</code>/<code>await</code> semantics coming in ES7.</p>
</blockquote>
<p>Whenever <code>.next()</code> is called on a generator, there’s four “events” that will suspend execution in the generator, returning an <em><code>IteratorResult</code></em> to the caller of <code>.next()</code>.</p>
<ul>
<li>A <code>yield</code> expression returning the <em>next</em> value in the sequence</li>
<li>A <code>return</code> statement returning the <em>last</em> value in the sequence</li>
<li>A <code>throw</code> statement halts execution in the generator entirely</li>
<li>Reaching the end of the generator function signals <code>{ done: true }</code></li>
</ul>
<p>Once the <code>g</code> generator ended iterating over a sequence, subsequent calls to <code>g.next()</code> will have no effect and just return <code>{ done: true }</code>.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">generator</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">yield</span> <span class="string">'only'</span></span><br><span class="line">&#125;</span><br><span class="line">var g = generator()</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="built_in">next</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">false</span>, value: <span class="string">'only'</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="built_in">next</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">true</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="built_in">next</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<h2 id="Generators-The-Weird-Awesome-Parts"><a href="#Generators-The-Weird-Awesome-Parts" class="headerlink" title="Generators: The Weird Awesome Parts"></a><a href="#generators-the-del-weird-del-ins-awesome-ins-parts">Generators: The Weird <em>Awesome</em> Parts</a></h2><p>Generator objects come with a couple more methods besides <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/next" target="_blank" rel="noopener"><code>.next</code></a>. These are <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return" target="_blank" rel="noopener"><code>.return</code></a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw" target="_blank" rel="noopener"><code>.throw</code></a>. We’ve already covered <code>.next</code> extensively, but not quite. You could also use <code>.next(value)</code> to send values <em>into the generator</em>.</p>
<p>Let’s make <strong>a magic 8-ball generator</strong>. First off, you’ll need some answers. Wikipedia obliges, yielding <a href="https://en.wikipedia.org/wiki/Magic_8-Ball#Possible_answers" target="_blank" rel="noopener">20 possible answers</a> for our magic 8-ball.</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var answers = [</span><br><span class="line">  `It is certain`, `It is decidedly so`, `Without <span class="literal">a</span> doubt`,</span><br><span class="line">  `Yes definitely`, `You may rely on it`, `As I see it, yes`,</span><br><span class="line">  `Most likely`, `Outlook good`, `Yes`, `Signs point to yes`,</span><br><span class="line">  `Reply hazy try again`, `Ask again later`, `Better <span class="literal">not</span> tell you now`,</span><br><span class="line">  `Cannot predict now`, `Concentrate <span class="literal">and</span> ask again`,</span><br><span class="line">  `Don't count on it`, `My reply is no`, `My sources say no`,</span><br><span class="line">  `Outlook <span class="literal">not</span> so good`, `Very doubtful`</span><br><span class="line">]</span><br><span class="line">function answer () &#123;</span><br><span class="line">  <span class="keyword">return</span> answers[Math.floor(Math.random() * answers.length)]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The following generator function can act as a <em>“genie”</em> that answers any questions you might have for them. Note how we discard the first result from <code>g.next()</code>. That’s because the first call to <code>.next</code> enters the generator and there’s no <code>yield</code> expression waiting to capture the <code>value</code> from <code>g.next(value)</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">chat</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> question = <span class="keyword">yield</span> <span class="string">'[Genie] '</span> + answer()</span><br><span class="line">    <span class="built_in">console</span>.log(question)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = chat()</span><br><span class="line">g.next()</span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">'[Me] Will ES6 die a painful death?'</span>).value)</span><br><span class="line"><span class="comment">// &lt;- '[Me] Will ES6 die a painful death?'</span></span><br><span class="line"><span class="comment">// &lt;- '[Genie] My sources say no'</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next(<span class="string">'[Me] How youuu doing?'</span>).value)</span><br><span class="line"><span class="comment">// &lt;- '[Me] How youuu doing?'</span></span><br><span class="line"><span class="comment">// &lt;- '[Genie] Concentrate and ask again'</span></span><br></pre></td></tr></table></figure>
<p>Randomly dropping <code>g.next()</code> feels like a very dirty coding practice, though. What else could we do? We could flip responsibilities around.</p>
<h3 id="Inversion-of-Control"><a href="#Inversion-of-Control" class="headerlink" title="Inversion of Control"></a><a href="#inversion-of-control">Inversion of Control</a></h3><p>We could have the Genie be in control, and have the generator ask the questions. How would that look like? At first, you might think that the code below is unconventional, but in fact, most libraries built around generators work by inverting responsibility.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">chat</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'[Me] Will ES6 die a painful death?'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'[Me] How youuu doing?'</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = chat()</span><br><span class="line"><span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">let</span> question = g.next()</span><br><span class="line">  <span class="keyword">if</span> (question.done) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(question.value)</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'[Genie] '</span> + answer())</span><br><span class="line">  <span class="comment">// &lt;- '[Me] Will ES6 die a painful death?'</span></span><br><span class="line">  <span class="comment">// &lt;- '[Genie] Very doubtful'</span></span><br><span class="line">  <span class="comment">// &lt;- '[Me] How youuu doing?'</span></span><br><span class="line">  <span class="comment">// &lt;- '[Genie] My reply is no'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You would expect the <strong>generator to do the heavy lifting</strong> of an iteration, but in fact generators make it easy to iterate over things by suspending execution of themselves – and deferring the heavy lifting. That’s one of the most powerful aspects of generators. Suppose now that the iterator is a <code>genie</code> method in a library, like so:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genie</span> (<span class="params">questions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = questions()</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> question = g.next()</span><br><span class="line">    <span class="keyword">if</span> (question.done) &#123;</span><br><span class="line">      <span class="keyword">break</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">console</span>.log(question.value)</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'[Genie] '</span> + answer())</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To use it, all you’d have to do is pass in a simple generator like the one we just made.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">genie(<span class="function"><span class="keyword">function</span>* <span class="title">questions</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'[Me] Will ES6 die a painful death?'</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="string">'[Me] How youuu doing?'</span></span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<p>Compare that to the generator we had before, where questions were sent to the generator instead of the other way around. See how much more complicated the logic would have to be to achieve the same goal? Letting the library deal with the flow control means you can <strong>just worry about the <em>thing</em> you want to iterate</strong> over, and you can <strong>delegate <em>how</em> to iterate over it</strong>. But yes, it does mean your code now has an asterisk in it. <em>Weird.</em></p>
<h3 id="Dealing-with-asynchronous-flows"><a href="#Dealing-with-asynchronous-flows" class="headerlink" title="Dealing with asynchronous flows"></a><a href="#dealing-with-asynchronous-flows">Dealing with asynchronous flows</a></h3><p>Imagine now that the <code>genie</code> library gets its magic 8-ball answers from an API. How does that look then? Probably something like the snippet below. Assume the <a href="https://github.com/Raynos/xhr" target="_blank" rel="noopener"><code>xhr</code></a> pseudocode call always yields JSON responses like <code>{ answer: &#39;No&#39; }</code>. Keep in mind this is a simple example that just processes each question in series. You could put together different and more complex flow control algorithms depending on what you’re looking for.</p>
<p>This is just a demonstration of the sheer power of generators.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genie</span> (<span class="params">questions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = questions()</span><br><span class="line">  pull()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pull</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> question = g.next()</span><br><span class="line">    <span class="keyword">if</span> (question.done) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ask(question.value, pull)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ask</span> (<span class="params">q, next</span>) </span>&#123;</span><br><span class="line">    xhr(<span class="string">'https://computer.genie/?q='</span> + <span class="built_in">encodeURIComponent</span>(q), got)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">got</span> (<span class="params">err, res, body</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        <span class="comment">// todo</span></span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(q)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[Genie] '</span> + body.answer)</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>See <a href="http://buff.ly/1UimWsZ" target="_blank" rel="noopener">this link for a live demo</a> on the Babel REPL</p>
<p>Even though we’ve just made our <code>genie</code> method asynchronous and are now using an API to fetch responses to the user’s questions, the way the consumer uses the <code>genie</code> library by passing a <code>questions</code> generator function <em>remains unchanged!</em> That’s awesome.</p>
<p>We haven’t handled the case for an <code>err</code> coming out of the API. That’s inconvenient. What can we do about that one?</p>
<h3 id="Throwing-at-a-Generator"><a href="#Throwing-at-a-Generator" class="headerlink" title="Throwing at a Generator"></a><a href="#throwing-at-a-generator">Throwing <em>at</em> a Generator</a></h3><p>Now that we’ve figured out that the most important aspect of generators is <em>actually the control flow code</em> that decides when to call <code>g.next()</code>, we can look at the other two methods and actually understand their purpose. Before shifting our thinking into <em>“the generator defines <strong>what</strong> to iterate over, not the <strong>how</strong>”</em>, we would’ve been hard pressed to find a user case for <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw" target="_blank" rel="noopener"><code>g.throw</code></a>. Now however it seems immediately obvious. The flow control that leverages a generator needs to be able to tell the generator that’s yielding the sequence to be iterated when something goes wrong processing an item in the sequence.</p>
<p>In the case of our <code>genie</code> flow, that is now using <a href="https://github.com/Raynos/xhr" target="_blank" rel="noopener"><code>xhr</code></a>, we may experience network issues and be unable to continue processing items, or we may want to warn the user about unexpected errors. Here’s how, we simply add <code>g.throw(error)</code> in our control flow code.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">genie</span> (<span class="params">questions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> g = questions()</span><br><span class="line">  pull()</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">pull</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> question = g.next()</span><br><span class="line">    <span class="keyword">if</span> (question.done) &#123;</span><br><span class="line">      <span class="keyword">return</span></span><br><span class="line">    &#125;</span><br><span class="line">    ask(question.value, pull)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">ask</span> (<span class="params">q, next</span>) </span>&#123;</span><br><span class="line">    xhr(<span class="string">'https://computer.genie/?q='</span> + <span class="built_in">encodeURIComponent</span>(q), got)</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">got</span> (<span class="params">err, res, body</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">if</span> (err) &#123;</span><br><span class="line">        g.throw(err)</span><br><span class="line">      &#125;</span><br><span class="line">      <span class="built_in">console</span>.log(q)</span><br><span class="line">      <span class="built_in">console</span>.log(<span class="string">'[Genie] '</span> + body.answer)</span><br><span class="line">      next()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <em>user code</em> is still unchanged, though. In between <code>yield</code> statements it may throw errors now. You could use <code>try</code>/<code>catch</code> blocks to address those issues. If you do this, execution will be able to resume. The good thing is that this is up to the user, it’s still perfectly sequential on their end, and they can leverage <code>try</code>/<code>catch</code> semantics just like in high-school.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">genie(<span class="function"><span class="keyword">function</span>* <span class="title">questions</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'[Me] Will ES6 die a painful death?'</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Error'</span>, e.message)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">try</span> &#123;</span><br><span class="line">    <span class="keyword">yield</span> <span class="string">'[Me] How youuu doing?'</span></span><br><span class="line">  &#125; <span class="keyword">catch</span> (e) &#123;</span><br><span class="line">    <span class="built_in">console</span>.error(<span class="string">'Error'</span>, e.message)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Returning-on-Behalf-of-a-Generator"><a href="#Returning-on-Behalf-of-a-Generator" class="headerlink" title="Returning on Behalf of a Generator"></a><a href="#returning-on-behalf-of-a-generator">Returning on Behalf of a Generator</a></h3><p>Usually not as interesting in asynchronous control flow mechanisms in general, the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/return" target="_blank" rel="noopener"><code>g.return()</code></a> method allows you to resume execution inside a generator function, much like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Generator/throw" target="_blank" rel="noopener"><code>g.throw()</code></a> did moments earlier. The key difference is that <code>g.return()</code> won’t result in an exception at the generator level, although <strong>it will end the sequence.</strong></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="built_in">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="built_in">yield</span> <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line">var g = numbers()</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="built_in">next</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">false</span>, value: <span class="number">1</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="keyword">return</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">true</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="built_in">next</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">true</span> &#125;, as we know</span><br></pre></td></tr></table></figure>
<p>You could also return a <code>value</code> using <code>g.return(value)</code>, and the resulting <code>IteratorResult</code> will contain said <code>value</code>. This is equivalent to having <code>return value</code> somewhere in the generator function. You should be careful there though – as neither <code>for..of</code>, <code>[...generator()]</code>, nor <code>Array.from(generator())</code> include the <code>value</code> in the <code>IteratorResult</code> that signals <code>{ done: true }</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="keyword">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log([...numbers()])</span><br><span class="line"><span class="comment">// &lt;- [1, 2]</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Array</span>.from(numbers()))</span><br><span class="line"><span class="comment">// &lt;- [1, 2]</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> n <span class="keyword">of</span> numbers()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(n)</span><br><span class="line">  <span class="comment">// &lt;- 1</span></span><br><span class="line">  <span class="comment">// &lt;- 2</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> g = numbers()</span><br><span class="line"><span class="built_in">console</span>.log(g.next())</span><br><span class="line"><span class="comment">// &lt;- &#123; done: false, value: 1 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next())</span><br><span class="line"><span class="comment">// &lt;- &#123; done: false, value: 2 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next())</span><br><span class="line"><span class="comment">// &lt;- &#123; done: true, value: 3 &#125;</span></span><br><span class="line"><span class="built_in">console</span>.log(g.next())</span><br><span class="line"><span class="comment">// &lt;- &#123; done: true &#125;</span></span><br></pre></td></tr></table></figure>
<p>Using <code>g.return</code> is no different in this regard, think of it as the programmatic equivalent of what we just did.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">yield</span> <span class="number">1</span></span><br><span class="line">  <span class="built_in">yield</span> <span class="number">2</span></span><br><span class="line">  <span class="keyword">return</span> <span class="number">3</span></span><br><span class="line">  <span class="built_in">yield</span> <span class="number">4</span></span><br><span class="line">&#125;</span><br><span class="line">var g = numbers()</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="built_in">next</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">false</span>, value: <span class="number">1</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="keyword">return</span>(<span class="number">5</span>))</span><br><span class="line">// &lt;- &#123; done: <span class="literal">true</span>, value: <span class="number">5</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="built_in">next</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">true</span> &#125;</span><br></pre></td></tr></table></figure>
<p>You can avoid the impending sequence termination, <a href="http://www.2ality.com/2015/03/es6-generators.html" target="_blank" rel="noopener">as Axel points out</a>, if the code in the generator function when <code>g.return()</code> got called is wrapped in <code>try</code>/<code>finally</code>. Once the <code>yield</code> expressions in the <code>finally</code> block are over, the sequence <em>will</em> end with the <code>value</code> passed to <code>g.return(value)</code></p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">numbers</span> <span class="params">()</span></span> &#123;</span><br><span class="line">  <span class="built_in">yield</span> <span class="number">1</span></span><br><span class="line">  try &#123;</span><br><span class="line">    <span class="built_in">yield</span> <span class="number">2</span></span><br><span class="line">  &#125; finally &#123;</span><br><span class="line">    <span class="built_in">yield</span> <span class="number">3</span></span><br><span class="line">    <span class="built_in">yield</span> <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">yield</span> <span class="number">5</span></span><br><span class="line">&#125;</span><br><span class="line">var g = numbers()</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="built_in">next</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">false</span>, value: <span class="number">1</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="built_in">next</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">false</span>, value: <span class="number">2</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="keyword">return</span>(<span class="number">6</span>))</span><br><span class="line">// &lt;- &#123; done: <span class="literal">false</span>, value: <span class="number">3</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="built_in">next</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">false</span>, value: <span class="number">4</span> &#125;</span><br><span class="line">console.<span class="built_in">log</span>(g.<span class="built_in">next</span>())</span><br><span class="line">// &lt;- &#123; done: <span class="literal">true</span>, value: <span class="number">6</span> &#125;</span><br></pre></td></tr></table></figure>
<p>That’s all there is to know when it comes to generators <em>in terms of functionality.</em></p>
<h2 id="Use-Cases-for-ES6-Generators"><a href="#Use-Cases-for-ES6-Generators" class="headerlink" title="Use Cases for ES6 Generators"></a><a href="#use-cases-for-es6-generators">Use Cases for ES6 Generators</a></h2><p>At this point in the article you should feel comfortable with the concepts of iterators, iterables, and generators in ES6. If you feel like reading more on the subject, I highly recommend you go over <a href="http://www.2ality.com/2015/03/es6-generators.html" target="_blank" rel="noopener">Axel’s article on generators</a>, as he put together an amazing write-up on use cases for generators just <em>a few months ago</em>.</p>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode String -- 4.Reverse String]]></title>
      <url>/2018/08/01/leetCode/string/04.reverse_string/</url>
      <content type="html"><![CDATA[<h2 id="Reverse-String"><a href="#Reverse-String" class="headerlink" title="Reverse String"></a>Reverse String</h2><p>Write a function that takes a string as input and returns the string reversed</p>
<blockquote>
<p>Example:<br>Given s = “hello”, return “olleh”.</p>
</blockquote>
<p><strong>solution：</strong></p>
<p>1.使用string的方法，拆分字符串，反序然后拼接：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;<span class="built_in">string</span>&#125; s</span><br><span class="line"> * @<span class="keyword">return</span> &#123;<span class="built_in">string</span>&#125;</span><br><span class="line"> */</span><br><span class="line">var reverseString = <span class="function"><span class="keyword">function</span><span class="params">(s)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> s.split(<span class="string">''</span>).<span class="built_in">reverse</span>().join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.使用es6的用法，可以减少split(‘’)来拆分：</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">/**</span><br><span class="line"> * @param &#123;<span class="built_in">string</span>&#125; s</span><br><span class="line"> * @<span class="keyword">return</span> &#123;<span class="built_in">string</span>&#125;</span><br><span class="line"> */</span><br><span class="line">var reverseString = <span class="function"><span class="keyword">function</span><span class="params">(s)</span></span> &#123;</span><br><span class="line">    <span class="keyword">return</span> [...s].<span class="built_in">reverse</span>().join(<span class="string">''</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[10.iterators]]></title>
      <url>/2018/08/01/pureMaterial/10.iterators/</url>
      <content type="html"><![CDATA[<h2 id="iterators"><a href="#iterators" class="headerlink" title="iterators"></a>iterators</h2><h2 id="Iterator-Protocol-and-Iterable-Protocol"><a href="#Iterator-Protocol-and-Iterable-Protocol" class="headerlink" title="Iterator Protocol and Iterable Protocol"></a><a href="#iterator-protocol-and-iterable-protocol">Iterator Protocol and Iterable Protocol</a></h2><blockquote>
<p><em>There’s a lot of new, intertwined terminology here. Please bear with me as I get some of these explanations out of the way!</em></p>
</blockquote>
<p>JavaScript gets two new protocols in ES6, <em>Iterators</em> and <em>Iterables</em>. In plain terms, you can think of protocols as <em>conventions</em>. As long as you follow a determined convention in the language, you get a side-effect. The <em>iterable</em> protocol allows you to define the behavior when JavaScript objects are being iterated. Under the hood, deep in the world of JavaScript interpreters and language specification <em>keyboard-smashers</em>, we have the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="noopener"><code>@@iterator</code></a> method. This method underlies the <em>iterable</em> protocol and, in the real world, you can assign to it using something called “the <em>“well-known”</em> <code>Symbol.iterator</code> Symbol”.</p>
<p>We’ll get back to <a href="/articles/es6-symbols-in-depth">what Symbols are</a> <em>later in the series</em>. Before losing focus, you should know that the <code>@@iterator</code> method is called <strong>once, whenever an object needs to be iterated</strong>. For example, at the beginning of a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Statements/for...of" target="_blank" rel="noopener"><code>for..of</code></a> loop <em>(which we’ll also get back to in a few minutes)</em>, the <code>@@iterator</code> will be asked for an <em>iterator</em>. The returned <em>iterator</em> will be used to obtain values out of the object.</p>
<p>Let’s use the snippet of code found below as a crutch to understand the concepts behind iteration. The first thing you’ll notice is that I’m making my object an iterable by assigning to it’s mystical <code>@@iterator</code> property through the <code>Symbol.iterator</code> property. I can’t use the symbol as a property name directly. Instead, I have to wrap in square brackets, meaning it’s a computed property name that evaluates to the <code>Symbol.iterator</code> <em>expression</em> – as you might recall from the <a href="/articles/es6-object-literal-features-in-depth">article on object literals</a>. The object returned by the method assigned to the <code>[Symbol.iterator]</code> property must adhere to the <em>iterator</em> protocol. The <em>iterator</em> protocol defines how to get values out of an object, and we must return an <code>@@iterator</code> that adheres to <em>iterator</em> protocol. The protocol indicates we must have an object with a <code>next</code> method. The <code>next</code> method takes no arguments and it should return an object with these two properties.</p>
<ul>
<li><code>done</code> signals that the sequence has ended when <code>true</code>, and <code>false</code> means there may be more values</li>
<li><code>value</code> is the current item in the sequence</li>
</ul>
<p>In my example, the iterator method returns an object that has a finite list of items and which emits those items until there aren’t any more left. The code below is an iterable object in ES6.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="params">()</span> =&gt;</span> (&#123;</span><br><span class="line">    items: [<span class="string">'p'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>, <span class="string">'y'</span>, <span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>],</span><br><span class="line">    next: <span class="function"><span class="keyword">function</span> <span class="title">next</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> &#123;</span><br><span class="line">        done: <span class="keyword">this</span>.items.length === <span class="number">0</span>,</span><br><span class="line">        value: <span class="keyword">this</span>.items.shift()</span><br><span class="line">      &#125;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To actually iterate over the object, we could use <code>for..of</code>. How would that look like? See below. The <code>for..of</code> iteration method is also new in ES6, and it settles the everlasting war against looping over JavaScript collections and randomly finding things that didn’t belong in the result-set you were expecting.</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (let pony of foo) &#123;</span><br><span class="line">  console.log(pony)</span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'p'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'o'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'n'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'y'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'f'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'o'</span></span><br><span class="line">  <span class="regexp">//</span> &lt;- <span class="string">'o'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>You can use <code>for..of</code> to iterate over any object that adheres to the <em>iterable</em> protocol. In ES6, that includes arrays, any objects with an user-defined <code>[Symbol.iterator]</code> method, <a href="/articles/es6-generators-in-depth"><em>generators</em></a>, DOM node collections from <a href="https://developer.mozilla.org/en-US/docs/Web/API/Element/querySelectorAll" target="_blank" rel="noopener"><code>.querySelectorAll</code></a> and friends, etc. If you just want to <em>“cast”</em> any iterable into an array, a couple of terse alternatives would be using the <a href="/articles/es6-spread-and-butter-in-depth">spread operator</a> and <code>Array.from</code>.</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log([...foo])</span><br><span class="line"><span class="regexp">//</span> &lt;- [<span class="string">'p'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>, <span class="string">'y'</span>, <span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>]</span><br><span class="line"><span class="built_in">console</span>.log(Array.<span class="keyword">from</span>(foo))</span><br><span class="line"><span class="regexp">//</span> &lt;- [<span class="string">'p'</span>, <span class="string">'o'</span>, <span class="string">'n'</span>, <span class="string">'y'</span>, <span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure>
<p>To recap, our <code>foo</code> object adheres to the <em>iterable</em> protocol by assigning a method to <code>[Symbol.iterator]</code> <em>– anywhere in the prototype chain for <code>foo</code> would work</em>. This means that the object is <em>iterable</em>: it can be iterated. Said method returns an object that adheres to the <em>iterator</em> protocol. The iterator method is called once whenever we want to start iterating over the object, and the returned <em>iterator</em> is used to pull values out of <code>foo</code>. To iterate over iterables, we can use <code>for..of</code>, the <a href="/articles/es6-spread-and-butter-in-depth">spread operator</a>, or <code>Array.from</code>.</p>
<h2 id="What-Does-This-All-Mean"><a href="#What-Does-This-All-Mean" class="headerlink" title="What Does This All Mean?"></a><a href="#what-does-this-all-mean">What Does This All Mean?</a></h2><p>In essence, the selling point about iteration protocols, <code>for..of</code>, <code>Array.from</code>, and the spread operator is that they provide expressive ways to effortlessly iterate over collections and array-likes <em>(such as <code>arguments</code>)</em>. Having the ability to define how any object may be iterated is huge, because it enables any libraries like <a href="http://lodash.com/docs" target="_blank" rel="noopener">lo-dash</a> to converge under a protocol the language natively understands <em>– iterables.</em> This is <strong>huge</strong>.</p>
<p>Just to give you another example, remember how I always complain about jQuery wrapper objects not being <a href="http://ponyfoo.com/articles/how-to-avoid-objectprototype-pollution" target="_blank" rel="noopener">true arrays</a>, or how <code>document.querySelectorAll</code> doesn’t return a true array either? If jQuery implemented the iterator protocol on their collection’s prototype, then you could do something like below.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> $(<span class="string">'li'</span>)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(item)</span><br><span class="line">  <span class="comment">// &lt;- the &lt;li&gt; wrapped in a jQuery object</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Why wrapped? Because it’s more expressive. You could easily iterate as deep as you need to.</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="built_in">list</span> <span class="keyword">of</span> $(<span class="string">'ul'</span>)) &#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> item <span class="keyword">of</span> <span class="built_in">list</span>.find(<span class="string">'li'</span>)) &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(item)</span><br><span class="line">    <span class="comment">// &lt;- the &lt;li&gt; wrapped in a jQuery object</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This brings me to an important aspect of iterables and iterators.</p>
<h2 id="Lazy-in-Nature"><a href="#Lazy-in-Nature" class="headerlink" title="Lazy in Nature"></a><a href="#lazy-in-nature">Lazy in Nature</a></h2><p>Iterators are <em>lazy in nature</em>. This is fancy-speak for saying that the sequence is accessed one item at a time. It can even be an infinite sequence – a legitimate scenario with many use cases. Given that iterators are lazy, having jQuery wrap every result in the sequence with their wrapper object wouldn’t have a big upfront cost. Instead, a wrapper is created each time a value is pulled from the <em>iterator</em>.</p>
<p>How would an infinite iterator look? The example below shows an iterator with a <code>1..Infinity</code> range. Note how it will never yields <code>done: true</code>, signaling that the sequence is over. Attempting to cast the iterable <code>foo</code> object into an array using either <code>Array.from(foo)</code> or <code>[...foo]</code> would crash our program, since the sequence <em>never ends</em>. We must be very careful with these types of sequences as they can crash and burn our Node process, or the human’s browser tab.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.iterator]: <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span></span><br><span class="line">    <span class="keyword">return</span> &#123; <span class="attr">next</span>: <span class="function"><span class="params">()</span> =&gt;</span> (&#123; <span class="attr">value</span>: ++i &#125;) &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The correct way of working with such an iterator is with an escape condition that prevents the loop from going infinite. The example below loops over our infinite sequence using <code>for..of</code>, but it breaks the loop as soon as the value goes over <code>10</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> pony <span class="keyword">of</span> foo) &#123;</span><br><span class="line">  <span class="keyword">if</span> (pony &gt; <span class="number">10</span>) &#123;</span><br><span class="line">    <span class="keyword">break</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(pony)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>The iterator doesn’t really <em>know</em> that the sequence is infinite. In that regard, this is similar to the <a href="https://en.wikipedia.org/wiki/Halting_problem" target="_blank" rel="noopener">halting problem</a> – there is no way of knowing whether the sequence is infinite or not in code.</p>
<p><img src="https://imgs.xkcd.com/comics/halting_problem.png" alt="The halting problem depicted by XKCD"></p>
<p>We <strong>usually have a good idea</strong> about whether a sequence is <em>finite or infinite</em>, since we construct those sequences. Whenever we have an infinite sequence it’s up to us to add an escape condition that ensures our program won’t crash in an attempt to loop over every single value in the sequence.</p>
</blockquote>
<p><em>Come back tomorrow for <a href="/articles/es6-generators-in-depth">a discussion about generators!</a></em></p>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[09.Symbols]]></title>
      <url>/2018/08/01/pureMaterial/09.symbol/</url>
      <content type="html"><![CDATA[<h2 id="symbols"><a href="#symbols" class="headerlink" title="symbols"></a>symbols</h2><h2 id="What-are-Symbols"><a href="#What-are-Symbols" class="headerlink" title="What are Symbols?"></a><a href="#what-are-symbols">What are Symbols?</a></h2><p>Symbols are a new primitive type in ES6. If you ask me, they’re <em>an awful lot like strings</em>. Just like with numbers and strings, symbols also come with their accompanying <code>Symbol</code> wrapper object.</p>
<p>We can create our own Symbols.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mystery = <span class="built_in">Symbol</span>()</span><br></pre></td></tr></table></figure>
<p>Note that there was no <code>new</code>. The <code>new</code> operator even throws a <code>TypeError</code> when we try it on <code>Symbol</code>.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> oops = <span class="keyword">new</span> <span class="built_in">Symbol</span>()</span><br><span class="line"><span class="comment">// &lt;- TypeError</span></span><br></pre></td></tr></table></figure>
<p>For debugging purposes, you can describe symbols.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> mystery = <span class="built_in">Symbol</span>(<span class="string">'this is a descriptive description'</span>)</span><br></pre></td></tr></table></figure>
<p>Symbols are <em>immutable</em>. Just like numbers or strings. Note however that symbols are <em>unique</em>, unlike primitive numbers and strings.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>() === <span class="built_in">Symbol</span>())</span><br><span class="line"><span class="comment">// &lt;- false</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>(<span class="string">'foo'</span>))</span><br><span class="line"><span class="comment">// &lt;- false</span></span><br></pre></td></tr></table></figure>
<p>Symbols are <em>symbols</em>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>())</span><br><span class="line"><span class="comment">// &lt;- 'symbol'</span></span><br><span class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> <span class="built_in">Symbol</span>(<span class="string">'foo'</span>))</span><br><span class="line"><span class="comment">// &lt;- 'symbol'</span></span><br></pre></td></tr></table></figure>
<p>There are three different flavors of symbols – each flavor is accessed in a different way. We’ll explore each of these and slowly figure out what all of this means.</p>
<ul>
<li>You can access local symbols by obtaining a reference to them <em>directly</em></li>
<li>You can place symbols on the <em>global registry</em> and access them across <em>realms</em></li>
<li>“Well-known” symbols exist across <em>realms</em> – but you can’t create them and they’re not on the <em>global registry</em></li>
</ul>
<p>What the heck is a <em>realm</em>, you say? A <em>realm</em> is <strong>spec-speak</strong> for any execution context, such as the page your application is running in, or an <code>&lt;iframe&gt;</code> within your page.</p>
<h2 id="The-“Runtime-Wide”-Symbol-Registry"><a href="#The-“Runtime-Wide”-Symbol-Registry" class="headerlink" title="The “Runtime-Wide” Symbol Registry"></a><a href="#the-runtime-wide-symbol-registry">The “Runtime-Wide” Symbol Registry</a></h2><p>There’s two methods you can use to add symbols to the runtime-wide symbol registry: <code>Symbol.for(key)</code> and <code>Symbol.keyFor(symbol)</code>. What do these do?</p>
<h3 id="Symbol-for-key"><a href="#Symbol-for-key" class="headerlink" title="Symbol.for(key)"></a><a href="#symbolfor-key"><code>Symbol.for(key)</code></a></h3><p>This method looks up <code>key</code> in the runtime-wide symbol registry. If a symbol with that <code>key</code> exists in the global registry, that symbol is returned. If no symbol with that <code>key</code> is found in the registry, one is created. That’s to say, <code>Symbol.for(key)</code> is <em>idempotent</em>. In the snippet below, the first call to <code>Symbol.for(&#39;foo&#39;)</code> creates a symbol, adds it to the registry, and returns it. The second call returns that same symbol because the <code>key</code> is already in the registry by then – and associated to the symbol returned by the first call.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br></pre></td></tr></table></figure>
<p>That is in contrast to what we knew about symbols being unique. The global symbol registry however keeps track of symbols by a <code>key</code>. Note that your <code>key</code> will also be used as a <code>description</code> when the symbols that go into the registry are created. Also note that these symbols are <strong>as global as globals get in JavaScript</strong>, so play nice and use a prefix and don’t just name your symbols <code>&#39;user&#39;</code> or some generic name like that.</p>
<h3 id="Symbol-keyFor-symbol"><a href="#Symbol-keyFor-symbol" class="headerlink" title="Symbol.keyFor(symbol)"></a><a href="#symbolkeyfor-symbol"><code>Symbol.keyFor(symbol)</code></a></h3><p>Given a symbol <code>symbol</code>, <code>Symbol.keyFor(symbol)</code> returns the <code>key</code> that was associated with <code>symbol</code> when the symbol was added to the global registry.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> symbol = <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>)</span><br><span class="line">console.log(<span class="built_in">Symbol</span>.keyFor(symbol))</span><br><span class="line"><span class="comment">// &lt;- 'foo'</span></span><br></pre></td></tr></table></figure>
<h3 id="How-Wide-is-Runtime-Wide"><a href="#How-Wide-is-Runtime-Wide" class="headerlink" title="How Wide is Runtime-Wide?"></a><a href="#how-wide-is-runtime-wide">How Wide is Runtime-Wide?</a></h3><p>Runtime-wide means the symbols in the global registry are <em>accessible across code realms</em>. I’ll probably have more success explaining this with a piece of code. It just means the registry is shared across realms.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frame = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(frame)</span><br><span class="line">console.log(<span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) === frame.contentWindow.<span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>))</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br></pre></td></tr></table></figure>
<h2 id="The-“Well-Known”-Symbols"><a href="#The-“Well-Known”-Symbols" class="headerlink" title="The “Well-Known” Symbols"></a><a href="#the-well-known-symbols">The “Well-Known” Symbols</a></h2><p>Let me put you at ease: <strong>these aren’t actually well-known at all.</strong> Far from it. I didn’t have any idea these things existed until a few months ago. Why are they <em>“well-known”</em>, then? That’s because they are JavaScript <em>built-ins</em>, and they are used to control parts of the language. They weren’t exposed to user code before ES6, but now you can fiddle with them.</p>
<p>A great example of a <em>“well-known”</em> symbol is something we’ve already been playing with on Pony Foo: the <a href="/articles/es6-iterators-in-depth"><code>Symbol.iterator</code></a> well-known symbol. We used that symbol to define the <code>@@iterator</code> method on objects that adhere to the <em>iterator</em> protocol. There’s <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Symbol#Well-known_symbols" target="_blank" rel="noopener">a list of well-known symbols</a> on MDN, but few of them are documented at the time of this writing.</p>
<p>One of the well-known symbols that <em>is</em> documented at this time is <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/match" target="_blank" rel="noopener"><code>Symbol.match</code></a>. According to MDN, you can set the <code>Symbol.match</code> property on regular expressions to <code>false</code> and have them behave as string literals when matching _(instead of regular expressions, which don’t play nice with <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/startsWith" target="_blank" rel="noopener"><code>.startsWith</code></a>, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/endsWith" target="_blank" rel="noopener"><code>.endsWith</code></a>, or <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/String/includes" target="_blank" rel="noopener"><code>.includes</code></a>)_.</p>
<p>This part of the spec hasn’t been implemented in Babel yet, <em>– I assume that’s just because it’s not worth the trouble –</em> but supposedly it goes like this.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'/foo/'</span></span><br><span class="line"><span class="keyword">var</span> literal = <span class="regexp">/foo/</span></span><br><span class="line">literal[<span class="built_in">Symbol</span>.match] = <span class="literal">false</span></span><br><span class="line"><span class="built_in">console</span>.log(text.startsWith(literal))</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br></pre></td></tr></table></figure>
<p>Why you’d want to do that instead of just casting <code>literal</code> to a string <em>is beyond me</em>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">'/foo/'</span></span><br><span class="line"><span class="keyword">var</span> casted = <span class="regexp">/foo/</span>.toString()</span><br><span class="line"><span class="built_in">console</span>.log(text.startsWith(casted))</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br></pre></td></tr></table></figure>
<p>I suspect the language has <strong>legitimate performance reasons</strong> that warrant the existence of this symbol, but I don’t think it’ll become a front-end development staple anytime soon.</p>
<blockquote>
<p>Regardless, <a href="/articles/es6-iterators-in-depth"><code>Symbol.iterator</code></a> is actually very useful, and I’m sure other well-known symbols are useful as well.</p>
</blockquote>
<p>Note that well-known symbols are unique, but <strong>shared across realms</strong>, even when they’re not accessible through the <em>global registry</em>.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> frame = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>)</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(frame)</span><br><span class="line">console.log(<span class="built_in">Symbol</span>.iterator === frame.contentWindow.<span class="built_in">Symbol</span>.iterator)</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br></pre></td></tr></table></figure>
<p>Not accessible through the <em>global registry</em>? Nope!</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Symbol</span>.keyFor(<span class="built_in">Symbol</span>.iterator))</span><br><span class="line"><span class="comment">// &lt;- undefined</span></span><br></pre></td></tr></table></figure>
<p>Accessing them statically from anywhere should be more than enough, though.</p>
<h2 id="Symbols-and-Iteration"><a href="#Symbols-and-Iteration" class="headerlink" title="Symbols and Iteration"></a><a href="#symbols-and-iteration">Symbols and Iteration</a></h2><p>Any consumer of the <em>iterable</em> protocol obviously ignores symbols other than the well-known <a href="/articles/es6-iterators-in-depth"><code>Symbol.iterator</code></a> that would define how to iterate and help identify the object as an <em>iterable</em>.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>()]: <span class="string">'foo'</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>(<span class="string">'foo'</span>)]: <span class="string">'bar'</span>,</span><br><span class="line">  [<span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'bar'</span>)]: <span class="string">'baz'</span>,</span><br><span class="line">  what: <span class="string">'ever'</span></span><br><span class="line">&#125;</span><br><span class="line">console.log([...foo])</span><br><span class="line"><span class="comment">// &lt;- []</span></span><br></pre></td></tr></table></figure>
<p>The ES5 <code>Object.keys</code> method ignores symbols.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.keys(foo))</span><br><span class="line"><span class="comment">// &lt;- ['what']</span></span><br></pre></td></tr></table></figure>
<p>Same goes for <code>JSON.stringify</code>.</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">console.log</span>(JSON.<span class="keyword">stringify(foo))</span></span><br><span class="line"><span class="keyword">// </span>&lt;- &#123;<span class="string">"what"</span>:<span class="string">"ever"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>So, <code>for..in</code> then? Nope.</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="built_in">key</span> in foo) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">key</span>)</span><br><span class="line">  <span class="comment">// &lt;- 'what'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I know, <code>Object.getOwnPropertyNames</code>. Nah! <em>– but close.</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(<span class="built_in">Object</span>.getOwnPropertyNames(foo))</span><br><span class="line"><span class="comment">// &lt;- ['what']</span></span><br></pre></td></tr></table></figure>
<p>You need to be explicitly looking for symbols to stumble upon them. They’re like JavaScript neutrinos. You can use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="noopener"><code>Object.getOwnPropertySymbols</code></a> to detect them.</p>
<figure class="highlight mathematica"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(Object.getOwnPropertySymbols(foo))</span><br><span class="line">// &lt;- [<span class="keyword">Symbol</span>(), <span class="keyword">Symbol</span>(<span class="string">'foo'</span>), <span class="keyword">Symbol</span>.for(<span class="string">'bar'</span>)]</span><br></pre></td></tr></table></figure>
<p>The magical drapes of symbols drop, and you can now iterate over the symbols with a <code>for..of</code> loop to finally figure out the treasures they were guarding. Hopefully, they won’t be as disappointing as the flukes in the snippet below.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> symbol <span class="keyword">of</span> <span class="built_in">Object</span>.getOwnPropertySymbols(foo)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(foo[symbol])</span><br><span class="line">  <span class="comment">// &lt;- 'foo'</span></span><br><span class="line">  <span class="comment">// &lt;- 'bar'</span></span><br><span class="line">  <span class="comment">// &lt;- 'baz'</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h2 id="Why-Would-I-Want-Symbols"><a href="#Why-Would-I-Want-Symbols" class="headerlink" title="Why Would I Want Symbols?"></a><a href="#why-would-i-want-symbols">Why Would I Want Symbols?</a></h2><p>There’s a few different uses for symbols.</p>
<h3 id="Name-Clashes"><a href="#Name-Clashes" class="headerlink" title="Name Clashes"></a><a href="#name-clashes">Name Clashes</a></h3><p>You can use symbols to <strong>avoid name clashes</strong> in property keys. This is important when following the <em>“objects as hash maps”</em> pattern, which regularly ends up failing miserably as native methods and properties are overridden unintentionally <em>(or maliciously)</em>.</p>
<h3 id="“Privacy”"><a href="#“Privacy”" class="headerlink" title="“Privacy”?"></a><a href="#privacy">“Privacy”?</a></h3><p>Symbols are <em>invisible to all “reflection” methods before ES6</em>. This can be useful in some scenarios, but they’re not private by any stretch of imagination, as we’ve just demonstrated with the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertySymbols" target="_blank" rel="noopener"><code>Object.getOwnPropertySymbols</code></a> API.</p>
<p>That being said, the fact that you have to actively look for symbols to find them means they’re useful in situations where you want to define metadata that shouldn’t be part of iterable sequences for arrays or any <em>iterable</em> objects.</p>
<h3 id="Defining-Protocols"><a href="#Defining-Protocols" class="headerlink" title="Defining Protocols"></a><a href="#defining-protocols">Defining Protocols</a></h3><p>I think the <em>biggest use case for symbols</em> is exactly what the ES6 implementers use them for: <strong>defining protocols</strong> – just like there’s <a href="/articles/es6-iterators-in-depth"><code>Symbol.iterator</code></a> which allows you to define how an object can be iterated.</p>
<p>Imagine for instance a library like <a href="https://github.com/bevacqua/dragula" target="_blank" rel="noopener"><code>dragula</code></a> defining a protocol through <code>Symbol.for(&#39;dragula.moves&#39;)</code>, where you could add a method on that <code>Symbol</code> to any DOM elements. If a DOM element follows the protocol, then <code>dragula</code> could call the <code>el[Symbol.for(&#39;dragula.moves&#39;)]()</code> user-defined method to assert whether the element can be moved.</p>
<p>This way, the logic about elements being draggable by <code>dragula</code> is shifted from a single place for the entire <code>drake</code> <em>(the <code>options</code> for an instance of <code>dragula</code>)</em>, to each individual DOM element. That’d make it easier to deal with complex interactions in larger implementations, as the logic would be delegated to individual DOM nodes instead of being centralized in a single <code>options.moves</code> method.</p>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[08.Let, Const and the “Temporal Dead Zone” (TDZ)]]></title>
      <url>/2018/08/01/pureMaterial/08.let_const_temporal_dead_zone/</url>
      <content type="html"><![CDATA[<h2 id="Let-Const-and-the-“Temporal-Dead-Zone”-TDZ"><a href="#Let-Const-and-the-“Temporal-Dead-Zone”-TDZ" class="headerlink" title="Let, Const and the “Temporal Dead Zone” (TDZ)"></a>Let, Const and the “Temporal Dead Zone” (TDZ)</h2><h2 id="Let-Statement"><a href="#Let-Statement" class="headerlink" title="Let Statement"></a><a href="#let-statement">Let Statement</a></h2><p>The <code>let</code> statement is one of the most well-known features in ES6, which is partly why I grouped it together with a few other new features. It works like a <code>var</code> statement, but it has different scoping rules. JavaScript has always had a complicated ruleset when it came to scoping, driving many programmers crazy when they were first trying to figure out how variables work in JavaScript.</p>
<p>Eventually, you discover this thing called <a href="/articles/javascript-variable-hoisting">hoisting</a>, and things start making a bit more sense to you. Hoisting means that variables get pulled from anywhere they were declared in user code to the top of their scope. For example, see the code below.</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areTheyAwesome</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'nico'</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> awesome = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> awesome</span><br><span class="line">&#125;</span><br><span class="line">areTheyAwesome(<span class="string">'nico'</span>)</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br><span class="line">areTheyAwesome(<span class="string">'christian heilmann'</span>)</span><br><span class="line"><span class="comment">// &lt;- undefined</span></span><br></pre></td></tr></table></figure>
<p>The reason why this doesn’t implode into oblivion is, as we know, that <code>var</code> is function-scoped. That coupled with hoisting means that what we’re really expressing is something like the piece of code below.</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">areTheyAwesome</span> <span class="params">(name)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> awesome</span><br><span class="line">  <span class="keyword">if</span> (name === <span class="string">'nico'</span>) &#123;</span><br><span class="line">    awesome = <span class="literal">true</span></span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> awesome</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Whether we like it or not (or we’re just used to it – I know I am), this is plainly more confusing than having block-scoped variables would be. Block scoping works on the bracket level, rather than the function level.</p>
<p>Instead of having to declare a new <code>function</code> if we want a deeper scoping level, block scoping allows you to just leverage existing code branches like those in <code>if</code>, <code>for</code>, or <code>while</code> statements; you could also create new <code>{}</code> blocks arbitrarily. As you may or may not know, the JavaScript language allows us to create an indiscriminate number of blocks, just because we want to.</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;var insane = <span class="string">'yes, you are'</span>&#125;&#125;&#125;&#125;&#125;</span><br><span class="line">console.log(insane)</span><br><span class="line">// &lt;- <span class="string">'yes, you are'</span></span><br></pre></td></tr></table></figure>
<p>With <code>var</code>, though, one could still access the variable from outside those many, many, many blocks, and not get an error. Sometimes it can be very useful to get errors in these situations. Particularly if one or more of these is true.</p>
<ul>
<li>Accessing the inner variable breaks some sort of encapsulation principle in our code</li>
<li>The inner variable doesn’t belong in the outer scope at all</li>
<li>The block in question has many siblings that would also want to use the same variable name</li>
<li>One of the parent blocks already has a variable with the name we need, but it’s still appropriate to use in the inner block</li>
</ul>
<h2 id="So-how-does-this-let-thing-work"><a href="#So-how-does-this-let-thing-work" class="headerlink" title="So how does this let thing work?"></a><a href="#so-how-does-this-let-thing-work">So how does this <code>let</code> thing work?</a></h2><blockquote>
<p>The <code>let</code> statement is an alternative to <code>var</code>. It follows block scoping rules instead of the default function scoping rules. This means you <strong>don’t need entire functions</strong> to get a new scope – <em>a simple <code>{}</code> block will do!</em></p>
</blockquote>
<figure class="highlight fsharp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> outer = <span class="symbol">'I</span> am so eccentric!'</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> inner = <span class="symbol">'I</span> play <span class="keyword">with</span> neighbors <span class="keyword">in</span> my block <span class="keyword">and</span> the sewers'</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> innermost = <span class="symbol">'I</span> only play <span class="keyword">with</span> neighbors <span class="keyword">in</span> my block'</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="comment">// accessing innermost here would throw</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// accessing inner here would throw</span></span><br><span class="line"><span class="comment">// accessing innermost here would throw</span></span><br></pre></td></tr></table></figure>
<p>Here is where things got interesting. As I wrote this example I thought <em>“well, but if we now declare a function inside a block and access it from outside that block, things will <strong>surely go awry</strong>”</em>. Based on my existing knowledge of ES5 I fully expected the following snippet of code to work, and it does in fact <em>work in ES5</em> but it’s <a href="http://www.2ality.com/2015/02/es6-scoping.html" target="_blank" rel="noopener">broken in ES6</a>. That would’ve been a problem because it’d make super easy to expose block-scoped properties through functions that become hoisted outside of the block. I didn’t expect this to <code>throw</code>.</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  let _nested = <span class="symbol">'secret</span>'</span><br><span class="line">  <span class="keyword">function</span> <span class="title">nested</span> () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">_nested</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">console.log(nested())</span><br><span class="line">// nested <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>
<p>As it turns out, this wasn’t a bug in Babel, but in fact a <em>(much welcome)</em> change in ES6 language semantics.</p>
<p>Note that you can still expose nested <code>let</code> things to outer scopes simply by assigning them to a variable that has more access. I wouldn’t recommend you do this however, as there probably are cleaner ways to write code in these situations – such as <strong>not using <code>let</code> when you don’t want block scoping</strong>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> nested</span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> _nested = <span class="string">'secret'</span></span><br><span class="line">  nested = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> _nested</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="built_in">console</span>.log(nested())</span><br><span class="line"><span class="comment">// &lt;- 'secret'</span></span><br></pre></td></tr></table></figure>
<p>In conclusion, block scoping can be quite useful in new codebases. Some people will tell you to drop <code>var</code> forever and just use <code>let</code> everywhere. Some will tell you to never use <code>let</code> because that’s not the <em>One True Way of JavaScript</em>. My position might change over time, but this is it – for the time being:</p>
<blockquote>
<p>I plan on using <code>var</code> most of the time, and <code>let</code> in those situations where I would’ve otherwise hoisted a variable to the top of the scope for no reason, when they actually belonged inside a conditional or iterator code branch.</p>
<p><strong>25 Nov 2016:</strong> after working with ES6 for over a year, I’ve completely changed my mind on how to declare variables in ES6. <a href="https://ponyfoo.com/books/practical-es6/chapters/9#practical-considerations" target="_blank" rel="noopener">Prefer <code>const</code> where possible, <code>let</code> anywhere else!</a></p>
</blockquote>
<h2 id="The-Temporal-Dead-Zone-and-the-Deathly-Hallows"><a href="#The-Temporal-Dead-Zone-and-the-Deathly-Hallows" class="headerlink" title="The Temporal Dead Zone and the Deathly Hallows"></a><a href="#the-temporal-dead-zone-and-the-deathly-hallows">The <em>Temporal Dead Zone</em> and the Deathly Hallows</a></h2><p>One last thing of note about <code>let</code> is a mystical concept called the <a href="http://jsrocks.org/2015/01/temporal-dead-zone-tdz-demystified/" target="_blank" rel="noopener">“Temporal Dead Zone” <em>(TDZ)</em></a> <em>– ooh… so scary, I know.</em></p>
<p><img src="https://i.imgur.com/79mp6As.jpg" alt="enter image description here"></p>
<p>In so many words: if you have code such as the following, it’ll throw.</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">there = <span class="symbol">'far</span> away'</span><br><span class="line">// &lt;- ReferenceError: there <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">let there = <span class="symbol">'dragons</span>'</span><br></pre></td></tr></table></figure>
<p>If your code tries to access <code>there</code> in any way before the <code>let there</code> statement is reached, the program will throw. Declaring a method that references <code>there</code> before it’s defined is okay, as long as the method doesn’t get executed while <code>there</code> is in the TDZ, and <code>there</code> will be in the TDZ for as long as the <code>let there</code> statement isn’t reached <em>(while the scope has been entered)</em>. This snippet won’t throw because <code>return there</code> isn’t executed until after <code>there</code> leaves the TDZ.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readThere</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> there</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> there = <span class="string">'dragons'</span></span><br><span class="line"><span class="built_in">console</span>.log(readThere())</span><br><span class="line"><span class="comment">// &lt;- 'dragons'</span></span><br></pre></td></tr></table></figure>
<p>But this snippet will, because access to <code>there</code> occurs <em>before leaving the TDZ for <code>there</code></em>.</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">readThere</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">there</span></span><br><span class="line">&#125;</span><br><span class="line">console.log(readThere())</span><br><span class="line">// ReferenceError: there <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">let there = <span class="symbol">'dragons</span>'</span><br></pre></td></tr></table></figure>
<p>Note that the semantics for these examples doesn’t change when <code>there</code> isn’t actually assigned a value when initially declared. The snippet below still throws, as it still tries to access <code>there</code> before leaving the TDZ.</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">readThere</span> () &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">there</span></span><br><span class="line">&#125;</span><br><span class="line">console.log(readThere())</span><br><span class="line">// ReferenceError: there <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br><span class="line">let there</span><br></pre></td></tr></table></figure>
<p>This snippet still works because it still leaves the TDZ before accessing <code>there</code> in any way.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">readThere</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> there</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> there</span><br><span class="line"><span class="built_in">console</span>.log(readThere())</span><br><span class="line"><span class="comment">// &lt;- undefined</span></span><br></pre></td></tr></table></figure>
<p>The only tricky part is to remember that <em>(when it comes to the TDZ)</em> functions work sort of like blackboxes until they’re actually executed for the first time, so it’s okay to place <code>there</code> inside functions that don’t get executed until we leave the TDZ.</p>
<blockquote>
<p>The whole point of the TDZ is to make it easier to catch errors where accessing a variable before it’s declared in user code leads to unexpected behavior. This happened a lot with ES5 due both to hoisting and poor coding conventions. In ES6 it’s easier to avoid. Keep in mind that hoisting still applies for <code>let</code> as well – this just means that the variables will be created when we enter the scope, and the TDZ will be born, but they will be inaccessible until code execution hits the place where the variable was actually declared, at which point we leave the TDZ and are cleared to use the variable.</p>
</blockquote>
<h2 id="Const-Statement"><a href="#Const-Statement" class="headerlink" title="Const Statement"></a><a href="#const-statement">Const Statement</a></h2><p>Phew. I wrote more than I ever wanted to write about <code>let</code>. Fortunately for both of us, <code>const</code> is quite similar to <code>let</code>.</p>
<ul>
<li><code>const</code> is also <em>block-scoped</em></li>
<li><code>const</code> also enjoys the marvels of <em>TDZ semantics</em></li>
</ul>
<p>There’s also a couple of major differences.</p>
<ul>
<li><code>const</code> variables must be declared using an initializer</li>
<li><code>const</code> variables can only be assigned to once, in said initializer</li>
<li><code>const</code> variables <strong>don’t</strong> make the assigned value immutable</li>
<li>Assigning to <code>const</code> will fail silently</li>
<li>Redeclaration of a variable by the same name <em>will</em> throw</li>
</ul>
<p>Let’s go to some examples. First, this snippet shows how it follows block-scoping rules just like <code>let</code>.</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cool = <span class="string">'ponyfoo'</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">const</span> cool = <span class="string">'dragons'</span>  </span><br><span class="line">  console.<span class="built_in">log</span>(cool)</span><br><span class="line">  // &lt;- <span class="string">'dragons'</span></span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(cool)</span><br><span class="line">// &lt;- <span class="string">'ponyfoo'</span></span><br></pre></td></tr></table></figure>
<p>Once a <code>const</code> is declared, you can’t change the reference or literal that’s assigned to it.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const cool = &#123; people: [<span class="string">'you'</span>, <span class="string">'me'</span>, <span class="string">'tesla'</span>, <span class="string">'musk'</span>] &#125;</span><br><span class="line">cool = &#123;&#125;</span><br><span class="line">// &lt;- <span class="string">"cool"</span> <span class="keyword">is</span> <span class="keyword">read</span>-<span class="keyword">only</span></span><br></pre></td></tr></table></figure>
<p>You can however, change the reference itself. It does not become immutable. You’d have to use <a href="https://i.imgur.com/79mp6As.jpg" target="_blank" rel="noopener"><code>Object.freeze</code></a> to make the value itself immutable.</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cool = &#123; people: [<span class="string">'you'</span>, <span class="string">'me'</span>, <span class="string">'tesla'</span>, <span class="string">'musk'</span>] &#125;</span><br><span class="line">cool.people.push(<span class="string">'berners-lee'</span>)</span><br><span class="line">console.<span class="built_in">log</span>(cool)</span><br><span class="line">// &lt;- &#123; people: [<span class="string">'you'</span>, <span class="string">'me'</span>, <span class="string">'tesla'</span>, <span class="string">'musk'</span>, <span class="string">'berners-lee'</span>] &#125;</span><br></pre></td></tr></table></figure>
<p>You can also make other references to the <code>const</code> that <em>can</em>, in fact, change.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cool = &#123; <span class="attr">people</span>: [<span class="string">'you'</span>, <span class="string">'me'</span>, <span class="string">'tesla'</span>, <span class="string">'musk'</span>] &#125;</span><br><span class="line"><span class="keyword">var</span> uncool = cool</span><br><span class="line">uncool = &#123; <span class="attr">people</span>: [<span class="string">'edison'</span>] &#125; <span class="comment">// so uncool he's all alone</span></span><br><span class="line"><span class="built_in">console</span>.log(uncool)</span><br><span class="line"><span class="comment">// &lt;- &#123; people: ['edison'] &#125;</span></span><br></pre></td></tr></table></figure>
<p>I think <code>const</code> is great because it allows us to mark things that we really need to preserve as such. Imagine the following piece of code, which does come up in some situations <em>– sorry about the extremely contrived example.</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">code</span> (<span class="params">groceries</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;eat&#125;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">eat</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (groceries.length === <span class="number">0</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'All out. Please buy more groceries to feed the code.'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> groceries.shift()</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> groceries = [<span class="string">'carrot'</span>, <span class="string">'lemon'</span>, <span class="string">'potato'</span>, <span class="string">'turducken'</span>]</span><br><span class="line"><span class="keyword">var</span> eater = code(groceries)</span><br><span class="line"><span class="built_in">console</span>.log(eater.eat())</span><br><span class="line"><span class="comment">// &lt;- 'carrot'</span></span><br></pre></td></tr></table></figure>
<p>I sometimes come across code where someone is trying to add more <code>groceries</code> to the list, and they figure that doing the following would <em>just work</em>. In many cases this does work. However, if we’re passing a reference to groceries to something else, the re-assignment wouldn’t be carried away to that other place, and hard to debug issues would ensue.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// <span class="keyword">a</span> few hundred <span class="keyword">lines</span> <span class="keyword">of</span> code later...</span><br><span class="line">groceries = [<span class="string">'heart of palm'</span>, <span class="string">'tomato'</span>, <span class="string">'corned beef'</span>]</span><br></pre></td></tr></table></figure>
<p>If <code>groceries</code> were a constant in the piece of code above, this re-assignment would’ve been far easier to detect. Yay, ES6! I can definitely see myself using <code>const</code> a lot in the future, but I haven’t quite internalized it yet.</p>
<blockquote>
<p>I guess more coding is in order!</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[materials --- string]]></title>
      <url>/2018/07/31/blog/summary/01.string/</url>
      <content type="html"><![CDATA[<h2 id="material-–-string"><a href="#material-–-string" class="headerlink" title="material – string"></a>material – string</h2>]]></content>
      
        <categories>
            
            <category> knowledge </category>
            
        </categories>
        
        
        <tags>
            
            <tag> knowledge </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode String -- 3.Judge Route Circle]]></title>
      <url>/2018/07/31/leetCode/string/03.judge_route_circle/</url>
      <content type="html"><![CDATA[<h2 id="Judge-Route-Circle"><a href="#Judge-Route-Circle" class="headerlink" title="Judge Route Circle"></a>Judge Route Circle</h2><p>Initially, there is a Robot at position (0, 0). Given a sequence of its moves, judge if this robot makes a circle, which means it moves back to the original place.</p>
<p>The move sequence is represented by a string. And each move is represent by a character. The valid robot moves are R (Right), L (Left), U (Up) and D (down). The output should be true or false representing whether the robot makes a circle.</p>
<blockquote>
<p>Example 1:<br>Input: “UD”<br>Output: true</p>
<p>Example 2:<br>input: “LL”<br>Output: false</p>
</blockquote>
<p><strong>solution：</strong></p>
<p>1.定义一个对象，保存四个方向的值，只要左右，上下对应相等即可：</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;string&#125; moves</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;boolean&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> judgeCircle = <span class="function"><span class="keyword">function</span><span class="params">(moves)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> storage = &#123;</span><br><span class="line">        R: <span class="number">0</span>,</span><br><span class="line">        L: <span class="number">0</span>,</span><br><span class="line">        U: <span class="number">0</span>,</span><br><span class="line">        D: <span class="number">0</span></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i in moves) &#123;</span><br><span class="line">        storage[moves[i]] += <span class="number">1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> (storage[<span class="string">'R'</span>] == storage[<span class="string">'L'</span>] &amp;&amp; storage[<span class="string">'U'</span>] === storage[<span class="string">'D'</span>])</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.这道题的思想大体类似，选择switch进行判断：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> judgeCircle = <span class="function"><span class="keyword">function</span>(<span class="params">moves</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> start = [<span class="number">0</span>, <span class="number">0</span>]</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; moves.length; i++) &#123;</span><br><span class="line">        <span class="keyword">switch</span> (moves[i]) &#123;</span><br><span class="line">            <span class="keyword">case</span> <span class="string">'U'</span>:</span><br><span class="line">                start = [start[<span class="number">0</span>], start[<span class="number">1</span>] + <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'D'</span>:</span><br><span class="line">                start = [start[<span class="number">0</span>], start[<span class="number">1</span>] - <span class="number">1</span>]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'L'</span>:</span><br><span class="line">                start = [start[<span class="number">0</span>] - <span class="number">1</span>, start[<span class="number">1</span>]]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">            <span class="keyword">case</span> <span class="string">'R'</span>:</span><br><span class="line">                start = [start[<span class="number">0</span>] + <span class="number">1</span>, start[<span class="number">1</span>]]</span><br><span class="line">                <span class="keyword">break</span></span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">if</span> (start.join(<span class="string">''</span>) === <span class="string">'00'</span>) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">true</span></span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="literal">false</span></span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode String -- 2.Unique Morse Code Words]]></title>
      <url>/2018/07/31/leetCode/string/02.unique_morse_code_words/</url>
      <content type="html"><![CDATA[<h2 id="Unique-Morse-Code-Words"><a href="#Unique-Morse-Code-Words" class="headerlink" title="Unique Morse Code Words"></a>Unique Morse Code Words</h2><p>International Morse Code defines a standard encoding where each letter is mapped to a series of dots and dashes, as follows: “a” maps to “.-“, “b” maps to “-…”, “c” maps to “-.-.”, and so on.</p>
<p>For convenience, the full table for the 26 letters of the English alphabet is given below:</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">".-"</span>,<span class="string">"-..."</span>,<span class="string">"-.-."</span>,<span class="string">"-.."</span>,<span class="string">"."</span>,<span class="string">"..-."</span>,<span class="string">"--."</span>,<span class="string">"...."</span>,<span class="string">".."</span>,<span class="string">".---"</span>,<span class="string">"-.-"</span>,<span class="string">".-.."</span>,<span class="string">"--"</span>,<span class="string">"-."</span>,<span class="string">"---"</span>,<span class="string">".--."</span>,<span class="string">"--.-"</span>,<span class="string">".-."</span>,<span class="string">"..."</span>,<span class="string">"-"</span>,<span class="string">"..-"</span>,<span class="string">"...-"</span>,<span class="string">".--"</span>,<span class="string">"-..-"</span>,<span class="string">"-.--"</span>,<span class="string">"--.."</span>]</span><br></pre></td></tr></table></figure>
<p>Now, given a list of words, each word can be written as a concatenation of the Morse code of each letter. For example, “cab” can be written as “-.-.-….-“, (which is the concatenation “-.-.” + “-…” + “.-“). We’ll call such a concatenation, the transformation of a word.</p>
<p>Return the number of different transformations among all words we have.</p>
<blockquote>
<p>Example:<br>Input: words = [“gin”, “zen”, “gig”, “msg”]<br>Output: 2<br>Explanation:<br>The transformation of each word is:<br>“gin” -&gt; “–…-.”<br>“zen” -&gt; “–…-.”<br>“gig” -&gt; “–…–.”<br>“msg” -&gt; “–…–.”</p>
</blockquote>
<p>There are 2 different transformations, “–…-.” and “–…–.”.</p>
<blockquote>
<p>Note:<br>The length of words will be at most 100.<br>Each words[i] will have length in range [1, 12].<br>words[i] will only consist of lowercase letters.</p>
</blockquote>
<p> <strong>solution：</strong></p>
<p>1.使用map 和set一一对应，代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment">* @param &#123;string[]&#125; words</span></span><br><span class="line"><span class="comment">* @return &#123;number&#125;</span></span><br><span class="line"><span class="comment">*/</span></span><br><span class="line"><span class="keyword">const</span> letters = <span class="string">'abcdefghijklmnopqrstuvwxyz'</span>;</span><br><span class="line"><span class="keyword">const</span> morseCode = [<span class="string">'.-'</span>,<span class="string">'-...'</span>,<span class="string">'-.-.'</span>,<span class="string">'-..'</span>,<span class="string">'.'</span>,<span class="string">'..-.'</span>,<span class="string">'--.'</span>,<span class="string">'....'</span>,<span class="string">'..'</span>,<span class="string">'.---'</span>,<span class="string">'-.-'</span>,<span class="string">'.-..'</span>,<span class="string">'--'</span>,<span class="string">'-.'</span>,<span class="string">'---'</span>,<span class="string">'.--.'</span>,<span class="string">'--.-'</span>,<span class="string">'.-.'</span>,<span class="string">'...'</span>,<span class="string">'-'</span>,<span class="string">'..-'</span>,<span class="string">'...-'</span>,<span class="string">'.--'</span>,<span class="string">'-..-'</span>,<span class="string">'-.--'</span>,<span class="string">'--..'</span>];</span><br><span class="line"><span class="keyword">const</span> mapMorse = <span class="keyword">new</span> <span class="built_in">Map</span>(morseCode.map(<span class="function">(<span class="params">code, index</span>) =&gt;</span> [letters[index], code]));</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uniqueMorseRepresentations = <span class="function"><span class="keyword">function</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> transformations = <span class="keyword">new</span> <span class="built_in">Set</span>();</span><br><span class="line">  words.forEach(<span class="function">(<span class="params">w</span>) =&gt;</span> &#123;</span><br><span class="line">    transformations.add(w.split(<span class="string">''</span>).map( <span class="function"><span class="params">l</span> =&gt;</span> mapMorse.get(l)).join(<span class="string">''</span>));</span><br><span class="line">  &#125;);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> transformations.size;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>2.在学习其他人的代码时，看到了一个比较厉害的例子，一行搞定：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string[]&#125; words</span></span><br><span class="line"><span class="comment"> * @return &#123;number&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> uniqueMorseRepresentations = <span class="function"><span class="keyword">function</span>(<span class="params">words</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>(words.map(<span class="function"><span class="params">word</span> =&gt;</span> [...word].map(<span class="function"><span class="params">val</span> =&gt;</span> [<span class="string">".-"</span>, <span class="string">"-..."</span>, <span class="string">"-.-."</span>, <span class="string">"-.."</span>, <span class="string">"."</span>, <span class="string">"..-."</span>, <span class="string">"--."</span>, <span class="string">"...."</span>, <span class="string">".."</span>, <span class="string">".---"</span>, <span class="string">"-.-"</span>, <span class="string">".-.."</span>, <span class="string">"--"</span>, <span class="string">"-."</span>, <span class="string">"---"</span>, <span class="string">".--."</span>, <span class="string">"--.-"</span>, <span class="string">".-."</span>, <span class="string">"..."</span>, <span class="string">"-"</span>, <span class="string">"..-"</span>, <span class="string">"...-"</span>, <span class="string">".--"</span>, <span class="string">"-..-"</span>, <span class="string">"-.--"</span>, <span class="string">"--.."</span>].slice(val.charCodeAt(<span class="number">0</span>) - <span class="string">'a'</span>.charCodeAt(<span class="number">0</span>), val.charCodeAt(<span class="number">0</span>) - <span class="string">'a'</span>.charCodeAt(<span class="number">0</span>) + <span class="number">1</span>)).join(<span class="string">''</span>))).size</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>也就是：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> uniqueMorseRepresentations = <span class="function"><span class="keyword">function</span> (<span class="params">words</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">let</span> code = [<span class="string">".-"</span>, <span class="string">"-..."</span>, <span class="string">"-.-."</span>, <span class="string">"-.."</span>, <span class="string">"."</span>, <span class="string">"..-."</span>, <span class="string">"--."</span>, <span class="string">"...."</span>, <span class="string">".."</span>, <span class="string">".---"</span>, <span class="string">"-.-"</span>, <span class="string">".-.."</span>, <span class="string">"--"</span>, <span class="string">"-."</span>, <span class="string">"---"</span>, <span class="string">".--."</span>, <span class="string">"--.-"</span>, <span class="string">".-."</span>, <span class="string">"..."</span>, <span class="string">"-"</span>, <span class="string">"..-"</span>, <span class="string">"...-"</span>, <span class="string">".--"</span>, <span class="string">"-..-"</span>, <span class="string">"-.--"</span>, <span class="string">"--.."</span>];</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Set</span>(words.map(<span class="function"><span class="params">word</span> =&gt;</span> [...word].map(<span class="function"><span class="params">val</span> =&gt;</span> code[val.charCodeAt(<span class="number">0</span>) - <span class="string">'a'</span>.charCodeAt(<span class="number">0</span>)]).join(<span class="string">''</span>))).size</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>mark一下。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode String -- 1.To Lower Case]]></title>
      <url>/2018/07/31/leetCode/string/01.to_lower_case/</url>
      <content type="html"><![CDATA[<h2 id="To-Lower-Case"><a href="#To-Lower-Case" class="headerlink" title="To Lower Case"></a>To Lower Case</h2><p>Implement function ToLowerCase() that has a string parameter str, and returns the same string in lowercase.</p>
<p>Example 1:</p>
<blockquote>
<p>Input: “Hello”<br>Output: “hello”</p>
</blockquote>
<p>Example 2:</p>
<blockquote>
<p>Input: “here”<br>Output: “here”</p>
</blockquote>
<p>Example 3:</p>
<blockquote>
<p>Input: “LOVELY”<br>Output: “lovely”</p>
</blockquote>
<p><strong>solution：</strong></p>
<ol>
<li>直接想到的办法就是使用js的toLowerCase()：</li>
</ol>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@param</span> &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * <span class="doctag">@return</span> &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> toLowerCase = <span class="function"><span class="keyword">function</span><span class="params">(str)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> str.toLowerCase();</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<ol>
<li>第二种是拆分当前字符串，根据ASCII码判断是否是大写字母，是的话转为小写：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/**</span></span><br><span class="line"><span class="comment"> * @param &#123;string&#125; str</span></span><br><span class="line"><span class="comment"> * @return &#123;string&#125;</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"><span class="keyword">var</span> toLowerCase = <span class="function"><span class="keyword">function</span>(<span class="params">str</span>) </span>&#123;</span><br><span class="line">   <span class="keyword">return</span> str.split(<span class="string">""</span>).map(<span class="function">(<span class="params">code</span>) =&gt;</span> &#123;</span><br><span class="line">     <span class="keyword">const</span> unicode = code.charCodeAt(<span class="number">0</span>);</span><br><span class="line">     <span class="keyword">return</span> unicode &gt;= <span class="number">65</span> &amp;&amp; unicode &lt;= <span class="number">90</span> ? <span class="built_in">String</span>.fromCharCode(unicode + <span class="number">32</span>) : code</span><br><span class="line">   &#125;).join(<span class="string">""</span>)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[07.classes]]></title>
      <url>/2018/07/31/pureMaterial/07.classes/</url>
      <content type="html"><![CDATA[<h2 id="What-do-you-mean-classes-in-JavaScript"><a href="#What-do-you-mean-classes-in-JavaScript" class="headerlink" title="What do you mean; classes in JavaScript?"></a><a href="#what-do-you-mean-1-classes-in-javascript"></a><a href="https://www.youtube.com/watch?v=fCEo2wfudqk" target="_blank" rel="noopener">What do you mean</a>; classes in JavaScript?</h2><p>JavaScript is a prototype-based language, so what are ES6 classes really? They’re syntactic sugar on top of prototypical inheritance – a device to make the language more inviting to programmers coming from other paradigms who might not be all that familiar with prototype chains. Many features in ES6 <em>(such as <a href="/articles/es6-destructuring-in-depth">destructuring</a>)</em> are, in fact, syntactic sugar – and classes are no exception. I like to clarify this because it makes it much easier to understand the underlying technology behind ES6 classes. There is no huge restructuring of the language, they just made it easier for people used to classes to leverage prototypal inheritance.</p>
<blockquote>
<p>While I may dislike the term <em>“classes”</em> for this particular feature, I have to say that the syntax is in fact much easier to work with than regular prototypal inheritance syntax in ES5, and that’s a win for everyone – regardless of them being called classes or not.</p>
</blockquote>
<p>Now that that’s out of the way, I’ll assume you understand prototypal inheritance – just because you’re reading a blog about JavaScript. Here’s how you would describe a <code>Car</code> that can be instantiated, fueled up, and move.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Car</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.fuel = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.distance = <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.move = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.fuel &lt; <span class="number">1</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'Fuel tank is depleted'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.fuel--</span><br><span class="line">  <span class="keyword">this</span>.distance += <span class="number">2</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Car.prototype.addFuel = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">this</span>.fuel &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'Fuel tank is full'</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">this</span>.fuel++</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To move the car, you could use the following piece of code.</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = <span class="function"><span class="keyword">new</span> <span class="title">Car</span>()</span></span><br><span class="line"><span class="function"><span class="title">car</span>.<span class="title">addFuel</span>()</span></span><br><span class="line"><span class="function"><span class="title">car</span>.<span class="title">move</span>()</span></span><br><span class="line"><span class="function"><span class="title">car</span>.<span class="title">move</span>()</span></span><br><span class="line"><span class="function"><span class="comment">// &lt;- RangeError: 'Fuel tank is depleted'</span></span></span><br></pre></td></tr></table></figure>
<p>Neat. What about with ES6 classes? The syntax is very similar to declaring an object, except we precede it with <code>class Name</code>, where <code>Name</code> is the name for our class. Here we are leveraging the <a href="/articles/es6-object-literal-features-in-depth#method-signatures">method signature notation</a> we covered yesterday to declare the methods using a shorter syntax. The <code>constructor</code> is just like the constructor method in ES5, so you can use that to initialize any variables your instances may have.</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.fuel = <span class="number">0</span></span><br><span class="line">    <span class="keyword">this</span>.distance = <span class="number">0</span></span><br><span class="line">  &#125;</span><br><span class="line">  move () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fuel &lt; <span class="number">1</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> new RangeError(<span class="string">'Fuel tank is depleted'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fuel--</span><br><span class="line">    <span class="keyword">this</span>.distance += <span class="number">2</span></span><br><span class="line">  &#125;</span><br><span class="line">  addFuel () &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.fuel &gt;= <span class="number">60</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> new RangeError(<span class="string">'Fuel tank is full'</span>)</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>.fuel++</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In case you haven’t noticed, and for some obscure reason that escapes me, <strong>commas are invalid</strong> in-between properties or methods in a class, as opposed to object literals where commas are <em>(still)</em> mandatory. That discrepancy is bound to cause headaches to people trying to decide whether they want a plain object literal or a class instead, but the code <em>does</em> look sort of cleaner without the commas here.</p>
<p>Many times <em>“classes”</em> have static methods. Think of your friend the <code>Array</code> for example. Arrays have instance methods like <code>.filter</code>, <code>.reduce</code>, and <code>.map</code>. The <code>Array</code> <em>“class”</em> itself has static methods as well, like <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/isArray" target="_blank" rel="noopener"><code>Array.isArray</code></a>. In ES5 code, it’s pretty easy to add these kind of methods to our <code>Car</code> <em>“class”</em>.</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">Car</span> () &#123;</span><br><span class="line">  this.topSpeed = Math.random()</span><br><span class="line">&#125;</span><br><span class="line">Car.<span class="keyword">is</span>Faster = <span class="keyword">function</span> <span class="title"></span>(left, right) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">left.topSpeed</span> &gt; right.topSpeed</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>In ES6 <code>class</code> notation, we can use precede our method with <code>static</code>, following a similar syntax as that of <code>get</code> and <code>set</code>. Again, just sugar on top of ES5, as it’s quite trivial to transpile this down into ES5 notation.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span> () &#123;</span><br><span class="line">    <span class="keyword">this</span>.topSpeed = <span class="built_in">Math</span>.random()</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">static</span> isFaster (left, right) &#123;</span><br><span class="line">    <span class="keyword">return</span> left.topSpeed &gt; right.topSpeed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>One sweet aspect of ES6 <code>class</code> sugar is that you also get an <code>extends</code> keyword that enables you to easily <em>“inherit”</em> from other <em>“classes”</em>. We all know Tesla cars move further while using the same amount of fuel, thus the code below shows how <code>Tesla extends Car</code> and “overrides” <em>(a concept you might be familiar with if you’ve ever <a href="https://msdn.microsoft.com/en-us/library/aa645768(v=vs.71" target="_blank" rel="noopener">played around with C#</a>.aspx))</em> the <code>move</code> method to cover a larger distance.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  move () &#123;</span><br><span class="line">    <span class="keyword">super</span>.move()</span><br><span class="line">    <span class="keyword">this</span>.distance += <span class="number">4</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The special <code>super</code> keyword identifies the <code>Car</code> class we’ve inherited from – and since we’re speaking about C#, it’s akin to <a href="https://msdn.microsoft.com/en-us/library/hfw7t1ce.aspx" target="_blank" rel="noopener"><code>base</code></a>. It’s <em>raison d’être</em> is that most of the time we <em>override</em> a method by re-implementing it in the inheriting class, – <code>Tesla</code> in our example – we’re supposed to call the method on the base class as well. This way we don’t have to copy logic over to the inheriting class whenever we re-implement a method. That’d be particularly lousy since whenever a base class changes we’d have to paste their logic into every inheriting class, turning our codebase into a maintainability nightmare.</p>
<p>If you now did the following, you’ll notice the Tesla car moves two places because of <code>base.move()</code>, which is what every regular car does as well, and it moves an additional four places because <code>Tesla</code> is just that good.</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> car = <span class="function"><span class="keyword">new</span> <span class="title">Tesla</span>()</span></span><br><span class="line"><span class="function"><span class="title">car</span>.<span class="title">addFuel</span>()</span></span><br><span class="line"><span class="function"><span class="title">car</span>.<span class="title">move</span>()</span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span>(car.distance)</span></span><br><span class="line"><span class="function"><span class="comment">// &lt;- 6</span></span></span><br></pre></td></tr></table></figure>
<p>The most common thing you’ll have to override is the <code>constructor</code> method. Here you can just call <code>super()</code>, passing any arguments that the base class needs. Tesla cars are twice as fast, so we just call the base <code>Car</code> constructor with twice the advertised <code>speed</code>.</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  constructor (speed) &#123;</span><br><span class="line">    <span class="keyword">this</span>.speed = speed</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Tesla</span> <span class="keyword">extends</span> <span class="title">Car</span> </span>&#123;</span><br><span class="line">  constructor (speed) &#123;</span><br><span class="line">    <span class="keyword">super</span>(speed * <span class="number">2</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[06.Object Literals]]></title>
      <url>/2018/07/31/pureMaterial/06.object_literals/</url>
      <content type="html"><![CDATA[<h2 id="Object-Literal"><a href="#Object-Literal" class="headerlink" title="Object Literal"></a>Object Literal</h2><h2 id="Property-Value-Shorthands"><a href="#Property-Value-Shorthands" class="headerlink" title="Property Value Shorthands"></a><a href="#property-value-shorthands">Property Value Shorthands</a></h2><p>Whenever you find yourself assigning a property value that matches a property name, you can omit the property value, it’s implicit in ES6.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> foo = <span class="string">'bar'</span></span><br><span class="line"><span class="selector-tag">var</span> baz = &#123; foo &#125;</span><br><span class="line">console.log(baz.foo)</span><br><span class="line"><span class="comment">// &lt;- 'bar'</span></span><br></pre></td></tr></table></figure>
<p>In the snippet shown below I re-implemented part of <code>localStorage</code> in memory as a polyfill. It displays a pattern that I’ve followed countless times <a href="https://github.com/bevacqua/local-storage/blob/b9725b0fc77faabc737ba7c6ee57d343afa95102/stub.js#L3-L32" target="_blank" rel="noopener">in my code</a>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> ms = &#123;&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItem</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> ms ? ms[key] : <span class="literal">null</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setItem</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  ms[key] = value</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ms = &#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getItem: getItem,</span><br><span class="line">  setItem: setItem,</span><br><span class="line">  clear: clear</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The reasons why <em>– most often –</em> I don’t place functions directly on an object definition are <em>several.</em></p>
<ul>
<li>Less indentation needed</li>
<li>Public API stands out</li>
<li>Harder to tightly couple methods</li>
<li>Easier to reason about</li>
</ul>
<p>With ES6, we can throw another bullet into that list, and that’s that the export can be even easier using <em>property value shorthands</em>. You can omit the property value if it matches the property name. The <code>module.exports</code> from the code above thus becomes:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">module<span class="selector-class">.exports</span> = &#123; getItem, setItem, <span class="attribute">clear</span> &#125;</span><br></pre></td></tr></table></figure>
<p>So good!</p>
<h2 id="Computed-Property-Names"><a href="#Computed-Property-Names" class="headerlink" title="Computed Property Names"></a><a href="#computed-property-names">Computed Property Names</a></h2><p>We already covered computed property names briefly in the <a href="/articles/es6-destructuring-in-depth">destructuring article</a>. This was a very common thing to do for me:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> foo = <span class="string">'bar'</span></span><br><span class="line"><span class="selector-tag">var</span> baz = &#123;&#125;</span><br><span class="line">baz[foo] = <span class="string">'ponyfoo'</span></span><br><span class="line">console.log(baz)</span><br><span class="line"><span class="comment">// &lt;- &#123; bar: 'ponyfoo' &#125;</span></span><br></pre></td></tr></table></figure>
<p>Computed property names allow you to write an <em>expression</em> wrapped in square brackets instead of the regular property name. Whatever the expression evaluates to will become the property name.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> foo = <span class="string">'bar'</span></span><br><span class="line"><span class="selector-tag">var</span> baz = &#123; [foo]: <span class="string">'ponyfoo'</span> &#125;</span><br><span class="line">console.log(baz)</span><br><span class="line"><span class="comment">// &lt;- &#123; bar: 'ponyfoo' &#125;</span></span><br></pre></td></tr></table></figure>
<p>One limitation of computed property names is that you won’t be able to use the shorthand expression with it. I presume this is because shorthand expression is meant to be simple, compile-time sugar.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> foo = <span class="string">'bar'</span></span><br><span class="line"><span class="selector-tag">var</span> bar = <span class="string">'ponyfoo'</span></span><br><span class="line"><span class="selector-tag">var</span> baz = &#123; [foo] &#125;</span><br><span class="line">console.log(baz)</span><br><span class="line"><span class="comment">// &lt;- SyntaxError</span></span><br></pre></td></tr></table></figure>
<p>That being said, I believe this to be the most common use case. Here our code is simpler because we don’t have to spend three steps in allocating a <code>foo</code> variable, assigning to <code>foo[type]</code>, and returning <code>foo</code>. Instead we can do all three in a single statement.</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">getModel</span> (type) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">&#123;</span></span><br><span class="line">    [<span class="keyword">type</span>]: &#123;</span><br><span class="line">      message: <span class="symbol">'hello</span>, this <span class="keyword">is</span> doge',</span><br><span class="line">      date: <span class="keyword">new</span> Date()</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Neat. What else?</p>
<h2 id="Method-Definitions"><a href="#Method-Definitions" class="headerlink" title="Method Definitions"></a><a href="#method-definitions">Method Definitions</a></h2><p>Typically in ES5 you declare methods on an object like so:</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123;</span><br><span class="line">  bar: <span class="function"><span class="keyword">function</span> <span class="params">(baz)</span> </span>&#123;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>While getters and setters have a syntax like this, where there’s no need for the <code>function</code> keyword. It’s just inferred from context.</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cart = &#123;</span><br><span class="line">  _wheels: <span class="number">4</span>,</span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">wheels</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._wheels</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="function"><span class="keyword">set</span> <span class="title">wheels</span> (<span class="params"><span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="keyword">this</span>._wheels) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'hey, come back here!'</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._wheels = <span class="keyword">value</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Starting in ES6, you can declare regular methods with a similar syntax, only difference is it’s not prefixed by <code>get</code> or <code>set</code>.</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> cart = &#123;</span><br><span class="line">  _wheels: <span class="number">4</span>,</span><br><span class="line">  <span class="keyword">get</span> wheels () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._wheels</span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="keyword">set</span> wheels (value) &#123;</span><br><span class="line">    <span class="keyword">if</span> (value &lt; <span class="keyword">this</span>._wheels) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'hey, come back here!'</span>)  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._wheels = value</span><br><span class="line">  &#125;,</span><br><span class="line">  dismantle () &#123;</span><br><span class="line">    <span class="keyword">this</span>._wheels = <span class="number">0</span></span><br><span class="line">    <span class="built_in">console</span>.warn(<span class="string">`you're all going to pay for this!`</span>)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>I think it’s nice that methods converged together with getters and setter. I for one don’t use this syntax a lot because I like to name my functions and decouple them from their host objects as I explained in the <a href="#property-value-shorthands">shorthand</a> section. However, it’s still useful in some situations and definitely useful when declaring <em>“classes”</em> – if you’re into that sort of thing.</p>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[extra --- 01.Fun with Native Arrays]]></title>
      <url>/2018/07/31/pureMaterial/extra.01.fun_with_native_arrays/</url>
      <content type="html"><![CDATA[<h2 id="Fun-with-Native-Arrays"><a href="#Fun-with-Native-Arrays" class="headerlink" title="Fun with Native Arrays"></a>Fun with Native Arrays</h2><p>In JavaScript, arrays can be created with the <code>Array</code> constructor, or using the <code>[]</code> convenience shortcut, which is also the preferred approach. Arrays inherit from the <code>Object</code> prototype and they haven’t a special value for <code>typeof</code>, they return <code>&#39;object&#39;</code> too. Using <code>[] instanceof Array</code>, however, returns true. That being said, there are also <em>Array-like objects</em> which complicate matters, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions_and_function_scope/arguments" target="_blank" rel="noopener">such as strings, or the <code>arguments</code> object</a>. The <code>arguments</code> object is not an instance of <code>Array</code>, but it still has a <code>length</code> property, and its values are indexed, so it can be looped like any Array.</p>
<p>In this article I’ll go over a few of the methods on the <code>Array</code> prototype, and explore the possibilities each of these methods unveil.</p>
<ul>
<li>Looping with <code>.forEach</code></li>
<li>Asserting with <code>.some</code> and <code>.every</code></li>
<li>Subtleties in <code>.join</code> and <code>.concat</code></li>
<li>Stacks and queues with <code>.pop</code>, <code>.push</code>, <code>.shift</code>, and <code>.unshift</code></li>
<li>Model mapping with <code>.map</code></li>
<li>Querying with <code>.filter</code></li>
<li>Ordering with <code>.sort</code></li>
<li>Computing with <code>.reduce</code>, <code>.reduceRight</code></li>
<li>Copying a <code>.slice</code></li>
<li>The power of <code>.splice</code></li>
<li>Lookups with <code>.indexOf</code></li>
<li>The <code>in</code> operator</li>
<li>Going in <code>.reverse</code></li>
</ul>
<p><img src="https://i.imgur.com/z0Hun2i.png" alt="console.png"></p>
<p>You can copy and paste any of the examples in your browser’s console, I sure did!</p>
<h3 id="Looping-with-forEach"><a href="#Looping-with-forEach" class="headerlink" title="Looping with .forEach"></a><a href="#looping-with-foreach">Looping with <code>.forEach</code></a></h3><p>This is one of the simplest methods in a native JavaScript Array. Unsurprisingly unsupport in IE7 and IE8.</p>
<p><code>forEach</code> takes a callback which is invoked once for each element in the array, and gets passed three arguments.</p>
<ul>
<li><code>value</code> containing the current array element</li>
<li><code>index</code> is the element’s position in the array</li>
<li><code>array</code> is a reference to the array</li>
</ul>
<p>Furthermore, we could pass an optional second argument which will become the context (<code>this</code>) for each function call.</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'_'</span>, <span class="string">'t'</span>, <span class="string">'a'</span>, <span class="string">'n'</span>, <span class="string">'i'</span>, <span class="string">'f'</span>, <span class="string">']'</span>].forEach(<span class="keyword">function</span> (<span class="keyword">value</span>, index, array) &#123;</span><br><span class="line">	<span class="keyword">this</span>.push(String.fromCharCode(<span class="keyword">value</span>.charCodeAt() + index + <span class="number">2</span>))</span><br><span class="line">&#125;, <span class="keyword">out</span> = [])</span><br><span class="line"></span><br><span class="line"><span class="keyword">out</span>.join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// &lt;- 'awesome'</span></span><br></pre></td></tr></table></figure>
<p>I cheated with <code>.join</code> which we didn’t cover <em>yet</em>, but we’ll look at it soon. In this case, it joins together the different elements in the array, effectively doing something like <code>out[0] + &#39;&#39; + out[1] + &#39;&#39; + out[2] + &#39;&#39; + out[n]</code>. We <strong>can’t break <code>forEach</code> loops</strong>, and throwing exceptions wouldn’t be very sensible. Luckily, we have other options available to us in those cases where we might want to short-circuit a loop.</p>
<h3 id="Asserting-with-some-and-every"><a href="#Asserting-with-some-and-every" class="headerlink" title="Asserting with .some and .every"></a><a href="#asserting-with-some-and-every">Asserting with <code>.some</code> and <code>.every</code></a></h3><p>If you’ve ever worked with .NET’s enumerables, these methods are the <em>poorly named</em> cousins of <a href="http://msdn.microsoft.com/en-us/library/bb534972(v=vs.110" target="_blank" rel="noopener"><code>.Any(x =&gt; x.IsAwesome)</code></a>.aspx) and <a href="http://msdn.microsoft.com/en-us/library/bb548541(v=vs.110" target="_blank" rel="noopener"><code>.All(x =&gt; x.IsAwesome)</code></a>.aspx).</p>
<p>These methods are similar to <code>.forEach</code> in that they also take a callback with <code>value</code>, <code>index</code>, and <code>array</code>, which can be context-bound passing a second argument. The MDN docs describe <code>.some</code>:</p>
<blockquote>
<p><code>some</code> executes the callback function once for each element present in the array until it finds one where <code>callback</code> returns a <code>true</code> value. If such an element is found, <code>some</code> immediately returns <code>true</code>. Otherwise, <code>some</code> returns <code>false</code>. <code>callback</code> is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values.</p>
</blockquote>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">max = -Infinity</span><br><span class="line">satisfied = [10, <span class="number">12</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">5</span>, <span class="number">23</span>].<span class="keyword">some</span>(<span class="keyword">function</span> (<span class="keyword">value</span>, <span class="keyword">index</span>, <span class="keyword">array</span>) &#123;</span><br><span class="line">	<span class="keyword">if</span> (<span class="keyword">value</span> &gt; <span class="built_in">max</span>) <span class="built_in">max</span> = <span class="keyword">value</span></span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">value</span> &lt; <span class="number">10</span></span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">max</span>)</span><br><span class="line">// &lt;- <span class="number">12</span></span><br><span class="line"></span><br><span class="line">satisfied</span><br><span class="line">// &lt;- <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>Note that the function stopped looping after it hit the first item which satisfied the callback’s condition <code>value &lt; 10</code>. <code>.every</code> works in the same way, but short-circuits happen when your callback returns <code>false</code>, rather than <code>true</code>.</p>
<h3 id="Subtleties-in-join-and-concat"><a href="#Subtleties-in-join-and-concat" class="headerlink" title="Subtleties in .join and .concat"></a><a href="#subtleties-in-join-and-concat">Subtleties in <code>.join</code> and <code>.concat</code></a></h3><p>The <code>.join</code> method is often confused with <code>.concat</code>. <code>.join(separator)</code> creates a string, resulting of taking every element in the array and separating them by <code>separator</code>. If no <code>separator</code> is provided, it’ll default to a comma <code>&#39;,&#39;</code>. <code>.concat</code> works by creating new arrays which are shallow copies of the source arrays.</p>
<ul>
<li><code>.concat</code> has the signature: <code>array.concat(val, val2, val3, valn)</code></li>
<li><code>.concat</code> returns a new array</li>
<li><code>array.concat()</code> with no arguments returns a shallow copy of the array</li>
</ul>
<p>Shallow copy means that the copy will hold the same object references as the source array, which is generally a good thing. For example:</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = &#123; foo: 'bar' &#125;</span><br><span class="line"><span class="keyword">var</span> b = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, a]</span><br><span class="line"><span class="keyword">var</span> <span class="built_in">c</span> = b.concat()</span><br><span class="line"></span><br><span class="line">console.log(b === <span class="built_in">c</span>)</span><br><span class="line"><span class="comment">// &lt;- false</span></span><br><span class="line"></span><br><span class="line">b[<span class="number">3</span>] === a &amp;&amp; <span class="built_in">c</span>[<span class="number">3</span>] === a</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br></pre></td></tr></table></figure>
<h3 id="Stacks-and-queues-with-pop-push-shift-and-unshift"><a href="#Stacks-and-queues-with-pop-push-shift-and-unshift" class="headerlink" title="Stacks and queues with .pop, .push, .shift, and .unshift"></a><a href="#stacks-and-queues-with-pop-push-shift-and-unshift">Stacks and queues with <code>.pop</code>, <code>.push</code>, <code>.shift</code>, and <code>.unshift</code></a></h3><p>Nowadays, everyone knows that <em>adding elements to the end of an array</em> is done using <code>.push</code>. Did you know that you can push many elements at once using <code>[].push(&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;, &#39;z&#39;)</code>?</p>
<p>The <code>.pop</code> method is the counterpart of the most common use for <code>.push</code>. It’ll return the last element in the array, and remove it from the array at the same time. If the array is empty, <a href="http://stackoverflow.com/questions/7452341/what-does-void-0-mean" target="_blank" rel="noopener"><code>void 0</code> (<code>undefined</code>)</a> is returned. Using <code>.push</code> and <code>.pop</code> we could easily create a <a href="http://en.wikipedia.org/wiki/LIFO_(computing" target="_blank" rel="noopener">LIFO (last in first out)</a>) stack.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Stack</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>._stack = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack.prototype.next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._stack.pop()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Stack.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._stack.push.apply(<span class="keyword">this</span>._stack, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">stack = <span class="keyword">new</span> Stack()</span><br><span class="line">stack.add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">stack.next()</span><br><span class="line"><span class="comment">// &lt;- 3</span></span><br></pre></td></tr></table></figure>
<p>Inversely, we could create a <a href="http://en.wikipedia.org/wiki/FIFO" target="_blank" rel="noopener">FIFO (first in first out)</a> queue using <code>.unshift</code> and <code>.shift</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Queue</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">this</span>._queue = []</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue.prototype.next = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._queue.shift()</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Queue.prototype.add = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>._queue.unshift.apply(<span class="keyword">this</span>._queue, <span class="built_in">arguments</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">queue = <span class="keyword">new</span> Queue()</span><br><span class="line">queue.add(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>)</span><br><span class="line"></span><br><span class="line">queue.next()</span><br><span class="line"><span class="comment">// &lt;- 1</span></span><br></pre></td></tr></table></figure>
<p>Using <code>.shift</code> (or <code>.pop</code>) is an easy way to loop through a set of array elements, while draining the array in the process.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">list</span> = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">7</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>]</span><br><span class="line"></span><br><span class="line">while (item = <span class="type">list</span>.shift()) &#123;</span><br><span class="line">	console.log(item)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">list</span></span><br><span class="line"><span class="comment">// &lt;- []</span></span><br></pre></td></tr></table></figure>
<h3 id="Model-mapping-with-map"><a href="#Model-mapping-with-map" class="headerlink" title="Model mapping with .map"></a><a href="#model-mapping-with-map">Model mapping with <code>.map</code></a></h3><blockquote>
<p><code>map</code> calls a provided callback function once for each element in an array, in order, and constructs a new array from the results. <code>callback</code> is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values.</p>
</blockquote>
<p>The <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Array/map" target="_blank" rel="noopener"><code>Array.prototype.map</code></a> method has the same signature we’ve seen in <code>.forEach</code>, <code>.some</code>, and <code>.every</code>: <code>.map(fn(value, index, array), thisArgument)</code>.</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">values = [void <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">false</span>, <span class="string">''</span>]</span><br><span class="line">values[<span class="number">7</span>] = void <span class="number">0</span></span><br><span class="line">result = values.map(function(value, index, array)&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(value)</span><br><span class="line">    <span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> &lt;- [<span class="literal">undefined</span>, <span class="literal">null</span>, <span class="literal">false</span>, <span class="string">''</span>, <span class="literal">undefined</span> × <span class="number">3</span>, <span class="literal">undefined</span>]</span><br></pre></td></tr></table></figure>
<p>The <code>undefined × 3</code> values explain that while <code>.map</code> won’t run for deleted or unassigned array elements, they’ll be still included in the resulting array. Mapping is very useful for casting or transforming arrays.</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// casting</span></span><br><span class="line">[<span class="number">1</span>, <span class="string">'2'</span>, <span class="string">'30'</span>, <span class="string">'9'</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">parseInt</span>(value, <span class="number">10</span>)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// 1, 2, 30, 9</span></span><br><span class="line"></span><br><span class="line">[<span class="number">97</span>, <span class="number">119</span>, <span class="number">101</span>, <span class="number">115</span>, <span class="number">111</span>, <span class="number">109</span>, <span class="number">101</span>].map(<span class="built_in">String</span>.fromCharCode).join(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// &lt;- 'awesome'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// a commonly used pattern is mapping to new objects</span></span><br><span class="line">items.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> &#123;</span><br><span class="line">		<span class="attribute">id:</span><span class="string"> item.id</span>,</span><br><span class="line">		<span class="attribute">name</span>: computeName(item)</span><br><span class="line">	&#125;</span><br><span class="line">&#125;)</span><br></pre></td></tr></table></figure>
<h3 id="Querying-with-filter"><a href="#Querying-with-filter" class="headerlink" title="Querying with .filter"></a><a href="#querying-with-filter">Querying with <code>.filter</code></a></h3><blockquote>
<p><code>filter</code> calls a provided callback function once for each element in an array, and constructs a new array of all the values for which <code>callback</code> returns a <code>true</code> value. <code>callback</code> is invoked only for indexes of the array which have assigned values; it is not invoked for indexes which have been deleted or which have never been assigned values. Array elements which do not pass the <code>callback</code> test are simply skipped, and <strong>are not included</strong> in the new array.</p>
</blockquote>
<p>Same as usual: <code>.filter(fn(value, index, array), thisArgument)</code>. Think of it as the <code>.Where(x =&gt; x.IsAwesome)</code> LINQ expression (if you’re into C#), or the <code>WHERE</code> SQL clause. Considering <code>.filter</code> only returns elements which pass the <code>callback</code> test with a truthy value, there are some interesting use cases.</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">[<span class="keyword">void</span> <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">false</span>, <span class="string">''</span>, <span class="number">1</span>].filter(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- [1]</span></span><br><span class="line"></span><br><span class="line">[<span class="keyword">void</span> <span class="number">0</span>, <span class="literal">null</span>, <span class="literal">false</span>, <span class="string">''</span>, <span class="number">1</span>].filter(<span class="function"><span class="keyword">function</span> <span class="params">(value)</span> </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> !value</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- [void 0, null, false, '']</span></span><br></pre></td></tr></table></figure>
<h3 id="Ordering-with-sort-compareFunction"><a href="#Ordering-with-sort-compareFunction" class="headerlink" title="Ordering with .sort(compareFunction)"></a><a href="#ordering-with-sort-comparefunction">Ordering with <code>.sort(compareFunction)</code></a></h3><blockquote>
<p>If <code>compareFunction</code> is not supplied, elements are sorted by converting them to strings and comparing strings in lexicographic (“dictionary” or “telephone book,” not numerical) order. For example, “80” comes before “9” in lexicographic order, but in a numeric sort 9 comes before 80.</p>
</blockquote>
<p>Like most sorting functions, <code>Array.prototype.sort(fn(a,b))</code> takes a callback which tests two elements, and should produce one of three return values:</p>
<ul>
<li>return value <code>&lt; 0</code> if <code>a</code> comes before <code>b</code></li>
<li>return value <code>=== 0</code> if both <code>a</code> and <code>b</code> are considered equivalent</li>
<li>return value <code>&gt; 0</code> if <code>a</code> comes after <code>b</code></li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">9</span>,<span class="number">80</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">6</span>].sort()</span><br><span class="line"><span class="comment">// &lt;- [10, 3, 5, 6, 80, 9]</span></span><br><span class="line"></span><br><span class="line">[<span class="number">9</span>,<span class="number">80</span>,<span class="number">3</span>,<span class="number">10</span>,<span class="number">5</span>,<span class="number">6</span>].sort(function (a, b) &#123;</span><br><span class="line">	return a - b</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- [3, 5, 6, 9, 10, 80]</span></span><br></pre></td></tr></table></figure>
<h3 id="Computing-with-reduce-reduceRight"><a href="#Computing-with-reduce-reduceRight" class="headerlink" title="Computing with .reduce, .reduceRight"></a><a href="#computing-with-reduce-reduceright">Computing with <code>.reduce</code>, <code>.reduceRight</code></a></h3><p>Reduce functions are, at first, hard to wrap our heads around. These functions loop through the array, from left-to-right <em>(<code>.reduce</code>)</em> or right-to-left <em>(<code>.reduceRight</code>)</em>, each invocation receives the partial result so far, and the operation results in a single aggregated return value.</p>
<p>Both methods have the following signature: <code>.reduce(callback(previousValue, currentValue, index, array), initialValue)</code>.</p>
<p>The <code>previousValue</code> will be the value returned in the last callback invocation, or <code>initialValue</code> the first time around. <code>currentValue</code> contains the current element, while <code>index</code> indicates the array position for the element. <code>array</code> is simply a reference to the array <code>.reduce</code> was called on.</p>
<p>One of the typical use cases for <code>.reduce</code> is the sum function.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.prototype.sum = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="keyword">this</span>.reduce(<span class="function"><span class="keyword">function</span> (<span class="params">partial, value</span>) </span>&#123;</span><br><span class="line">		<span class="keyword">return</span> partial + value</span><br><span class="line">	&#125;, <span class="number">0</span>)</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>,<span class="number">10</span>].sum()</span><br><span class="line"><span class="comment">// &lt;- 28</span></span><br></pre></td></tr></table></figure>
<p>Say we wanted to join a few strings together. We could use <code>.join</code> to that purpose. In the case of objects, though, <code>.join</code> wouldn’t work as we expected, unless the objects had a reasonable <code>valueOf</code> or <code>toString</code> representation. However, we might use <code>.reduce</code> as a string builder for those objects.</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span> <span class="params">(input)</span></span> &#123;</span><br><span class="line">	<span class="keyword">return</span> <span class="built_in">input</span>.reduce(<span class="function"><span class="keyword">function</span> <span class="params">(partial, value)</span></span> &#123;</span><br><span class="line">		<span class="keyword">if</span> (partial) &#123;</span><br><span class="line">			partial += <span class="string">', '</span></span><br><span class="line">		&#125;</span><br><span class="line">		<span class="keyword">return</span> partial + value.name</span><br><span class="line">	&#125;, <span class="string">''</span>)</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">concat</span>([</span><br><span class="line">	&#123; name: <span class="string">'George'</span> &#125;,</span><br><span class="line">	&#123; name: <span class="string">'Sam'</span> &#125;,</span><br><span class="line">	&#123; name: <span class="string">'Pear'</span> &#125;</span><br><span class="line">])</span><br><span class="line">// &lt;- <span class="string">'George, Sam, Pear'</span></span><br></pre></td></tr></table></figure>
<h3 id="Copying-a-slice"><a href="#Copying-a-slice" class="headerlink" title="Copying a .slice"></a><a href="#copying-a-slice">Copying a <code>.slice</code></a></h3><p>Similarly to <code>.concat</code>, calls to <code>.slice</code> without any arguments produce a shallow copy of the source array. Slice takes two arguments, a <code>begin</code> and an <code>end</code> position. <code>Array.prototype.slice</code> can be used to convert array-like objects into real arrays.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array<span class="selector-class">.prototype</span><span class="selector-class">.slice</span><span class="selector-class">.call</span>(&#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, length: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// &lt;- ['a', 'b']</span></span><br></pre></td></tr></table></figure>
<p>This won’t work with <code>.concat</code>, because it’ll wrap the array-like object in a real array, instead.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array<span class="selector-class">.prototype</span><span class="selector-class">.concat</span><span class="selector-class">.call</span>(&#123; <span class="number">0</span>: <span class="string">'a'</span>, <span class="number">1</span>: <span class="string">'b'</span>, length: <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// &lt;- [&#123; 0: 'a', 1: 'b', length: 2 &#125;]</span></span><br></pre></td></tr></table></figure>
<p>Other than that, another common use for <code>.slice</code> is <em>removing the first few elements</em> from a list of arguments (an array-like object, which we could cast to a real array).</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">format</span> (<span class="params">text, bold</span>) </span>&#123;</span><br><span class="line">	<span class="keyword">if</span> (bold) &#123;</span><br><span class="line">		text = <span class="string">'&lt;b&gt;'</span> + text + <span class="string">'&lt;/b&gt;'</span></span><br><span class="line">	&#125;</span><br><span class="line">	<span class="keyword">var</span> values = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>, <span class="number">2</span>)</span><br><span class="line"></span><br><span class="line">	values.forEach(<span class="function"><span class="keyword">function</span> (<span class="params">value</span>) </span>&#123;</span><br><span class="line">		text = text.replace(<span class="string">'%s'</span>, value)</span><br><span class="line">	&#125;)</span><br><span class="line"></span><br><span class="line">	<span class="keyword">return</span> text</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">format(<span class="string">'some%sthing%s %s'</span>, <span class="literal">true</span>, <span class="string">'some'</span>, <span class="string">'other'</span>, <span class="string">'things'</span>)</span><br><span class="line"><span class="comment">// &lt;- &lt;b&gt;somesomethingother things&lt;/b&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="The-power-of-splice"><a href="#The-power-of-splice" class="headerlink" title="The power of .splice"></a><a href="#the-power-of-splice">The power of <code>.splice</code></a></h3><p><code>.splice</code> is one of my favorite native array functions. It allows you to remove elements, insert new ones, and to do both in the same position, using just one function call. Note that this function alters the source array, unlike <code>.concat</code> or <code>.slice</code>.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">var source = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>]</span><br><span class="line">var spliced = source.splice(<span class="number">3</span>, <span class="number">4</span>, <span class="number">4</span>, <span class="number">5</span>, <span class="number">6</span>, <span class="number">7</span>)</span><br><span class="line"></span><br><span class="line">console.log(source)</span><br><span class="line"><span class="comment">// &lt;- [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12 ,13]</span></span><br><span class="line"></span><br><span class="line">spliced</span><br><span class="line"><span class="comment">// &lt;- [8, 8, 8, 8]</span></span><br></pre></td></tr></table></figure>
<p>As you might’ve noted, it also returns the removed elements. This might come in handy if you want to loop a section of the array and then forget about it.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">var source = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">8</span>,<span class="number">9</span>,<span class="number">10</span>,<span class="number">11</span>,<span class="number">12</span>,<span class="number">13</span>]</span><br><span class="line">var spliced = source.splice(<span class="number">9</span>)</span><br><span class="line"></span><br><span class="line">spliced.forEach(function (value) &#123;</span><br><span class="line">	console.log('removed', value)</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- removed 10</span></span><br><span class="line"><span class="comment">// &lt;- removed 11</span></span><br><span class="line"><span class="comment">// &lt;- removed 12</span></span><br><span class="line"><span class="comment">// &lt;- removed 13</span></span><br><span class="line"></span><br><span class="line">console.log(source)</span><br><span class="line"><span class="comment">// &lt;- [1, 2, 3, 8, 8, 8, 8, 8, 9]</span></span><br></pre></td></tr></table></figure>
<h3 id="Lookups-with-indexOf"><a href="#Lookups-with-indexOf" class="headerlink" title="Lookups with .indexOf"></a><a href="#lookups-with-indexof">Lookups with <code>.indexOf</code></a></h3><p>With <code>.indexOf</code>, we can look up array element positions. If it can’t find a match, <code>-1</code> is returned. A pattern I find myself using a lot, is when I have comparisons such as <code>a === &#39;a&#39; || a === &#39;b&#39; || a === &#39;c&#39;</code>, or even with just two comparsions. You could just use <code>.indexOf</code>, like so: <code>[&#39;a&#39;, &#39;b&#39;, &#39;c&#39;].indexOf(a) !== -1</code>.</p>
<p>Note that objects will be found only if the same reference is provided. A second argument can provide the start index at which to begin searching.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = &#123; foo: <span class="string">'bar'</span> &#125;</span><br><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">b</span> = [<span class="selector-tag">a</span>, <span class="number">2</span>]</span><br><span class="line"></span><br><span class="line">console.log(<span class="selector-tag">b</span>.indexOf(<span class="number">1</span>))</span><br><span class="line"><span class="comment">// &lt;- -1</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="selector-tag">b</span>.indexOf(&#123; foo: <span class="string">'bar'</span> &#125;))</span><br><span class="line"><span class="comment">// &lt;- -1</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="selector-tag">b</span>.indexOf(a))</span><br><span class="line"><span class="comment">// &lt;- 0</span></span><br><span class="line"></span><br><span class="line">console.log(<span class="selector-tag">b</span>.indexOf(<span class="selector-tag">a</span>, <span class="number">1</span>))</span><br><span class="line"><span class="comment">// &lt;- -1</span></span><br><span class="line"></span><br><span class="line"><span class="selector-tag">b</span>.indexOf(<span class="number">2</span>, <span class="number">1</span>)</span><br><span class="line"><span class="comment">// &lt;- 1</span></span><br></pre></td></tr></table></figure>
<p>If you want to go in the reverse direction, <code>.lastIndexOf</code> will do the trick.</p>
<h3 id="The-in-operator"><a href="#The-in-operator" class="headerlink" title="The in operator"></a><a href="#the-in-operator">The <code>in</code> operator</a></h3><p>A common rookie mistake during interviews is to confuse <code>.indexOf</code> with the <code>in</code> operator, and hand-scribbling things such as:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> <span class="keyword">in</span> a</span><br><span class="line"><span class="comment">// &lt;- true, but because of the 2!</span></span><br><span class="line"></span><br><span class="line"><span class="number">5</span> <span class="keyword">in</span> a</span><br><span class="line"><span class="comment">// &lt;- false</span></span><br></pre></td></tr></table></figure>
<p>The problem here was that the <code>in</code> operator checks the object key for a value, rather than searching for values. This is, of course, much faster than using <code>.indexOf</code>.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var a = [<span class="number">3</span>, <span class="number">7</span>, <span class="number">6</span>]</span><br><span class="line"></span><br><span class="line"><span class="number">1</span> in a === !!a[<span class="number">1</span>]</span><br><span class="line"><span class="comment">// &lt;- true</span></span><br></pre></td></tr></table></figure>
<p>The <code>in</code> operator is similar to casting the value at the provided key to a boolean value. The <code>!!</code> expression is used by some developers to negate a value, and then negate it again. <em>Effectively casting to boolean</em> any truthy value to <code>true</code>, and any falsy value to <code>false</code>.</p>
<h3 id="Going-in-reverse"><a href="#Going-in-reverse" class="headerlink" title="Going in .reverse"></a><a href="#going-in-reverse">Going in <code>.reverse</code></a></h3><p>This method will take the elements in an array and reverse them in place.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> <span class="selector-tag">a</span> = [<span class="number">1</span>, <span class="number">1</span>, <span class="number">7</span>, <span class="number">8</span>]</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">a</span>.reverse()</span><br><span class="line"><span class="comment">// [8, 7, 1, 1]</span></span><br></pre></td></tr></table></figure>
<p>Rather than a copy, the array itself is modified. In a future article we’ll expand on these concepts to see how we could create an <code>_</code>-like library, such as <a href="http://underscorejs.org/" target="_blank" rel="noopener">Underscore</a> or <a href="http://lodash.com/" target="_blank" rel="noopener">Lo-Dash</a>.</p>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[05.Template Literals]]></title>
      <url>/2018/07/31/pureMaterial/05.template_literals/</url>
      <content type="html"><![CDATA[<h2 id="Template-Literals"><a href="#Template-Literals" class="headerlink" title="Template Literals"></a>Template Literals</h2><p>Template literals are a new feature in ES6 to make working with strings and string templates easier. You wrap your text in <code>`backticks`</code> and you’ll get the features described below.</p>
<ul>
<li>You can interpolate variables in them</li>
<li>You can actually interpolate using <em>any kind of expression</em>, not just variables</li>
<li>They can be <strong>multi-line</strong>. <em>Finally!</em></li>
<li>You can construct <em>raw templates</em> that don’t interpret backslashes</li>
</ul>
<p>In addition, you can also define <em>a method</em> that will decide what to make of the template, instead of using the default templating behavior. There are some interesting use cases for this one.</p>
<blockquote>
<p>Let’s dig into template literals and see what we can come up with.</p>
</blockquote>
<h2 id="Using-Template-Literals"><a href="#Using-Template-Literals" class="headerlink" title="Using Template Literals"></a><a href="#using-template-literals">Using Template Literals</a></h2><p>We’ve already covered the basic <em><code>`I&#39;m just a string`</code></em>. One aspect of template literals that may be worth mentioning is that you’re now able to declare strings with both <code>&#39;</code> and <code>&quot;</code> quotation marks in them without having to escape anything.</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var <span class="built_in">text</span> = `I'm <span class="string">"amazed"</span> <span class="keyword">that</span> we have so many quotation marks <span class="keyword">to</span> choose <span class="keyword">from</span>!`</span><br></pre></td></tr></table></figure>
<p>That was neat, but surely there’s more useful stuff we can apply template literals to. How about some <em>actual interpolation</em>? You can use the <code>${expression}</code> notation for that.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> host = <span class="string">'ponyfoo.com'</span></span><br><span class="line"><span class="keyword">var</span> text = <span class="string">`this blog lives at <span class="subst">$&#123;host&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(text)</span><br><span class="line"><span class="comment">// &lt;- 'this blog lives at ponyfoo.com'</span></span><br></pre></td></tr></table></figure>
<p>I’ve already mentioned you can have any kind of expressions you want in there. Think of whatever expressions you put in there as defining a variable before the template runs, and then concatenating that value with the rest of the string. That means that variables you use, methods you call, and so on, should all be available to the current scope.</p>
<p>The following expressions would all work just as well. It’ll be up to us to decide how much logic we cram into the interpolation expressions.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = <span class="string">`this blog lives at <span class="subst">$&#123;<span class="string">'ponyfoo.com'</span>&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(text)</span><br><span class="line"><span class="comment">// &lt;- 'this blog lives at ponyfoo.com'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> <span class="built_in">today</span> = new <span class="built_in">Date</span>()</span><br><span class="line"><span class="built_in">var</span> <span class="built_in">text</span> = `the <span class="built_in">time</span> <span class="built_in">and</span> <span class="built_in">date</span> is $&#123;today.toLocaleString()&#125;`</span><br><span class="line">console.log(<span class="built_in">text</span>)</span><br><span class="line">// &lt;- 'the <span class="built_in">time</span> <span class="built_in">and</span> <span class="built_in">date</span> is <span class="number">8</span>/<span class="number">26</span>/<span class="number">2015</span>, <span class="symbol">3:15</span><span class="symbol">:20</span> PM'</span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> moment <span class="keyword">from</span> <span class="string">'moment'</span></span><br><span class="line"><span class="keyword">var</span> today = <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line"><span class="keyword">var</span> text = <span class="string">`today is the <span class="subst">$&#123;moment(today).format(<span class="string">'Do [of] MMMM'</span>)&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(text)</span><br><span class="line"><span class="comment">// &lt;- 'today is the 26th of August'</span></span><br></pre></td></tr></table></figure>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var <span class="keyword">text</span> = <span class="string">`such $&#123;Infinity/0&#125;, very uncertain`</span></span><br><span class="line">console.<span class="keyword">log</span>(<span class="keyword">text</span>)</span><br><span class="line"><span class="comment">// &lt;- 'such Infinity, very uncertain'</span></span><br></pre></td></tr></table></figure>
<p>Multi-line strings mean that you no longer have to use methods like these anymore.</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var text = (</span><br><span class="line">  <span class="symbol">'foo</span>\n' +</span><br><span class="line">  <span class="symbol">'bar</span>\n' +</span><br><span class="line">  <span class="symbol">'baz'</span></span><br><span class="line">)</span><br></pre></td></tr></table></figure>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> text = [</span><br><span class="line">  <span class="string">'foo'</span>,</span><br><span class="line">  <span class="string">'bar'</span>,</span><br><span class="line">  <span class="string">'baz'</span></span><br><span class="line">].<span class="keyword">join</span>(<span class="string">'\n'</span>)</span><br></pre></td></tr></table></figure>
<p>Instead, you can now just use backticks! Note that spacing matters, so you might still want to use parenthesis in order to keep the first line of text away from the variable declaration.</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var text = (</span><br><span class="line">`foo</span><br><span class="line">bar</span><br><span class="line">baz`)</span><br></pre></td></tr></table></figure>
<p>Multi-line strings really shine when you have, <em>for instance</em>, a chunk of HTML you want to interpolate some variables to. Much like with <a href="/articles/react-jsx-and-es6-the-weird-parts">JSX</a>, you’re perfectly able to use an expression to iterate over a collection and <code>return</code> yet another template literal to declare list items. This makes it a breeze to declare sub-components in your templates. Note also how I’m <a href="/articles/es6-destructuring-in-depth">using destructuring</a> to avoid having to prefix every expression of mine with <code>article.</code>, I like to think of it as <em>“a <code>with</code> block, but not as insane”</em>.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line">var article = &#123;</span><br><span class="line">  title: <span class="string">'Hello Template Literals'</span>,</span><br><span class="line">  teaser: <span class="string">'String interpolation is awesome. Here are some features'</span>,</span><br><span class="line">  body: <span class="string">'Lots and lots of sanitized HTML'</span>,</span><br><span class="line">  <span class="keyword">tag</span><span class="variable">s:</span> [<span class="string">'es6'</span>, <span class="string">'template-literals'</span>, <span class="string">'es6-in-depth'</span>]</span><br><span class="line">&#125;</span><br><span class="line">var &#123;title,teaser,body,<span class="keyword">tags</span>&#125; = article</span><br><span class="line">var html = `<span class="symbol">&lt;article&gt;</span></span><br><span class="line">  <span class="symbol">&lt;header&gt;</span></span><br><span class="line">    <span class="symbol">&lt;h1&gt;</span>$&#123;title&#125;&lt;/h1&gt;</span><br><span class="line">  &lt;/header&gt;</span><br><span class="line">  <span class="symbol">&lt;section&gt;</span></span><br><span class="line">    <span class="symbol">&lt;div&gt;</span>$&#123;teaser&#125;&lt;/div&gt;</span><br><span class="line">    <span class="symbol">&lt;div&gt;</span>$&#123;body&#125;&lt;/div&gt;</span><br><span class="line">  &lt;/section&gt;</span><br><span class="line">  <span class="symbol">&lt;footer&gt;</span></span><br><span class="line">    <span class="symbol">&lt;ul&gt;</span></span><br><span class="line">      $&#123;<span class="keyword">tags</span>.<span class="keyword">map</span>(<span class="keyword">tag</span> =&gt; `<span class="symbol">&lt;li&gt;</span>$&#123;<span class="keyword">tag</span>&#125;&lt;/li&gt;`).<span class="keyword">join</span>(<span class="string">'\n      '</span>)&#125;</span><br><span class="line">    &lt;/ul&gt;</span><br><span class="line">  &lt;/footer&gt;</span><br><span class="line">&lt;/article&gt;`</span><br></pre></td></tr></table></figure>
<p>The above will produce output as shown below. Note how the spacing trick was enough to properly indent the <code>&lt;li&gt;</code> tags.</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;article&gt;</span></span><br><span class="line">  <span class="variable">&lt;header&gt;</span></span><br><span class="line">    <span class="variable">&lt;h1&gt;</span>Hello <span class="keyword">Template</span> Literals<span class="variable">&lt;/h1&gt;</span></span><br><span class="line">  <span class="variable">&lt;/header&gt;</span></span><br><span class="line">  <span class="variable">&lt;section&gt;</span></span><br><span class="line">    <span class="variable">&lt;div&gt;</span>String interpolation is awesome. Here are some features<span class="variable">&lt;/div&gt;</span></span><br><span class="line">    <span class="variable">&lt;div&gt;</span>Lots and lots of sanitized HTML<span class="variable">&lt;/div&gt;</span></span><br><span class="line">  <span class="variable">&lt;/section&gt;</span></span><br><span class="line">  <span class="variable">&lt;footer&gt;</span></span><br><span class="line">    <span class="variable">&lt;ul&gt;</span></span><br><span class="line">      <span class="variable">&lt;li&gt;</span>es6<span class="variable">&lt;/li&gt;</span></span><br><span class="line">      <span class="variable">&lt;li&gt;</span>template-literals<span class="variable">&lt;/li&gt;</span></span><br><span class="line">      <span class="variable">&lt;li&gt;</span>es6-in-depth<span class="variable">&lt;/li&gt;</span></span><br><span class="line">    <span class="variable">&lt;/ul&gt;</span></span><br><span class="line">  <span class="variable">&lt;/footer&gt;</span></span><br><span class="line"><span class="variable">&lt;/article&gt;</span></span><br></pre></td></tr></table></figure>
<p>Raw templates are the same in essence, you just have to prepend your template literal with <code>String.raw</code>. This can be very convenient in some use cases.</p>
<figure class="highlight vhdl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var <span class="literal">text</span> = <span class="built_in">String</span>.raw`The <span class="string">"\n"</span> newline won<span class="symbol">'t</span> result <span class="keyword">in</span> a <span class="keyword">new</span> <span class="literal">line</span>.</span><br><span class="line">It<span class="symbol">'ll</span> be escaped.`</span><br><span class="line">console.log(<span class="literal">text</span>)</span><br><span class="line">// The <span class="string">"\n"</span> newline won<span class="symbol">'t</span> result <span class="keyword">in</span> a <span class="keyword">new</span> <span class="literal">line</span>.</span><br><span class="line">// It<span class="symbol">'ll</span> be escaped.</span><br></pre></td></tr></table></figure>
<p>You might’ve noticed that <code>String.raw</code> seems to be a special part of the template literal syntax, and you’d be right! The method you choose will be used to parse the template. Template literal methods – called <em>“tagged templates”</em> – receive an array containing a list of the static parts of the template, as well as each expression on their own variables.</p>
<p>For instance a template literal like <code>`hello ${name}. I am ${emotion}!`</code> will pass arguments to the <em>“tagged template”</em> in a function call like the one below.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">fn</span><span class="params">([<span class="string">'hello '</span>, <span class="string">'. I am'</span>, <span class="string">'!'</span>], <span class="string">'nico'</span>, <span class="string">'confused'</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>You might be confused by the seeming oddity in which the arguments are laid out, but they start to make sense when you think of it this way: for every item in the template array, there’s an expression result after it.</p>
<h2 id="Demystifying-Tagged-Templates"><a href="#Demystifying-Tagged-Templates" class="headerlink" title="Demystifying Tagged Templates"></a><a href="#demystifying-tagged-templates">Demystifying Tagged Templates</a></h2><p>I wrote an example <code>normal</code> method below, and it works <em>exactly like the default behavior</em>. This might help you better understand what happens under the hood for template literals.</p>
<blockquote>
<p>If you don’t know what <code>.reduce</code> does, refer to <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_Objects/Array/reduce" target="_blank" rel="noopener">MDN</a> or my <a href="/articles/fun-with-native-arrays#computing-with-reduce-reduceright">“Fun with Native Arrays”</a> article. Reduce is always useful when you’re trying to map a collection of values into a single value that can be computed from the collection.</p>
</blockquote>
<p>In this case we can reduce the <code>template</code> starting from <code>template[0]</code> and then reducing all other parts by adding the preceding <code>expression</code> and the subsequent <code>part</code>.</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">normal</span> <span class="params">(template, <span class="rest_arg">...expressions</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> template.reduce((accumulator, part, i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> accumulator + expressions[i - <span class="number">1</span>] + part</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The <code>...expressions</code> syntax is new in ES6 as well. It’s called the <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="noopener"><em>“rest parameters syntax”</em></a>, and it’ll basically place all the arguments passed to <code>normal</code> that come after <code>template</code> into a single array. You can try the tagged template as seen below, and you’ll notice you get the same output as if you omitted <code>normal</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> name = <span class="string">'nico'</span></span><br><span class="line"><span class="keyword">var</span> outfit = <span class="string">'leather jacket'</span></span><br><span class="line"><span class="keyword">var</span> text = normal<span class="string">`hello <span class="subst">$&#123;name&#125;</span>, you look lovely today in that <span class="subst">$&#123;outfit&#125;</span>`</span></span><br><span class="line"><span class="built_in">console</span>.log(text)</span><br><span class="line"><span class="comment">// &lt;- 'hello nico, you look lovely today in that leather jacket'</span></span><br></pre></td></tr></table></figure>
<p>Now that we’ve figured out how tagged templates work, what can we do with them? Well, whatever we want. One possible use case might be to make user input uppercase, turning our greeting into something that sounds more satirical – <em>I read the result out loud in my head with Gob’s voice from Arrested Development, now I’m laughing alone. I’ve made a huge mistake</em>.</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">upperExpr</span> <span class="params">(template, <span class="rest_arg">...expressions</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> template.reduce((accumulator, part, i) =&gt; &#123;</span><br><span class="line">    <span class="keyword">return</span> accumulator + expressions[i - <span class="number">1</span>].toUpperCase() + part</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'nico'</span></span><br><span class="line"><span class="keyword">var</span> outfit = <span class="string">'leather jacket'</span></span><br><span class="line"><span class="keyword">var</span> text = upperExpr`hello $&#123;name&#125;, you look lovely today <span class="keyword">in</span> that $&#123;outfit&#125;`</span><br><span class="line">console.log(text)</span><br><span class="line"><span class="comment">// &lt;- 'hello NICO, you look lovely today in that LEATHER JACKET'</span></span><br></pre></td></tr></table></figure>
<p>There’s obviously much more useful use cases for tagged templates than laughing at yourself. In fact, you could go crazy with tagged templates. A decidedly useful use case would be to sanitize user input in your templates automatically. Given a template where all expressions are considered user-input, we could use <a href="https://github.com/bevacqua/insane" target="_blank" rel="noopener"><code>insane</code></a> to sanitize them out of HTML tags we dislike.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> insane <span class="keyword">from</span> <span class="string">'insane'</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sanitize</span> (<span class="params">template, ...expressions</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> template.reduce(<span class="function">(<span class="params">accumulator, part, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> accumulator + insane(expressions[i - <span class="number">1</span>]) + part</span><br><span class="line">  &#125;)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> comment = <span class="string">'haha xss is so easy &lt;iframe src="http://evil.corp"&gt;&lt;/iframe&gt;'</span></span><br><span class="line"><span class="keyword">var</span> html = sanitize<span class="string">`&lt;div&gt;<span class="subst">$&#123;comment&#125;</span>&lt;/div&gt;`</span></span><br><span class="line"><span class="built_in">console</span>.log(html)</span><br><span class="line"><span class="comment">// &lt;- '&lt;div&gt;haha xss is so easy &lt;/div&gt;'</span></span><br></pre></td></tr></table></figure>
<p><em>Not so easy now!</em></p>
<blockquote>
<p>I can definitely see a future where the only strings I use in JavaScript begin and finish with a backtick.</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[04.Arrow Functions]]></title>
      <url>/2018/07/31/pureMaterial/04.arrow_functions/</url>
      <content type="html"><![CDATA[<h2 id="Arrow-Functions"><a href="#Arrow-Functions" class="headerlink" title="Arrow Functions"></a>Arrow Functions</h2><h2 id="Using-Arrow-Functions-in-JavaScript"><a href="#Using-Arrow-Functions-in-JavaScript" class="headerlink" title="Using Arrow Functions in JavaScript"></a><a href="#using-arrow-functions-in-javascript">Using Arrow Functions in JavaScript</a></h2><p>Arrow functions are available to many other modern languages and was one of the features I sorely missed a few years ago when I moved from C# to JavaScript. Fortunately, they’re now part of ES6 and thus available to us in JavaScript. The syntax is quite expressive. We already had anonymous functions, but sometimes it’s nice to have a terse alternative.</p>
<p>Here’s how the syntax looks like if we have a single argument and just want to return the results for an expression.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="params">num</span> =&gt;</span> num * <span class="number">2</span>)</span><br><span class="line"><span class="comment">// &lt;- [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<p>The ES5 equivalent would be as below.</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> <span class="params">(num)</span> </span>&#123; <span class="keyword">return</span> num * <span class="number">2</span> &#125;)</span><br><span class="line"><span class="comment">// &lt;- [2, 4, 6]</span></span><br></pre></td></tr></table></figure>
<p>If we need to declare more arguments <em>(or no arguments)</em>, we’ll have to use parenthesis.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map((num, index) =&gt; num * <span class="number">2</span> + index)</span><br><span class="line"><span class="comment">// &lt;- [2, 5, 8, 11]</span></span><br></pre></td></tr></table></figure>
<p>You might want to have some other statements and not just an expression to return. In this case you’ll have to use bracket notation.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map(<span class="built_in">num</span> =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> multiplier = <span class="number">2</span> + <span class="built_in">num</span></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">num</span> * multiplier</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- [3, 8, 15, 24]</span></span><br></pre></td></tr></table></figure>
<p>You could also add more arguments with the parenthesis syntax here.</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>].map((<span class="built_in">num</span>, index) =&gt; &#123;</span><br><span class="line">  <span class="keyword">var</span> multiplier = <span class="number">2</span> + index</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">num</span> * multiplier</span><br><span class="line">&#125;)</span><br><span class="line"><span class="comment">// &lt;- [2, 6, 12, 20]</span></span><br></pre></td></tr></table></figure>
<p>At that point, however, chances are you’d be better off using a named function declaration for a number of reasons.</p>
<ul>
<li><code>(num, index) =&gt;</code> is only marginally shorter than <code>function (num, index)</code></li>
<li>The <code>function</code> form allows you to name the method, improving code quality</li>
<li>When a function has multiple arguments and multiple statements, I’d say it’s improbable that six extra characters will make a difference</li>
<li>However, naming the method might add just enough context into the equation that those six extra characters (plus method name) become really worthwhile</li>
</ul>
<p>Moving on, if we need to return an object literal, we’ll have to wrap the expression in parenthesis. That way the object literal won’t be interpreted as a statement block (which would result in a silent error or worse, a <strong>syntax error</strong> because <code>number: n</code> isn’t a valid expression in the example below. The first example interprets <code>number</code> as a label and then figures out we have an <code>n</code> expression. Since we’re in a block and not returning anything, the mapped values will be <code>undefined</code>. In the second case, after the label and the <code>n</code> expression, <code>, something: &#39;else&#39;</code> makes no sense to the compiler, and a <code>SyntaxError</code> is thrown.</p>
<figure class="highlight vim"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="keyword">map</span>(n =&gt; &#123; <span class="keyword">number</span>: n &#125;)</span><br><span class="line">// [undefined, undefined, undefined]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="keyword">map</span>(n =&gt; &#123; <span class="keyword">number</span>: n, somethin<span class="variable">g:</span> <span class="string">'else'</span> &#125;)</span><br><span class="line">// &lt;- SyntaxError</span><br><span class="line"></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="keyword">map</span>(n =&gt; (&#123; <span class="keyword">number</span>: n &#125;))</span><br><span class="line">// &lt;- [&#123; <span class="keyword">number</span>: <span class="number">1</span> &#125;, &#123; <span class="keyword">number</span>: <span class="number">2</span> &#125;, &#123; <span class="keyword">number</span>: <span class="number">3</span> &#125;]</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].<span class="keyword">map</span>(n =&gt; (&#123; <span class="keyword">number</span>: n, somethin<span class="variable">g:</span> <span class="string">'else'</span> &#125;))</span><br><span class="line">/* &lt;- [</span><br><span class="line">  &#123; <span class="keyword">number</span>: <span class="number">1</span>, somethin<span class="variable">g:</span> <span class="string">'else'</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">number</span>: <span class="number">2</span>, somethin<span class="variable">g:</span> <span class="string">'else'</span> &#125;,</span><br><span class="line">  &#123; <span class="keyword">number</span>: <span class="number">3</span>, somethin<span class="variable">g:</span> <span class="string">'else'</span> &#125;]</span><br><span class="line">*/</span><br></pre></td></tr></table></figure>
<p>A cool aspect of arrow functions in ES6 is that they’re bound to their lexical scope. That means that you can say goodbye to <code>var self = this</code> and similar hacks <em>– such as using <code>.bind(this)</code> –</em> to preserve the context from within deeply nested methods.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.seconds = <span class="number">0</span></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.seconds++, <span class="number">1000</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer()</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(timer.seconds), <span class="number">3100</span>)</span><br><span class="line"><span class="comment">// &lt;- 3</span></span><br></pre></td></tr></table></figure>
<p>Keep in mind that the lexical <code>this</code> binding in ES6 arrow functions means that <code>.call</code> and <code>.apply</code> won’t be able to change the context. Usually however, that’s more of a feature than a bug.</p>
<h2 id="Conclusions"><a href="#Conclusions" class="headerlink" title="Conclusions"></a><a href="#conclusions">Conclusions</a></h2><p>Arrow functions are neat when it comes to defining anonymous functions that should probably be <em>lexically bound anyways</em>, and they can definitely make your code more terse in some situations.</p>
<p>There’s no reason why you should be turning all of your function declarations into arrow functions unless their arguments and expression body are descriptive enough. I’m a big proponent of named function declarations, because they improve readability of the codebase without the need for comments – which means I’ll have <em>“a hard time”</em> adopting arrow functions in most situations.</p>
<p>That being said, I think arrow functions are particularly useful in most functional programming situations such as when using <code>.map</code>, <code>.filter</code>, or <code>.reduce</code> on collections. Similarly, arrow functions will be really useful in asynchronous flows since those typically have a bunch of callbacks that just do argument balancing, a situation where arrow functions really shine.</p>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[03.Spread Operator and Rest Parameters]]></title>
      <url>/2018/07/31/pureMaterial/03.spread_operator_and_rest_parameters/</url>
      <content type="html"><![CDATA[<h2 id="Spread-Operator-and-Rest-Parameters"><a href="#Spread-Operator-and-Rest-Parameters" class="headerlink" title="Spread Operator and Rest Parameters"></a>Spread Operator and Rest Parameters</h2><h2 id="Rest-parameters"><a href="#Rest-parameters" class="headerlink" title="Rest parameters"></a><a href="#rest-parameters">Rest parameters</a></h2><p>You know how sometimes there’s a ton of arguments and you end up having to use the <code>arguments</code> magic variable to work with them? Consider the following method that joins any arguments passed to it as a string.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = concat(<span class="string">'this'</span>, <span class="string">'was'</span>, <span class="string">'no'</span>, <span class="string">'fun'</span>)</span><br><span class="line"><span class="built_in">console</span>.log(result)</span><br><span class="line"><span class="comment">// &lt;- 'this was no fun'</span></span><br></pre></td></tr></table></figure>
<p>The rest parameters syntax enables you to pull a real <code>Array</code> out of the <code>function</code>‘s arguments by adding a parameter name prefixed by <code>...</code>. Definitely simpler, the fact that it’s a real <code>Array</code> is also very convenient, and I for one am glad not to have to resort to <code>arguments</code> anymore.</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">concat</span> <span class="params">(<span class="rest_arg">...words</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> words.join(<span class="string">' '</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = concat(<span class="string">'this'</span>, <span class="string">'is'</span>, <span class="string">'okay'</span>)</span><br><span class="line">console.log(result)</span><br><span class="line"><span class="comment">// &lt;- 'this is okay'</span></span><br></pre></td></tr></table></figure>
<p>When you have more parameters in your <code>function</code> it works slightly different. Whenever I declare a method that has a rest parameter, I like to think of its behavior as follows.</p>
<ul>
<li>Rest parameter gets all the <code>arguments</code> passed to the function call</li>
<li>Each time a parameter is added on the left, it’s as if its value is assigned by calling <code>rest.shift()</code></li>
<li>Note that you can’t actually place parameters to the right: rest parameters can only be the last argument</li>
</ul>
<p>It’s easier to visualize how that would behave than try to put it into words, so let’s do that. The method below computes the <code>sum</code> for all <code>arguments</code> except the first one, which is then used as a <code>multiplier</code> for the <code>sum</code>. In case you don’t recall, <code>.shift()</code> returns the first value in an array, and also removes it from the collection, which makes it a useful mnemonic device in my opinion.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> numbers = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>) <span class="comment">// numbers gets all arguments</span></span><br><span class="line">  <span class="keyword">var</span> multiplier = numbers.shift()</span><br><span class="line">  <span class="keyword">var</span> base = numbers.shift()</span><br><span class="line">  <span class="keyword">var</span> sum = numbers.reduce(<span class="function">(<span class="params">accumulator, num</span>) =&gt;</span> accumulator + num, base)</span><br><span class="line">  <span class="keyword">return</span> multiplier * sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> total = sum(<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line"><span class="built_in">console</span>.log(total)</span><br><span class="line"><span class="comment">// &lt;- 66</span></span><br></pre></td></tr></table></figure>
<p>Here’s how that method would look if we were to use the rest parameter to pluck the numbers. Note how we don’t need to use <code>arguments</code> nor do any shifting anymore. This is great because it vastly reduces the complexity in our method – which now can focus on its functionality itself and not so much on rebalancing <code>arguments</code>.</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> <span class="params">(multiplier, base, <span class="rest_arg">...numbers</span>)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> sum = numbers.reduce((accumulator, num) =&gt; accumulator + num, base)</span><br><span class="line">  <span class="keyword">return</span> multiplier * sum</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> total = sum(<span class="number">2</span>, <span class="number">6</span>, <span class="number">10</span>, <span class="number">8</span>, <span class="number">9</span>)</span><br><span class="line">console.log(total)</span><br><span class="line"><span class="comment">// &lt;- 66</span></span><br></pre></td></tr></table></figure>
<h2 id="Spread-Operator"><a href="#Spread-Operator" class="headerlink" title="Spread Operator"></a><a href="#spread-operator">Spread Operator</a></h2><p>Typically you invoke a function by passing arguments into it.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// &lt;- '1 2 3'</span></span><br></pre></td></tr></table></figure>
<p>Sometimes however you have those arguments in a list and just don’t want to access every index just for a method call <em>– or you just can’t because the array is formed dynamically –</em> so you use <code>.apply</code>. This feels kind of awkward because <code>.apply</code> also takes a context for <code>this</code>, which feels out of place when it’s not relevant and you have to reiterate the host object <em>(or use <code>null</code>)</em>.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log.apply(console, [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// &lt;- '1 2 3'</span></span><br></pre></td></tr></table></figure>
<p>The spread operator can be used as <em>a butter knife</em> alternative over using <code>.apply</code>. There is no need for a context either. You just append three dots <code>...</code> to the array, just like with the rest parameter.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// &lt;- '1 2 3'</span></span><br></pre></td></tr></table></figure>
<p>As we’ll investigate more in-depth next monday, in the article about iterators in ES6, a nice perk of the spread operator is that it can be used on anything that’s an <em>iterable</em>. This encompasses even things like the results of <code>document.querySelectorAll(&#39;div&#39;)</code>.</p>
<figure class="highlight erlang"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...document.<span class="keyword">query</span>SelectorAll('<span class="keyword">div</span>')]</span><br><span class="line">// &lt;- [&lt;<span class="keyword">div</span>&gt;, &lt;<span class="keyword">div</span>&gt;, &lt;<span class="keyword">div</span>&gt;]</span><br></pre></td></tr></table></figure>
<p>Another nice aspect of the <em>butter knife operator</em> is that you can <strong>mix and match</strong> regular arguments with it, and they’ll be spread over the function call exactly how you’d expect them to. This, too, can be <em>very very useful</em> when you have a lot of argument rebalancing going on in your ES5 code.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>) <span class="comment">// becomes `console.log(1, 2, 3, 4, 5)`</span></span><br><span class="line"><span class="comment">// &lt;- '1 2 3 4 5'</span></span><br></pre></td></tr></table></figure>
<p>Time for a real-world example. I sometimes use the method below in Express applications to allow <a href="https://github.com/expressjs/morgan" target="_blank" rel="noopener"><code>morgan</code></a> <em>(the request logger in Express)</em> stream its messages through <a href="https://github.com/winstonjs/winston" target="_blank" rel="noopener"><code>winston</code></a>, a general purpose multi-transport logger. I remove the trailing line breaks from the <code>message</code> because <code>winston</code> already takes care of those. I also place some metadata about the currently executing process like the host and the process <code>pid</code> into the arguments list, and then I <code>.apply</code> everything on the <code>winston</code> logging mechanism. If you take a close look at the code, the only line of code that’s actually doing anything is the one I’ve highlighted in yellow, the rest is just playing around with <code>arguments</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWriteStream</span> (<span class="params">level</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    write: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> bits = <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>)</span><br><span class="line">      <span class="keyword">var</span> message = bits.shift().replace(<span class="regexp">/\n+$/</span>, <span class="string">''</span>) <span class="comment">// remove trailing breaks</span></span><br><span class="line">      bits.unshift(message)</span><br><span class="line">      bits.push(&#123; <span class="attr">hostname</span>: os.hostname(), <span class="attr">pid</span>: process.pid &#125;)</span><br><span class="line">      winston[level].apply(winston, bits)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">app.use(morgan(<span class="string">':status :method :url'</span>, &#123;</span><br><span class="line">  stream: createWriteStream(<span class="string">'debug'</span>)</span><br><span class="line">&#125;))</span><br></pre></td></tr></table></figure>
<p>We can thoroughly simplify the solution with ES6. First, we can use the rest parameter instead of relying on <code>arguments</code>. The rest parameter already gives us a true array, so there’s no casting involved either. We can grab the <code>message</code> directly as the first parameter, and we can then apply everything on <code>winston[level]</code> directly by combining normal arguments with the rest of the <code>...bits</code> and pieces. The code below is <strong>in much better shape</strong>, as now every piece of it is actually relevant to what we’re trying to accomplish, which is call <code>winston[level]</code> with a few <em>modified arguments</em>. The piece of code we had earlier, in contrast, spent most time manipulating the arguments, and the focus quickly dissipated into <strong>a battle of wits against JavaScript itself</strong> – <em>the method stopped being about the code we were trying to write.</em></p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWriteStream</span> <span class="params">(level)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    write: <span class="function"><span class="keyword">function</span> <span class="params">(message, <span class="rest_arg">...bits</span>)</span> </span>&#123;</span><br><span class="line">      winston[level](message.replace(/\n+$/, <span class="string">''</span>), ...bits, &#123;</span><br><span class="line">        hostname: os.hostname(), pid: process.pid</span><br><span class="line">      &#125;)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>We could further <em>simplify the method by pulling</em> the process metadata out, since that won’t change for the lifespan of the process. We could’ve done that in the ES5 code too, though.</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proc = &#123; hostname: os.hostname(), pid: process.pid &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWriteStream</span> <span class="params">(level)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    write: <span class="function"><span class="keyword">function</span> <span class="params">(message, <span class="rest_arg">...bits</span>)</span> </span>&#123;</span><br><span class="line">      winston[level](message.replace(/\n+$/, <span class="string">''</span>), ...bits, proc)</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Another thing we could do to shorten that piece of code might be to use <a href="/articles/es6-arrow-functions-in-depth">an arrow function</a>. In this case however, it <strong>would only complicate matters</strong>. You’d have to shorten <code>message</code> to <code>msg</code> so that it fits in a single line, and the call to <code>winston[level]</code> with the rest and spread operators in there makes it <strong>an incredibly complicated sight</strong> to anyone who <em>hasn’t</em> spent the last 15 minutes thinking about the method <em>– be it a team mate or yourself the week after you wrote this function.</em></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> proc = &#123; <span class="attr">hostname</span>: os.hostname(), <span class="attr">pid</span>: process.pid &#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">createWriteStream</span> (<span class="params">level</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    write: <span class="function">(<span class="params">msg, ...bits</span>) =&gt;</span> winston[level](msg.replace(<span class="regexp">/\n+$/</span>, <span class="string">''</span>), ...bits, proc)</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It would be wiser to just keep our earlier version. While it’s <em>quite self-evident</em> in this case that an arrow function only <strong>piles onto the complexity</strong>, in other cases it might not be so. It’s up to you to decide, and you need to be able to distinguish between using ES6 features because they genuinely improve your codebase and its maintainability, or <strong>whether you’re actually decreasing maintainability</strong> by translating things into ES6 just for the sake of doing so.</p>
<p>Some other useful uses are detailed below. You can obviously use the spread operator when creating a new array, but you can also use <a href="/articles/es6-destructuring-in-depth">while destructuring</a>, in which case it works sort of like <code>...rest</code> did, and a use case that’s not going to come up often but is still worth mentioning is that you can use spread to pseudo-<code>.apply</code> when using the <code>new</code> operator as well.</p>
<table>
<thead>
<tr>
<th>Use Case</th>
<th>ES5</th>
<th>ES6</th>
</tr>
</thead>
<tbody>
<tr>
<td>Concatenation</td>
<td><code>[1, 2].concat(more)</code></td>
<td><code>[1, 2, ...more]</code></td>
</tr>
<tr>
<td>Push onto list</td>
<td><code>list.push.apply(list, [3, 4])</code></td>
<td><code>list.push(...[3, 4])</code></td>
</tr>
<tr>
<td>Destructuring</td>
<td><code>a = list[0], rest = list.slice(1)</code></td>
<td><code>[a, ...rest] = list</code></td>
</tr>
<tr>
<td><code>new</code> + <code>apply</code></td>
<td><a href="http://stackoverflow.com/a/8843181/389745" target="_blank" rel="noopener"><code>new (Date.bind.apply(Date, [null,2015,8,1]))</code></a></td>
<td><code>new Date(...[2015,8,1])</code></td>
</tr>
</tbody>
</table>
<h2 id="Default-Operator"><a href="#Default-Operator" class="headerlink" title="Default Operator"></a><a href="#default-operator">Default Operator</a></h2><p>The default operator is something we’ve covered in <a href="/articles/es6-destructuring-in-depth">the destructuring article</a>, but only tangentially. Just like you can use default values during destructuring, you can define a default value for any parameter in a function, as shown below.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sum</span> (<span class="title">left</span>=<span class="title">1</span>, <span class="title">right</span>=<span class="title">2</span>) &#123;</span></span><br><span class="line">  <span class="literal">return</span> left + <span class="literal">right</span></span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">sum</span>())</span><br><span class="line">// &lt;- <span class="number">3</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">sum</span>(<span class="number">2</span>))</span><br><span class="line">// &lt;- <span class="number">4</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">0</span>))</span><br><span class="line">// &lt;- <span class="number">1</span></span><br></pre></td></tr></table></figure>
<p>Consider the code that initializes options in <a href="https://github.com/bevacqua/dragula/blob/f5f4c569780b0db160269e978eaf69dc36e421bb/dragula.js#L27-L37" target="_blank" rel="noopener"><code>dragula</code></a>.</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">function dragula (options) &#123;</span><br><span class="line">  var <span class="attr">o</span> = options || &#123;&#125;;</span><br><span class="line">  <span class="keyword">if</span> (o.<span class="attr">moves</span> === void <span class="number">0</span>) &#123; o.<span class="attr">moves</span> = always; &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.<span class="attr">accepts</span> === void <span class="number">0</span>) &#123; o.<span class="attr">accepts</span> = always; &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.<span class="attr">invalid</span> === void <span class="number">0</span>) &#123; o.<span class="attr">invalid</span> = invalidTarget; &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.<span class="attr">containers</span> === void <span class="number">0</span>) &#123; o.<span class="attr">containers</span> = initialContainers || []; &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.<span class="attr">isContainer</span> === void <span class="number">0</span>) &#123; o.<span class="attr">isContainer</span> = never; &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.<span class="attr">copy</span> === void <span class="number">0</span>) &#123; o.<span class="attr">copy</span> = <span class="literal">false</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.<span class="attr">revertOnSpill</span> === void <span class="number">0</span>) &#123; o.<span class="attr">revertOnSpill</span> = <span class="literal">false</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.<span class="attr">removeOnSpill</span> === void <span class="number">0</span>) &#123; o.<span class="attr">removeOnSpill</span> = <span class="literal">false</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.<span class="attr">direction</span> === void <span class="number">0</span>) &#123; o.<span class="attr">direction</span> = 'vertical'; &#125;</span><br><span class="line">  <span class="keyword">if</span> (o.<span class="attr">mirrorContainer</span> === void <span class="number">0</span>) &#123; o.<span class="attr">mirrorContainer</span> = body; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Assignment Destructuring]]></title>
      <url>/2018/07/31/pureMaterial/02.Assignment_destructuring/</url>
      <content type="html"><![CDATA[<h2 id="Destructuring"><a href="#Destructuring" class="headerlink" title="Destructuring"></a><a href="#destructuring">Destructuring</a></h2><p>This is easily one of the features I’ve been using the most. It’s also one of the simplest. It binds properties to as many variables as you need and it works with both Arrays and Objects.<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123; <span class="attr">bar</span>: <span class="string">'pony'</span>, <span class="attr">baz</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">var</span> &#123;bar, baz&#125; = foo</span><br><span class="line"><span class="built_in">console</span>.log(bar)</span><br><span class="line"><span class="comment">// &lt;- 'pony'</span></span><br><span class="line"><span class="built_in">console</span>.log(baz)</span><br><span class="line"><span class="comment">// &lt;- 3</span></span><br></pre></td></tr></table></figure></p>
<p>It makes it very quick to pull out a specific property from an object. You’re also allowed to map properties into aliases as well.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> foo = &#123; <span class="attr">bar</span>: <span class="string">'pony'</span>, <span class="attr">baz</span>: <span class="number">3</span> &#125;</span><br><span class="line"><span class="keyword">var</span> &#123;<span class="attr">bar</span>: a, <span class="attr">baz</span>: b&#125; = foo</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// &lt;- 'pony'</span></span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="comment">// &lt;- 3</span></span><br></pre></td></tr></table></figure>
<p>You can also pull properties as deep as you want, and you could also alias those deep bindings.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">var foo = &#123; <span class="string">bar:</span> &#123; <span class="string">deep:</span> <span class="string">'pony'</span>, <span class="string">dangerouslySetInnerHTML:</span> <span class="string">'lol'</span> &#125; &#125;</span><br><span class="line">var &#123;<span class="string">bar:</span> &#123; deep, <span class="string">dangerouslySetInnerHTML:</span> sure &#125;&#125; = foo</span><br><span class="line">console.log(deep)</span><br><span class="line"><span class="comment">// &lt;- 'pony'</span></span><br><span class="line">console.log(sure)</span><br><span class="line"><span class="comment">// &lt;- 'lol'</span></span><br></pre></td></tr></table></figure>
<p>By default, properties that aren’t found will be <code>undefined</code>, just like when accessing properties on an object with the dot or bracket notation.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;foo&#125; = &#123;<span class="attr">bar</span>: <span class="string">'baz'</span>&#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"><span class="comment">// &lt;- undefined</span></span><br></pre></td></tr></table></figure>
<p>If you’re trying to access a deeply nested property of a parent that doesn’t exist, then you’ll get an exception, though.</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">var &#123;<span class="string">foo:</span>&#123;bar&#125;&#125; = &#123;<span class="string">baz:</span> <span class="string">'ouch'</span>&#125;</span><br><span class="line"><span class="comment">// &lt;- Exception</span></span><br></pre></td></tr></table></figure>
<p>That makes a lot of sense, if you think of destructuring as sugar for ES5 like the code below.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> _temp = &#123; baz: <span class="string">'ouch'</span> &#125;</span><br><span class="line"><span class="selector-tag">var</span> bar = _temp<span class="selector-class">.foo</span><span class="selector-class">.bar</span></span><br><span class="line"><span class="comment">// &lt;- Exception</span></span><br></pre></td></tr></table></figure>
<p>A cool property of destructuring is that it allows you to swap variables without the need for the infamous <code>aux</code> variable.</p>
<figure class="highlight swift"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">function es5 () &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">right</span> = <span class="number">20</span></span><br><span class="line">  <span class="keyword">var</span> aux</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">right</span> &gt; <span class="keyword">left</span>) &#123;</span><br><span class="line">    aux = <span class="keyword">right</span></span><br><span class="line">    <span class="keyword">right</span> = <span class="keyword">left</span></span><br><span class="line">    <span class="keyword">left</span> = aux</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"></span><br><span class="line">function es6 () &#123;</span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">left</span> = <span class="number">10</span></span><br><span class="line">  <span class="keyword">var</span> <span class="keyword">right</span> = <span class="number">20</span></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">right</span> &gt; <span class="keyword">left</span>) &#123;</span><br><span class="line">    [<span class="keyword">left</span>, <span class="keyword">right</span>] = [<span class="keyword">right</span>, <span class="keyword">left</span>]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Another convenient aspect of destructuring is the ability to pull keys using <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Object_initializer#Computed_property_names" target="_blank" rel="noopener">computed property names</a>.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> key = <span class="string">'such_dynamic'</span></span><br><span class="line"><span class="selector-tag">var</span> &#123; [key]: foo &#125; = &#123; such_dynamic: <span class="string">'bar'</span> &#125;</span><br><span class="line">console.log(foo)</span><br><span class="line"><span class="comment">// &lt;- 'bar'</span></span><br></pre></td></tr></table></figure>
<p>In ES5, that’d take an extra statement and variable allocation on your behalf.</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">var</span> key = <span class="string">'such_dynamic'</span></span><br><span class="line"><span class="selector-tag">var</span> baz = &#123; such_dynamic: <span class="string">'bar'</span> &#125;</span><br><span class="line"><span class="selector-tag">var</span> foo = baz[key]</span><br><span class="line">console.log(foo)</span><br></pre></td></tr></table></figure>
<p>You can also define default values, for the case where the pulled property evaluates to <code>undefined</code>.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;foo=<span class="number">3</span>&#125; = &#123; <span class="attr">foo</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"><span class="comment">// &lt;- 2</span></span><br><span class="line"><span class="keyword">var</span> &#123;foo=<span class="number">3</span>&#125; = &#123; <span class="attr">foo</span>: <span class="literal">undefined</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"><span class="comment">// &lt;- 3</span></span><br><span class="line"><span class="keyword">var</span> &#123;foo=<span class="number">3</span>&#125; = &#123; <span class="attr">bar</span>: <span class="number">2</span> &#125;</span><br><span class="line"><span class="built_in">console</span>.log(foo)</span><br><span class="line"><span class="comment">// &lt;- 3</span></span><br></pre></td></tr></table></figure>
<p>Destructuring works for Arrays as well, as we mentioned earlier. Note how I’m <strong>using square brackets</strong> in the destructuring side of the declaration now.</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var [<span class="keyword">a</span>] = [<span class="number">10</span>]</span><br><span class="line">console.<span class="built_in">log</span>(<span class="keyword">a</span>)</span><br><span class="line">// &lt;- <span class="number">10</span></span><br></pre></td></tr></table></figure>
<p>Here, again, we can use the default values and follow the same rules.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> [a] = []</span><br><span class="line"><span class="built_in">console</span>.log(a)</span><br><span class="line"><span class="comment">// &lt;- undefined</span></span><br><span class="line"><span class="keyword">var</span> [b=<span class="number">10</span>] = [<span class="literal">undefined</span>]</span><br><span class="line"><span class="built_in">console</span>.log(b)</span><br><span class="line"><span class="comment">// &lt;- 10</span></span><br><span class="line"><span class="keyword">var</span> [c=<span class="number">10</span>] = []</span><br><span class="line"><span class="built_in">console</span>.log(c)</span><br><span class="line"><span class="comment">// &lt;- 10</span></span><br></pre></td></tr></table></figure>
<p>When it comes to Arrays you can conveniently skip over elements that you don’t care about.</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var [,,a,b] = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>,<span class="number">5</span>]</span><br><span class="line">console.log(a)</span><br><span class="line"><span class="comment">// &lt;- 3</span></span><br><span class="line">console.log(b)</span><br><span class="line"><span class="comment">// &lt;- 4</span></span><br></pre></td></tr></table></figure>
<p>You can also use destructuring in a <code>function</code>‘s parameter list.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">greet</span> (<span class="params">&#123; age, name:greeting=<span class="string">'she'</span> &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">`<span class="subst">$&#123;greeting&#125;</span> is <span class="subst">$&#123;age&#125;</span> years old.`</span>)</span><br><span class="line">&#125;</span><br><span class="line">greet(&#123; <span class="attr">name</span>: <span class="string">'nico'</span>, <span class="attr">age</span>: <span class="number">27</span> &#125;)</span><br><span class="line"><span class="comment">// &lt;- 'nico is 27 years old'</span></span><br><span class="line">greet(&#123; <span class="attr">age</span>: <span class="number">24</span> &#125;)</span><br><span class="line"><span class="comment">// &lt;- 'she is 24 years old'</span></span><br></pre></td></tr></table></figure>
<p>That’s roughly <strong>how</strong> you can use destructuring. What is destructuring <strong>good</strong> for?</p>
<h2 id="Use-Cases-for-Destructuring"><a href="#Use-Cases-for-Destructuring" class="headerlink" title="Use Cases for Destructuring"></a><a href="#use-cases-for-destructuring">Use Cases for Destructuring</a></h2><p>There are many situations where destructuring comes in handy. Here’s some of the most common ones. Whenever you have a method that returns an object, destructuring makes it much terser to interact with.</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getCoords</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    x: <span class="number">10</span>,</span><br><span class="line">    y: <span class="number">22</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> &#123;x, y&#125; = getCoords()</span><br><span class="line"><span class="built_in">console</span>.log(x)</span><br><span class="line"><span class="comment">// &lt;- 10</span></span><br><span class="line"><span class="built_in">console</span>.log(y)</span><br><span class="line"><span class="comment">// &lt;- 22</span></span><br></pre></td></tr></table></figure>
<p>A similar use case but in the opposite direction is being able to define default options when you have a method with a bunch of options that need default values. This is particularly interesting as an alternative to named parameters in other languages like Python and C#.</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">random</span> (&#123; <span class="built_in">min</span>=<span class="number">1</span>, <span class="built_in">max</span>=<span class="number">300</span> &#125;) &#123;</span><br><span class="line">  <span class="keyword">return</span> Math.<span class="built_in">floor</span>(Math.<span class="built_in">random</span>() * (<span class="built_in">max</span> - <span class="built_in">min</span>)) + <span class="built_in">min</span></span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">random</span>(&#123;&#125;))</span><br><span class="line"><span class="comment">// &lt;- 174</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">random</span>(&#123;<span class="built_in">max</span>: <span class="number">24</span>&#125;))</span><br><span class="line"><span class="comment">// &lt;- 18</span></span><br></pre></td></tr></table></figure>
<p>If you wanted to make the options object <em>entirely optional</em> you could change the syntax to the following.</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">random</span> (&#123; <span class="built_in">min</span>=<span class="number">1</span>, <span class="built_in">max</span>=<span class="number">300</span> &#125; = &#123;&#125;) &#123;</span><br><span class="line">    <span class="keyword">return</span> Math.<span class="built_in">floor</span>(Math.<span class="built_in">random</span>() * (<span class="built_in">max</span> - <span class="built_in">min</span>)) + <span class="built_in">min</span></span><br><span class="line">&#125;</span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">random</span>())</span><br><span class="line"><span class="comment">// &lt;- 133</span></span><br></pre></td></tr></table></figure>
<p>A great fit for destructuring are things like regular expressions, where you would just love to name parameters without having to resort to index numbers. Here’s an example parsing a URL with a random <code>RegExp</code> <a href="http://stackoverflow.com/a/27755/389745" target="_blank" rel="noopener">I got on StackOverflow</a>.</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getUrlParts</span> (<span class="params">url</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> magic = <span class="regexp">/^(https?):\/\/(ponyfoo\.com)(\/articles\/([a-z0-9-]+))$/</span></span><br><span class="line">  <span class="keyword">return</span> magic.exec(<span class="built_in">url</span>)</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> parts = getUrlParts(<span class="string">'http://ponyfoo.com/articles/es6-destructuring-in-depth'</span>)</span><br><span class="line"><span class="keyword">var</span> [,protocol,host,pathname,slug] = parts</span><br><span class="line"><span class="built_in">console</span>.log(protocol)</span><br><span class="line"><span class="comment">// &lt;- 'http'</span></span><br><span class="line"><span class="built_in">console</span>.log(host)</span><br><span class="line"><span class="comment">// &lt;- 'ponyfoo.com'</span></span><br><span class="line"><span class="built_in">console</span>.log(pathname)</span><br><span class="line"><span class="comment">// &lt;- '/articles/es6-destructuring-in-depth'</span></span><br><span class="line"><span class="built_in">console</span>.log(slug)</span><br><span class="line"><span class="comment">// &lt;- 'es6-destructuring-in-depth'</span></span><br></pre></td></tr></table></figure>
<h3 id="Special-Case-import-Statements"><a href="#Special-Case-import-Statements" class="headerlink" title="Special Case: import Statements"></a><a href="#special-case-import-statements">Special Case: <code>import</code> Statements</a></h3><p>Even though <code>import</code> statements don’t follow destructuring rules, they behave a bit similarly. This is probably the <em>“destructuring-like”</em> use case I find myself using the most, even though it’s not actually destructuring. Whenever you’re writing module <code>import</code> statements, you can pull just what you need from a module’s public API. An example using <a href="https://github.com/bevacqua/contra" target="_blank" rel="noopener"><code>contra</code></a>:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">import &#123;series, concurrent, map &#125; from <span class="string">'contra'</span></span><br><span class="line"><span class="function"><span class="title">series</span><span class="params">(tasks, done)</span></span></span><br><span class="line"><span class="function"><span class="title">concurrent</span><span class="params">(tasks, done)</span></span></span><br><span class="line"><span class="function"><span class="title">map</span><span class="params">(items, mapper, done)</span></span></span><br></pre></td></tr></table></figure>
<p>Note that, however, <code>import</code> statements have a different syntax. When compared against destructuring, none of the following <code>import</code> statements will work.</p>
<ul>
<li>Use defaults values such as <code>import {series = noop} from &#39;contra&#39;</code></li>
<li>“Deep” destructuring style like <code>import {map: { series }} from &#39;contra&#39;</code></li>
<li>Aliasing syntax <code>import {map: mapAsync} from &#39;contra&#39;</code></li>
</ul>
<p>The main reason for these limitations is that the <code>import</code> statement brings in a <em>binding</em>, and not a reference or a value. This is an important differentiation that we’ll explore more in depth in a future article about ES6 modules.</p>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.An introduction to how JavaScript package managers work]]></title>
      <url>/2018/07/30/pureMaterial/01.package_managers/</url>
      <content type="html"><![CDATA[<h2 id="An-introduction-to-how-JavaScript-package-managers-work"><a href="#An-introduction-to-how-JavaScript-package-managers-work" class="headerlink" title="An introduction to how JavaScript package managers work"></a>An introduction to how JavaScript package managers work</h2><p>A few days ago, <a href="https://medium.com/@ag_dubs" target="_blank" rel="noopener">ashley williams</a>, one of the leaders of the Node.js community, tweeted this:</p>
<blockquote>
<p>lockfiles = awesome for apps, bad for libs this is not a new thought, i’m confused why’s everyone mad about this</p>
</blockquote>
<p>I didn’t really understand what she meant, so I decided to dig in deeper and read about how package managers work.</p>
<p>This was right when the newest kid on the JavaScript package manager block — <a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a> — had just arrived and was generating a lot of buzz.</p>
<p>So I used this opportunity to also understand <a href="https://code.facebook.com/posts/1840075619545360/yarn-a-new-package-manager-for-javascript/" target="_blank" rel="noopener">how and why Yarn does things differently from npm</a>.</p>
<p>I had so much fun researching this. I wish I’d done so a long time ago. So I wrote this simple introduction to npm and Yarn to share what I’ve learned.</p>
<p>Let’s start with some definitions:</p>
<h4 id="What-is-a-package"><a href="#What-is-a-package" class="headerlink" title="What is a package?"></a>What is a package?</h4><p>A package is a reusable piece of software which can be downloaded from a global registry into a developer’s local environment. Each package may or may not depend on other packages.</p>
<h4 id="What-is-a-Package-Manager"><a href="#What-is-a-Package-Manager" class="headerlink" title="What is a Package Manager?"></a><strong>What is a Package Manager?</strong></h4><p>Simply put — a package manager is a piece of software that lets you manage the <strong>dependencies</strong> (external code written by you or someone else) that your project needs to work correctly.</p>
<p>Most package managers juggle the following pieces of your project:</p>
<h4 id="Project-Code"><a href="#Project-Code" class="headerlink" title="Project Code"></a><strong>Project Code</strong></h4><p>This is the code of your project for which you need to manage various dependencies. Typically, all of this code is checked into a version control system like Git.</p>
<h4 id="Manifest-file"><a href="#Manifest-file" class="headerlink" title="Manifest file"></a><strong>Manifest file</strong></h4><p>This is a file that keeps track of all your dependencies (the packages to be managed). It also contains other metadata about your project. In the JavaScript world, this file is your <a href="https://docs.npmjs.com/files/package.json" target="_blank" rel="noopener">package.json</a></p>
<h4 id="Dependency-code"><a href="#Dependency-code" class="headerlink" title="Dependency code"></a><strong>Dependency code</strong></h4><p>This code constitutes your dependencies. It shouldn’t be mutated during the lifetime of your application, and should be accessible by your project code in memory when it’s needed.</p>
<h4 id="Lock-file"><a href="#Lock-file" class="headerlink" title="Lock file"></a><strong>Lock file</strong></h4><p>This file is written automatically by the package manager itself. It contains all the information needed to reproduce the full dependency source tree. It contains information about each of your project’s dependencies, along with their respective versions.</p>
<p>It’s worth pointing out at this point that Yarn uses a lockfile, while npm doesn’t. We’ll talk about the consequences of this distinction in a bit.</p>
<p>Now that I’ve introduced you to the parts of a package manager, let’s discuss dependencies themselves.</p>
<h3 id="Flat-versus-Nested-Dependencies"><a href="#Flat-versus-Nested-Dependencies" class="headerlink" title="Flat versus Nested Dependencies"></a>Flat versus Nested Dependencies</h3><p>To understand the difference between the Flat versus Nested dependency schemes, let’s try visualizing a dependency graph of dependencies in your project.</p>
<p>It’s important to keep in mind that the dependencies your project depends on might have dependencies of their own. And these dependencies may in turn have some dependencies in common.</p>
<p>To make this clear, let’s say our application depends on dependencies A, B and C, and C depends on A.</p>
<h4 id="Flat-Dependencies"><a href="#Flat-Dependencies" class="headerlink" title="Flat Dependencies"></a><strong>Flat Dependencies</strong></h4><p><img src="https://cdn-images-1.medium.com/max/800/1*QFSdXpqBdeuJIJDzr0KfZg.png" alt=""></p>
<p style="text-align:center"><a href="http://maxogden.com/nested-dependencies.html" target="_blank" rel="noopener">Dependency graph in case of flat dependencies</a></p>

<p>As shown in the image, both the app and C have A as their dependency. For dependency resolution in a flat dependency scheme, there is only one layer of dependencies that your package manager needs to traverse.</p>
<p>Long story short — you can have only one version of a particular package in your source tree, as there is one common namespace for all your dependencies.</p>
<p>Suppose that package A is upgraded to version 2.0. If your app is compatible with version 2.0, but package C isn’t, then we need two versions of package A in order to make our app work correctly. This is known an <strong>Dependency Hell.</strong></p>
<h4 id="Nested-Dependencies"><a href="#Nested-Dependencies" class="headerlink" title="Nested Dependencies"></a><strong>Nested Dependencies</strong></h4><p><img src="https://cdn-images-1.medium.com/max/800/1*GWq1l9Mxe0k7teuJCIOlYw.png" alt=""></p>
<p style="text-align:center"><a href="http://maxogden.com/nested-dependencies.html" target="_blank" rel="noopener">Dependency graph in case of nested dependencies</a></p>

<p>One simple solution to deal with the problem of Dependency Hell is to have two different versions of package A — version 1.0 and version 2.0.</p>
<p>This is where nested dependencies come into play. In case of nested dependencies, every dependency can isolate its own dependencies from other dependencies, in a different namespace.</p>
<p>The package manager needs to traverse multiple levels for dependency resolution.</p>
<p>We can have several copies of a single dependency in such a scheme.</p>
<p>But as you might have guessed, this leads to a few problems too. What if we add another package — package D — and it also depends on version 1.0 of package A?</p>
<p>So with this scheme, we can end up with <strong>duplication</strong> of version 1.0 of package A. This can cause confusion, and takes up unnecessary disk space.</p>
<p>One solution to the above problem is to have two versions of package A, v1.0 and v2.0, but only one copy of v1.0 in order to avoid unnecessary duplication. This is the <a href="https://docs.npmjs.com/how-npm-works/npm3-dupe" target="_blank" rel="noopener">approach taken by npm v3</a>, which reduces the time taken to traverse the dependency tree considerably.</p>
<p>As <a href="https://medium.com/@ag_dubs" target="_blank" rel="noopener">ashley williams</a> explains, <a href="https://docs.npmjs.com/how-npm-works/npm2" target="_blank" rel="noopener">npm v2 installs dependencies in a nested manner</a>. That’s why npm v3 is considerably faster by comparison.</p>
<h3 id="Determinism-vs-Non-determinism"><a href="#Determinism-vs-Non-determinism" class="headerlink" title="Determinism vs Non-determinism"></a><strong>Determinism vs Non-determinism</strong></h3><p>Another important concept in package managers is that of determinism. In the context of the JavaScript ecosystem, determinism means that all computers with a given <code>package.json</code> file will all have the exact same source tree of dependencies installed on them in their <code>node_modules</code> folder.</p>
<p>But with a non-deterministic package manager, this isn’t guaranteed. Even if you have the exact same <code>package.json</code> on two different computers, the layout of your <code>node_modules</code> may differ between them.</p>
<p>Determinism is desirable. It helps you avoid <strong>“worked on my machine but it broke when we deployed it”</strong> issues, which arise when you have different <code>node_modules</code> on different computers.</p>
<p><img src="https://cdn-images-1.medium.com/max/800/1*i4QK4sSGX7Q4RRgOytkSuw.jpeg" alt=""></p>
<p style="text-align:center">This popular developer meme illustrates the problems with non-determinism.</p>

<p><a href="https://docs.npmjs.com/how-npm-works/npm3-nondet" target="_blank" rel="noopener">npm v3, by default has non-deterministic installs</a> and offers a <a href="https://docs.npmjs.com/cli/shrinkwrap" target="_blank" rel="noopener">shrinkwrap feature</a> to make installs deterministic. This writes all the packages on the disk to a lockfile, along with their respective versions.</p>
<p>Yarn offers deterministic installs because it uses a lockfile to lockdown all the dependencies recursively at the application level. So if package A depends on v1.0 of package C, and package B depends on v2.0 of package A, both of them will be written to the lockfile separately.</p>
<p>When you know the exact versions of the dependencies you’re working with, you can easily reproduce builds, then track down and isolate bugs.</p>
<blockquote>
<p>“To make it more clear, your <code>package.json</code> states <strong>“what I want”</strong> for the project whereas your lockfile says <strong>“what I had”</strong> in terms of dependencies. — <a href="https://medium.com/@dan_abramov" target="_blank" rel="noopener">Dan Abramov</a></p>
</blockquote>
<p>So now we can return to the original question that started me on this learning spree in the first place: <strong>Why is it considered a good practice to have lockfiles for applications, but not for libraries?</strong></p>
<p>The main reason is that you actually deploy applications. So you need to have deterministic dependencies that lead to reproducible builds in different environments — testing, staging, and production.</p>
<p>But the same isn’t true for libraries. Libraries aren’t deployed. They’re used to build other libraries, or in application themselves. Libraries need to be flexible so that they can maximize compatibility.</p>
<p>If we had a lockfile for each dependency (library) that we used in an application, and the application was forced to respect these lockfiles, it would be impossible to get anywhere close to a flat dependency structure we talked about earlier, with the <a href="http://semver.org/" target="_blank" rel="noopener">semantic versioning</a> flexibility, which is the best case scenario for dependency resolution.</p>
<p>Here’s why: if your application has to recursively honor the lockfiles of all your dependencies, there would be version conflicts all over the place — even in relatively small projects. This would cause a large amount of unavoidable duplication due to <a href="https://docs.npmjs.com/getting-started/semantic-versioning" target="_blank" rel="noopener">semantic versioning</a>.</p>
<p>This is not to say that libraries can’t have lockfiles. They certainly can. But the main takeaway is that package managers like Yarn and npm — which consume these libraries — will not respect those lockfiles.</p>
]]></content>
      
        <categories>
            
            <category> pure material </category>
            
        </categories>
        
        
        <tags>
            
            <tag> pure material </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[CSS--flex]]></title>
      <url>/2018/07/23/css/flex/</url>
      <content type="html"><![CDATA[<h2 id="CSS-–-flex"><a href="#CSS-–-flex" class="headerlink" title="CSS – flex"></a>CSS – flex</h2><h3 id="Background"><a href="#Background" class="headerlink" title="Background"></a>Background</h3><p>The Flexbox Layout (Flexible Box) module (currently a W3C Last Call Working Draft) aims at providing a more efficient way to lay out, align and distribute space among items in a container, even when their size is unknown and/or dynamic (thus the word “flex”).</p>
<p>The main idea behind the flex layout is to give the container the ability to alter its items’ width/height (and order) to best fill the available space (mostly to accommodate to all kind of display devices and screen sizes). A flex container expands items to fill available free space, or shrinks them to prevent overflow.</p>
<p>Most importantly, the flexbox layout is direction-agnostic as opposed to the regular layouts (block which is vertically-based and inline which is horizontally-based). While those work well for pages, they lack flexibility (no pun intended) to support large or complex applications (especially when it comes to orientation changing, resizing, stretching, shrinking, etc.).</p>
<p>Most importantly, the flexbox layout is direction-agnostic as opposed to the regular layouts (block which is vertically-based and inline which is horizontally-based). While those work well for pages, they lack flexibility (no pun intended) to support large or complex applications (especially when it comes to orientation changing, resizing, stretching, shrinking, etc.).</p>
<p>Note: Flexbox layout is most appropriate to the components of an application, and small-scale layouts, while the <a href="http://css-tricks.com/snippets/css/complete-guide-grid/" target="_blank" rel="noopener">Grid</a> layout is intended for larger scale layouts.</p>
<h3 id="Basics-amp-Terminology"><a href="#Basics-amp-Terminology" class="headerlink" title="Basics &amp; Terminology"></a>Basics &amp; Terminology</h3><p>Since flexbox is a whole module and not a single property, it involves a lot of things including its whole set of properties. Some of them are meant to be set on the container (parent element, known as “flex container”) whereas the others are meant to be set on the children (said “flex items”).</p>
<p>If regular layout is based on both block and inline flow directions, the flex layout is based on “flex-flow directions”. Please have a look at this figure from the specification, explaining the main idea behind the flex layout.</p>
<p><img src="/images/css/flexbox.png"></p>
<p>Basically, items will be laid out following either the main axis (from <code>main-start</code> to <code>main-end</code>) or the cross axis (from <code>cross-start</code> to <code>cross-end</code>).</p>
<ul>
<li><strong>main axis</strong> - The main axis of a flex container is the primary axis along which flex items are laid out. Beware, it is not necessarily horizontal; it depends on the <code>flex-direction</code> property (see below).</li>
<li><strong>main-start</strong> | <strong>main-end</strong> - The flex items are placed within the container starting from main-start and going to main-end.</li>
<li><strong>main size</strong> - A flex item’s width or height, whichever is in the main dimension, is the item’s main size. The flex item’s main size property is either the ‘width’ or ‘height’ property, whichever is in the main dimension.</li>
<li><strong>cross axis</strong> - The axis perpendicular to the main axis is called the cross axis. Its direction depends on the main axis direction.</li>
<li><strong>cross-start</strong> | <strong>cross-end</strong> - Flex lines are filled with items and placed into the container starting on the cross-start side of the flex container and going toward the cross-end side.</li>
<li><strong>cross size</strong> - The width or height of a flex item, whichever is in the cross dimension, is the item’s cross size. The cross size property is whichever of ‘width’ or ‘height’ that is in the cross dimension.</li>
</ul>
<p><img src="/images/css/flex-container.svg"></p>
<h3 id="Properties-for-the-Parent"><a href="#Properties-for-the-Parent" class="headerlink" title="Properties for the Parent"></a>Properties for the Parent</h3><h4 id="display"><a href="#display" class="headerlink" title="display"></a>display</h4><p>This defines a flex container; inline or block depending on the given value. It enables a flex context for all its direct children.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex; <span class="comment">/* or inline-flex */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that CSS columns have no effect on a flex container.</p>
<h4 id="flex-direction"><a href="#flex-direction" class="headerlink" title="flex-direction"></a>flex-direction</h4><p><img src="/images/css/flex-direction2.svg"></p>
<p>This establishes the main-axis, thus defining the direction flex items are placed in the flex container. Flexbox is (aside from optional wrapping) a single-direction layout concept. Think of flex items as primarily laying out either in horizontal rows or vertical columns.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">flex-direction</span>: row | row-reverse | column | column-reverse;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>row (default): left to right in ltr; right to left in rtl</li>
<li>row-reverse: right to left in ltr; left to right in rtl</li>
<li>column: same as row but top to bottom</li>
<li>column-reverse: same as row-reverse but bottom to top</li>
</ul>
<h4 id="flex-wrap"><a href="#flex-wrap" class="headerlink" title="flex-wrap"></a>flex-wrap</h4><p><img src="/images/css/flex-wrap.svg"></p>
<p>By default, flex items will all try to fit onto one line. You can change that and allow the items to wrap as needed with this property</p>
<ul>
<li>nowrap (default): all flex items will be on one line</li>
<li>wrap: flex items will wrap onto multiple lines, from top to bottom.</li>
<li>wrap-reverse: flex items will wrap onto multiple lines from bottom to top.</li>
</ul>
<h4 id="flex-flow-Applies-to-parent-flex-container-element"><a href="#flex-flow-Applies-to-parent-flex-container-element" class="headerlink" title="flex-flow (Applies to: parent flex container element)"></a>flex-flow (Applies to: parent flex container element)</h4><p>This is a shorthand flex-direction and flex-wrap properties, which together define the flex container’s main and cross axes. Default is row nowrap.</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">flex-flow: <span class="tag">&lt;<span class="name">‘flex-direction’</span>&gt;</span> || <span class="tag">&lt;<span class="name">‘flex-wrap’</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="justify-content"><a href="#justify-content" class="headerlink" title="justify-content"></a>justify-content</h4><p><img src="/images/css/justify-content-2.svg"></p>
<p>This defines the alignment along the main axis. It helps distribute extra free space left over when either all the flex items on a line are inflexible, or are flexible but have reached their maximum size. It also exerts some control over the alignment of items when they overflow the line.</p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  justify-content: flex-start | flex-<span class="keyword">end</span> | center | <span class="literal">space</span>-<span class="keyword">between</span> | <span class="literal">space</span>-<span class="keyword">around</span> | <span class="literal">space</span>-evenly;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li><code>flex-start</code> (default): items are packed toward the start line</li>
<li><code>flex-end</code>: items are packed toward to end line</li>
<li><code>center</code>: items are centered along the line</li>
<li><code>space-between</code>: items are evenly distributed in the line; first item is on the start line, last item on the end line</li>
<li><code>space-around</code>: items are evenly distributed in the line with equal space around them. Note that visually the spaces aren’t equal, since all the items have equal space on both sides. The first item will have one unit of space against the container edge, but two units of space between the next item because that next item has its own spacing that applies.</li>
<li><code>space-evenly</code>: items are distributed so that the spacing between any two items (and the space to the edges) is equal.</li>
</ul>
<h4 id="align-items"><a href="#align-items" class="headerlink" title="align-items"></a>align-items</h4><p><img src="/images/css/align-items.svg"></p>
<p>This defines the default behaviour for how flex items are laid out along the cross axis on the current line. Think of it as the justify-content version for the cross-axis (perpendicular to the main-axis).</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.container</span> &#123;</span><br><span class="line">  <span class="attribute">align-items</span>: flex-start | flex-end | center | baseline | stretch;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flex-start: cross-start margin edge of the items is placed on the cross-start line</li>
<li>flex-end: cross-end margin edge of the items is placed on the cross-end line</li>
<li>center: items are centered in the cross-axis</li>
<li>baseline: items are aligned such as their baselines align</li>
<li>stretch (default): stretch to fill the container (still respect min-width/max-width)</li>
</ul>
<h4 id="align-content"><a href="#align-content" class="headerlink" title="align-content"></a>align-content</h4><p><img src="/images/css/align-content.svg"></p>
<p>This aligns a flex container’s lines within when there is extra space in the cross-axis, similar to how justify-content aligns individual items within the main-axis.</p>
<p>Note: this property has no effect when there is only one line of flex items.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.container &#123;</span><br><span class="line">  align-content: flex-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">space</span>-between | <span class="type">space</span>-around | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ul>
<li>flex-start: lines packed to the start of the container</li>
<li>flex-end: lines packed to the end of the container</li>
<li>center: lines packed to the center of the container</li>
<li>space-between: lines evenly distributed; the first line is at the start of the container while the last one is at the end</li>
<li>space-around: lines evenly distributed with equal space around each line</li>
<li>stretch (default): lines stretch to take up the remaining space</li>
</ul>
<p><img src="images/css/flex-items.svg"></p>
<h3 id="Properties-for-the-Children-flex-items"><a href="#Properties-for-the-Children-flex-items" class="headerlink" title="Properties for the Children(flex items)"></a>Properties for the Children(flex items)</h3><h4 id="order"><a href="#order" class="headerlink" title="order"></a>order</h4><p><img src="/images/css/order-2.svg"></p>
<p>By default, flex items are laid out in the source order. However, the <code>order</code> property controls the order in which they appear in the flex container.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">order</span>: &lt;integer&gt;; <span class="comment">/* default is 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="flex-grow"><a href="#flex-grow" class="headerlink" title="flex-grow"></a>flex-grow</h4><p><img src="/images/css/flex-grow.svg"></p>
<p>This defines the ability for a flex item to grow if necessary. It accepts a unitless value that serves as a proportion. It dictates what amount of the available space inside the flex container the item should take up.</p>
<p>If all items have flex-grow set to 1, the remaining space in the container will be distributed equally to all children. If one of the children has a value of 2, the remaining space would take up twice as much space as the others (or it will try to, at least).</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-grow</span>: &lt;number&gt;; <span class="comment">/* default 0 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Negative numbers are invalid.</p>
<h4 id="flex-shrink"><a href="#flex-shrink" class="headerlink" title="flex-shrink"></a>flex-shrink</h4><p>This defines the ability for a flex item to shrink if necessary.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-shrink</span>: &lt;number&gt;; <span class="comment">/* default 1 */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="flex-basis"><a href="#flex-basis" class="headerlink" title="flex-basis"></a>flex-basis</h4><p>This defines the default size of an element before the remaining space is distributed. It can be a length (e.g. 20%, 5rem, etc.) or a keyword. The auto keyword means “look at my width or height property” (which was temporarily done by the main-size keyword until deprecated). The content keyword means “size it based on the item’s content” - this keyword isn’t well supported yet, so it’s hard to test and harder to know what its brethren max-content, min-content, and fit-content do.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex-basis</span>: &lt;length&gt; | auto; <span class="comment">/* default auto */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="flex"><a href="#flex" class="headerlink" title="flex"></a>flex</h4><p>This is the shorthand for flex-grow, flex-shrink and flex-basis combined. The second and third parameters (flex-shrink and flex-basis) are optional. Default is 0 1 auto.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.item</span> &#123;</span><br><span class="line">  <span class="attribute">flex</span>: none | [ &lt;<span class="string">'flex-grow'</span>&gt; &lt;<span class="string">'flex-shrink'</span>&gt;? || &lt;<span class="string">'flex-basis'</span>&gt; ]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>It is recommended that you use this shorthand property rather than set the individual properties. The short hand sets the other values intelligently.</p>
<h4 id="align-self"><a href="#align-self" class="headerlink" title="align-self"></a>align-self</h4><p><img src="/images/css/align-self.svg"></p>
<p>This allows the default alignment (or the one specified by align-items) to be overridden for individual flex items.</p>
<p>Please see the align-items explanation to understand the available values.</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">.item &#123;</span><br><span class="line">  align-self: <span class="built_in">auto</span> | <span class="type">flex</span>-start | <span class="type">flex</span>-<span class="keyword">end</span> | <span class="type">center</span> | <span class="type">baseline</span> | <span class="type">stretch</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that float, clear and vertical-align have no effect on a flex item.</p>
<h1 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a>Examples</h1><p>Let’s start with a very very simple example, solving an almost daily problem: perfect centering. It couldn’t be any simpler if you use flexbox.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.parent</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">height</span>: <span class="number">300px</span>; <span class="comment">/* Or whatever */</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-class">.child</span> &#123;</span><br><span class="line">  <span class="attribute">width</span>: <span class="number">100px</span>;  <span class="comment">/* Or whatever */</span></span><br><span class="line">  <span class="attribute">height</span>: <span class="number">100px</span>; <span class="comment">/* Or whatever */</span></span><br><span class="line">  <span class="attribute">margin</span>: auto;  <span class="comment">/* Magic! */</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This relies on the fact a margin set to <code>auto</code> in a flex container absorb extra space. So setting a vertical margin of auto will make the item perfectly centered in both axis.</p>
<p>Now let’s use some more properties. Consider a list of 6 items, all with a fixed dimensions in a matter of aesthetics but they could be auto-sized. We want them to be evenly and nicely distributed on the horizontal axis so that when we resize the browser, everything is fine (without media queries!).</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.flex-container</span> &#123;</span><br><span class="line">  <span class="comment">/* We first create a flex layout context */</span></span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then we define the flow direction</span></span><br><span class="line"><span class="comment">     and if we allow the items to wrap</span></span><br><span class="line"><span class="comment">   * Remember this is the same as:</span></span><br><span class="line"><span class="comment">   * flex-direction: row;</span></span><br><span class="line"><span class="comment">   * flex-wrap: wrap;</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line"></span><br><span class="line">  <span class="comment">/* Then we define how is distributed the remaining space */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s try something else. Imagine we have a right-aligned navigation on the very top of our website, but we want it to be centered on medium-sized screens and single-columned on small devices. Easy enough.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">/* Large */</span></span><br><span class="line"><span class="selector-class">.navigation</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">  <span class="comment">/* This aligns items to the end line on main-axis */</span></span><br><span class="line">  <span class="attribute">justify-content</span>: flex-end;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Medium screens */</span></span><br><span class="line">@<span class="keyword">media</span> all and (max-width: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.navigation</span> &#123;</span><br><span class="line">    <span class="comment">/* When on medium sized screens, we center it by evenly distributing empty space around items */</span></span><br><span class="line">    <span class="attribute">justify-content</span>: space-around;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Small screens */</span></span><br><span class="line">@<span class="keyword">media</span> all and (max-width: <span class="number">500px</span>) &#123;</span><br><span class="line">  <span class="selector-class">.navigation</span> &#123;</span><br><span class="line">    <span class="comment">/* On small screens, we are no longer using row direction but column */</span></span><br><span class="line">    <span class="attribute">flex-direction</span>: column;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Let’s try something even better by playing with flex items flexibility! What about a mobile-first 3-columns layout with full-width header and footer. And independent from source order.</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-class">.wrapper</span> &#123;</span><br><span class="line">  <span class="attribute">display</span>: flex;</span><br><span class="line">  <span class="attribute">flex-flow</span>: row wrap;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We tell all items to be 100% width, via flex-basis */</span></span><br><span class="line"><span class="selector-class">.wrapper</span> &gt; * &#123;</span><br><span class="line">  <span class="attribute">flex</span>: <span class="number">1</span> <span class="number">100%</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* We rely on source order for mobile-first approach</span></span><br><span class="line"><span class="comment"> * in this case:</span></span><br><span class="line"><span class="comment"> * 1. header</span></span><br><span class="line"><span class="comment"> * 2. article</span></span><br><span class="line"><span class="comment"> * 3. aside 1</span></span><br><span class="line"><span class="comment"> * 4. aside 2</span></span><br><span class="line"><span class="comment"> * 5. footer</span></span><br><span class="line"><span class="comment"> */</span></span><br><span class="line"></span><br><span class="line"><span class="comment">/* Medium screens */</span></span><br><span class="line">@<span class="keyword">media</span> all and (min-width: <span class="number">600px</span>) &#123;</span><br><span class="line">  <span class="comment">/* We tell both sidebars to share a row */</span></span><br><span class="line">  <span class="selector-class">.aside</span> &#123; <span class="attribute">flex</span>: <span class="number">1</span> auto; &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">/* Large screens */</span></span><br><span class="line">@<span class="keyword">media</span> all and (min-width: <span class="number">800px</span>) &#123;</span><br><span class="line">  <span class="comment">/* We invert order of first sidebar and main</span></span><br><span class="line"><span class="comment">   * And tell the main element to take twice as much width as the other two sidebars</span></span><br><span class="line"><span class="comment">   */</span></span><br><span class="line">  <span class="selector-class">.main</span> &#123; <span class="attribute">flex</span>: <span class="number">2</span> <span class="number">0px</span>; &#125;</span><br><span class="line">  <span class="selector-class">.aside-1</span> &#123; <span class="attribute">order</span>: <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="selector-class">.main</span>    &#123; <span class="attribute">order</span>: <span class="number">2</span>; &#125;</span><br><span class="line">  <span class="selector-class">.aside-2</span> &#123; <span class="attribute">order</span>: <span class="number">3</span>; &#125;</span><br><span class="line">  <span class="selector-class">.footer</span>  &#123; <span class="attribute">order</span>: <span class="number">4</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> css </category>
            
        </categories>
        
        
        <tags>
            
            <tag> css </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[03.Advanced Guides -- 04.Error Boundaries]]></title>
      <url>/2018/07/05/react/03.Advanced_Guides/04.Error_Boundaries/</url>
      <content type="html"><![CDATA[<h3 id="Error-Boundaries-错误边界"><a href="#Error-Boundaries-错误边界" class="headerlink" title="Error Boundaries(错误边界)"></a>Error Boundaries(错误边界)</h3><p>In the past, JavaScript errors inside components used to corrupt React’s internal state and cause it to <a href="https://github.com/facebook/react/issues/4026" target="_blank" rel="noopener">emit</a> <a href="https://github.com/facebook/react/issues/6895" target="_blank" rel="noopener">cryptic</a> <a href="https://github.com/facebook/react/issues/8579" target="_blank" rel="noopener">errors</a> on next renders. These errors were always caused by an earlier error in the application code, but React did not provide a way to handle them gracefully in components, and could not recover from them.</p>
<p>过去，组件内部的JavaScript错误会导致React的内部状态产生问题并可能导致在下一次渲染时<a href="https://github.com/facebook/react/issues/4026" target="_blank" rel="noopener">产生</a><a href="https://github.com/facebook/react/issues/6895" target="_blank" rel="noopener">不可预知的</a><a href="https://github.com/facebook/react/issues/8579" target="_blank" rel="noopener">错误</a>。这些错误总是由应用程序代码中的早期错误引起，但React没有提供在组件中优雅地处理它们的方法，并且无法从这些旧的错误中恢复回来。</p>
<h4 id="Introducing-Error-Boundaries-介绍错误边界"><a href="#Introducing-Error-Boundaries-介绍错误边界" class="headerlink" title="Introducing Error Boundaries(介绍错误边界)"></a>Introducing Error Boundaries(介绍错误边界)</h4><p>A JavaScript error in a part of the UI shouldn’t break the whole app. To solve this problem for React users, React 16 introduces a new concept of an “error boundary”.</p>
<p>JavaScript中UI部分的错误不应该阻断整个应用程序的运行。为了解决React用户的这个问题，React 16引入了一个新的“错误边界”的概念。</p>
<p>Error boundaries are React components that <strong>catch JavaScript errors anywhere in their child component tree, log those errors, and display a fallback UI</strong> instead of the component tree that crashed. Error boundaries catch errors during rendering, in lifecycle methods, and in constructors of the whole tree below them.</p>
<p>错误边界属于React组件，它们<strong>可以在其子组件树中的任何位置捕获JavaScript错误，并会记录这些错误，以UI的形式返回</strong>而不是阻断的的组件树。错误边界是在渲染期间，生命周期方法以及它们下面的整个树的构造函数中捕获错误的。</p>
<blockquote>
<p>Note<br>Error boundaries do not catch errors for:</p>
<ul>
<li>Event handlers (<a href="https://reactjs.org/docs/error-boundaries.html#how-about-event-handlers" target="_blank" rel="noopener">learn more</a>)</li>
<li>Asynchronous code (e.g. <code>setTimeout</code> or <code>requestAnimationFrame</code> callbacks)</li>
<li>Server side rendering</li>
<li>Errors thrown in the error boundary itself (rather than its children)</li>
</ul>
<p>注意<br>错误边界不会获取以下错误：</p>
<ul>
<li>事件处理器（<a href="https://reactjs.org/docs/error-boundaries.html#how-about-event-handlers" target="_blank" rel="noopener">关于更多</a>）</li>
<li>异步代码（例如<code>setTimeout</code>或<code>requestAnimationFrame</code>回调函数）</li>
<li>服务器端的渲染</li>
<li>在错误边界内部抛出的错误(而不是它的子组件中)</li>
</ul>
</blockquote>
<p>A class component becomes an error boundary if it defines a new lifecycle method called <code>componentDidCatch(error, info)</code>:</p>
<p>当类组件被定义为一个名为<code>componentDidCatch(error, info)</code>的新的生命周期函数时，它会变为一个错误边界：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">ErrorBoundary</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">hasError</span>: <span class="literal">false</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidCatch(error, info) &#123;</span><br><span class="line">    <span class="comment">// Display fallback UI</span></span><br><span class="line">    <span class="keyword">this</span>.setState(&#123; <span class="attr">hasError</span>: <span class="literal">true</span> &#125;);</span><br><span class="line">    <span class="comment">// You can also log the error to an error reporting service</span></span><br><span class="line">    logErrorToMyService(error, info);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.hasError) &#123;</span><br><span class="line">      <span class="comment">// You can render any custom fallback UI</span></span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Something went wrong.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.props.children;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then you can use it as a regular component:</p>
<p>然后您可以将它作为常规组件使用：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;ErrorBoundary&gt;</span></span><br><span class="line">  <span class="section">&lt;MyWidget /&gt;</span></span><br><span class="line"><span class="section">&lt;/ErrorBoundary&gt;</span></span><br></pre></td></tr></table></figure>
<p>The <code>componentDidCatch()</code> method works like a JavaScript <code>catch {}</code> block, but for components. Only class components can be error boundaries. In practice, most of the time you’ll want to declare an error boundary component once and use it throughout your application.</p>
<p><code>componentDidCatch（）</code>方法的工作方式类似于JavaScript <code>catch {}</code>，但对于组件而言。只有类组件可以被定义为错误边界。实际上，大多数情况下，您需要声明一次错误边界组件并在整个应用程序中使用它。</p>
<p>Note that <strong>error boundaries only catch errors in the components below them in the tree.</strong> An error boundary can’t catch an error within itself. If an error boundary fails trying to render the error message, the error will propagate to the closest error boundary above it. This, too, is similar to how catch {} block works in JavaScript.</p>
<p>请注意，<strong>错误边界仅捕获它们的子组件中的错误。</strong> 一个错误边界无法捕获自身的错误。如果错误边界要呈现错误信息时，错误将传到到其上方最接近的错误边界组件上呈现。这也类似于JavaScript中catch的工作方式。</p>
<h3 id="componentDidCatch-Parameters（componentDidCatch参数）"><a href="#componentDidCatch-Parameters（componentDidCatch参数）" class="headerlink" title="componentDidCatch Parameters（componentDidCatch参数）"></a>componentDidCatch Parameters（componentDidCatch参数）</h3><p><code>error</code> is an error that has been thrown.</p>
<p><code>error</code>是一个被抛出的错误。</p>
<p><code>info</code> is an object with <code>componentStack</code> key. The property has information about component stack during thrown error.</p>
<p><code>info</code>是<code>componentStack</code>键的对象。该属性包含有关抛出错误期间组件堆栈的信息。</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">//...</span><br><span class="line">componentDidCatch(error, info) &#123;</span><br><span class="line"></span><br><span class="line">  /* <span class="keyword">Example</span> stack information:</span><br><span class="line">     <span class="built_in">in</span> ComponentThatThrows (created <span class="built_in">by</span> App)</span><br><span class="line">     <span class="built_in">in</span> ErrorBoundary (created <span class="built_in">by</span> App)</span><br><span class="line">     <span class="built_in">in</span> div (created <span class="built_in">by</span> App)</span><br><span class="line">     <span class="built_in">in</span> App</span><br><span class="line">  */</span><br><span class="line">  logComponentStackToMyService(info.componentStack);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">//...</span><br></pre></td></tr></table></figure>
<h3 id="Live-Demo-实例"><a href="#Live-Demo-实例" class="headerlink" title="Live Demo(实例)"></a>Live Demo(实例)</h3><p>Check out <a href="https://codepen.io/gaearon/pen/wqvxGa?editors=0010" target="_blank" rel="noopener">this example of declaring and using an error boundary</a> with <a href="https://reactjs.org/blog/2017/09/26/react-v16.0.html" target="_blank" rel="noopener">React 16</a>.</p>
<p>请看在<a href="https://reactjs.org/blog/2017/09/26/react-v16.0.html" target="_blank" rel="noopener">React 16</a><a href="https://codepen.io/gaearon/pen/wqvxGa?editors=0010" target="_blank" rel="noopener">声明和使用一个错误边界的例子</a></p>
<h3 id="Where-to-Place-Error-Boundaries-在哪个放置错误边界"><a href="#Where-to-Place-Error-Boundaries-在哪个放置错误边界" class="headerlink" title="Where to Place Error Boundaries(在哪个放置错误边界)"></a>Where to Place Error Boundaries(在哪个放置错误边界)</h3><p>The granularity of error boundaries is up to you. You may wrap top-level route components to display a “Something went wrong” message to the user, just like server-side frameworks often handle crashes. You may also wrap individual widgets in an error boundary to protect them from crashing the rest of the application.</p>
<p>错误边界的位置取决于您。您可以将顶层路由组件包装为向用户显示“Something going wrong”消息，就像服务器端框架经常处理崩溃一样。您还可以将各个小组件包装在错误边界中，以防止它们阻碍应用程序的其余部分。</p>
<h3 id="New-Behavior-for-Uncaught-Errors-未捕获错误的新行为"><a href="#New-Behavior-for-Uncaught-Errors-未捕获错误的新行为" class="headerlink" title="New Behavior for Uncaught Errors(未捕获错误的新行为)"></a>New Behavior for Uncaught Errors(未捕获错误的新行为)</h3><p>This change has an important implication. <strong>As of React 16, errors that were not caught by any error boundary will result in unmounting of the whole React component tree.</strong></p>
<p>这种变化具有重要的意义。<strong>从React 16开始，未被任何错误边界捕获的错误将导致卸载整个React组件树。</strong></p>
<p>We debated this decision, but in our experience it is worse to leave corrupted UI in place than to completely remove it. For example, in a product like Messenger leaving the broken UI visible could lead to somebody sending a message to the wrong person. Similarly, it is worse for a payments app to display a wrong amount than to render nothing.</p>
<p>我们讨论过这个决定，但根据我们的经验，将错误的UI显示出来比完全删除它更糟糕。例如，在像Messenger这样的产品中，对用户可见的错误UI可能会导致某人向他人误发消息。同样，支付应用程序显示错误的金额比提供任何其他内容更糟糕。</p>
<p>This change means that as you migrate to React 16, you will likely uncover existing crashes in your application that have been unnoticed before. Adding error boundaries lets you provide better user experience when something goes wrong.</p>
<p>此更改意味着在迁移到React 16后，您可能会发现应用程序中以前未被注意到的bug导致整个应用程序的崩溃。添加错误边界可让您在出现问题时提供更好的用户体验。</p>
<p>For example, Facebook Messenger wraps content of the sidebar, the info panel, the conversation log, and the message input into separate error boundaries. If some component in one of these UI areas crashes, the rest of them remain interactive.</p>
<p>例如，Facebook Messenger将侧边栏，信息面板，对话日志和消息输入的内容包装到单独的错误边界中。 如果其中一个UI区域中的某个组件崩溃，则其余组件还可以保持正常的交互状态。</p>
<p>We also encourage you to use JS error reporting services (or build your own) so that you can learn about unhandled exceptions as they happen in production, and fix them.</p>
<p>我们还鼓励您使用JS错误报告服务（或构建您自己的错误报告），以便让您可以了解生产中发生的未处理的异常并去修复它们。</p>
<h3 id="Component-Stack-Traces-组件堆栈的跟踪"><a href="#Component-Stack-Traces-组件堆栈的跟踪" class="headerlink" title="Component Stack Traces(组件堆栈的跟踪)"></a>Component Stack Traces(组件堆栈的跟踪)</h3><p>React 16 prints all errors that occurred during rendering to the console in development, even if the application accidentally swallows them. In addition to the error message and the JavaScript stack, it also provides component stack traces. Now you can see where exactly in the component tree the failure has happened:</p>
<p>React 16将在渲染过程中发生的所有错误打印到开发工具中的控制台，即使应用程序意外未显示它们也是如此。除了错误消息和JavaScript堆栈之外，它还提供了组件堆栈的跟踪。现在，您可以看到故障发生在组件树中的确切位置：</p>
<p><img src="/images/react_document/03-04-error-info-one.png"></p>
<p>You can also see the filenames and line numbers in the component stack trace. This works by default in <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a> projects:</p>
<p>您还可以在组件堆栈跟踪中查看文件名和行号。默认情况下，这会在<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>项目下显示：</p>
<p><img src="/images/react_document/03-04-error-info-two.png"></p>
<p>If you don’t use Create React App, you can add <a href="https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source" target="_blank" rel="noopener">this plugin</a> manually to your Babel configuration. Note that it’s intended only for development and <strong>must be disabled in production.</strong></p>
<p>如果您不使用Create React App，则可以将<a href="https://www.npmjs.com/package/babel-plugin-transform-react-jsx-source" target="_blank" rel="noopener">此插件</a>手动添加到Babel的配置中。请注意，此插件仅用于开发环境，<strong>在生产环境中必须禁用。</strong></p>
<blockquote>
<p>Note<br>Component names displayed in the stack traces depend on the <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name" target="_blank" rel="noopener">Function.name</a> property. If you support older browsers and devices which may not yet provide this natively (e.g. IE 11), consider including a <code>Function.name</code> polyfill in your bundled application, such as <a href="https://github.com/JamesMGreene/Function.name" target="_blank" rel="noopener">function.name-polyfill</a>. Alternatively, you may explicitly set the <a href="https://reactjs.org/docs/react-component.html#displayname" target="_blank" rel="noopener">displayName</a> property on all your components.</p>
<p>注意<br>堆栈跟踪中显示的组件名称取决于<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Function/name" target="_blank" rel="noopener">Function.name</a>属性。 如果您支持旧版本的浏览器和设备（例如IE 11），请考虑在捆绑应用程序中包含polyfill的<code>Function.name</code>，例如<a href="https://github.com/JamesMGreene/Function.name" target="_blank" rel="noopener">function.name-polyfill</a>。 或者，您可以在所有组件上显式设置<a href="https://reactjs.org/docs/react-component.html#displayname" target="_blank" rel="noopener">displayName</a>属性。</p>
</blockquote>
<h3 id="How-About-try-catch-关于try-catch如何？"><a href="#How-About-try-catch-关于try-catch如何？" class="headerlink" title="How About try/catch?(关于try / catch如何？)"></a>How About try/catch?(关于try / catch如何？)</h3><p><code>try</code> / <code>catch</code> is great but it only works for imperative code:</p>
<p><code>try</code> / <code>catch</code>不错，但它只适用于命令式代码：</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  showButton();</span><br><span class="line">&#125; <span class="keyword">catch</span> (<span class="keyword">error</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>However, React components are declarative and specify what should be rendered:</p>
<p>然而，React组件是声明式的，并指定应该如何渲染：</p>
<figure class="highlight apache"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="section">&lt;Button /&gt;</span></span><br></pre></td></tr></table></figure>
<p>Error boundaries preserve the declarative nature of React, and behave as you would expect. For example, even if an error occurs in a <code>componentDidUpdate</code> hook caused by a <code>setState</code> somewhere deep in the tree, it will still correctly propagate to the closest error boundary.</p>
<p>错误边界保留了React的声明式的本质，并且表现的和您期待的一样。例如，即使在由组件树中深处的某个<code>setState</code>引起的<code>componentDidUpdate</code>钩子上发生错误，它仍会正确地传播到最接近的错误边界。</p>
<h3 id="How-About-Event-Handlers-事件处理器如何？"><a href="#How-About-Event-Handlers-事件处理器如何？" class="headerlink" title="How About Event Handlers?(事件处理器如何？)"></a>How About Event Handlers?(事件处理器如何？)</h3><p>Error boundaries <strong>do not</strong> catch errors inside event handlers.</p>
<p>错误边界<strong>不会</strong>捕获在事件处理器中的错误。</p>
<p>React doesn’t need error boundaries to recover from errors in event handlers. Unlike the render method and lifecycle hooks, the event handlers don’t happen during rendering. So if they throw, React still knows what to display on the screen.</p>
<p>React不需要错误边界从事件处理程序中的错误中恢复。与render方法和生命周期钩子不同，事件处理器在渲染过程中不会发生。因此，如果它们抛出错误，React仍然知道在屏幕上如何显示。</p>
<p>If you need to catch an error inside event handler, use the regular JavaScript <code>try</code> / <code>catch</code> statement:</p>
<p>如果您需要在事件处理器中捕获问题，请使用常规的JavaScript的<code>try</code> / <code>catch</code>语法：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyComponent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123; <span class="attr">error</span>: <span class="literal">null</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">try</span> &#123;</span><br><span class="line">      <span class="comment">// Do something that could throw</span></span><br><span class="line">    &#125; <span class="keyword">catch</span> (error) &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123; error &#125;);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span>.state.error) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Caught an error.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">onClick</span>=<span class="string">&#123;this.handleClick&#125;</span>&gt;</span>Click Me<span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note that the above example is demonstrating regular JavaScript behavior and doesn’t use error boundaries.</p>
<p>注意上面的例子只用了常规的JavaScript语法，并没有使用错误边界。</p>
<h3 id="Naming-Changes-from-React-15（与React-15相比的命名改变）"><a href="#Naming-Changes-from-React-15（与React-15相比的命名改变）" class="headerlink" title="Naming Changes from React 15（与React 15相比的命名改变）"></a>Naming Changes from React 15（与React 15相比的命名改变）</h3><p>React 15 included a very limited support for error boundaries under a different method name: <code>unstable_handleError</code>. This method no longer works, and you will need to change it to <code>componentDidCatch</code> in your code starting from the first 16 beta release.</p>
<p>React 15对不同方法名称下的错误边界的支持非常有限：比如<code>unstable_handleError</code>。 此方法不再有效，您需要在第一个16 beta版本中将代码其更改为`componentDidCatch·。</p>
<p>For this change, we’ve provided a <a href="https://github.com/reactjs/react-codemod#error-boundaries" target="_blank" rel="noopener">codemod</a> to automatically migrate your code.</p>
<p>对于此更改，我们提供了一个自动迁移代码的<a href="https://github.com/reactjs/react-codemod#error-boundaries" target="_blank" rel="noopener">codemod</a>。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[03.Advanced Guides -- 03.Context]]></title>
      <url>/2018/07/02/react/03.Advanced_Guides/03.Context/</url>
      <content type="html"><![CDATA[<h2 id="Context-上下文"><a href="#Context-上下文" class="headerlink" title="Context(上下文)"></a>Context(上下文)</h2><blockquote>
<p>Context provides a way to pass data through the component tree without having to pass props down manually at every level.<br>Context提供了一种通过组件树传递数据的方法，而无需在每层组件之间手动传递props。</p>
</blockquote>
<p>In a typical React application, data is passed top-down (parent to child) via props, but this can be cumbersome for certain types of props (e.g. locale preference, UI theme) that are required by many components within an application. Context provides a way to share values like these between components without having to explicitly pass a prop through every level of the tree.</p>
<p>在一个典型的React应用中，数据是从顶向下（从父元素向子元素）提供props传递的，但是这对于某些特定类型的props（例如本地配置的首选项，UI主题）来说，在一个应用的多个组件之间传递实在太过笨重。Context提供了一种在组件之间共享这些值，且不需要显示地在每层组件之间传递props的方法。</p>
<ul>
<li><a href="#when-to-use-context">When to Use Context(什么时候使用Context)</a></li>
<li><a href="#API">[API]</a><ul>
<li><a href="#reactcreatecontext">React.createContext</a></li>
<li><a href="#provider">Provider</a></li>
<li><a href="#consumer">Consumer</a></li>
</ul>
</li>
<li><a href="#examples">Examples</a><ul>
<li><a href="#dynamic-context">Dynamic Context（动态上下文）</a></li>
<li><a href="#updating-context-from-a-nested-component">Updating Context from a Nested Component（从一个嵌套的组件里更新上下文）</a></li>
<li><a href="#consuming-multiple-contexts">Consuming Multiple Contexts（使用多个上下文）</a></li>
<li><a href="#accessing-context-in-lifecycle-methods">Accessing Context in Lifecycle Methods（在生命周期方法中访问上下文）</a></li>
<li><a href="#consuming-context-with-a-hoc">Consuming Context with a HOC（提供HOC使用上下文）</a></li>
<li><a href="#forwarding-refs-to-context-consumers">Forwarding Refs to Context Consumers（通过Refs传给上下文使用者）</a></li>
</ul>
</li>
<li><a href="#caveats">Caveats（注意事项）</a></li>
<li><a href="#legacy-api">Legacy API（遗留的API）</a></li>
</ul>
<h3 id="When-to-Use-Context-什么时候使用上下文"><a href="#When-to-Use-Context-什么时候使用上下文" class="headerlink" title="When to Use Context(什么时候使用上下文)"></a><a name="when-to-use-context">When to Use Context(什么时候使用上下文)</a></h3><p>Context is designed to share data that can be considered “global” for a tree of React components, such as the current authenticated user, theme, or preferred language. For example, in the code below we manually thread through a “theme” prop in order to style the Button component:</p>
<p>上下文旨在共享可被视为React组件树中的“全局”数据，例如当前经过身份验证的用户，主题或首选语言。例如，在下面的代码中，我们手动穿过“theme”参数以设置Button组件的样式：</p>
<figure class="highlight jsx"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Toolbar</span> <span class="attr">theme</span>=<span class="string">"dark"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml">function Toolbar(props) &#123;</span></span><br><span class="line"><span class="xml">  // The Toolbar component must take an extra "theme" prop</span></span><br><span class="line"><span class="xml">  // and pass it to the ThemedButton. This can become painful</span></span><br><span class="line"><span class="xml">  // if every single button in the app needs to know the theme</span></span><br><span class="line"><span class="xml">  // because it would have to be passed through all components.</span></span><br><span class="line"><span class="xml">  return (</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton theme=&#123;props.theme&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line">function ThemedButton(props) &#123;</span><br><span class="line">  return &lt;Button theme=&#123;props.theme&#125; /&gt;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Using context, we can avoid passing props through intermediate elements:</p>
<p>使用context，我们可以变通过中间元素传参。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Context lets us pass a value deep into the component tree</span></span><br><span class="line"><span class="comment">// without explicitly threading it through every component.</span></span><br><span class="line"><span class="comment">// Create a context for the current theme (with "light" as the default).</span></span><br><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// Use a Provider to pass the current theme to the tree below.</span></span><br><span class="line">    <span class="comment">// Any component can read it, no matter how deep it is.</span></span><br><span class="line">    <span class="comment">// In this example, we're passing "dark" as the current value.</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=<span class="string">"dark"</span>&gt;</span><br><span class="line">        &lt;Toolbar /&gt;</span><br><span class="line">      &lt;/ThemeContext.Provider&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// A component in the middle doesn't have to</span></span><br><span class="line"><span class="comment">// pass the theme down explicitly anymore.</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;ThemedButton /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemedButton</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// Use a Consumer to read the current theme context.</span></span><br><span class="line">  <span class="comment">// React will find the closest theme Provider above and use its value.</span></span><br><span class="line">  <span class="comment">// In this example, the current theme is "dark".</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;theme =&gt; &lt;Button &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125;</span><br><span class="line">    &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note<br>Don’t use context just to avoid passing props a few levels down. Stick to cases where the same data needs to be accessed in many components at multiple levels.</p>
<p>注意：<br>不要仅仅为了避免向下几层组件传参就使用context。尤其是在多个层次的组件中访问相同数据的情况。</p>
</blockquote>
<h3 id="API"><a href="#API" class="headerlink" title="API"></a><a name="API">API</a></h3><h4 id="React-createContext"><a href="#React-createContext" class="headerlink" title="React.createContext"></a><a name="reactcreatecontext">React.createContext</a></h4><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123;Provider, Consumer&#125; = React.createContext(defaultValue);</span><br></pre></td></tr></table></figure>
<p>Creates a <code>{ Provider, Consumer }</code> pair. When React renders a context Consumer, it will read the current context value from the closest matching Provider above it in the tree.</p>
<p>创造一对<code>{ Provider, Consumer }</code>。当React渲染上下文Consumer时，它会从react树中与它最接近的Provider上读取当前context值。</p>
<p>The <code>defaultValue</code> argument is only used by a Consumer when it does not have a matching Provider above it in the tree. This can be helpful for testing components in isolation without wrapping them. Note: passing <code>undefined</code> as a Provider value does not cause Consumers to use <code>defaultValue</code>.</p>
<p><code>defaultValue</code>参数仅在使用者在树中没有与之匹配的Provider时使用。这有助于在不没有对应的provider包围它们的情况下单独测试组件。注意：将<code>undefined</code>作为Provider值传递不会导致使用者使用<code>defaultValue</code>。</p>
<h3 id="Provider"><a href="#Provider" class="headerlink" title="Provider"></a><a name="provider">Provider</a></h3><figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">Provider</span> <span class="attr">value</span>=</span></span><span class="template-tag">&#123;/* <span class="name">some</span> value */&#125;</span><span class="xml"><span class="tag">&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>A React component that allows Consumers to subscribe to context changes.</p>
<p>一个可以让使用者获取context改变的react组件。</p>
<p>Accepts a value <code>prop</code> to be passed to Consumers that are descendants of this Provider. One Provider can be connected to many Consumers. Providers can be nested to override values deeper within the tree.</p>
<p>接受作为此Provider的后代使用者的值<code>prop</code>。一个Provider可以连接到许多使用者者。可以通过嵌套来覆盖树中更深层的值。</p>
<h3 id="Consumer"><a href="#Consumer" class="headerlink" title="Consumer"></a><a name="consumer">Consumer</a></h3><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="params">&lt;Consumer&gt;</span></span><br><span class="line">  &#123;value =&gt; <span class="comment">/* render something based on the context value */</span>&#125;</span><br><span class="line"><span class="params">&lt;/Consumer&gt;</span></span><br></pre></td></tr></table></figure>
<p>A React component that subscribes to context changes.</p>
<p>一个接受context变化的React组件。</p>
<p>Requires a <a href="https://reactjs.org/docs/render-props.html#using-props-other-than-render" target="_blank" rel="noopener">function as a child</a>. The function receives the current context value and returns a React node. The <code>value</code> argument passed to the function will be equal to the <code>value</code> prop of the closest Provider for this context above in the tree. If there is no Provider for this context above, the <code>value</code> argument will be equal to the <code>defaultValue</code> that was passed to createContext().</p>
<p>需要一个<a href="https://reactjs.org/docs/render-props.html#using-props-other-than-render" target="_blank" rel="noopener">作为子元素的函数</a>。该函数接收当前context值并返回React节点。传递给函数的<code>value</code>参数将等于React组件树中与此context最近的Provider的prop值。如果父组件没有此context的Provider，则<code>value</code>参数将等于传递给createContext（）的<code>defaultValue</code>。</p>
<blockquote>
<p>Note<br>For more information about the ‘function as a child’ pattern, see <a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener">render props</a>.</p>
<p>注意<br>想查看更多有关于‘将函数作为一个子元素’的信息，请看<a href="https://reactjs.org/docs/render-props.html" target="_blank" rel="noopener">渲染参数</a></p>
</blockquote>
<p>All Consumers that are descendants of a Provider will re-render whenever the Provider’s <code>value</code> prop changes. The propagation from Provider to its descendant Consumers is not subject to the <code>shouldComponentUpdate</code> method, so the Consumer is updated even when an ancestor component bails out of the update.</p>
<p>作为Provider后代的所有使用者将在Provider的<code>value</code>发生变化时重新呈现。从Provider到其后代的使用者的传递不受<code>shouldComponentUpdate</code>方法的限制，因此即使祖先组件退出更新，使用者也会更新。</p>
<p>Changes are determined by comparing the new and old values using the same algorithm as <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description" target="_blank" rel="noopener">Object.is</a>.</p>
<p>改变是通过<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/is#Description" target="_blank" rel="noopener">Object.is</a>相同的算法比较新旧值来确定更改。</p>
<blockquote>
<p>Note<br>The way changes are determined can cause some issues when passing objects as value: see <a href="https://reactjs.org/docs/context.html#caveats" target="_blank" rel="noopener">Caveats</a>.</p>
<p>注意：<br>确定更改的方式可能会在将对象作为值传递时导致一些问题：请参阅<a href="https://reactjs.org/docs/context.html#caveats" target="_blank" rel="noopener">警告</a>。</p>
</blockquote>
<h3 id="Examples"><a href="#Examples" class="headerlink" title="Examples"></a><a name="examples">Examples</a></h3><h4 id="Dynamic-Context（动态上下文）"><a href="#Dynamic-Context（动态上下文）" class="headerlink" title="Dynamic Context（动态上下文）"></a><a name="dynamic-context">Dynamic Context（动态上下文）</a></h4><p>A more complex example with dynamic values for the theme:</p>
<p>一个将theme作为动态值的更为复杂的例子：</p>
<h5 id="theme-context-js"><a href="#theme-context-js" class="headerlink" title="theme-context.js"></a>theme-context.js</h5><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> themes = &#123;</span><br><span class="line">  light: &#123;</span><br><span class="line">    foreground: <span class="string">'#000000'</span>,</span><br><span class="line">    <span class="built_in">background</span>: <span class="string">'#eeeeee'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">  dark: &#123;</span><br><span class="line">    foreground: <span class="string">'#ffffff'</span>,</span><br><span class="line">    <span class="built_in">background</span>: <span class="string">'#222222'</span>,</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext(</span><br><span class="line">  themes.dark <span class="comment">// default value</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h5 id="themed-button-js"><a href="#themed-button-js" class="headerlink" title="themed-button.js"></a>themed-button.js</h5><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ThemeContext&#125; from <span class="string">'./theme-context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> ThemedButton(props) &#123;</span><br><span class="line">  return (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;theme =&gt; (</span><br><span class="line">        &lt;button</span><br><span class="line">          &#123;...props&#125;</span><br><span class="line">          style=&#123;&#123;backgroundColor: theme.background&#125;&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">      )&#125;</span><br><span class="line">    &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> ThemedButton;</span><br></pre></td></tr></table></figure>
<h5 id="app-js"><a href="#app-js" class="headerlink" title="app.js"></a>app.js</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ThemeContext, themes&#125; <span class="keyword">from</span> <span class="string">'./theme-context'</span>;</span><br><span class="line"><span class="keyword">import</span> ThemedButton <span class="keyword">from</span> <span class="string">'./themed-button'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// An intermediate component that uses the ThemedButton</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Toolbar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemedButton onClick=&#123;props.changeTheme&#125;&gt;</span><br><span class="line">      Change Theme</span><br><span class="line">    &lt;<span class="regexp">/ThemedButton&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">class App extends React.Component &#123;</span></span><br><span class="line"><span class="regexp">  constructor(props) &#123;</span></span><br><span class="line"><span class="regexp">    super(props);</span></span><br><span class="line"><span class="regexp">    this.state = &#123;</span></span><br><span class="line"><span class="regexp">      theme: themes.light,</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">    this.toggleTheme = () =&gt; &#123;</span></span><br><span class="line"><span class="regexp">      this.setState(state =&gt; (&#123;</span></span><br><span class="line"><span class="regexp">        theme:</span></span><br><span class="line"><span class="regexp">          state.theme === themes.dark</span></span><br><span class="line"><span class="regexp">            ? themes.light</span></span><br><span class="line"><span class="regexp">            : themes.dark,</span></span><br><span class="line"><span class="regexp">      &#125;));</span></span><br><span class="line"><span class="regexp">    &#125;;</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">  render() &#123;</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ The ThemedButton button inside the ThemeProvider</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ uses the theme from state while the one outside uses</span></span><br><span class="line"><span class="regexp">    /</span><span class="regexp">/ the default dark theme</span></span><br><span class="line"><span class="regexp">    return (</span></span><br><span class="line"><span class="regexp">      &lt;Page&gt;</span></span><br><span class="line"><span class="regexp">        &lt;ThemeContext.Provider value=&#123;this.state.theme&#125;&gt;</span></span><br><span class="line"><span class="regexp">          &lt;Toolbar changeTheme=&#123;this.toggleTheme&#125; /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">        &lt;Section&gt;</span></span><br><span class="line"><span class="regexp">          &lt;ThemedButton /</span>&gt;</span><br><span class="line">        &lt;<span class="regexp">/Section&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>Page&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(<span class="xml"><span class="tag">&lt;<span class="name">App</span> /&gt;</span>, document.root);</span></span><br></pre></td></tr></table></figure>
<h4 id="Updating-Context-from-a-Nested-Component（从一个嵌套的组件里更新上下文）"><a href="#Updating-Context-from-a-Nested-Component（从一个嵌套的组件里更新上下文）" class="headerlink" title="Updating Context from a Nested Component（从一个嵌套的组件里更新上下文）"></a><a name="updating-context-from-a-nested-component">Updating Context from a Nested Component（从一个嵌套的组件里更新上下文）</a></h4><p>It is often necessary to update the context from a component that is nested somewhere deeply in the component tree. In this case you can pass a function down through the context to allow consumers to update the context:</p>
<p>通常需要从组件树上嵌套层数较深的组件中更新context。在这种情况下，您可以在context中向下传递一个函数，以允许使用者更新context：</p>
<h5 id="theme-context-js-1"><a href="#theme-context-js-1" class="headerlink" title="theme-context.js"></a>theme-context.js</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Make sure the shape of the default value passed to</span></span><br><span class="line"><span class="comment">// createContext matches the shape that the consumers expect!</span></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">const</span> ThemeContext = React.createContext(&#123;</span><br><span class="line">  theme: themes.dark,</span><br><span class="line">  toggleTheme: <span class="function"><span class="params">()</span> =&gt;</span> &#123;&#125;,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h5 id="theme-toggler-button-js"><a href="#theme-toggler-button-js" class="headerlink" title="theme-toggler-button.js"></a>theme-toggler-button.js</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ThemeContext&#125; <span class="keyword">from</span> <span class="string">'./theme-context'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemeTogglerButton</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// The Theme Toggler Button receives not only the theme</span></span><br><span class="line">  <span class="comment">// but also a toggleTheme function from the context</span></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;(&#123;theme, toggleTheme&#125;) =&gt; (</span><br><span class="line">        &lt;button</span><br><span class="line">          onClick=&#123;toggleTheme&#125;</span><br><span class="line">          style=&#123;&#123;<span class="attr">backgroundColor</span>: theme.background&#125;&#125;&gt;</span><br><span class="line">          Toggle Theme</span><br><span class="line">        &lt;<span class="regexp">/button&gt;</span></span><br><span class="line"><span class="regexp">      )&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">export</span> <span class="keyword">default</span> ThemeTogglerButton;</span><br></pre></td></tr></table></figure>
<h5 id="app-js-1"><a href="#app-js-1" class="headerlink" title="app.js"></a>app.js</h5><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123;ThemeContext, themes&#125; <span class="keyword">from</span> <span class="string">'./theme-context'</span>;</span><br><span class="line"><span class="keyword">import</span> ThemeTogglerButton <span class="keyword">from</span> <span class="string">'./theme-toggler-button'</span>;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">this</span>.toggleTheme = <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(<span class="function"><span class="params">state</span> =&gt;</span> (&#123;</span><br><span class="line">        theme:</span><br><span class="line">          state.theme === themes.dark</span><br><span class="line">            ? themes.light</span><br><span class="line">            : themes.dark,</span><br><span class="line">      &#125;));</span><br><span class="line">    &#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// State also contains the updater function so it will</span></span><br><span class="line">    <span class="comment">// be passed down into the context provider</span></span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      theme: themes.light,</span><br><span class="line">      toggleTheme: <span class="keyword">this</span>.toggleTheme,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// The entire state is passed to the provider</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Provider value=&#123;<span class="keyword">this</span>.state&#125;&gt;</span><br><span class="line">        &lt;Content /&gt;</span><br><span class="line">      &lt;<span class="regexp">/ThemeContext.Provider&gt;</span></span><br><span class="line"><span class="regexp">    );</span></span><br><span class="line"><span class="regexp">  &#125;</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">function Content() &#123;</span></span><br><span class="line"><span class="regexp">  return (</span></span><br><span class="line"><span class="regexp">    &lt;div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;ThemeTogglerButton /</span>&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(&lt;App /</span>&gt;, <span class="built_in">document</span>.root);</span><br></pre></td></tr></table></figure>
<h4 id="Consuming-Multiple-Contexts"><a href="#Consuming-Multiple-Contexts" class="headerlink" title="Consuming Multiple Contexts"></a><a name="consuming-multiple-contexts">Consuming Multiple Contexts</a></h4><p>To keep context re-rendering fast, React needs to make each context consumer a separate node in the tree.</p>
<p>为了保证context重新渲染的速度更快，React需要让每个context使用者在react组件树中都作为一个独立的子节点。</p>
<figure class="highlight haskell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><span class="line">// <span class="type">Theme</span> context, <span class="keyword">default</span> to light theme</span><br><span class="line"><span class="title">const</span> <span class="type">ThemeContext</span> = <span class="type">React</span>.createContext('light');</span><br><span class="line"></span><br><span class="line">// <span class="type">Signed</span>-<span class="keyword">in</span> user context</span><br><span class="line"><span class="title">const</span> <span class="type">UserContext</span> = <span class="type">React</span>.createContext(&#123;</span><br><span class="line">  name: '<span class="type">Guest'</span>,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="type">App</span> extends <span class="type">React</span>.<span class="type">Component</span> &#123;</span></span><br><span class="line"><span class="class">  render() &#123;</span></span><br><span class="line"><span class="class">    const &#123;signedInUser, theme&#125; = this.props;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">    // <span class="type">App</span> component that provides initial context values</span></span><br><span class="line"><span class="class">    return (</span></span><br><span class="line"><span class="class">      &lt;<span class="type">ThemeContext</span>.<span class="type">Provider</span> <span class="title">value</span>=&#123;<span class="title">theme</span>&#125;&gt;</span></span><br><span class="line"><span class="class">        &lt;<span class="type">UserContext</span>.<span class="type">Provider</span> <span class="title">value</span>=&#123;<span class="title">signedInUser</span>&#125;&gt;</span></span><br><span class="line"><span class="class">          &lt;<span class="type">Layout</span> /&gt;</span></span><br><span class="line"><span class="class">        &lt;/<span class="type">UserContext</span>.<span class="type">Provider</span>&gt;</span></span><br><span class="line"><span class="class">      &lt;/<span class="type">ThemeContext</span>.<span class="type">Provider</span>&gt;</span></span><br><span class="line"><span class="class">    );</span></span><br><span class="line"><span class="class">  &#125;</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">function <span class="type">Layout</span>() &#123;</span></span><br><span class="line"><span class="class">  return (</span></span><br><span class="line"><span class="class">    &lt;<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">      &lt;<span class="type">Sidebar</span> /&gt;</span></span><br><span class="line"><span class="class">      &lt;<span class="type">Content</span> /&gt;</span></span><br><span class="line"><span class="class">    &lt;/<span class="title">div</span>&gt;</span></span><br><span class="line"><span class="class">  );</span></span><br><span class="line"><span class="class">&#125;</span></span><br><span class="line"><span class="class"></span></span><br><span class="line"><span class="class">// <span class="type">A</span> component may consume multiple contexts</span></span><br><span class="line"><span class="class">function <span class="type">Content</span>() &#123;</span></span><br><span class="line"><span class="class">  return (</span></span><br><span class="line"><span class="class">    &lt;<span class="type">ThemeContext</span>.<span class="type">Consumer</span>&gt;</span></span><br><span class="line"><span class="class">      &#123;<span class="title">theme</span> =&gt; (</span></span><br><span class="line"><span class="class">        &lt;<span class="type">UserContext</span>.<span class="type">Consumer</span>&gt;</span></span><br><span class="line"><span class="class">          &#123;<span class="title">user</span> =&gt; (</span></span><br><span class="line"><span class="class">            &lt;<span class="type">ProfilePage</span> <span class="title">user</span>=&#123;<span class="title">user</span>&#125; <span class="title">theme</span>=&#123;<span class="title">theme</span>&#125; /&gt;</span></span><br><span class="line"><span class="class">          )&#125;</span></span><br><span class="line"><span class="class">        &lt;/<span class="type">UserContext</span>.<span class="type">Consumer</span>&gt;</span></span><br><span class="line"><span class="class">      )&#125;</span></span><br><span class="line"><span class="class">    &lt;/<span class="type">ThemeContext</span>.<span class="type">Consumer</span>&gt;</span></span><br><span class="line"><span class="class">  );</span></span><br><span class="line"><span class="class">&#125;</span></span><br></pre></td></tr></table></figure>
<p>If two or more context values are often used together, you might want to consider creating your own render prop component that provides both.</p>
<p>如果两个或更多的context值经常一起使用，您可能需要考虑创建您自己的渲染参数的组件来一起提供它们。</p>
<h4 id="Accessing-Context-in-Lifecycle-Methods"><a href="#Accessing-Context-in-Lifecycle-Methods" class="headerlink" title="Accessing Context in Lifecycle Methods"></a><a name="accessing-context-in-lifecycle-methods">Accessing Context in Lifecycle Methods</a></h4><p>Accessing values from context in lifecycle methods is a relatively common use case. Instead of adding context to every lifecycle method, you just need to pass it as a prop, and then work with it just like you’d normally work with a prop.</p>
<p>在生命周期方法中从context访问值是一种相对常见的用例。您只需要将其作为prop传递，而不是向每个生命周期方法添加context，然后使用它就像您通常使用prop一样。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Button</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="comment">// ThemeContext value is this.props.theme</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate(prevProps, prevState) &#123;</span><br><span class="line">    <span class="comment">// Previous ThemeContext value is prevProps.theme</span></span><br><span class="line">    <span class="comment">// New ThemeContext value is this.props.theme</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    const &#123;theme, children&#125; = <span class="keyword">this</span>.props;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button className=&#123;theme ? <span class="symbol">'dar</span>k' : <span class="symbol">'ligh</span>t'&#125;&gt;</span><br><span class="line">        &#123;children&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">export <span class="keyword">default</span> props =&gt; (</span><br><span class="line">  &lt;<span class="type">ThemeContext</span>.<span class="type">Consumer</span>&gt;</span><br><span class="line">    &#123;theme =&gt; &lt;<span class="type">Button</span> &#123;...props&#125; theme=&#123;theme&#125; /&gt;&#125;</span><br><span class="line">  &lt;/<span class="type">ThemeContext</span>.<span class="type">Consumer</span>&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h4 id="Consuming-Context-with-a-HOC"><a href="#Consuming-Context-with-a-HOC" class="headerlink" title="Consuming Context with a HOC"></a><a name="consuming-context-with-a-hoc">Consuming Context with a HOC</a></h4><p>Some types of contexts are consumed by many components (e.g. theme or localization). It can be tedious to explicitly wrap each dependency with a <code>&lt;Context.Consumer&gt;</code> element. A <a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">higher-order component</a> can help with this.</p>
<p>一些类型的context会被许多组件（例如主题或本地化）使用。使用<code>&lt;Context.Consumer&gt;</code>元素显式地包装每个依赖项可能会很繁琐。这时候<a href="https://reactjs.org/docs/higher-order-components.html" target="_blank" rel="noopener">更高阶的组件</a>可以帮助解决这个问题。</p>
<p>For example, a button component might consume a theme context like so:</p>
<p>例如，一个button组件可能会这样使用主题context：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ThemedButton</span><span class="params">(props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;ThemeContext.Consumer&gt;</span><br><span class="line">      &#123;theme =&gt; &lt;button className=&#123;theme&#125; &#123;...props&#125; /&gt;&#125;</span><br><span class="line">    &lt;/ThemeContext.Consumer&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>That’s alright for a few components, but what if we wanted to use the theme context in a lot of places?</p>
<p>这对于几个组件来说是够用了，但是如果我们想在许多地方用主题的context呢？</p>
<p>We could create a higher-order component called <code>withTheme</code>:</p>
<p>我们可以创建一个更高级别的组件，叫做<code>withTheme</code>：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> ThemeContext = React.createContext(<span class="string">'light'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// This function takes a component...</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">withTheme</span>(<span class="params">Component</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...and returns another component...</span></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">ThemedComponent</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">    <span class="comment">// ... and renders the wrapped component with the context theme!</span></span><br><span class="line">    <span class="comment">// Notice that we pass through any additional props as well</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;ThemeContext.Consumer&gt;</span><br><span class="line">        &#123;theme =&gt; <span class="xml"><span class="tag">&lt;<span class="name">Component</span> &#123;<span class="attr">...props</span>&#125; <span class="attr">theme</span>=<span class="string">&#123;theme&#125;</span> /&gt;</span>&#125;</span></span><br><span class="line"><span class="xml">      <span class="tag">&lt;/<span class="name">ThemeContext.Consumer</span>&gt;</span></span></span><br><span class="line"><span class="xml">    );</span></span><br><span class="line"><span class="xml">  &#125;;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Now any component that depends on the theme context can easily subscribe to it using the <code>withTheme</code> function we’ve created:</p>
<p>现在任何依赖于主题context的组件都通过我们创建的<code>withTheme</code>函数可以轻松的使用它。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Button</span><span class="params">(&#123;theme, <span class="rest_arg">...rest</span>&#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &lt;button className=&#123;theme&#125; &#123;...rest&#125; /&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> ThemedButton = withTheme(Button);</span><br></pre></td></tr></table></figure>
<h4 id="Forwarding-Refs-to-Context-Consumers"><a href="#Forwarding-Refs-to-Context-Consumers" class="headerlink" title="Forwarding Refs to Context Consumers"></a><a name="forwarding-refs-to-context-consumers">Forwarding Refs to Context Consumers</a></h4><p>One issue with the render prop API is that refs don’t automatically get passed to wrapped elements. To get around this, use <code>React.forwardRef</code>:</p>
<p>render prop API的一个问题是refs不会自动传递给子元素。要解决此问题，请使用<code>React.forwardRef</code>：</p>
<h5 id="fancy-button-js"><a href="#fancy-button-js" class="headerlink" title="fancy-button.js"></a>fancy-button.js</h5><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">FancyButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  focus() &#123;</span><br><span class="line">    <span class="comment">// ...</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Use context to pass the current "theme" to FancyButton.</span></span><br><span class="line"><span class="comment">// Use forwardRef to pass refs to FancyButton as well.</span></span><br><span class="line">export <span class="keyword">default</span> <span class="type">React</span>.forwardRef((props, ref) =&gt; (</span><br><span class="line">  &lt;<span class="type">ThemeContext</span>.<span class="type">Consumer</span>&gt;</span><br><span class="line">    &#123;theme =&gt; (</span><br><span class="line">      &lt;<span class="type">FancyButton</span> &#123;...props&#125; theme=&#123;theme&#125; ref=&#123;ref&#125; /&gt;</span><br><span class="line">    )&#125;</span><br><span class="line">  &lt;/<span class="type">ThemeContext</span>.<span class="type">Consumer</span>&gt;</span><br><span class="line">));</span><br></pre></td></tr></table></figure>
<h5 id="app-js-2"><a href="#app-js-2" class="headerlink" title="app.js"></a>app.js</h5><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">import FancyButton <span class="keyword">from</span> <span class="string">'./fancy-button'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> <span class="keyword">ref</span> = React.createRef();</span><br><span class="line"></span><br><span class="line"><span class="comment">// Our ref will point to the FancyButton component,</span></span><br><span class="line"><span class="comment">// And not the ThemeContext.Consumer that wraps it.</span></span><br><span class="line"><span class="comment">// This means we can call FancyButton methods like ref.current.focus()</span></span><br><span class="line">&lt;FancyButton <span class="keyword">ref</span>=&#123;<span class="keyword">ref</span>&#125; onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">  Click me!</span><br><span class="line">&lt;/FancyButton&gt;;</span><br></pre></td></tr></table></figure>
<h3 id="Caveats"><a href="#Caveats" class="headerlink" title="Caveats"></a><a name="caveats">Caveats</a></h3><p>Because context uses reference identity to determine when to re-render, there are some gotchas that could trigger unintentional renders in consumers when a provider’s parent re-renders. For example, the code below will re-render all consumers every time the Provider re-renders because a new object is always created for <code>value</code>:</p>
<p>因为上下文使用引用参考标识符来确定何时重新渲染，所以当Provider的父级重新渲染时，使用者可能会触发一些无意的渲染。例如，下面的代码将在每次Provider重新渲染时重新呈现所有使用者，因为始终会为<code>value</code>创建新对象：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;<span class="type">Provider</span> value=&#123;&#123;something: <span class="symbol">'somethin</span>g'&#125;&#125;&gt;</span><br><span class="line">        &lt;<span class="type">Toolbar</span> /&gt;</span><br><span class="line">      &lt;/<span class="type">Provider</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>To get around this, lift the value into the parent’s state:</p>
<p>为了解决此问题，将value放在父组件的state中：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">App</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;</span><br><span class="line">      value: &#123;something: <span class="symbol">'somethin</span>g'&#125;,</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;<span class="type">Provider</span> value=&#123;<span class="keyword">this</span>.state.value&#125;&gt;</span><br><span class="line">        &lt;<span class="type">Toolbar</span> /&gt;</span><br><span class="line">      &lt;/<span class="type">Provider</span>&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>###<a name="legacy-api">Legacy API</a></p>
<blockquote>
<p>Note<br>React previously shipped with an experimental context API. The old API will be supported in all 16.x releases, but applications using it should migrate to the new version. The legacy API will be removed in a future major React version. Read the <a href="https://reactjs.org/docs/legacy-context.html" target="_blank" rel="noopener">legacy context docs here</a>.</p>
<p>注意：<br>之前版本的React附带有实验context的API。所有16.x版本都支持旧的API，但应用程序应当使用新版本的API。 遗留API将在未来的主版本的React中删除。您可以在[此处阅读旧版<a href="https://reactjs.org/docs/legacy-context.html" target="_blank" rel="noopener">context文档</a>。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[03.Advanced Guides -- 02.Code-Splitting]]></title>
      <url>/2018/06/30/react/03.Advanced_Guides/02.Code_Spliting/</url>
      <content type="html"><![CDATA[<h2 id="Code-Splitting-代码拆分"><a href="#Code-Splitting-代码拆分" class="headerlink" title="Code-Splitting(代码拆分)"></a>Code-Splitting(代码拆分)</h2><h3 id="Bundling-打包"><a href="#Bundling-打包" class="headerlink" title="Bundling(打包)"></a>Bundling(打包)</h3><p>Most React apps will have their files “bundled” using tools like <a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a> or <a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>. Bundling is the process of following imported files and merging them into a single file: a “bundle”. This bundle can then be included on a webpage to load an entire app at once.</p>
<p>大多数React应用程序都有它们自己的“打包”工具，例如<a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a> 或者<a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>。打包是指跟踪导入的文件并将它们合并到单个文件–“bundle”中的过程。然后，可以将打包后的文件加载到网页上，以立即加载整个应用。</p>
<blockquote>
<p>Example(举例)</p>
</blockquote>
<h4 id="App"><a href="#App" class="headerlink" title="App:"></a>App:</h4><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// app.js</span></span><br><span class="line"><span class="keyword">import</span> &#123; add &#125; <span class="keyword">from</span> <span class="string">'./math.js'</span>;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(add(<span class="number">16</span>, <span class="number">26</span>)); <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// math.js</span></span><br><span class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Bundle"><a href="#Bundle" class="headerlink" title="Bundle:"></a>Bundle:</h4><figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(a, b)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  return a + b;</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">console</span>.<span class="title">log</span><span class="params">(<span class="keyword">add</span>(16, 26)</span>);</span> <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note(注意):<br>Your bundles will end up looking a lot different than this.<br>您打包后的文件可能跟上述代码有所不同。</p>
</blockquote>
<p>If you’re using <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>, <a href="https://github.com/zeit/next.js/" target="_blank" rel="noopener">Next.js</a>, <a href="https://www.gatsbyjs.org/" target="_blank" rel="noopener">Gatsby</a>, or a similar tool, you will have a Webpack setup out of the box to bundle your app.</p>
<p>如果您正在使用<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>, <a href="https://github.com/zeit/next.js/" target="_blank" rel="noopener">Next.js</a>, <a href="https://www.gatsbyjs.org/" target="_blank" rel="noopener">Gatsby</a>或者其他相似的工具，您可以使用开箱即用的Webpack设置来捆绑您的应用。</p>
<p>If you aren’t, you’ll need to setup bundling yourself. For example, see the <a href="https://webpack.js.org/guides/installation/" target="_blank" rel="noopener">Installation</a> and <a href="https://webpack.js.org/guides/getting-started/" target="_blank" rel="noopener">Getting Started</a> guides on the Webpack docs.</p>
<p>如果您不是什么样的上述工具，您就得自己安装打包工具了。例如，请看webpack文档的<a href="https://webpack.js.org/guides/installation/" target="_blank" rel="noopener">安装</a>和<a href="https://webpack.js.org/guides/getting-started/" target="_blank" rel="noopener">开始</a>目录。</p>
<h3 id="Code-Splitting-代码拆分-1"><a href="#Code-Splitting-代码拆分-1" class="headerlink" title="Code Splitting(代码拆分)"></a>Code Splitting(代码拆分)</h3><p>Bundling is great, but as your app grows, your bundle will grow too. Especially if you are including large third-party libraries. You need to keep an eye on the code you are including in your bundle so that you don’t accidentally make it so large that your app takes a long time to load.</p>
<p>打包工具虽然很棒，但随着您的应用程序的扩展，您捆绑的包也会随之增长。特别是如果您包含第三方大型的库。您需要密切关注打完的包中的代码，这样您就不会将其编写的过大，以至于您的应用需要很长时间才能加载完成。</p>
<p>To avoid winding up with a large bundle, it’s good to get ahead of the problem and start “splitting” your bundle. <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">Code-Splitting</a> is a feature supported by bundlers like Webpack and Browserify (via <a href="https://github.com/browserify/factor-bundle" target="_blank" rel="noopener">factor-bundle</a>) which can create multiple bundles that can be dynamically loaded at runtime.</p>
<p>为了避免大量捆绑的发生，最好从最开始就解决问题，并开始“拆分”打过的包。<a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">Code-Splitting</a>是Webpack和Browserify等打包软件支持的一项功能，（通过<a href="https://github.com/browserify/factor-bundle" target="_blank" rel="noopener">factor-bundle</a>）可以创建多个可在运行时动态加载的bundle。</p>
<p>Code-splitting your app can help you “lazy-load” just the things that are currently needed by the user, which can dramatically improve the performance of your app. While you haven’t reduced the overall amount of code in your app, you’ve avoided loading code that the user may never need, and reduced the amount of code needed during the initial load.</p>
<p>拆分您应用程序的代码可以帮助您在当前用户需要的时候实现“懒加载”，这样可以提高您应用程序的性能。当您没有减少您应用程序整体代码量的时候，您可以避免加载用户可能从来不需要的代码，并且减少在初次加载时的代码量。</p>
<h3 id="import"><a href="#import" class="headerlink" title="import()"></a>import()</h3><p>The best way to introduce code-splitting into your app is through the dynamic <code>import()</code> syntax.</p>
<p>在您的应用程序中介绍分隔代码最好的方式就是动态的使用<code>import()</code>语法。</p>
<blockquote>
<p>Before(之前):</p>
</blockquote>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">import &#123; <span class="keyword">add</span><span class="bash"> &#125; from <span class="string">'./math'</span>;</span></span><br><span class="line"><span class="bash"></span></span><br><span class="line"><span class="bash">console.log(add(16, 26));</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>After(之后):</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span>(<span class="string">"./math"</span>).then(<span class="function"><span class="params">math</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(math.add(<span class="number">16</span>, <span class="number">26</span>));</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>Note(注意):<br>The dynamic <code>import()</code> syntax is a ECMAScript (JavaScript) proposal not currently part of the language standard. It is expected to be accepted in the near future.<br>动态的<code>import()</code>语法只是ECMAScript (JavaScript)的一个建议，并非语法标准。它也许会在以后的版本中被接受。</p>
</blockquote>
<p>When Webpack comes across this syntax, it automatically starts code-splitting your app. If you’re using Create React App, this is already configured for you and you can <a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#code-splitting" target="_blank" rel="noopener">start using it</a> immediately. It’s also supported out of the box in <a href="https://github.com/zeit/next.js/#dynamic-import" target="_blank" rel="noopener">Next.js</a>.</p>
<p>当Webpack遇到这种语法时，它会自动启动拆分代码的部分来拆分您的应用程序。如果您正在使用Create React App，那么您已经配置好了这个并可以<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#code-splitting" target="_blank" rel="noopener">立即开始使用它</a>。在<a href="https://github.com/zeit/next.js/#dynamic-import" target="_blank" rel="noopener">Next.js</a>中也支持开箱即用。</p>
<p>If you’re setting up Webpack yourself, you’ll probably want to read Webpack’s <a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">guide on code splitting</a>. Your Webpack config should look vaguely <a href="https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269" target="_blank" rel="noopener">like this</a>.</p>
<p>如何您自己正在设置Webpack，您可能需要阅读Webpack的<a href="https://webpack.js.org/guides/code-splitting/" target="_blank" rel="noopener">拆分代码指南</a>。您的Webpack配置大体看上去应该<a href="https://gist.github.com/gaearon/ca6e803f5c604d37468b0091d9959269" target="_blank" rel="noopener">像这样</a>。</p>
<p>When using <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>, you’ll need to make sure that Babel can parse the dynamic import syntax but is not transforming it. For that you will need <a href="https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import" target="_blank" rel="noopener">babel-plugin-syntax-dynamic-import</a>.</p>
<p>当使用<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>，您需要确保Babel能够解析动态导入的语法，但不会对其进行转换。为此，您需要使用<a href="https://yarnpkg.com/en/package/babel-plugin-syntax-dynamic-import" target="_blank" rel="noopener">babel-plugin-syntax-dynamic-import</a>。</p>
<h3 id="Libraries-库"><a href="#Libraries-库" class="headerlink" title="Libraries(库)"></a>Libraries(库)</h3><h4 id="ReactLoadable-React的可加载性"><a href="#ReactLoadable-React的可加载性" class="headerlink" title="ReactLoadable(React的可加载性)"></a>ReactLoadable(React的可加载性)</h4><p><a href="https://github.com/thejameskyle/react-loadable" target="_blank" rel="noopener">React Loadable</a> wraps dynamic imports in a nice, React-friendly API for introducing code splitting into your app at a given component.</p>
<p><a href="https://github.com/thejameskyle/react-loadable" target="_blank" rel="noopener">React Loadable</a>包装在一个良好的，对React友好的API中，这个API用于拆分的代码引入到给定组件的应用程序中。</p>
<blockquote>
<p>Before(之前):</p>
</blockquote>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> OtherComponent <span class="keyword">from</span> <span class="string">'./OtherComponent'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;OtherComponent/&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<blockquote>
<p>After:</p>
</blockquote>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">'react-loadable'</span>;</span><br><span class="line"></span><br><span class="line">const LoadableOtherComponent = Loadable(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./OtherComponent'</span>),</span><br><span class="line">  loading: <span class="function"><span class="params">()</span> =&gt;</span> &lt;div&gt;Loading...&lt;/div&gt;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const MyComponent = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;LoadableOtherComponent/&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>React Loadable helps you create <a href="https://github.com/thejameskyle/react-loadable#creating-a-great-loading-component" target="_blank" rel="noopener">loading states</a>, <a href="https://github.com/thejameskyle/react-loadable#loading-error-states" target="_blank" rel="noopener">error states</a>, <a href="https://github.com/thejameskyle/react-loadable#timing-out-when-the-loader-is-taking-too-long" target="_blank" rel="noopener">timeouts</a>, <a href="https://github.com/thejameskyle/react-loadable#preloading" target="_blank" rel="noopener">preloading</a>, and more. It can even help you <a href="https://github.com/thejameskyle/react-loadable#------------server-side-rendering" target="_blank" rel="noopener">server-side render</a> an app with lots of code-splitting.</p>
<p>React Loadable可帮助您创建<a href="https://github.com/thejameskyle/react-loadable#creating-a-great-loading-component" target="_blank" rel="noopener">加载状态</a>，<a href="https://github.com/thejameskyle/react-loadable#loading-error-states" target="_blank" rel="noopener">错误状态</a>，<a href="https://github.com/thejameskyle/react-loadable#timing-out-when-the-loader-is-taking-too-long" target="_blank" rel="noopener">超时</a>，<a href="https://github.com/thejameskyle/react-loadable#preloading" target="_blank" rel="noopener">预加载</a>等。 它甚至可以帮助您在<a href="https://github.com/thejameskyle/react-loadable#------------server-side-rendering" target="_blank" rel="noopener">服务器端渲染</a>具有大量代码拆分的应用程序。</p>
<h3 id="Route-based-code-splitting-基于路由的代码拆分"><a href="#Route-based-code-splitting-基于路由的代码拆分" class="headerlink" title="Route-based code splitting(基于路由的代码拆分)"></a>Route-based code splitting(基于路由的代码拆分)</h3><p>Deciding where in your app to introduce code splitting can be a bit tricky. You want to make sure you choose places that will split bundles evenly, but won’t disrupt the user experience.</p>
<p>在你的应用中选择哪里引入代码拆分的位置可能有点棘手。引入代码拆分的位置要确保位于拆分合理的地方，并且不会破坏用户体验。</p>
<p>A good place to start is with routes. Most people on the web are used to page transitions taking some amount of time to load. You also tend to be re-rendering the entire page at once so your users are unlikely to be interacting with other elements on the page at the same time.</p>
<p>引用代码拆分的一个好的位置是路由。大多数人在网页上都习惯于页面切换，这需要花费一些时间来加载。您还可以重新渲染整个页面，这样您的用户就不可能同时与页面上的其他元素进行交互。</p>
<p>Here’s an example of how to setup route-based code splitting into your app using libraries like <a href="https://reacttraining.com/react-router/" target="_blank" rel="noopener">React Router</a> and <a href="https://github.com/thejameskyle/react-loadable" target="_blank" rel="noopener">React Loadable</a>.</p>
<p>以下是如何使用<a href="https://reacttraining.com/react-router/" target="_blank" rel="noopener">React Router</a>和<a href="https://github.com/thejameskyle/react-loadable" target="_blank" rel="noopener">React Loadable</a>等库将基于路由的代码拆分到应用程序的示例。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; BrowserRouter <span class="keyword">as</span> Router, Route, Switch &#125; <span class="keyword">from</span> <span class="string">'react-router-dom'</span>;</span><br><span class="line"><span class="keyword">import</span> Loadable <span class="keyword">from</span> <span class="string">'react-loadable'</span>;</span><br><span class="line"></span><br><span class="line">const Loading = <span class="function"><span class="params">()</span> =&gt;</span> &lt;div&gt;Loading...&lt;/div&gt;;</span><br><span class="line"></span><br><span class="line">const Home = Loadable(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./routes/Home'</span>),</span><br><span class="line">  loading: Loading,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const About = Loadable(&#123;</span><br><span class="line">  loader: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">import</span>(<span class="string">'./routes/About'</span>),</span><br><span class="line">  loading: Loading,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">const App = <span class="function"><span class="params">()</span> =&gt;</span> (</span><br><span class="line">  &lt;Router&gt;</span><br><span class="line">    &lt;Switch&gt;</span><br><span class="line">      &lt;Route exact path=<span class="string">"/"</span> component=&#123;Home&#125;/&gt;</span><br><span class="line">      &lt;Route path=<span class="string">"/about"</span> component=&#123;About&#125;/&gt;</span><br><span class="line">    &lt;/Switch&gt;</span><br><span class="line">  &lt;/Router&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[03.Advanced Guides -- 01.Accessibility]]></title>
      <url>/2018/06/29/react/03.Advanced_Guides/01.Accessibility/</url>
      <content type="html"><![CDATA[<h2 id="Accessibility-可访问性"><a href="#Accessibility-可访问性" class="headerlink" title="Accessibility(可访问性)"></a>Accessibility(可访问性)</h2><h3 id="Why-Accessibility-为什么要考虑可访问性？"><a href="#Why-Accessibility-为什么要考虑可访问性？" class="headerlink" title="Why Accessibility?(为什么要考虑可访问性？)"></a>Why Accessibility?(为什么要考虑可访问性？)</h3><p>Web accessibility (also referred to as <a href="https://en.wiktionary.org/wiki/a11y" target="_blank" rel="noopener">a11y</a>) is the design and creation of websites that can be used by everyone. Accessibility support is necessary to allow assistive technology to interpret web pages.</p>
<p>Web可访问性（也称为<a href="https://en.wiktionary.org/wiki/a11y" target="_blank" rel="noopener">a11y</a>）是指如何设计和创建可供任何人都可以使用的网站。可访问性的支持是必须的，因为它们可以才协助辅助性技术渲染网页。</p>
<p>React fully supports building accessible websites, often by using standard HTML techniques.</p>
<p>React可以通过使用标准的HTML技术来完全支持构建可访问性的网站。</p>
<h3 id="Standards-and-Guidelines（标准和指南）"><a href="#Standards-and-Guidelines（标准和指南）" class="headerlink" title="Standards and Guidelines（标准和指南）"></a>Standards and Guidelines（标准和指南）</h3><h4 id="WCAG"><a href="#WCAG" class="headerlink" title="WCAG"></a>WCAG</h4><p>The <a href="https://www.w3.org/WAI/intro/wcag" target="_blank" rel="noopener">Web Content Accessibility Guidelines</a> provides guidelines for creating accessible web sites.</p>
<p><a href="https://www.w3.org/WAI/intro/wcag" target="_blank" rel="noopener">网站内容可访问性指南</a>为创建可访问网站的提供了指导指南。</p>
<p>The following WCAG checklists provide an overview:</p>
<p>以下为WCAG清单提供了一个概述：</p>
<ul>
<li><a href="https://www.wuhcag.com/wcag-checklist/" target="_blank" rel="noopener">WCAG checklist from Wuhcag</a></li>
<li><a href="http://webaim.org/standards/wcag/checklist" target="_blank" rel="noopener">WCAG checklist from WebAIM</a></li>
<li><p><a href="http://a11yproject.com/checklist.html" target="_blank" rel="noopener">Checklist from The A11Y Project</a></p>
</li>
<li><p><a href="https://www.wuhcag.com/wcag-checklist/" target="_blank" rel="noopener">关于WCAG的Wuhcag概述</a></p>
</li>
<li><a href="http://webaim.org/standards/wcag/checklist" target="_blank" rel="noopener">关于WCAG的WebAIM概述</a></li>
<li><a href="http://a11yproject.com/checklist.html" target="_blank" rel="noopener">来自A11Y项目的概述</a></li>
</ul>
<h4 id="WAI-ARIA"><a href="#WAI-ARIA" class="headerlink" title="WAI-ARIA"></a>WAI-ARIA</h4><p>The <a href="https://www.w3.org/WAI/intro/aria" target="_blank" rel="noopener">Web Accessibility Initiative - Accessible Rich Internet Applications</a> document contains techniques for building fully accessible JavaScript widgets.</p>
<p><a href="https://www.w3.org/WAI/intro/aria" target="_blank" rel="noopener">网页可访问性倡议 - 充分可访问性的互联网应用程序</a>文章中包含了对于构建充分可访问的JavaScript部件的技术。</p>
<p>Note that all <code>aria-*</code> HTML attributes are fully supported in JSX. Whereas most DOM properties and attributes in React are camelCased, these attributes should be lowercased:</p>
<p>注意，JSX完全支持所有<code>aria- *</code> HTML属性。尽管React中的大多数DOM属性和特性都是camelCased的，但<code>aria-*</code>属性应该是小写的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&lt;input</span><br><span class="line">  type=<span class="string">"text"</span></span><br><span class="line">  aria-label=&#123;labelText&#125;</span><br><span class="line">  aria-required=<span class="string">"true"</span></span><br><span class="line">  onChange=&#123;onchangeHandler&#125;</span><br><span class="line">  value=&#123;inputValue&#125;</span><br><span class="line">  name=<span class="string">"name"</span></span><br><span class="line">/&gt;</span><br></pre></td></tr></table></figure>
<h3 id="Semantic-HTML-语义化的HTML"><a href="#Semantic-HTML-语义化的HTML" class="headerlink" title="Semantic HTML(语义化的HTML)"></a>Semantic HTML(语义化的HTML)</h3><p>Semantic HTML is the foundation of accessibility in a web application. Using the various HTML elements to reinforce the meaning of information in our websites will often give us accessibility for free.</p>
<p>语义化的HTML是一个web应用可访问性的基础。我们可以通过在网站中使用不同的HTML元素来加强想表达的信息的含义，这可以让我们的应用更具有可访问性。</p>
<ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/HTML/Element" target="_blank" rel="noopener">MDN HTML elements reference(MDN HTML元素的参阅)</a></li>
</ul>
<p>Sometimes we break HTML semantics when we add <div> elements to our JSX to make our React code work, especially when working with lists (<ol>, <ul> and <dl>) and the HTML <table>. In these cases we should rather use React Fragments to group together multiple elements.</table></dl></ul></ol></div></p>
<p>有时，当我们将<code>&lt;div&gt;</code>元素添加到JSX中以使我们的React代码工作时，我们会破坏HTML语义，尤其是在使用列表（<code>&lt;ol&gt;</code>，<code>&lt;ul&gt;</code>和<code>&lt;dl&gt;</code>）和HTML <code>&lt;table&gt;</code>时。 在这些情况下，我们应该使用React Fragments将多个元素组合在一起。</p>
<p>Use <code>&lt;Fragment&gt;</code> when a key prop is required:</p>
<p>在key的属性是必须时使用<code>&lt;Fragment&gt;</code></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React, &#123; Fragment &#125; <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Glossary</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;dl&gt;</span><br><span class="line">      &#123;props.items.map(<span class="function"><span class="params">item</span> =&gt;</span> (</span><br><span class="line">        <span class="comment">// Without the `key`, React will fire a key warning</span></span><br><span class="line">        &lt;Fragment key=&#123;item.id&#125;&gt;</span><br><span class="line">          &lt;dt&gt;&#123;item.term&#125;&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">          &lt;dd&gt;&#123;item.description&#125;&lt;/</span>dd&gt;</span><br><span class="line">        &lt;<span class="regexp">/Fragment&gt;</span></span><br><span class="line"><span class="regexp">      ))&#125;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>dl&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Use <code>&lt;&gt;&lt;/&gt;</code> syntax everywhere else:</p>
<p>在任何地方使用<code>&lt;&gt;&lt;/&gt;</code>语法</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ListItem</span>(<span class="params">&#123; item &#125;</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;&gt;</span><br><span class="line">      &lt;dt&gt;&#123;item.term&#125;&lt;<span class="regexp">/dt&gt;</span></span><br><span class="line"><span class="regexp">      &lt;dd&gt;&#123;item.description&#125;&lt;/</span>dd&gt;</span><br><span class="line">    &lt;<span class="regexp">/&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<blockquote>
<p>即为了不破坏HTML结构的完整性和统一性，可以将React Fragment或者<code>&lt;&gt;&lt;/&gt;</code>添加到React组件返回的内容上以此来保持返回元素的可访问性。</p>
</blockquote>
<h3 id="Accessible-Forms-可访问性的表单"><a href="#Accessible-Forms-可访问性的表单" class="headerlink" title="Accessible Forms(可访问性的表单)"></a>Accessible Forms(可访问性的表单)</h3><h4 id="Labeling-标签"><a href="#Labeling-标签" class="headerlink" title="Labeling(标签)"></a>Labeling(标签)</h4><p>Every HTML form control, such as <code>&lt;input&gt;</code> and <code>&lt;textarea&gt;</code>, needs to be labeled accessibly. We need to provide descriptive labels that are also exposed to screen readers.</p>
<p>每个HTML表单中的控制元件，例如<code>&lt;input&gt;</code>和<code>&lt;textarea&gt;</code>都需要有可访问性的标签。我们也需要也向屏幕阅读器提供公开的描述性标签。</p>
<p>The following resources show us how to do this:</p>
<p>下列资源告诉我们如何做到这些：</p>
<ul>
<li><a href="https://www.w3.org/WAI/tutorials/forms/labels/" target="_blank" rel="noopener">The W3C shows us how to label elements</a></li>
<li><a href="http://webaim.org/techniques/forms/controls" target="_blank" rel="noopener">WebAIM shows us how to label elements</a></li>
<li><p><a href="https://www.paciellogroup.com/blog/2017/04/what-is-an-accessible-name/" target="_blank" rel="noopener">The Paciello Group explains accessible names</a></p>
</li>
<li><p><a href="https://www.w3.org/WAI/tutorials/forms/labels/" target="_blank" rel="noopener">W3C 告诉我们如何标记元素</a></p>
</li>
<li><a href="http://webaim.org/techniques/forms/controls" target="_blank" rel="noopener">WebAIM告诉我们如何标记元素</a></li>
<li><a href="https://www.paciellogroup.com/blog/2017/04/what-is-an-accessible-name/" target="_blank" rel="noopener">Paciello项目组介绍了如何让名称具有可访问性</a></li>
</ul>
<p>Although these standard HTML practices can be directly used in React, note that the <code>for</code> attribute is written as <code>htmlFor</code> in JSX:</p>
<p>尽管这些标准的HTML元素可以直接在React中使用，但还要注意<code>for</code>属性在JSX中应当写成’htmlFor’:</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;label <span class="attribute">htmlFor</span>=<span class="string">"namedInput"</span>&gt;Name:&lt;/label&gt;</span><br><span class="line">&lt;input <span class="attribute">id</span>=<span class="string">"namedInput"</span> <span class="attribute">type</span>=<span class="string">"text"</span> <span class="attribute">name</span>=<span class="string">"name"</span>/&gt;</span><br></pre></td></tr></table></figure>
<h4 id="Notifying-the-user-of-errors-通知用户错误信息"><a href="#Notifying-the-user-of-errors-通知用户错误信息" class="headerlink" title="Notifying the user of errors(通知用户错误信息)"></a>Notifying the user of errors(通知用户错误信息)</h4><p>Error situations need to be understood by all users. The following link shows us how to expose error texts to screen readers as well:</p>
<p>所有用户都需要能够读懂错误信息。以下链接向我们展示了如何将错误文本展示给屏幕阅读器：</p>
<ul>
<li><a href="https://www.w3.org/WAI/tutorials/forms/notifications/" target="_blank" rel="noopener">The W3C demonstrates user notifications</a></li>
<li><a href="http://webaim.org/techniques/formvalidation/" target="_blank" rel="noopener">WebAIM looks at form validation</a></li>
<li><a href="https://www.w3.org/WAI/tutorials/forms/notifications/" target="_blank" rel="noopener">W3C演示用户通知示例</a></li>
<li><a href="http://webaim.org/techniques/formvalidation/" target="_blank" rel="noopener">WebAIM演示表单验证</a></li>
</ul>
<h3 id="Focus-Control-焦点控制"><a href="#Focus-Control-焦点控制" class="headerlink" title="Focus Control(焦点控制)"></a>Focus Control(焦点控制)</h3><p>Ensure that your web application can be fully operated with the keyboard only:</p>
<p>确保您的web应用只可以通过键盘进行操作：</p>
<ul>
<li><a href="http://webaim.org/techniques/keyboard/" target="_blank" rel="noopener">WebAIM talks about keyboard accessibility</a></li>
<li><a href="http://webaim.org/techniques/keyboard/" target="_blank" rel="noopener">WebAIM讨论键盘的可访问性</a></li>
</ul>
<h4 id="Keyboard-focus-and-focus-outline-键盘聚焦和轮廓聚焦"><a href="#Keyboard-focus-and-focus-outline-键盘聚焦和轮廓聚焦" class="headerlink" title="Keyboard focus and focus outline(键盘聚焦和轮廓聚焦)"></a>Keyboard focus and focus outline(键盘聚焦和轮廓聚焦)</h4><p>Keyboard focus refers to the current element in the DOM that is selected to accept input from the keyboard. We see it everywhere as a focus outline similar to that shown in the following image:</p>
<p>键盘聚焦是指选用DOM中的当前元素作为键盘中的输入。这种表现非常常见，与下图所示类似的焦点轮廓类似：</p>
<p><img src="/images/react_document/03-01-keyboard_focus_button.png" style="margin:0 auto;display:block"></p>
<p>Only ever use CSS that removes this outline, for example by setting <code>outline: 0</code>, if you are replacing it with another focus outline implementation.</p>
<p>只可以通过CSS来删除外边框，如果您用另一种聚焦外边框来替换它，可以通过设置<code>outline: 0</code>来实现。</p>
<h4 id="Mechanisms-to-skip-to-desired-content-跳转到期待的内容的机制"><a href="#Mechanisms-to-skip-to-desired-content-跳转到期待的内容的机制" class="headerlink" title="Mechanisms to skip to desired content(跳转到期待的内容的机制)"></a>Mechanisms to skip to desired content(跳转到期待的内容的机制)</h4><p>Provide a mechanism to allow users to skip past navigation sections in your application as this assists and speeds up keyboard navigation.</p>
<p>我们提供了一种机制，允许用户在您的应用中跳过导航部分，因为这有助于通过键盘导航。</p>
<p>Skiplinks or Skip Navigation Links are hidden navigation links that only become visible when keyboard users interact with the page. They are very easy to implement with internal page anchors and some styling:</p>
<p>跳转链接或跳转导航链接通常是隐藏的，只有当用户通过键盘与页面进行交互时才会显示。通过内部页面锚点和一些样式，我们非常容易实现这种功能：</p>
<ul>
<li><a href="http://webaim.org/techniques/skipnav/" target="_blank" rel="noopener">WebAIM - Skip Navigation Links</a></li>
<li><a href="http://webaim.org/techniques/skipnav/" target="_blank" rel="noopener">WebAIM - 跳转导航链接</a></li>
</ul>
<h4 id="Programmatically-managing-focus-用编程化的方式来管理焦点"><a href="#Programmatically-managing-focus-用编程化的方式来管理焦点" class="headerlink" title="Programmatically managing focus(用编程化的方式来管理焦点)"></a>Programmatically managing focus(用编程化的方式来管理焦点)</h4><p>Our React applications continuously modify the HTML DOM during runtime, sometimes leading to keyboard focus being lost or set to an unexpected element. In order to repair this, we need to programmatically nudge the keyboard focus in the right direction. For example, by resetting keyboard focus to a button that opened a modal window after that modal window is closed.</p>
<p>我们的React项目会在运行时持续的调整HTML节点，有时会导致键盘丢失焦点或设置到意想不到的元素上。为了修复这个问题，我们需要以正确的方向以编程方式来设置键盘焦点。例如，在一个模式窗口关闭后通过重置键盘焦点到一个按钮上来打开一个模式窗口。</p>
<p>MDN Web Docs takes a look at this and describes how we can build keyboard-navigable <a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets" target="_blank" rel="noopener">JavaScript widgets</a>.</p>
<p>MDN Web文档考虑到了这方面的问题并向我们介绍了如何搭建键盘导航的<a href="https://developer.mozilla.org/en-US/docs/Web/Accessibility/Keyboard-navigable_JavaScript_widgets" target="_blank" rel="noopener">JavaScript组件</a></p>
<p>To set focus in React, we can use <a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">Refs to DOM elements</a>.</p>
<p>为了设置React焦点，我们可以使用<a href="https://reactjs.org/docs/refs-and-the-dom.html" target="_blank" rel="noopener">DOM元素的Refs</a></p>
<p>Using this, we first create a ref to an element in the JSX of a component class:</p>
<p>为了介绍Refs，我们首先在组件类的JSX中创建一个元素的ref：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">CustomTextInput</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="comment">// Create a ref to store the textInput DOM element</span></span><br><span class="line">    <span class="keyword">this</span>.textInput = <span class="type">React</span>.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">  <span class="comment">// Use the `ref` callback to store a reference to the text input DOM</span></span><br><span class="line">  <span class="comment">// element in an instance field (for example, this.textInput).</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;input</span><br><span class="line">        <span class="class"><span class="keyword">type</span></span>=<span class="string">"text"</span></span><br><span class="line">        ref=&#123;<span class="keyword">this</span>.textInput&#125;</span><br><span class="line">      /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then we can focus it elsewhere in our component when needed:</p>
<p>然后当我们需要时，我们可以在组件的任何地方调用focus函数了：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">focus() &#123;</span><br><span class="line">  <span class="comment">// Explicitly focus the text input using the raw DOM API</span></span><br><span class="line">  <span class="comment">// Note: we're accessing "current" to get the DOM node</span></span><br><span class="line">  <span class="keyword">this</span>.textInput.current.focus();</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Sometimes a parent component needs to set focus to an element in a child component. We can do this by exposing <a href="https://reactjs.org/docs/refs-and-the-dom.html#exposing-dom-refs-to-parent-components" target="_blank" rel="noopener">DOM refs to parent components</a> through a special prop on the child component that forwards the parent’s ref to the child’s DOM node.</p>
<p>有些时候父组件需要将焦点设置在子组件的一个元素上。我们可以根据<a href="https://reactjs.org/docs/refs-and-the-dom.html#exposing-dom-refs-to-parent-components" target="_blank" rel="noopener">向父组件传递DOM refs</a>通过在子组件上设置一个特殊的属性,然后父组件通过ref指向子组件的DOM节点。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line">function <span class="type">CustomTextInput</span>(props) &#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;input ref=&#123;props.inputRef&#125; /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.inputElement = <span class="type">React</span>.createRef();</span><br><span class="line">  &#125;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;<span class="type">CustomTextInput</span> inputRef=&#123;<span class="keyword">this</span>.inputElement&#125; /&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">/&gt;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Now you can set focus when required.</span></span><br><span class="line"><span class="keyword">this</span>.inputElement.current.focus();</span><br></pre></td></tr></table></figure>
<p>When using a HOC to extend components, it is recommended to <a href="https://reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener">forward the ref</a> to the wrapped component using the <code>forwardRef</code> function of React. If a third party HOC does not implement ref forwarding, the above pattern can still be used as a fallback.</p>
<p>当使用HOC扩展组件时，建议使用React的<code>forwardRef</code>函数<a href="https://reactjs.org/docs/forwarding-refs.html" target="_blank" rel="noopener">将ref传到</a>到包装好的组件。如果第三方库HOC没有使用向下传递ref，上述模式仍然可以用作备用方案。</p>
<p>A great focus management example is the <a href="https://github.com/davidtheclark/react-aria-modal" target="_blank" rel="noopener">react-aria-modal</a>. This is a relatively rare example of a fully accessible modal window. Not only does it set initial focus on the cancel button (preventing the keyboard user from accidentally activating the success action) and trap keyboard focus inside the modal, it also resets focus back to the element that initially triggered the modal.</p>
<p>一个很好的焦点管理的例子就是<a href="https://github.com/davidtheclark/react-aria-modal" target="_blank" rel="noopener">react-aria-modal</a>。 这是一个相当罕见的完全无障碍的窗口模式的例子。它不仅将初始焦点设置在取消按钮上以避免键盘焦点陷入该模式中（防止键盘用户意外激活成功操作）还将焦点重置回最初触发模式的元素。</p>
<blockquote>
<p>Note:<br>While this is a very important accessibility feature, it is also a technique that should be used judiciously. Use it to repair the keyboard focus flow when it is disturbed, not to try and anticipate how users want to use applications.</p>
<p>提示：<br>虽然这是可访问性非常重要的一个特点，但它也是一种应该谨慎使用的技术。用它修复键盘焦点流时，不要试图预测用户是如何使用应用程序的。</p>
</blockquote>
<h3 id="More-Complex-Widgets-更复杂的组件"><a href="#More-Complex-Widgets-更复杂的组件" class="headerlink" title="More Complex Widgets(更复杂的组件)"></a>More Complex Widgets(更复杂的组件)</h3><p>A more complex user experience should not mean a less accessible one. Whereas accessibility is most easily achieved by coding as close to HTML as possible, even the most complex widget can be coded accessibly.</p>
<p>更复杂的用户体验不应该意味着可访问性更差。尽管通过类似HTML编码最容易实现可访问性，但即使是最复杂的小部件也可以有良好的访问性。</p>
<p>Here we require knowledge of <a href="https://www.w3.org/TR/wai-aria/#roles" target="_blank" rel="noopener">ARIA Roles</a> as well as <a href="https://www.w3.org/TR/wai-aria/#states_and_properties" target="_blank" rel="noopener">ARIA States and Properties</a>. These are toolboxes filled with HTML attributes that are fully supported in JSX and enable us to construct fully accessible, highly functional React components.</p>
<p>在这里，我们需要知道<a href="https://www.w3.org/TR/wai-aria/#roles" target="_blank" rel="noopener">ARIA角色</a>以及<a href="https://www.w3.org/TR/wai-aria/#states_and_properties" target="_blank" rel="noopener">ARIA的状态和属性</a>。 这些工具箱包含了JSX完全支持的HTML属性，使我们能够构建可访问性良好，功能强大的React组件。</p>
<p>Each type of widget has a specific design pattern and is expected to function in a certain way by users and user agents alike:</p>
<p>每个类型的组件都有一个特定的设计模式，并且预计会以某种方式由用户和用户代理运行：</p>
<ul>
<li><a href="https://www.w3.org/TR/wai-aria-practices/#aria_ex" target="_blank" rel="noopener">WAI-ARIA Authoring Practices - Design Patterns and Widgets</a></li>
<li><a href="http://heydonworks.com/practical_aria_examples/" target="_blank" rel="noopener">Heydon Pickering - ARIA Examples</a></li>
<li><p><a href="https://inclusive-components.design/" target="_blank" rel="noopener">Inclusive Components</a></p>
</li>
<li><p><a href="https://www.w3.org/TR/wai-aria-practices/#aria_ex" target="_blank" rel="noopener">WAI-ARIA创作实践 - 设计模式和小工具</a></p>
</li>
<li><a href="http://heydonworks.com/practical_aria_examples/" target="_blank" rel="noopener">Heydon Pickering - ARIA示例</a></li>
<li><a href="https://inclusive-components.design/" target="_blank" rel="noopener">包容性组件</a></li>
</ul>
<h3 id="Other-Points-for-Consideration-其他需要考虑的点"><a href="#Other-Points-for-Consideration-其他需要考虑的点" class="headerlink" title="Other Points for Consideration(其他需要考虑的点)"></a>Other Points for Consideration(其他需要考虑的点)</h3><h4 id="Setting-the-language-设置语言"><a href="#Setting-the-language-设置语言" class="headerlink" title="Setting the language(设置语言)"></a>Setting the language(设置语言)</h4><p>Indicate the human language of page texts as screen reader software uses this to select the correct voice settings:</p>
<p>当屏幕阅读器软件选择语音设置时，请指明页面上对应的语言：</p>
<ul>
<li><a href="http://webaim.org/techniques/screenreader/#language" target="_blank" rel="noopener">WebAIM - Document Language</a></li>
<li><a href="http://webaim.org/techniques/screenreader/#language" target="_blank" rel="noopener">WebAIM - 文本语言</a></li>
</ul>
<h4 id="Setting-the-document-title-设置文本标题"><a href="#Setting-the-document-title-设置文本标题" class="headerlink" title="Setting the document title(设置文本标题)"></a>Setting the document title(设置文本标题)</h4><p>Set the document <code>&lt;title&gt;</code> to correctly describe the current page content as this ensures that the user remains aware of the current page context:</p>
<p>设置文本的<code>&lt;title&gt;</code>来正确的描述现在页面的内容，以此来保证用户始终正确了解页面的内容：</p>
<ul>
<li><a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/navigation-mechanisms-title.html" target="_blank" rel="noopener">WCAG - Understanding the Document Title Requirement</a></li>
<li><a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/navigation-mechanisms-title.html" target="_blank" rel="noopener">WCAG - 理解文档标题的需要</a></li>
</ul>
<p>We can set this in React using the <a href="https://github.com/gaearon/react-document-title" target="_blank" rel="noopener">React Document Title Component.</a></p>
<p>我们可以使用<a href="https://github.com/gaearon/react-document-title" target="_blank" rel="noopener">React文档标题组件</a>在React中使用。</p>
<h4 id="Color-contrast-颜色对比"><a href="#Color-contrast-颜色对比" class="headerlink" title="Color contrast(颜色对比)"></a>Color contrast(颜色对比)</h4><p>Ensure that all readable text on your website has sufficient color contrast to remain maximally readable by users with low vision:</p>
<p>确保您的网站页面上所有可阅读的文本度有足够的颜色对比，以便视力不便的用户也有最好的阅读体验。</p>
<ul>
<li><a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html" target="_blank" rel="noopener">WCAG - Understanding the Color Contrast Requirement</a></li>
<li><a href="https://www.smashingmagazine.com/2014/10/color-contrast-tips-and-tools-for-accessibility/" target="_blank" rel="noopener">Everything About Color Contrast And Why You Should Rethink It</a></li>
<li><p><a href="http://a11yproject.com/posts/what-is-color-contrast/" target="_blank" rel="noopener">A11yProject - What is Color Contrast</a></p>
</li>
<li><p><a href="https://www.w3.org/TR/UNDERSTANDING-WCAG20/visual-audio-contrast-contrast.html" target="_blank" rel="noopener">WCAG - 理解颜色对比的需要</a></p>
</li>
<li><a href="https://www.smashingmagazine.com/2014/10/color-contrast-tips-and-tools-for-accessibility/" target="_blank" rel="noopener">有关颜色对比的所有事及为什么应该重新思考它</a></li>
<li><a href="http://a11yproject.com/posts/what-is-color-contrast/" target="_blank" rel="noopener">A11yProject - 什么是颜色对比</a></li>
</ul>
<p>It can be tedious to manually calculate the proper color combinations for all cases in your website so instead, you can <a href="http://jxnblk.com/colorable/" target="_blank" rel="noopener">calculate an entire accessible color palette with Colorable</a>.</p>
<p>手动计算网站中所有组件适当的颜色组合可能是非常繁琐的，因此您可以<a href="http://jxnblk.com/colorable/" target="_blank" rel="noopener">使用Colorable来计算整个可访问的调色板</a>。</p>
<p>Both the aXe and WAVE tools mentioned below also include color contrast tests and will report on contrast errors.</p>
<p>下面提到的ax和WAVE工具都包括颜色对比测试，并会提到对比度误差。</p>
<p>If you want to extend your contrast testing abilities you can use these tools:</p>
<p>如果您想扩展您的颜色对比测试能力，您可以使用下列工具：</p>
<ul>
<li><a href="http://webaim.org/resources/contrastchecker/" target="_blank" rel="noopener">WebAIM - Color Contrast Checker</a></li>
<li><p><a href="https://www.paciellogroup.com/resources/contrastanalyser/" target="_blank" rel="noopener">The Paciello Group - Color Contrast Analyzer</a></p>
</li>
<li><p><a href="http://webaim.org/resources/contrastchecker/" target="_blank" rel="noopener">WebAIM - 颜色对比度检查器</a></p>
</li>
<li><a href="https://www.paciellogroup.com/resources/contrastanalyser/" target="_blank" rel="noopener">Paciello组 - 颜色对比处理器</a></li>
</ul>
<h3 id="Development-and-Testing-Tools-开发及测试工具"><a href="#Development-and-Testing-Tools-开发及测试工具" class="headerlink" title="Development and Testing Tools(开发及测试工具)"></a>Development and Testing Tools(开发及测试工具)</h3><p>There are a number of tools we can use to assist in the creation of accessible web applications.</p>
<p>下面是可以用来协助我们创建可访问性的网站的一系列的工具。</p>
<h4 id="The-keyboard-键盘"><a href="#The-keyboard-键盘" class="headerlink" title="The keyboard(键盘)"></a>The keyboard(键盘)</h4><p>By far the easiest and also one of the most important checks is to test if your entire website can be reached and used with the keyboard alone. Do this by:</p>
<p>到目前为止，最简单也是最重要的检查之一是测试整个网站是否可以与键盘一起使用。通过下面几步，我们可以做到这一点：</p>
<ol>
<li>Plugging out your mouse.</li>
<li>Using Tab and Shift+Tab to browse.</li>
<li>Using Enter to activate elements.</li>
<li><p>Where required, using your keyboard arrow keys to interact with some elements, such as menus and dropdowns.</p>
</li>
<li><p>拔下鼠标。</p>
</li>
<li>使用Tab和Shift + Tab浏览。</li>
<li>使用Enter激活元素。</li>
<li>根据需要，使用键盘上的箭头键与某些元素（如菜单和下拉菜单）进行交互。</li>
</ol>
<h4 id="Development-assistance-开发者工具"><a href="#Development-assistance-开发者工具" class="headerlink" title="Development assistance(开发者工具)"></a>Development assistance(开发者工具)</h4><p>We can check some accessibility features directly in our JSX code. Often intellisense checks are already provided in JSX aware IDE’s for the ARIA roles, states and properties. We also have access to the following tool:</p>
<p>我们可以在我们的JSX代码中直接检测一些可访问性的因素。通常IDE会扮演ARIA的角色自动进行状态和属性的检测。 我们也可以访问以下工具：</p>
<blockquote>
<p>eslint-plugin-jsx-a11y</p>
</blockquote>
<p>The <a href="https://github.com/evcohen/eslint-plugin-jsx-a11y" target="_blank" rel="noopener">eslint-plugin-jsx-a11y</a> plugin for ESLint provides AST linting feedback regarding accessibility issues in your JSX. Many IDE’s allow you to integrate these findings directly into code analysis and source code windows.</p>
<p>ESLint的<a href="https://github.com/evcohen/eslint-plugin-jsx-a11y" target="_blank" rel="noopener">eslint-plugin-jsx-a11y</a>提供了JSX在AST中可访问性问题的linting反馈。许多IDE允许您将这些问题直接集成到代码分析窗口和源代码窗口中。</p>
<p><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a> has this plugin with a subset of rules activated. If you want to enable even more accessibility rules, you can create an <code>.eslintrc</code> file in the root of your project with this content:</p>
<p><a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>已有这个插件并沿用其中的一些规则。如果您希望使用更多可访问性的规则，则可以使用以下指令在项目的根目录下创建<code>.eslintrc</code>文件：</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"extends"</span>: [<span class="string">"react-app"</span>, <span class="string">"plugin:jsx-a11y/recommended"</span>],</span><br><span class="line">  <span class="attr">"plugins"</span>: [<span class="string">"jsx-a11y"</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="Testing-accessibility-in-the-browser-在浏览器中测试可访问性"><a href="#Testing-accessibility-in-the-browser-在浏览器中测试可访问性" class="headerlink" title="Testing accessibility in the browser(在浏览器中测试可访问性)"></a>Testing accessibility in the browser(在浏览器中测试可访问性)</h4><p>A number of tools exist that can run accessibility audits on web pages in your browser. Please use them in combination with other accessibility checks mentioned here as they can only test the technical accessibility of your HTML.</p>
<p>许多工具可以在浏览器的网页上测试可访问性。请将它们与其他可访问性检查结合使用，因为它们只能测试与HTML相关的可访问性。</p>
<blockquote>
<p>aXe, aXe-core and react-axe</p>
</blockquote>
<p>Deque Systems offers <a href="https://github.com/dequelabs/axe-core" target="_blank" rel="noopener">aXe-core</a> for automated and end-to-end accessibility tests of your applications. This module includes integrations for Selenium.</p>
<p>Deque Systems为您的应用程序的自动化和端对端可访问性测试提供了<a href="https://github.com/dequelabs/axe-core" target="_blank" rel="noopener">ax-core</a>。 该模块包含Selenium的集成。</p>
<p><a href="https://www.deque.com/products/axe/" target="_blank" rel="noopener">The Accessibility Engine</a> or aXe, is an accessibility inspector browser extension built on <code>aXe-core</code>.</p>
<p><a href="https://www.deque.com/products/axe/" target="_blank" rel="noopener">可访问性的引擎</a>或者aXe,是一个内嵌在<code>aXe-core</code>上的检测可访问性的浏览器插件。</p>
<p>You can also use the <a href="https://github.com/dylanb/react-axe" target="_blank" rel="noopener">react-axe</a> module to report these accessibility findings directly to the console while developing and debugging.</p>
<p>您也可以使用<a href="https://github.com/dylanb/react-axe" target="_blank" rel="noopener">react-axe</a>模块在开发和调试时直接向控制台报告这些可访问性结果。</p>
<blockquote>
<p>WebAIM WAVE</p>
</blockquote>
<p>The <a href="http://wave.webaim.org/extension/" target="_blank" rel="noopener">Web Accessibility Evaluation Tool</a> is another accessibility browser extension.</p>
<p><a href="http://wave.webaim.org/extension/" target="_blank" rel="noopener">网络可访问性评估工具</a>是另一个可访问性的浏览器插件。</p>
<blockquote>
<p>Accessibility inspectors and the Accessibility Tree(可访问性检测器及可访问性树)</p>
</blockquote>
<p><a href="https://www.paciellogroup.com/blog/2015/01/the-browser-accessibility-tree/" target="_blank" rel="noopener">The Accessibility Tree</a> is a subset of the DOM tree that contains accessible objects for every DOM element that should be exposed to assistive technology, such as screen readers.</p>
<p><a href="https://www.paciellogroup.com/blog/2015/01/the-browser-accessibility-tree/" target="_blank" rel="noopener">可访问性树</a>是DOM树的子集，其中包含每个DOM元素的可访问对象，这些元素会暴露给可访问的设备，例如屏幕阅读器。</p>
<p>In some browsers we can easily view the accessibility information for each element in the accessibility tree:</p>
<p>在一些浏览器中，我们可以轻松地查看可访问性功能树中每个元素的可访问性信息：</p>
<ul>
<li>Activate the Accessibility Inspector in Chrome</li>
<li><p>Using the Accessibility Inspector in OS X Safari</p>
</li>
<li><p>在Chrome中激活辅助功能检查器</p>
</li>
<li>在OS X Safari中使用辅助功能检查器</li>
</ul>
<h4 id="Screen-readers-屏幕阅读器"><a href="#Screen-readers-屏幕阅读器" class="headerlink" title="Screen readers(屏幕阅读器)"></a>Screen readers(屏幕阅读器)</h4><p>Testing with a screen reader should form part of your accessibility tests.</p>
<p>测试屏幕阅读器应该是您可访问性测试的一部分。</p>
<p>Please note that browser / screen reader combinations matter. It is recommended that you test your application in the browser best suited to your screen reader of choice.</p>
<p>请注意，浏览器/屏幕阅读器的组合很重要。建议您在最适合的屏幕阅读器的浏览器中测试您的应用程序。</p>
<h4 id="Commonly-Used-Screen-Readers-通用的屏幕阅读器"><a href="#Commonly-Used-Screen-Readers-通用的屏幕阅读器" class="headerlink" title="Commonly Used Screen Readers(通用的屏幕阅读器)"></a>Commonly Used Screen Readers(通用的屏幕阅读器)</h4><blockquote>
<p>NVDA in Firefox</p>
</blockquote>
<p><a href="https://www.nvaccess.org/" target="_blank" rel="noopener">NonVisual Desktop Access</a> or NVDA is an open source Windows screen reader that is widely used.</p>
<p><a href="https://www.nvaccess.org/" target="_blank" rel="noopener">不可视的桌面访问</a>或者NVDA时一个广泛使用的开源的Windows屏幕阅读器。</p>
<p>Refer to the following guides on how to best use NVDA:</p>
<p>您可以参考下列的目录来学习如何最好的使用NVDA：</p>
<ul>
<li><a href="http://webaim.org/articles/nvda/" target="_blank" rel="noopener">WebAIM - Using NVDA to Evaluate Web Accessibility</a></li>
<li><p><a href="https://dequeuniversity.com/screenreaders/nvda-keyboard-shortcuts" target="_blank" rel="noopener">Deque - NVDA Keyboard Shortcuts</a></p>
</li>
<li><p><a href="http://webaim.org/articles/nvda/" target="_blank" rel="noopener">WebAIM - 使用NVDA来评估网络的可访问性</a></p>
</li>
<li><a href="https://dequeuniversity.com/screenreaders/nvda-keyboard-shortcuts" target="_blank" rel="noopener">Deque - NVDA键盘的快捷键</a></li>
</ul>
<blockquote>
<p>VoiceOver in Safari</p>
</blockquote>
<p>VoiceOver is an integrated screen reader on Apple devices.</p>
<p>VoiceOver是Apple设备上的集成屏幕阅读器。</p>
<p>Refer to the following guides on how activate and use VoiceOver:</p>
<p>您可以参考下列的目录来学习如何激活并使用VoiceOver：</p>
<ul>
<li><a href="http://webaim.org/articles/voiceover/" target="_blank" rel="noopener">WebAIM - Using VoiceOver to Evaluate Web Accessibility</a></li>
<li><a href="https://dequeuniversity.com/screenreaders/voiceover-keyboard-shortcuts" target="_blank" rel="noopener">Deque - VoiceOver for OS X Keyboard Shortcuts</a></li>
<li><p><a href="https://dequeuniversity.com/screenreaders/voiceover-ios-shortcuts" target="_blank" rel="noopener">Deque - VoiceOver for iOS Shortcuts</a></p>
</li>
<li><p><a href="http://webaim.org/articles/voiceover/" target="_blank" rel="noopener">WebAIM - 使用VoiceOver来评估Web可访问性</a></p>
</li>
<li><a href="https://dequeuniversity.com/screenreaders/voiceover-keyboard-shortcuts" target="_blank" rel="noopener">Deque- VoiceOver在OS X的快捷键</a></li>
<li><a href="https://dequeuniversity.com/screenreaders/voiceover-ios-shortcuts" target="_blank" rel="noopener">Deque - VoiceOver在iOS上的快捷键</a></li>
</ul>
<blockquote>
<p>JAWS in Internet Explorer</p>
</blockquote>
<p><a href="http://www.freedomscientific.com/Products/Blindness/JAWS" target="_blank" rel="noopener">Job Access With Speech</a> or JAWS, is a prolifically used screen reader on Windows.</p>
<p><a href="http://www.freedomscientific.com/Products/Blindness/JAWS" target="_blank" rel="noopener">Job Access With Speech</a>或JAWS进行工作访问是Windows上一种多用途的屏幕阅读器。</p>
<p>Refer to the following guides on how to best use JAWS:</p>
<p>参考下列目录来学习如何最好的使用JAWS：</p>
<ul>
<li><a href="http://webaim.org/articles/jaws/" target="_blank" rel="noopener">WebAIM - Using JAWS to Evaluate Web Accessibility</a></li>
<li><p><a href="https://dequeuniversity.com/screenreaders/jaws-keyboard-shortcuts" target="_blank" rel="noopener">Deque - JAWS Keyboard Shortcuts</a></p>
</li>
<li><p><a href="http://webaim.org/articles/jaws/" target="_blank" rel="noopener">WebAIM - 使用JAWS来评估Web的可访问性</a></p>
</li>
<li><a href="https://dequeuniversity.com/screenreaders/jaws-keyboard-shortcuts" target="_blank" rel="noopener">Deque - JAWS键盘快捷键</a></li>
</ul>
<h4 id="Other-Screen-Readers-其他的屏幕阅读器"><a href="#Other-Screen-Readers-其他的屏幕阅读器" class="headerlink" title="Other Screen Readers(其他的屏幕阅读器)"></a>Other Screen Readers(其他的屏幕阅读器)</h4><blockquote>
<p>ChromeVox in Google Chrome</p>
</blockquote>
<p><a href="http://www.chromevox.com/" target="_blank" rel="noopener">ChromeVox</a> is an integrated screen reader on Chromebooks and is available as an extension for Google Chrome.</p>
<p><a href="http://www.chromevox.com/" target="_blank" rel="noopener">ChromeVox</a>是Chromebook上的集成屏幕阅读器，可作为Google Chrome的扩展程序。</p>
<p>Refer to the following guides on how best to use ChromeVox:</p>
<p>参考下列目录来学习如何最好的使用ChromeVox：</p>
<ul>
<li><a href="https://support.google.com/chromebook/answer/7031755?hl=en" target="_blank" rel="noopener">Google Chromebook Help - Use the Built-in Screen Reader</a></li>
<li><p><a href="http://www.chromevox.com/keyboard_shortcuts.html" target="_blank" rel="noopener">ChromeVox Classic Keyboard Shortcuts Reference</a></p>
</li>
<li><p><a href="https://support.google.com/chromebook/answer/7031755?hl=en" target="_blank" rel="noopener">Google Chromebook帮助 - 使用内建的屏幕阅读器</a></p>
</li>
<li><a href="http://www.chromevox.com/keyboard_shortcuts.html" target="_blank" rel="noopener">ChromeVox Classic传统的快捷键参阅</a></li>
</ul>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[react组件之间的通信]]></title>
      <url>/2018/06/23/blog/problem/react_communication/</url>
      <content type="html"><![CDATA[<h2 id="react组件之间的通信"><a href="#react组件之间的通信" class="headerlink" title="react组件之间的通信"></a>react组件之间的通信</h2><p>说 React 组件间通讯之前，我们先来讨论一下 React 组件究竟有多少种层级间的关系。假设我们开发的项目是一个纯 React 的项目，那我们项目应该有如下类似的关系：</p>
<p><img src="/images/blog/react_communicatioin.png"></p>
<p>父子：Parent 与 Child_1、Child_2、Child_1_1、Child_1_2、Child_2_1</p>
<p>兄弟：Child_1 与 Child_2、Child_1_1 与 Child_2、etc.</p>
<p>针对这些关系，我们将来好好讨论一下这些关系间的通讯方式。</p>
<p>（在 React 中，React 组件之间的关系为从属关系，与 DOM 元素之间的父子关系有所不同，下面只是为了说明方便，将 React 组件的关系类比成父子关系进行阐述）</p>
<hr>
<h3 id="父组件向子组件通讯"><a href="#父组件向子组件通讯" class="headerlink" title="父组件向子组件通讯"></a>父组件向子组件通讯</h3><p>通讯是单向的，数据必须是由一方传到另一方。在 React 中，父组件可以向子组件通过传 props 的方式，向子组件进行通讯。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="string">'start'</span></span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">        msg: <span class="string">'end'</span></span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">Child_1</span> <span class="attr">msg</span>=<span class="string">&#123;this.state.msg&#125;</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">class Child_1 extends Component&#123;</span></span><br><span class="line"><span class="xml">  render() &#123;</span></span><br><span class="line"><span class="xml">    return <span class="tag">&lt;<span class="name">p</span>&gt;</span>&#123;this.props.msg&#125;<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br><span class="line"><span class="xml">  &#125;</span></span><br><span class="line"><span class="xml">&#125;</span></span><br></pre></td></tr></table></figure>
<p>如果父组件与子组件之间不止一个层级，如 Parent 与 Child_1_1 这样的关系，可通过 … 运算符（Object 剩余和展开属性），将父组件的信息，以更简洁的方式传递给更深层级的子组件。通过这种方式，不用考虑性能的问题，通过 babel 转义后的 … 运算符 性能和原生的一致，且上级组件 props 与 state 的改变，会导致组件本身及其子组件的生命周期改变，</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 通过 ... 运算符 向 Child_1_1 传递 Parent 组件的信息</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;p&gt;&#123;<span class="keyword">this</span>.props.msg&#125;&lt;/p&gt;</span><br><span class="line">      &lt;<span class="type">Child_1_1</span> &#123;...<span class="keyword">this</span>.props&#125;/&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;p&gt;&#123;<span class="keyword">this</span>.props.msg&#125;&lt;/p&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<hr>
<h3 id="子组件向父组件通讯"><a href="#子组件向父组件通讯" class="headerlink" title="子组件向父组件通讯"></a>子组件向父组件通讯</h3><p>在上一个例子中，父组件可以通过传递 props 的方式，自顶而下向子组件进行通讯。而子组件向父组件通讯，同样也需要父组件向子组件传递 props 进行通讯，只是父组件传递的，是作用域为父组件自身的函数，子组件调用该函数，将子组件想要传递的信息，作为参数，传递到父组件的作用域中。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="symbol">'star</span>t'</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  transferMsg(msg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">        &lt;p&gt;child msg: &#123;<span class="keyword">this</span>.state.msg&#125;&lt;/p&gt;</span><br><span class="line">        &lt;<span class="type">Child_1</span> transferMsg = &#123;msg =&gt; <span class="keyword">this</span>.transferMsg(msg)&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.transferMsg(<span class="symbol">'en</span>d')</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_1 component&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在上面的例子中，我们使用了 箭头函数，将父组件的 transferMsg 函数通过 props 传递给子组件，得益于箭头函数，保证子组件在调用 transferMsg 函数时，其内部 this 仍指向父组件。</p>
<p>当然，对于层级比较深的子组件与父组件之间的通讯，仍可使用 … 运算符，将父组件的调用函数传递给子组件，具体方法和上面的例子类似。</p>
<hr>
<h3 id="兄弟组件间通讯"><a href="#兄弟组件间通讯" class="headerlink" title="兄弟组件间通讯"></a>兄弟组件间通讯</h3><p>对于没有直接关联关系的两个节点，就如 Child_1 与 Child_2 之间的关系，他们唯一的关联点，就是拥有相同的父组件。参考之前介绍的两种关系的通讯方式，如果我们向由 Child_1 向 Child_2 进行通讯，我们可以先通过 Child_1 向 Parent 组件进行通讯，再由 Parent 向 Child_2 组件进行通讯，所以有以下代码。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Parent</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  state = &#123;</span><br><span class="line">    msg: <span class="symbol">'star</span>t'</span><br><span class="line">  &#125;;</span><br><span class="line"></span><br><span class="line">  transferMsg(msg) &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      msg</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(<span class="symbol">'Parent</span> update');</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;<span class="type">Child_1</span> transferMsg = &#123;msg =&gt; <span class="keyword">this</span>.transferMsg(msg)&#125; /&gt;</span><br><span class="line">        &lt;<span class="type">Child_2</span> msg = &#123;<span class="keyword">this</span>.state.msg&#125; /&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    setTimeout(() =&gt; &#123;</span><br><span class="line">      <span class="keyword">this</span>.props.transferMsg(<span class="symbol">'en</span>d')</span><br><span class="line">    &#125;, <span class="number">1000</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(<span class="symbol">'Child_1</span> update');</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_1 component&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(<span class="symbol">'Child_2</span> update');</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_2 component: &#123;<span class="keyword">this</span>.props.msg&#125;&lt;/p&gt;</span><br><span class="line">      &lt;<span class="type">Child_2_1</span> /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Child_2_1</span> <span class="keyword">extends</span> <span class="title">Component</span></span>&#123;</span><br><span class="line">  componentDidUpdate() &#123;</span><br><span class="line">    console.log(<span class="symbol">'Child_2_1</span> update');</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;div&gt;</span><br><span class="line">      &lt;p&gt;child_2_1 component&lt;/p&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>然而，这个方法有一个问题，由于 Parent 的 state 发生变化，会触发 Parent 及从属于 Parent 的子组件的生命周期，所以我们在控制台中可以看到，在各个组件中的 componentDidUpdate 方法均被触发。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 10.Symbol]]></title>
      <url>/2018/06/19/ES6/10.symbol/</url>
      <content type="html"><![CDATA[<h1 id="Symbol"><a href="#Symbol" class="headerlink" title="Symbol"></a>Symbol</h1><h2 id="概-述"><a href="#概-述" class="headerlink" title="概 述"></a>概 述</h2><p>ES5 的对象属性名都是字符串，这容易造成属性名的冲突。比如，你使用了一个他人提供的对象，但又想为这个对象添加新的方法（mixin 模式），新方法的名字就有可能与现有方法产生冲突。如果有一种机制，保证每个属性的名字都是独一无二的就好了，这样就从根本上防止属性名的冲突。这就是 ES6 引入<code>Symbol</code>的原因。</p>
<p>ES6 引入了一种新的原始数据类型<code>Symbol</code>，表示独一无二的值。它是 JavaScript 语言的第七种数据类型，前六种是：<code>undefined</code>、<code>null</code>、布尔值（Boolean）、字符串（String）、数值（Number）、对象（Object）。</p>
<p>Symbol 值通过<code>Symbol</code>函数生成。这就是说，对象的属性名现在可以有两种类型，一种是原来就有的字符串，另一种就是新增的 Symbol 类型。凡是属性名属于 Symbol 类型，就都是独一无二的，可以保证不会与其他属性名产生冲突。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="keyword">typeof</span> s</span><br><span class="line"><span class="comment">// "symbol"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>s</code>就是一个独一无二的值。<code>typeof</code>运算符的结果，表明变量<code>s</code>是 Symbol 数据类型，而不是字符串之类的其他类型。</p>
<p>注意，<code>Symbol</code>函数前不能使用<code>new</code>命令，否则会报错。这是因为生成的 Symbol 是一个原始类型的值，不是对象。也就是说，由于 Symbol 值不是对象，所以不能添加属性。基本上，它是一种类似于字符串的数据类型。</p>
<p><code>Symbol</code>函数可以接受一个字符串作为参数，表示对 Symbol 实例的描述，主要是为了在控制台显示，或者转为字符串时，比较容易区分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'bar'</span>);</span><br><span class="line"></span><br><span class="line">s1 <span class="comment">// Symbol(foo)</span></span><br><span class="line">s2 <span class="comment">// Symbol(bar)</span></span><br><span class="line">    </span><br><span class="line">s1.toString() <span class="comment">// "Symbol(foo)"</span></span><br><span class="line">s2.toString() <span class="comment">// "Symbol(bar)"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>s1</code>和<code>s2</code>是两个 Symbol 值。如果不加参数，它们在控制台的输出都是<code>Symbol()</code>，不利于区分。有了参数以后，就等于为它们加上了描述，输出的时候就能够分清，到底是哪一个值。</p>
<p>如果 Symbol 的参数是一个对象，就会调用该对象的<code>toString</code>方法，将其转为字符串，然后才生成一个 Symbol 值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  toString() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'abc'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> sym = <span class="built_in">Symbol</span>(obj);</span><br><span class="line">sym <span class="comment">// Symbol(abc)</span></span><br></pre></td></tr></table></figure>
<p>注意，<code>Symbol</code>函数的参数只是表示对当前 Symbol 值的描述，因此相同参数的<code>Symbol</code>函数的返回值是不相等的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 有参数的情况</span></span><br><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s1 === s2 <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>s1</code>和<code>s2</code>都是<code>Symbol</code>函数的返回值，而且参数相同，但是它们是不相等的。</p>
<p>Symbol 值不能与其他类型的值进行运算，会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="string">"your symbol is "</span> + sym</span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br><span class="line"><span class="string">`your symbol is <span class="subst">$&#123;sym&#125;</span>`</span></span><br><span class="line"><span class="comment">// TypeError: can't convert symbol to string</span></span><br></pre></td></tr></table></figure>
<p>但是，Symbol 值可以显式转为字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>(<span class="string">'My symbol'</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>(sym) <span class="comment">// 'Symbol(My symbol)'</span></span><br><span class="line">sym.toString() <span class="comment">// 'Symbol(My symbol)'</span></span><br></pre></td></tr></table></figure>
<p>另外，Symbol 值也可以转为布尔值，但是不能转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> sym = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="built_in">Boolean</span>(sym) <span class="comment">// true</span></span><br><span class="line">!sym  <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (sym) &#123;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="built_in">Number</span>(sym) <span class="comment">// TypeError</span></span><br><span class="line">sym + <span class="number">2</span> <span class="comment">// TypeError</span></span><br></pre></td></tr></table></figure>
<h2 id="作为属性名的-Symbol"><a href="#作为属性名的-Symbol" class="headerlink" title="作为属性名的 Symbol"></a>作为属性名的 Symbol</h2><p>由于每一个 Symbol 值都是不相等的，这意味着 Symbol 值可以作为标识符，用于对象的属性名，就能保证不会出现同名的属性。这对于一个对象由多个模块构成的情况非常有用，能防止某一个键被不小心改写或覆盖。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mySymbol = Symbol();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第一种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">a[mySymbol] = <span class="string">'Hello!'</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第二种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;</span><br><span class="line">  [<span class="meta">mySymbol</span>]: <span class="string">'Hello!'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 第三种写法</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;&#125;;</span><br><span class="line">Object.defineProperty(a, mySymbol, &#123; <span class="keyword">value</span>: <span class="string">'Hello!'</span> &#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以上写法都得到同样结果</span></span><br><span class="line">a[mySymbol] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure>
<p>上面代码通过方括号结构和<code>Object.defineProperty</code>，将对象的属性名指定为一个 Symbol 值。</p>
<p>注意，Symbol 值作为对象属性名时，不能用点运算符。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> mySymbol = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> a = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">a.mySymbol = <span class="string">'Hello!'</span>;</span><br><span class="line">a[mySymbol] <span class="comment">// undefined</span></span><br><span class="line">a[<span class="string">'mySymbol'</span>] <span class="comment">// "Hello!"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，因为点运算符后面总是字符串，所以不会读取<code>mySymbol</code>作为标识名所指代的那个值，导致<code>a</code>的属性名实际上是一个字符串，而不是一个 Symbol 值。</p>
<p>同理，在对象的内部，使用 Symbol 值定义属性时，Symbol 值必须放在方括号之中。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let s = Symbol();</span><br><span class="line"></span><br><span class="line">let obj = &#123;</span><br><span class="line">  [s]: function (arg) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj[<span class="string">s</span>](<span class="link">123</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果<code>s</code>不放在方括号中，该属性的键名就是字符串<code>s</code>，而不是<code>s</code>所代表的那个 Symbol 值。</p>
<p>采用增强的对象写法，上面代码的<code>obj</code>对象可以写得更简洁一些。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  [<span class="string">s</span>](<span class="link">arg</span>) &#123; ... &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>Symbol 类型还可以用于定义一组常量，保证这组常量的值都是不相等的。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">log</span> = &#123;&#125;<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>.levels = &#123;</span><br><span class="line">  DEBUG: Symbol(<span class="string">'debug'</span>),</span><br><span class="line">  INFO: Symbol(<span class="string">'info'</span>),</span><br><span class="line">  WARN: Symbol(<span class="string">'warn'</span>)</span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">log</span>.levels.DEBUG, <span class="string">'debug message'</span>)<span class="comment">;</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">log</span>.levels.INFO, <span class="string">'info message'</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>下面是另外一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> COLOR_RED    = <span class="built_in">Symbol</span>();</span><br><span class="line"><span class="keyword">const</span> COLOR_GREEN  = <span class="built_in">Symbol</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getComplement</span>(<span class="params">color</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">switch</span> (color) &#123;</span><br><span class="line">    <span class="keyword">case</span> COLOR_RED:</span><br><span class="line">      <span class="keyword">return</span> COLOR_GREEN;</span><br><span class="line">    <span class="keyword">case</span> COLOR_GREEN:</span><br><span class="line">      <span class="keyword">return</span> COLOR_RED;</span><br><span class="line">    <span class="keyword">default</span>:</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Undefined color'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>常量使用 Symbol 值最大的好处，就是其他任何值都不可能有相同的值了，因此可以保证上面的<code>switch</code>语句会按设计的方式工作。</p>
<p>还有一点需要注意，Symbol 值作为属性名时，该属性还是公开属性，不是私有属性。</p>
<p>实例：消除魔术字符串</p>
<p>魔术字符串指的是，在代码之中多次出现、与代码形成强耦合的某一个具体的字符串或者数值。风格良好的代码，应该尽量消除魔术字符串，改由含义清晰的变量代替。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">function getArea(<span class="built_in">shape</span>, options) &#123;</span><br><span class="line">  let area = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">shape</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> <span class="string">'Triangle'</span>: <span class="comment">// 魔术字符串</span></span><br><span class="line">      area = <span class="number">.5</span> * options.<span class="built_in">width</span> * options.<span class="built_in">height</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">    <span class="comment">/* ... more code ... */</span></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(<span class="string">'Triangle'</span>, &#123; <span class="built_in">width</span>: <span class="number">100</span>, <span class="built_in">height</span>: <span class="number">100</span> &#125;); <span class="comment">// 魔术字符串</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串<code>Triangle</code>就是一个魔术字符串。它多次出现，与代码形成“强耦合”，不利于将来的修改和维护。</p>
<p>常用的消除魔术字符串的方法，就是把它写成一个变量。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  <span class="built_in">triangle</span>: <span class="string">'Triangle'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function getArea(<span class="built_in">shape</span>, options) &#123;</span><br><span class="line">  let area = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">switch</span> (<span class="built_in">shape</span>) &#123;</span><br><span class="line">    <span class="keyword">case</span> shapeType.<span class="built_in">triangle</span>:</span><br><span class="line">      area = <span class="number">.5</span> * options.<span class="built_in">width</span> * options.<span class="built_in">height</span>;</span><br><span class="line">      <span class="keyword">break</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> area;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getArea(shapeType.<span class="built_in">triangle</span>, &#123; <span class="built_in">width</span>: <span class="number">100</span>, <span class="built_in">height</span>: <span class="number">100</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>上面代码中，我们把<code>Triangle</code>写成<code>shapeType</code>对象的<code>triangle</code>属性，这样就消除了强耦合。</p>
<p>如果仔细分析，可以发现<code>shapeType.triangle</code>等于哪个值并不重要，只要确保不会跟其他<code>shapeType</code>属性的值冲突即可。因此，这里就很适合改用 Symbol 值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shapeType = &#123;</span><br><span class="line">  triangle: <span class="built_in">Symbol</span>()</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，除了将<code>shapeType.triangle</code>的值设为一个 Symbol，其他地方都不用修改。</p>
<h2 id="属性名的遍历"><a href="#属性名的遍历" class="headerlink" title="属性名的遍历"></a>属性名的遍历</h2><p>Symbol 作为属性名，该属性不会出现在<code>for...in</code>、<code>for...of</code>循环中，也不会被<code>Object.keys()</code>、<code>Object.getOwnPropertyNames()</code>、<code>JSON.stringify()</code>返回。但是，它也不是私有属性，有一个<code>Object.getOwnPropertySymbols</code>方法，可以获取指定对象的所有 Symbol 属性名。</p>
<p><code>Object.getOwnPropertySymbols</code>方法返回一个数组，成员是当前对象的所有用作属性名的 Symbol 值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> a = <span class="built_in">Symbol</span>(<span class="string">'a'</span>);</span><br><span class="line"><span class="keyword">let</span> b = <span class="built_in">Symbol</span>(<span class="string">'b'</span>);</span><br><span class="line">    </span><br><span class="line">obj[a] = <span class="string">'Hello'</span>;</span><br><span class="line">obj[b] = <span class="string">'World'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> objectSymbols = <span class="built_in">Object</span>.getOwnPropertySymbols(obj);</span><br><span class="line"></span><br><span class="line">objectSymbols</span><br><span class="line"><span class="comment">// [Symbol(a), Symbol(b)]</span></span><br></pre></td></tr></table></figure>
<p>下面是另一个例子，<code>Object.getOwnPropertySymbols</code>方法与<code>for...in</code>循环、<code>Object.getOwnPropertyNames</code>方法进行对比的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> foo = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.defineProperty(obj, foo, &#123;</span><br><span class="line">  value: <span class="string">"foobar"</span>,</span><br><span class="line">&#125;);</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">in</span> obj) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(i); <span class="comment">// 无输出</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(obj)</span><br><span class="line"><span class="comment">// []</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(obj)</span><br><span class="line"><span class="comment">// [Symbol(foo)]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，使用<code>Object.getOwnPropertyNames</code>方法得不到<code>Symbol</code>属性名，需要使用<code>Object.getOwnPropertySymbols</code>方法。</p>
<p>另一个新的 API，<code>Reflect.ownKeys</code>方法可以返回所有类型的键名，包括常规键名和 Symbol 键名。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  [Symbol(<span class="string">'my_key'</span>)]: <span class="number">1</span>,</span><br><span class="line">  <span class="class"><span class="keyword">enum</span>: 2,</span></span><br><span class="line">  <span class="symbol">nonEnum:</span> <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Reflect.ownKeys(obj)</span><br><span class="line">/<span class="regexp">/  ["enum", "nonEnum", Symbol(my_key)]</span></span><br></pre></td></tr></table></figure>
<p>由于以 Symbol 值作为名称的属性，不会被常规方法遍历得到。我们可以利用这个特性，为对象定义一些非私有的、但又希望只用于内部的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> size = <span class="built_in">Symbol</span>(<span class="string">'size'</span>);</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>() &#123;</span><br><span class="line">    <span class="keyword">this</span>[size] = <span class="number">0</span>;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  add(item) &#123;</span><br><span class="line">    <span class="keyword">this</span>[<span class="keyword">this</span>[size]] = item;</span><br><span class="line">    <span class="keyword">this</span>[size]++;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">static</span> sizeOf(instance) &#123;</span><br><span class="line">    <span class="keyword">return</span> instance[size];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> x = <span class="keyword">new</span> Collection();</span><br><span class="line">Collection.sizeOf(x) <span class="comment">// 0</span></span><br><span class="line"></span><br><span class="line">x.add(<span class="string">'foo'</span>);</span><br><span class="line">Collection.sizeOf(x) <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.keys(x) <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertyNames(x) <span class="comment">// ['0']</span></span><br><span class="line"><span class="built_in">Object</span>.getOwnPropertySymbols(x) <span class="comment">// [Symbol(size)]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，对象<code>x</code>的<code>size</code>属性是一个 Symbol 值，所以<code>Object.keys(x)</code>、<code>Object.getOwnPropertyNames(x)</code>都无法获取它。这就造成了一种非私有的内部方法的效果。</p>
<h2 id="Symbol-for-，Symbol-keyFor"><a href="#Symbol-for-，Symbol-keyFor" class="headerlink" title="Symbol.for()，Symbol.keyFor()"></a>Symbol.for()，Symbol.keyFor()</h2><p>有时，我们希望重新使用同一个 Symbol 值，<code>Symbol.for</code>方法可以做到这一点。它接受一个字符串作为参数，然后搜索有没有以该参数作为名称的 Symbol 值。如果有，就返回这个 Symbol 值，否则就新建并返回一个以该字符串为名称的 Symbol 值。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s<span class="number">1</span> = Symbol.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"><span class="keyword">let</span> s<span class="number">2</span> = Symbol.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">s<span class="number">1</span> === s<span class="number">2</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>s1</code>和<code>s2</code>都是 Symbol 值，但是它们都是同样参数的<code>Symbol.for</code>方法生成的，所以实际上是同一个值。</p>
<p><code>Symbol.for()</code>与<code>Symbol()</code>这两种写法，都会生成新的 Symbol。它们的区别是，前者会被登记在全局环境中供搜索，后者不会。<code>Symbol.for()</code>不会每次调用就返回一个新的 Symbol 类型的值，而是会先检查给定的<code>key</code>是否已经存在，如果不存在才会新建一个值。比如，如果你调用<code>Symbol.for(&quot;cat&quot;)</code>30 次，每次都会返回同一个 Symbol 值，但是调用<code>Symbol(&quot;cat&quot;)</code>30 次，会返回 30 个不同的 Symbol 值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Symbol</span>(<span class="string">"bar"</span>) === <span class="built_in">Symbol</span>(<span class="string">"bar"</span>)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，由于<code>Symbol()</code>写法没有登记机制，所以每次调用都会返回一个不同的值。</p>
<p><code>Symbol.keyFor</code>方法返回一个已登记的 Symbol 类型值的<code>key</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s1 = <span class="built_in">Symbol</span>.for(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s1) <span class="comment">// "foo"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> s2 = <span class="built_in">Symbol</span>(<span class="string">"foo"</span>);</span><br><span class="line"><span class="built_in">Symbol</span>.keyFor(s2) <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>s2</code>属于未登记的 Symbol 值，所以返回<code>undefined</code>。</p>
<p>需要注意的是，<code>Symbol.for</code>为 Symbol 值登记的名字，是全局环境的，可以在不同的 iframe 或 service worker 中取到同一个值。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">iframe = <span class="built_in">document</span>.createElement(<span class="string">'iframe'</span>);</span><br><span class="line">iframe.src = <span class="built_in">String</span>(<span class="built_in">window</span>.location);</span><br><span class="line"><span class="built_in">document</span>.body.appendChild(iframe);</span><br><span class="line"></span><br><span class="line">iframe.contentWindow.<span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>) === <span class="built_in">Symbol</span>.<span class="keyword">for</span>(<span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，iframe 窗口生成的 Symbol 值，可以在主页面得到。</p>
<h2 id="实例：模块的-Singleton-模式"><a href="#实例：模块的-Singleton-模式" class="headerlink" title="实例：模块的 Singleton 模式"></a>实例：模块的 Singleton 模式</h2><p>Singleton 模式指的是调用一个类，任何时候返回的都是同一个实例。</p>
<p>对于 Node 来说，模块文件可以看成是一个类。怎么保证每次执行这个模块文件，返回的都是同一个实例呢？</p>
<p>很容易想到，可以把实例放到顶层对象<code>global</code>。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  this.foo = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">global</span>._foo) &#123;</span><br><span class="line">  <span class="keyword">global</span>._foo = <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = <span class="keyword">global</span>._foo;</span><br></pre></td></tr></table></figure>
<p>然后，加载上面的<code>mod.js</code>。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.foo);</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量<code>a</code>任何时候加载的都是<code>A</code>的同一个实例。</p>
<p>但是，这里有一个问题，全局变量<code>global._foo</code>是可写的，任何文件都可以修改。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">global</span>._foo = &#123; foo: <span class="string">'world'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);</span><br><span class="line"><span class="built_in">console</span>.log(a.foo);</span><br></pre></td></tr></table></figure>
<p>上面的代码，会使得加载<code>mod.js</code>的脚本都失真。</p>
<p>为了防止这种情况出现，我们就可以使用 Symbol。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">const</span> FOO_KEY = Symbol.<span class="keyword">for</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">A</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  this.foo = <span class="string">'hello'</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (!<span class="keyword">global</span>[FOO_KEY]) &#123;</span><br><span class="line">  <span class="keyword">global</span>[FOO_KEY] = <span class="keyword">new</span> A();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">module.exports = <span class="keyword">global</span>[FOO_KEY];</span><br></pre></td></tr></table></figure>
<p>上面代码中，可以保证<code>global[FOO_KEY]</code>不会被无意间覆盖，但还是可以被改写。</p>
<figure class="highlight livescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">global</span>[Symbol.<span class="keyword">for</span>(<span class="string">'foo'</span>)] = &#123; foo: <span class="string">'world'</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="built_in">require</span>(<span class="string">'./mod.js'</span>);</span><br></pre></td></tr></table></figure>
<p>如果键名使用<code>Symbol</code>方法生成，那么外部将无法引用这个值，当然也就无法改写。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// mod.js</span></span><br><span class="line"><span class="keyword">const</span> FOO_KEY = <span class="built_in">Symbol</span>(<span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 后面代码相同 ……</span></span><br></pre></td></tr></table></figure>
<p>上面代码将导致其他脚本都无法引用<code>FOO_KEY</code>。但这样也有一个问题，就是如果多次执行这个脚本，每次得到的<code>FOO_KEY</code>都是不一样的。虽然 Node 会将脚本的执行结果缓存，一般情况下，不会多次执行同一个脚本，但是用户可以手动清除缓存，所以也不是绝对可靠。</p>
<h2 id="内置的-Symbol-值"><a href="#内置的-Symbol-值" class="headerlink" title="内置的 Symbol 值"></a>内置的 Symbol 值</h2><p>除了定义自己使用的 Symbol 值以外，ES6 还提供了 11 个内置的 Symbol 值，指向语言内部使用的方法。</p>
<h3 id="Symbol-hasInstance"><a href="#Symbol-hasInstance" class="headerlink" title="Symbol.hasInstance"></a>Symbol.hasInstance</h3><p>对象的<code>Symbol.hasInstance</code>属性，指向一个内部方法。当其他对象使用<code>instanceof</code>运算符，判断是否为该对象的实例时，会调用这个方法。比如，<code>foo instanceof Foo</code>在语言内部，实际调用的是<code>Foo[Symbol.hasInstance](foo)</code>。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">class MyClass &#123;</span><br><span class="line">  [<span class="string">Symbol.hasInstance</span>](<span class="link">foo</span>) &#123;</span><br><span class="line"><span class="code">    return foo instanceof Array;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">[1, 2, 3] instanceof new MyClass() // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>MyClass</code>是一个类，<code>new MyClass()</code>会返回一个实例。该实例的<code>Symbol.hasInstance</code>方法，会在进行<code>instanceof</code>运算时自动调用，判断左侧的运算子是否为<code>Array</code>的实例。</p>
<p>下面是另一个例子。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">class Even &#123;</span><br><span class="line">  static [<span class="string">Symbol.hasInstance</span>](<span class="link">obj</span>) &#123;</span><br><span class="line"><span class="code">    return Number(obj) % 2 === 0;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="code">    </span></span><br><span class="line">// 等同于</span><br><span class="line">const Even = &#123;</span><br><span class="line">  [<span class="string">Symbol.hasInstance</span>](<span class="link">obj</span>) &#123;</span><br><span class="line"><span class="code">    return Number(obj) % 2 === 0;</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">1 instanceof Even // false</span><br><span class="line">2 instanceof Even // true</span><br><span class="line">12345 instanceof Even // false</span><br></pre></td></tr></table></figure>
<h3 id="Symbol-isConcatSpreadable"><a href="#Symbol-isConcatSpreadable" class="headerlink" title="Symbol.isConcatSpreadable"></a>Symbol.isConcatSpreadable</h3><p>对象的<code>Symbol.isConcatSpreadable</code>属性等于一个布尔值，表示该对象用于<code>Array.prototype.concat()</code>时，是否可以展开。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let arr1 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr1, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br><span class="line">arr1[<span class="symbol">Symbol</span>.isConcatSpreadable] // undefined</span><br><span class="line">    </span><br><span class="line">let arr2 = [<span class="string">'c'</span>, <span class="string">'d'</span>];</span><br><span class="line">arr2[<span class="symbol">Symbol</span>.isConcatSpreadable] = false;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(arr2, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, [<span class="string">'c'</span>,<span class="string">'d'</span>], <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码说明，数组的默认行为是可以展开，<code>Symbol.isConcatSpreadable</code>默认等于<code>undefined</code>。该属性等于<code>true</code>时，也有展开的效果。</p>
<p>类似数组的对象正好相反，默认不展开。它的<code>Symbol.isConcatSpreadable</code>属性设为<code>true</code>，才可以展开。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;length: <span class="number">2</span>, <span class="number">0</span>: <span class="string">'c'</span>, <span class="number">1</span>: <span class="string">'d'</span>&#125;;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, obj, <span class="string">'e'</span>]</span><br><span class="line"></span><br><span class="line">obj[<span class="symbol">Symbol</span>.isConcatSpreadable] = true;</span><br><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>].concat(obj, <span class="string">'e'</span>) // [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span>]</span><br></pre></td></tr></table></figure>
<p><code>Symbol.isConcatSpreadable</code>属性也可以定义在类里面。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A1</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  constructor(args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(args);</span><br><span class="line">    <span class="keyword">this</span>[<span class="type">Symbol</span>.isConcatSpreadable] = <span class="literal">true</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">A2</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  constructor(args) &#123;</span><br><span class="line">    <span class="keyword">super</span>(args);</span><br><span class="line">  &#125;</span><br><span class="line">  get [<span class="type">Symbol</span>.isConcatSpreadable] () &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let a1 = <span class="keyword">new</span> <span class="type">A1</span>();</span><br><span class="line">a1[<span class="number">0</span>] = <span class="number">3</span>;</span><br><span class="line">a1[<span class="number">1</span>] = <span class="number">4</span>;</span><br><span class="line">let a2 = <span class="keyword">new</span> <span class="type">A2</span>();</span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">5</span>;</span><br><span class="line">a2[<span class="number">1</span>] = <span class="number">6</span>;</span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>].concat(a1).concat(a2)</span><br><span class="line"><span class="comment">// [1, 2, 3, 4, [5, 6]]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，类<code>A1</code>是可展开的，类<code>A2</code>是不可展开的，所以使用<code>concat</code>时有不一样的结果。</p>
<p>注意，<code>Symbol.isConcatSpreadable</code>的位置差异，<code>A1</code>是定义在实例上，<code>A2</code>是定义在类本身，效果相同。</p>
<h3 id="Symbol-species"><a href="#Symbol-species" class="headerlink" title="Symbol.species"></a>Symbol.species</h3><p>对象的<code>Symbol.species</code>属性，指向一个构造函数。创建衍生对象时，会使用该属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> MyArray(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>);</span><br><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"><span class="keyword">const</span> c = a.filter(<span class="function"><span class="params">x</span> =&gt;</span> x &gt; <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> MyArray <span class="comment">// true</span></span><br><span class="line">c <span class="keyword">instanceof</span> MyArray <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，子类<code>MyArray</code>继承了父类<code>Array</code>，<code>a</code>是<code>MyArray</code>的实例，<code>b</code>和<code>c</code>是<code>a</code>的衍生对象。你可能会认为，<code>b</code>和<code>c</code>都是调用数组方法生成的，所以应该是数组（<code>Array</code>的实例），但实际上它们也是<code>MyArray</code>的实例。</p>
<p><code>Symbol.species</code>属性就是为了解决这个问题而提供的。现在，我们可以为<code>MyArray</code>设置<code>Symbol.species</code>属性。</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  static get [<span class="type">Symbol</span>.species]() &#123; <span class="keyword">return</span> <span class="type">Array</span>; &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于定义了<code>Symbol.species</code>属性，创建衍生对象时就会使用这个属性返回的函数，作为构造函数。这个例子也说明，定义<code>Symbol.species</code>属性要采用<code>get</code>取值器。默认的<code>Symbol.species</code>属性等同于下面的写法。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">static get [<span class="string">Symbol.species</span>](<span class="link"></span>) &#123;</span><br><span class="line">  return this;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>现在，再来看前面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span> </span>&#123;</span><br><span class="line">  <span class="keyword">static</span> get [<span class="built_in">Symbol</span>.species]() &#123; <span class="keyword">return</span> <span class="built_in">Array</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> a = <span class="keyword">new</span> MyArray();</span><br><span class="line"><span class="keyword">const</span> b = a.map(<span class="function"><span class="params">x</span> =&gt;</span> x);</span><br><span class="line"></span><br><span class="line">b <span class="keyword">instanceof</span> MyArray <span class="comment">// false</span></span><br><span class="line">b <span class="keyword">instanceof</span> <span class="built_in">Array</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>a.map(x =&gt; x)</code>生成的衍生对象，就不是<code>MyArray</code>的实例，而直接就是<code>Array</code>的实例。</p>
<p>再看一个例子。<br><figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T1</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">T2</span> <span class="keyword">extends</span> <span class="title">Promise</span> </span>&#123;</span><br><span class="line">  static get [<span class="type">Symbol</span>.species]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="type">Promise</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="type">T1</span>(r =&gt; r()).then(v =&gt; v) instanceof <span class="type">T1</span> <span class="comment">// true</span></span><br><span class="line"><span class="keyword">new</span> <span class="type">T2</span>(r =&gt; r()).then(v =&gt; v) instanceof <span class="type">T2</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>T2</code>定义了<code>Symbol.species</code>属性，<code>T1</code>没有。结果就导致了创建衍生对象时（<code>then</code>方法），<code>T1</code>调用的是自身的构造方法，而<code>T2</code>调用的是<code>Promise</code>的构造方法。</p>
<p>总之，<code>Symbol.species</code>的作用在于，实例对象在运行过程中，需要再次调用自身的构造函数时，会调用该属性指定的构造函数。它主要的用途是，有些类库是在基类的基础上修改的，那么子类使用继承的方法时，作者可能希望返回基类的实例，而不是子类的实例。</p>
<h3 id="Symbol-match"><a href="#Symbol-match" class="headerlink" title="Symbol.match"></a>Symbol.match</h3><p>对象的<code>Symbol.match</code>属性，指向一个函数。当执行<code>str.match(myObject)</code>时，如果该属性存在，会调用它，返回该方法的返回值。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.match(regexp)</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">regexp[Symbol.match](<span class="keyword">this</span>)</span><br><span class="line"></span><br><span class="line"><span class="keyword">class</span> <span class="title">MyMatcher</span> &#123;</span><br><span class="line">    [<span class="meta">Symbol.match</span>](<span class="keyword">string</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'hello world'</span>.indexOf(<span class="keyword">string</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="string">'e'</span>.match(<span class="keyword">new</span> MyMatcher()) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="Symbol-replace"><a href="#Symbol-replace" class="headerlink" title="Symbol.replace"></a>Symbol.replace</h3><p>对象的<code>Symbol.replace</code>属性，指向一个方法，当该对象被<code>String.prototype.replace</code>方法调用时，会返回该方法的返回值。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.replace(searchValue, replaceValue)</span><br><span class="line">// 等同于</span><br><span class="line">searchValue[<span class="string">Symbol.replace</span>](<span class="link">this, replaceValue</span>)</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const x = &#123;&#125;;</span><br><span class="line">x[Symbol.replace] = <span class="function"><span class="params">(...s)</span> =&gt;</span> <span class="built_in">console</span>.log(s);</span><br><span class="line"></span><br><span class="line"><span class="string">'Hello'</span>.replace(x, <span class="string">'World'</span>) <span class="regexp">//</span> [<span class="string">"Hello"</span>, <span class="string">"World"</span>]</span><br></pre></td></tr></table></figure>
<p><code>Symbol.replace</code>方法会收到两个参数，第一个参数是<code>replace</code>方法正在作用的对象，上面例子是<code>Hello</code>，第二个参数是替换后的值，上面例子是<code>World</code>。</p>
<h3 id="Symbol-search"><a href="#Symbol-search" class="headerlink" title="Symbol.search"></a>Symbol.search</h3><p>对象的<code>Symbol.search</code>属性，指向一个方法，当该对象被<code>String.prototype.search</code>方法调用时，会返回该方法的返回值。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.search(regexp)</span><br><span class="line">// 等同于</span><br><span class="line">regexp[<span class="string">Symbol.search</span>](<span class="link">this</span>)</span><br><span class="line"></span><br><span class="line">class MySearch &#123;</span><br><span class="line">  constructor(value) &#123;</span><br><span class="line"><span class="code">    this.value = value;</span></span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="string">Symbol.search</span>](<span class="link">string</span>) &#123;</span><br><span class="line"><span class="code">    return string.indexOf(this.value);</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">'foobar'.search(new MySearch('foo')) // 0</span><br></pre></td></tr></table></figure>
<h3 id="Symbol-split"><a href="#Symbol-split" class="headerlink" title="Symbol.split"></a>Symbol.split</h3><p>对象的<code>Symbol.split</code>属性，指向一个方法，当该对象被<code>String.prototype.split</code>方法调用时，会返回该方法的返回值。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">String.prototype.split(separator, limit)</span><br><span class="line">// 等同于</span><br><span class="line">separator[<span class="string">Symbol.split</span>](<span class="link">this, limit</span>)</span><br></pre></td></tr></table></figure>
<p>下面是一个例子。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">class</span> <span class="title">MySplitter</span> &#123;</span><br><span class="line">  constructor(<span class="keyword">value</span>) &#123;</span><br><span class="line">    <span class="keyword">this</span>.<span class="keyword">value</span> = <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  [<span class="meta">Symbol.split</span>](<span class="keyword">string</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> index = <span class="keyword">string</span>.indexOf(<span class="keyword">this</span>.<span class="keyword">value</span>);</span><br><span class="line">    <span class="keyword">if</span> (index === <span class="number">-1</span>) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">string</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [</span><br><span class="line">      <span class="keyword">string</span>.substr(<span class="number">0</span>, index),</span><br><span class="line">      <span class="keyword">string</span>.substr(index + <span class="keyword">this</span>.<span class="keyword">value</span>.length)</span><br><span class="line">    ];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'foo'</span>))</span><br><span class="line"><span class="comment">// ['', 'bar']</span></span><br><span class="line"></span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'bar'</span>))</span><br><span class="line"><span class="comment">// ['foo', '']</span></span><br><span class="line"></span><br><span class="line"><span class="string">'foobar'</span>.split(<span class="keyword">new</span> MySplitter(<span class="string">'baz'</span>))</span><br><span class="line"><span class="comment">// 'foobar'</span></span><br></pre></td></tr></table></figure>
<p>上面方法使用<code>Symbol.split</code>方法，重新定义了字符串对象的<code>split</code>方法的行为，</p>
<h3 id="Symbol-iterator"><a href="#Symbol-iterator" class="headerlink" title="Symbol.iterator"></a>Symbol.iterator</h3><p>对象的<code>Symbol.iterator</code>属性，指向该对象的默认遍历器方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> myIterable = &#123;&#125;;</span><br><span class="line">myIterable[<span class="built_in">Symbol</span>.iterator] = <span class="function"><span class="keyword">function</span>* (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...myIterable] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>对象进行<code>for...of</code>循环时，会调用<code>Symbol.iterator</code>方法，返回该对象的默认遍历器，详细介绍参见《Iterator 和 for…of 循环》一章。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  *[<span class="built_in">Symbol</span>.iterator]() &#123;</span><br><span class="line">    <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span>(<span class="keyword">this</span>[i] !== <span class="literal">undefined</span>) &#123;</span><br><span class="line">      <span class="keyword">yield</span> <span class="keyword">this</span>[i];</span><br><span class="line">      ++i;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> myCollection = <span class="keyword">new</span> Collection();</span><br><span class="line">myCollection[<span class="number">0</span>] = <span class="number">1</span>;</span><br><span class="line">myCollection[<span class="number">1</span>] = <span class="number">2</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> myCollection) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<h3 id="Symbol-toPrimitive"><a href="#Symbol-toPrimitive" class="headerlink" title="Symbol.toPrimitive"></a>Symbol.toPrimitive</h3><p>对象的<code>Symbol.toPrimitive</code>属性，指向一个方法。该对象被转为原始类型的值时，会调用这个方法，返回该对象对应的原始类型值。</p>
<p><code>Symbol.toPrimitive</code>被调用时，会接受一个字符串参数，表示当前运算的模式，一共有三种模式。</p>
<ul>
<li>Number：该场合需要转成数值</li>
<li>String：该场合需要转成字符串</li>
<li>Default：该场合可以转成数值，也可以转成字符串</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  [<span class="built_in">Symbol</span>.toPrimitive](hint) &#123;</span><br><span class="line">    <span class="keyword">switch</span> (hint) &#123;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'number'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="number">123</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'string'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'str'</span>;</span><br><span class="line">      <span class="keyword">case</span> <span class="string">'default'</span>:</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'default'</span>;</span><br><span class="line">      <span class="keyword">default</span>:</span><br><span class="line">        <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>();</span><br><span class="line">     &#125;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line"><span class="number">2</span> * obj <span class="comment">// 246</span></span><br><span class="line"><span class="number">3</span> + obj <span class="comment">// '3default'</span></span><br><span class="line">obj == <span class="string">'default'</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">String</span>(obj) <span class="comment">// 'str'</span></span><br></pre></td></tr></table></figure>
<h3 id="Symbol-toStringTag"><a href="#Symbol-toStringTag" class="headerlink" title="Symbol.toStringTag"></a>Symbol.toStringTag</h3><p>对象的<code>Symbol.toStringTag</code>属性，指向一个方法。在该对象上面调用<code>Object.prototype.toString</code>方法时，如果这个属性存在，它的返回值会出现在<code>toString</code>方法返回的字符串之中，表示对象的类型。也就是说，这个属性可以用来定制<code>[object Object]</code>或<code>[object Array]</code>中<code>object</code>后面的那个字符串。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line">(&#123;[<span class="built_in">Symbol</span>.toStringTag]: <span class="string">'Foo'</span>&#125;.toString())</span><br><span class="line"><span class="comment">// "[object Foo]"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</span><br><span class="line">  <span class="keyword">get</span> [<span class="built_in">Symbol</span>.toStringTag]() &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'xxx'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">let x = <span class="keyword">new</span> Collection();</span><br><span class="line"><span class="built_in">Object</span>.prototype.toString.call(x) <span class="comment">// "[object xxx]"</span></span><br></pre></td></tr></table></figure>
<p>ES6 新增内置对象的<code>Symbol.toStringTag</code>属性值如下。</p>
<ul>
<li><code>JSON[Symbol.toStringTag]</code>：’JSON’</li>
<li><code>Math[Symbol.toStringTag]</code>：’Math’</li>
<li>Module 对象<code>M[Symbol.toStringTag]</code>：’Module’</li>
<li><code>ArrayBuffer.prototype[Symbol.toStringTag]</code>：’ArrayBuffer’</li>
<li><code>DataView.prototype[Symbol.toStringTag]</code>：’DataView’</li>
<li><code>Map.prototype[Symbol.toStringTag]</code>：’Map’</li>
<li><code>Promise.prototype[Symbol.toStringTag]</code>：’Promise’</li>
<li><code>Set.prototype[Symbol.toStringTag]</code>：’Set’</li>
<li><code>%TypedArray%.prototype[Symbol.toStringTag]</code>：’Uint8Array’等</li>
<li><code>WeakMap.prototype[Symbol.toStringTag]</code>：’WeakMap’</li>
<li><code>WeakSet.prototype[Symbol.toStringTag]</code>：’WeakSet’</li>
<li><code>%MapIteratorPrototype%[Symbol.toStringTag]</code>：’Map Iterator’</li>
<li><code>%SetIteratorPrototype%[Symbol.toStringTag]</code>：’Set Iterator’</li>
<li><code>%StringIteratorPrototype%[Symbol.toStringTag]</code>：’String Iterator’</li>
<li><code>Symbol.prototype[Symbol.toStringTag]</code>：’Symbol’</li>
<li><code>Generator.prototype[Symbol.toStringTag]</code>：’Generator’</li>
<li><code>GeneratorFunction.prototype[Symbol.toStringTag]</code>：’GeneratorFunction’</li>
</ul>
<h3 id="Symbol-unscopables"><a href="#Symbol-unscopables" class="headerlink" title="Symbol.unscopables"></a>Symbol.unscopables</h3><p>对象的<code>Symbol.unscopables</code>属性，指向一个对象。该对象指定了使用<code>with</code>关键字时，哪些属性会被<code>with</code>环境排除。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Array.prototype[Symbol.unscopables]</span></span><br><span class="line"><span class="string">//</span> <span class="string">&#123;</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">copyWithin:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">entries:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">fill:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">find:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">findIndex:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">includes:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">keys:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">//</span> <span class="string">&#125;</span></span><br><span class="line">    </span><br><span class="line"><span class="string">Object.keys(Array.prototype[Symbol.unscopables])</span></span><br><span class="line"><span class="string">//</span> <span class="string">['copyWithin',</span> <span class="string">'entries'</span><span class="string">,</span> <span class="string">'fill'</span><span class="string">,</span> <span class="string">'find'</span><span class="string">,</span> <span class="string">'findIndex'</span><span class="string">,</span> <span class="string">'includes'</span><span class="string">,</span> <span class="string">'keys'</span><span class="string">]</span></span><br></pre></td></tr></table></figure>
<p>上面代码说明，数组有 7 个属性，会被<code>with</code>命令排除。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 没有 unscopables 时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  foo() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">  foo(); <span class="comment">// 1</span></span><br><span class="line">&#125;</span><br><span class="line">    </span><br><span class="line"><span class="comment">// 有 unscopables 时</span></span><br><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyClass</span> </span>&#123;</span><br><span class="line">  foo() &#123; <span class="keyword">return</span> <span class="number">1</span>; &#125;</span><br><span class="line">  <span class="keyword">get</span> [Symbol.unscopables]() &#123;</span><br><span class="line">    <span class="keyword">return</span> &#123; foo: <span class="literal">true</span> &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> foo = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">2</span>; &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">with</span> (MyClass.prototype) &#123;</span><br><span class="line">  foo(); <span class="comment">// 2</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码通过指定<code>Symbol.unscopables</code>属性，使得<code>with</code>语法块不会在当前作用域寻找<code>foo</code>属性，即<code>foo</code>将指向外层作用域的变量。</p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 09.对象的扩展]]></title>
      <url>/2018/06/19/ES6/09.%E5%AF%B9%E8%B1%A1%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h1 id="对象的扩展"><a href="#对象的扩展" class="headerlink" title="对象的扩展"></a>对象的扩展</h1><h2 id="1-属性的简洁表示法"><a href="#1-属性的简洁表示法" class="headerlink" title="1.属性的简洁表示法 "></a>1.属性的简洁表示法 </h2><p>ES6 允许直接写入变量和函数，作为对象的属性和方法。这样的书写更加简洁。<br>    <figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123;foo&#125;;</span><br><span class="line">baz <span class="comment">// &#123;foo: "bar"&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">const</span> baz = &#123;<span class="attr">foo</span>: foo&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码表明，ES6 允许在对象之中，直接写变量。这时，属性名为变量名, 属性值为变量的值。下面是另一个例子。<br>    <figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;x: x, y: y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// Object &#123;x: 1, y: 2&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>除了属性简写，方法也可以简写。</p>
 <figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> o = &#123;</span><br><span class="line">   <span class="function"><span class="keyword">method</span>(</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br><span class="line"> </span><br><span class="line"> // 等同于</span><br><span class="line"> </span><br><span class="line"> <span class="keyword">const</span> o = &#123;</span><br><span class="line">   <span class="function"><span class="keyword">method</span>:</span> <span class="function"><span class="keyword">function</span>(</span>) &#123;</span><br><span class="line">     <span class="keyword">return</span> <span class="string">"Hello!"</span>;</span><br><span class="line">   &#125;</span><br><span class="line"> &#125;;</span><br></pre></td></tr></table></figure>
<p>下面是一个实际的例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> birth = <span class="string">'2000/01/01'</span>;</span><br><span class="line">    </span><br><span class="line"><span class="keyword">const</span> Person = &#123;</span><br><span class="line"></span><br><span class="line">  name: <span class="string">'张三'</span>,</span><br><span class="line"></span><br><span class="line">  <span class="comment">//等同于birth: birth</span></span><br><span class="line">  birth,</span><br><span class="line"></span><br><span class="line">  <span class="comment">// 等同于hello: function ()...</span></span><br><span class="line">  hello() &#123; <span class="built_in">console</span>.log(<span class="string">'我的名字是'</span>, <span class="keyword">this</span>.name); &#125;</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>这种写法用于函数的返回值，将会非常方便。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getPoint</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">const</span> y = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">return</span> &#123;x, y&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">getPoint()</span><br><span class="line"><span class="comment">// &#123;x:1, y:10&#125;</span></span><br></pre></td></tr></table></figure>
<p>CommonJS 模块输出一组变量，就非常合适使用简洁写法。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ms = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getItem</span> (<span class="params">key</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> key <span class="keyword">in</span> ms ? ms[key] : <span class="literal">null</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">setItem</span> (<span class="params">key, value</span>) </span>&#123;</span><br><span class="line">  ms[key] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clear</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  ms = &#123;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">module</span>.exports = &#123; getItem, setItem, clear &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">module</span>.exports = &#123;</span><br><span class="line">  getItem: getItem,</span><br><span class="line">  setItem: setItem,</span><br><span class="line">  clear: clear</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>属性的赋值器（setter）和取值器（getter），事实上也是采用这种写法。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> cart = &#123;</span><br><span class="line">  _wheels: <span class="number">4</span>,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">wheels</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">this</span>._wheels;</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">set</span> <span class="title">wheels</span> (<span class="params"><span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">value</span> &lt; <span class="keyword">this</span>._wheels) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'数值太小了！'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">this</span>._wheels = <span class="keyword">value</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>注意，简洁写法的属性名总是字符串，这会导致一些看上去比较奇怪的结果。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="class"><span class="keyword">class</span> () </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">    </span><br><span class="line"><span class="keyword">var</span> obj = &#123;</span><br><span class="line">  <span class="string">'class'</span>: <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>class</code>是字符串，所以不会因为它属于关键字，而导致语法解析报错。</p>
<p>如果某个方法的值是一个 Generator 函数，前面需要加上星号。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  * m() &#123;</span><br><span class="line">    <span class="built_in">yield</span> <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h2 id="属性名表达式"><a href="#属性名表达式" class="headerlink" title="属性名表达式"></a>属性名表达式</h2><p>JavaScript 定义对象的属性，有两种方法。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">obj.foo = <span class="literal">true</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line">obj[<span class="string">'a'</span> + <span class="string">'bc'</span>] = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码的方法一是直接用标识符作为属性名，方法二是用表达式作为属性名，这时要将表达式放在方括号之内。</p>
<p>但是，如果使用字面量方式定义对象（使用大括号），在 ES5 中只能使用方法一（标识符）定义属性。</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  foo:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="attr">  abc:</span> <span class="number">123</span></span><br><span class="line"><span class="string">&#125;;</span></span><br></pre></td></tr></table></figure>
<p>ES6 允许字面量定义对象时，用方法二（表达式）作为对象的属性名，即把表达式放在方括号内。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let propKey</span> = <span class="string">'foo'</span>;</span><br><span class="line"></span><br><span class="line"><span class="attribute">let obj</span> = &#123;</span><br><span class="line">  [propKey]: true,</span><br><span class="line">  [<span class="string">'a'</span> + <span class="string">'bc'</span>]: 123</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>下面是另一个例子。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let lastWord = <span class="string">'last word'</span>;</span><br><span class="line"></span><br><span class="line">const a = &#123;</span><br><span class="line">  <span class="string">'first word'</span>: <span class="string">'hello'</span>,</span><br><span class="line">  [lastWord]: <span class="string">'world'</span></span><br><span class="line">&#125;;</span><br><span class="line">    </span><br><span class="line">a[<span class="string">'first word'</span>] // <span class="string">"hello"</span></span><br><span class="line">a[lastWord] // <span class="string">"world"</span></span><br><span class="line">a[<span class="string">'last word'</span>] // <span class="string">"world"</span></span><br></pre></td></tr></table></figure>
<p>表达式还可以用于定义方法名。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;</span><br><span class="line">  [<span class="string">'h' + 'ello'</span>](<span class="link"></span>) &#123;</span><br><span class="line"><span class="code">    return 'hi';</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.hello() // hi</span><br></pre></td></tr></table></figure>
<p>注意，属性名表达式与简洁表示法，不能同时使用，会报错。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">const</span> bar = <span class="string">'abc'</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo] &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 正确</span></span><br><span class="line"><span class="keyword">const</span> foo = <span class="string">'bar'</span>;</span><br><span class="line"><span class="keyword">const</span> baz = &#123; [foo]: <span class="string">'abc'</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>注意，属性名表达式如果是一个对象，默认情况下会自动将对象转为字符串<code>[object Object]</code>，这一点要特别小心。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> keyA = &#123;a: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> keyB = &#123;b: <span class="number">2</span>&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> myObject = &#123;</span><br><span class="line">  [<span class="meta">keyA</span>]: <span class="string">'valueA'</span>,</span><br><span class="line">  [<span class="meta">keyB</span>]: <span class="string">'valueB'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">myObject <span class="comment">// Object &#123;[object Object]: "valueB"&#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>[keyA]</code>和<code>[keyB]</code>得到的都是<code>[object Object]</code>，所以<code>[keyB]</code>会把<code>[keyA]</code>覆盖掉，而<code>myObject</code>最后只有一个<code>[object Object]</code>属性。</p>
<h2 id="方法的-name-属性"><a href="#方法的-name-属性" class="headerlink" title="方法的 name 属性"></a>方法的 name 属性</h2><p>函数的<code>name</code>属性，返回函数名。对象方法也是函数，因此也有<code>name</code>属性。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> person = &#123;</span><br><span class="line">  sayName() &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(<span class="string">'hello!'</span>)<span class="comment">;</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;<span class="comment">;</span></span><br><span class="line">    </span><br><span class="line">person.sayName.name   // <span class="string">"sayName"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，方法的<code>name</code>属性返回函数名（即方法名）。</p>
<p>如果对象的方法使用了取值函数（<code>getter</code>）和存值函数（<code>setter</code>），则<code>name</code>属性不是在该方法上面，而是该方法的属性的描述对象的<code>get</code>和<code>set</code>属性上面，返回值是方法名前加上<code>get</code>和<code>set</code>。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;&#125;,</span><br><span class="line">  <span class="function"><span class="keyword">set</span> <span class="title">foo</span>(<span class="params">x</span>) </span>&#123;&#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">obj.foo.name</span><br><span class="line"><span class="comment">// TypeError: Cannot read property 'name' of undefined</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> descriptor = Object.getOwnPropertyDescriptor(obj, <span class="string">'foo'</span>);</span><br><span class="line"></span><br><span class="line">descriptor.<span class="keyword">get</span>.name <span class="comment">// "get foo"</span></span><br><span class="line">descriptor.<span class="keyword">set</span>.name <span class="comment">// "set foo"</span></span><br></pre></td></tr></table></figure>
<p>有两种特殊情况：<code>bind</code>方法创造的函数，<code>name</code>属性返回<code>bound</code>加上原函数的名字；<code>Function</code>构造函数创造的函数，<code>name</code>属性返回<code>anonymous</code>。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(new <span class="function"><span class="keyword">Function</span><span class="params">()</span></span>).<span class="keyword">name</span> // <span class="string">"anonymous"</span></span><br><span class="line"></span><br><span class="line">var doSomething = <span class="function"><span class="keyword">function</span><span class="params">()</span></span> &#123;</span><br><span class="line">  // ...</span><br><span class="line">&#125;;</span><br><span class="line">doSomething.<span class="keyword">bind</span>().<span class="keyword">name</span> // <span class="string">"bound doSomething"</span></span><br></pre></td></tr></table></figure>
<p>如果对象的方法是一个 Symbol 值，那么<code>name</code>属性返回的是这个 Symbol 值的描述。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const key1 = Symbol('description');</span><br><span class="line">const key2 = Symbol();</span><br><span class="line">let obj = &#123;</span><br><span class="line">  [<span class="string">key1</span>](<span class="link"></span>) &#123;&#125;,</span><br><span class="line">  [<span class="string">key2</span>](<span class="link"></span>) &#123;&#125;,</span><br><span class="line">&#125;;</span><br><span class="line">obj[key1].name // "[description]"</span><br><span class="line">obj[key2].name // ""</span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>key1</code>对应的 Symbol 值有描述，<code>key2</code>没有。</p>
<h2 id="Object-is"><a href="#Object-is" class="headerlink" title="Object.is()"></a>Object.is()</h2><p>ES5 比较两个值是否相等，只有两个运算符：相等运算符（<code>==</code>）和严格相等运算符（<code>===</code>）。它们都有缺点，前者会自动转换数据类型，后者的<code>NaN</code>不等于自身，以及<code>+0</code>等于<code>-0</code>。JavaScript 缺乏一种运算，在所有环境中，只要两个值是一样的，它们就应该相等。</p>
<p>ES6 提出“Same-value equality”（同值相等）算法，用来解决这个问题。<code>Object.is</code>就是部署这个算法的新方法。它用来比较两个值是否严格相等，与严格比较运算符（===）的行为基本一致。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(<span class="string">'foo'</span>, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.<span class="keyword">is</span>(&#123;&#125;, &#123;&#125;)</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>不同之处只有两个：一是<code>+0</code>不等于<code>-0</code>，二是<code>NaN</code>等于自身。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">+<span class="number">0</span> === <span class="number">-0</span> <span class="comment">//true</span></span><br><span class="line"><span class="literal">NaN</span> === <span class="literal">NaN</span> <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.is(+<span class="number">0</span>, <span class="number">-0</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Object</span>.is(<span class="literal">NaN</span>, <span class="literal">NaN</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>ES5 可以通过下面的代码，部署<code>Object.is</code>。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>, <span class="string">'is'</span>, &#123;</span><br><span class="line">  value: <span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (x === y) &#123;</span><br><span class="line">      <span class="comment">// 针对+0 不等于 -0的情况</span></span><br><span class="line">      <span class="keyword">return</span> x !== <span class="number">0</span> || <span class="number">1</span> / x === <span class="number">1</span> / y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">// 针对NaN的情况</span></span><br><span class="line">    <span class="keyword">return</span> x !== x &amp;&amp; y !== y;</span><br><span class="line">  &#125;,</span><br><span class="line">  configurable: <span class="literal">true</span>,</span><br><span class="line">  enumerable: <span class="literal">false</span>,</span><br><span class="line">  writable: <span class="literal">true</span></span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure></p>
<h2 id="Object-assign"><a href="#Object-assign" class="headerlink" title="Object.assign()"></a>Object.assign()</h2><h3 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h3><p><code>Object.assign</code>方法用于对象的合并，将源对象（source）的所有可枚举属性，复制到目标对象（target）。</p>
<figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">target</span> = &#123; a: 1 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; b: 2 &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(<span class="keyword">target</span>, source1, source2);</span><br><span class="line"><span class="keyword">target</span> <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure>
<p><code>Object.assign</code>方法的第一个参数是目标对象，后面的参数都是源对象。</p>
<p>注意，如果目标对象与源对象有同名属性，或多个源对象有同名属性，则后面的属性会覆盖前面的属性。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="keyword">target</span> = &#123; a: 1, b: 1 &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> source1 = &#123; b: 2, c: 2 &#125;;</span><br><span class="line"><span class="keyword">const</span> source2 = &#123; c: 3 &#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(<span class="keyword">target</span>, source1, source2);</span><br><span class="line"><span class="keyword">target</span> <span class="comment">// &#123;a:1, b:2, c:3&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果只有一个参数，<code>Object.assign</code>会直接返回该参数。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="comment">&#123;a: 1&#125;</span>;</span><br><span class="line"><span class="keyword">Object</span>.assign(obj) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>如果该参数不是对象，则会先转成对象，然后返回。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> <span class="built_in">Object</span>.assign(<span class="number">2</span>) <span class="comment">// "object"</span></span><br></pre></td></tr></table></figure></p>
<p>由于<code>undefined</code>和<code>null</code>无法转成对象，所以如果它们作为参数，就会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">undefined</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="built_in">Object</span>.assign(<span class="literal">null</span>) <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure></p>
<p>如果非对象参数出现在源对象的位置（即非首参数），那么处理规则有所不同。首先，这些参数都会转成对象，如果无法转成对象，就会跳过。这意味着，如果<code>undefined</code>和<code>null</code>不在首参数，就不会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">a</span>: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">undefined</span>) === obj <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.assign(obj, <span class="literal">null</span>) === obj <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>其他类型的值（即数值、字符串和布尔值）不在首参数，也不会报错。但是，除了字符串会以数组形式，拷贝入目标对象，其他值都不会产生效果。<br><figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> v1 = <span class="comment">'abc';</span></span><br><span class="line"><span class="keyword">const</span> v2 = <span class="literal">true</span>;</span><br><span class="line"><span class="keyword">const</span> v3 = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = Object.assign(&#123;&#125;, v1, v2, v3);</span><br><span class="line">console.<span class="built_in">log</span>(obj); // &#123; <span class="string">"0"</span>: <span class="string">"a"</span>, <span class="string">"1"</span>: <span class="string">"b"</span>, <span class="string">"2"</span>: <span class="string">"c"</span> &#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>v1</code>、<code>v2</code>、<code>v3</code>分别是字符串、布尔值和数值，结果只有字符串合入目标对象（以字符数组的形式），数值和布尔值都会被忽略。这是因为只有字符串的包装对象，会产生可枚举属性。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Object(<span class="literal">true</span>) // &#123;<span class="string">[[PrimitiveValue]]</span>: <span class="literal">true</span>&#125;</span><br><span class="line">Object(<span class="number">10</span>)  //  &#123;<span class="string">[[PrimitiveValue]]</span>: <span class="number">10</span>&#125;</span><br><span class="line">Object(<span class="string">'abc'</span>) // &#123;<span class="number">0</span>: <span class="string">"a"</span>, <span class="number">1</span>: <span class="string">"b"</span>, <span class="number">2</span>: <span class="string">"c"</span>, length: <span class="number">3</span>, <span class="string">[[PrimitiveValue]]</span>: <span class="string">"abc"</span>&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，布尔值、数值、字符串分别转成对应的包装对象，可以看到它们的原始值都在包装对象的内部属性<code>[[PrimitiveValue]]</code>上面，这个属性是不会被<code>Object.assign</code>拷贝的。只有字符串的包装对象，会产生可枚举的实义属性，那些属性则会被拷贝。</p>
<p><code>Object.assign</code>拷贝的属性是有限制的，只拷贝源对象的自身属性（不拷贝继承属性），也不拷贝不可枚举的属性（<code>enumerable: false</code>）。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Object</span><span class="selector-class">.assign</span>(&#123;<span class="attribute">b</span>: <span class="string">'c'</span>&#125;,</span><br><span class="line">  <span class="selector-tag">Object</span><span class="selector-class">.defineProperty</span>(&#123;&#125;, <span class="string">'invisible'</span>, &#123;</span><br><span class="line">    <span class="attribute">enumerable</span>: false,</span><br><span class="line">    <span class="attribute">value</span>: <span class="string">'hello'</span></span><br><span class="line">  &#125;)</span><br><span class="line">)</span><br><span class="line"><span class="comment">// &#123; b: 'c' &#125;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.assign</code>要拷贝的对象只有一个不可枚举属性<code>invisible</code>，这个属性并没有被拷贝进去。</p>
<p>属性名为 Symbol 值的属性，也会被<code>Object.assign</code>拷贝。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign(&#123; a: <span class="string">'b'</span> &#125;, &#123; [Symbol(<span class="string">'c'</span>)]: <span class="string">'d'</span> &#125;)</span><br><span class="line">// &#123; a: <span class="string">'b'</span>, Symbol(c): <span class="string">'d'</span> &#125;</span><br></pre></td></tr></table></figure>
<h3 id="注意点"><a href="#注意点" class="headerlink" title="注意点"></a>注意点</h3><p><strong>（1）浅拷贝</strong></p>
<p><code>Object.assign</code>方法实行的是浅拷贝，而不是深拷贝。也就是说，如果源对象某个属性的值是对象，那么目标对象拷贝得到的是这个对象的引用。<br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj1 = <span class="comment">&#123;a: &#123;b: 1&#125;</span>&#125;;</span><br><span class="line"><span class="keyword">const</span> obj2 = <span class="keyword">Object</span>.assign(<span class="comment">&#123;&#125;</span>, obj1);</span><br><span class="line"></span><br><span class="line">obj1.a.b = <span class="number">2</span>;</span><br><span class="line">obj2.a.b <span class="comment">// 2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，源对象<code>obj1</code>的<code>a</code>属性的值是一个对象，<code>Object.assign</code>拷贝得到的是这个对象的引用。这个对象的任何变化，都会反映到目标对象上面。</p>
<p><strong>（2）同名属性的替换</strong></p>
<p>对于这种嵌套的对象，一旦遇到同名属性，<code>Object.assign</code>的处理方法是替换，而不是添加。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const target = &#123; <span class="selector-tag">a</span>: &#123; <span class="selector-tag">b</span>: <span class="string">'c'</span>, d: <span class="string">'e'</span> &#125; &#125;</span><br><span class="line">const source = &#123; <span class="selector-tag">a</span>: &#123; <span class="selector-tag">b</span>: <span class="string">'hello'</span> &#125; &#125;</span><br><span class="line">Object.assign(target, source)</span><br><span class="line"><span class="comment">// &#123; a: &#123; b: 'hello' &#125; &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>target</code>对象的<code>a</code>属性被<code>source</code>对象的<code>a</code>属性整个替换掉了，而不会得到<code>{ a: { b: &#39;hello&#39;, d: &#39;e&#39; } }</code>的结果。这通常不是开发者想要的，需要特别小心。</p>
<p>一些函数库提供<code>Object.assign</code>的定制版本（比如 Lodash 的<code>_.defaultsDeep</code>方法），可以得到深拷贝的合并。</p>
<p><strong>（3）数组的处理</strong></p>
<p><code>Object.assign</code>可以用来处理数组，但是会把数组视为对象。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.assign([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], [<span class="number">4</span>, <span class="number">5</span>])</span><br><span class="line"><span class="comment">// [4, 5, 3]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，<code>Object.assign</code>把数组视为属性名为 0、1、2 的对象，因此源数组的 0 号属性<code>4</code>覆盖了目标数组的 0 号属性<code>1</code>。</p>
<p><strong>（4）取值函数的处理</strong></p>
<p><code>Object.assign</code>只能进行值的复制，如果要复制的值是一个取值函数，那么将求值后再复制。<br><figure class="highlight aspectj"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="function">get <span class="title">foo</span><span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="number">1</span> &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">target</span> = &#123;&#125;;</span><br><span class="line"></span><br><span class="line">Object.assign(<span class="keyword">target</span>, source)</span><br><span class="line"><span class="comment">// &#123; foo: 1 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>source</code>对象的<code>foo</code>属性是一个取值函数，<code>Object.assign</code>不会复制这个取值函数，只会拿到值以后，将这个值复制过去。</p>
<h3 id="常见用途"><a href="#常见用途" class="headerlink" title="常见用途"></a>常见用途</h3><p><code>Object.assign</code>方法有很多用处。</p>
<p><strong>（1）为对象添加属性</strong><br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Point</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(x, y) &#123;</span><br><span class="line">    <span class="built_in">Object</span>.assign(<span class="keyword">this</span>, &#123;x, y&#125;);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面方法通过<code>Object.assign</code>方法，将<code>x</code>属性和<code>y</code>属性添加到<code>Point</code>类的对象实例。</p>
<p><strong>（2）为对象添加方法</strong><br><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Object</span>.assign(SomeClass.prototype, <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">  someMethod(arg1, arg2) &#123;</span></span><br><span class="line"><span class="comment">    ···</span></span><br><span class="line"><span class="comment">  &#125;</span>,</span><br><span class="line">  anotherMethod() <span class="comment">&#123;</span></span><br><span class="line"><span class="comment">    ···</span></span><br><span class="line"><span class="comment">  &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于下面的写法</span></span><br><span class="line">SomeClass.prototype.someMethod = <span class="function"><span class="keyword">function</span> <span class="params">(arg1, arg2)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  ···</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>;</span></span><br><span class="line">SomeClass.prototype.anotherMethod = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  ···</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span>;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码使用了对象属性的简洁表示法，直接将两个函数放在大括号中，再使用<code>assign</code>方法添加到<code>SomeClass.prototype</code>之中。</p>
<p><strong>（3）克隆对象</strong><br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">clone</span>(origin) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">Object.assign(&#123;&#125;,</span> origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码将原始对象拷贝到一个空对象，就得到了原始对象的克隆。</p>
<p>不过，采用这种方法克隆，只能克隆原始对象自身的值，不能克隆它继承的值。如果想要保持继承链，可以采用下面的代码。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clone</span>(<span class="params">origin</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> originProto = <span class="built_in">Object</span>.getPrototypeOf(origin);</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>.assign(<span class="built_in">Object</span>.create(originProto), origin);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p><strong>（4）合并多个对象</strong></p>
<p>将多个对象合并到某个对象。<br><figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">merge</span> =</span><br><span class="line">  (<span class="keyword">target</span>, ...sources) =&gt; Object.<span class="keyword">assign</span>(<span class="keyword">target</span>, ...sources);</span><br></pre></td></tr></table></figure></p>
<p>如果希望合并后返回一个新对象，可以改写上面函数，对一个空对象合并。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> merge =</span><br><span class="line">  (...sources) =&gt; <span class="built_in">Object</span>.assign(&#123;&#125;, ...sources);</span><br></pre></td></tr></table></figure></p>
<p><strong>（5）为属性指定默认值</strong><br><figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">const DEFAULTS = &#123;</span><br><span class="line">  logLevel: <span class="number">0</span>,</span><br><span class="line">  outputFormat: <span class="string">'html'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">function processContent(<span class="keyword">options</span>) &#123;</span><br><span class="line">  <span class="keyword">options</span> = Object.<span class="keyword">assign</span>(&#123;&#125;, DEFAULTS, <span class="keyword">options</span>);</span><br><span class="line">  console.<span class="built-in">log</span>(<span class="keyword">options</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>DEFAULTS</code>对象是默认值，<code>options</code>对象是用户提供的参数。<code>Object.assign</code>方法将<code>DEFAULTS</code>和<code>options</code>合并成一个新对象，如果两者有同名属性，则<code>option</code>的属性值会覆盖<code>DEFAULTS</code>的属性值。</p>
<p>注意，由于存在浅拷贝的问题，<code>DEFAULTS</code>对象和<code>options</code>对象的所有属性的值，最好都是简单类型，不要指向另一个对象。否则，<code>DEFAULTS</code>对象的该属性很可能不起作用。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const DEFAULTS = &#123;</span><br><span class="line"><span class="symbol">  url:</span> &#123;</span><br><span class="line"><span class="symbol">    host:</span> <span class="string">'example.com'</span>,</span><br><span class="line"><span class="symbol">    port:</span> <span class="number">7070</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">processContent(&#123; <span class="string">url:</span> &#123;<span class="string">port:</span> <span class="number">8000</span>&#125; &#125;)</span><br><span class="line"><span class="comment">// &#123;</span></span><br><span class="line"><span class="comment">//   url: &#123;port: 8000&#125;</span></span><br><span class="line"><span class="comment">// &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码的原意是将<code>url.port</code>改成 8000，<code>url.host</code>不变。实际结果却是<code>options.url</code>覆盖掉<code>DEFAULTS.url</code>，所以<code>url.host</code>就不存在了。</p>
<h2 id="属性的可枚举性和遍历"><a href="#属性的可枚举性和遍历" class="headerlink" title="属性的可枚举性和遍历"></a>属性的可枚举性和遍历</h2><h3 id="可枚举性"><a href="#可枚举性" class="headerlink" title="可枚举性"></a>可枚举性</h3><p>对象的每个属性都有一个描述对象（Descriptor），用来控制该属性的行为。<code>Object.getOwnPropertyDescriptor</code>方法可以获取该属性的描述对象。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">let</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;</span> <span class="attr">foo:</span> <span class="number">123</span> <span class="string">&#125;;</span></span><br><span class="line"><span class="string">Object.getOwnPropertyDescriptor(obj,</span> <span class="string">'foo'</span><span class="string">)</span></span><br><span class="line"><span class="string">//</span>  <span class="string">&#123;</span></span><br><span class="line"><span class="string">//</span>    <span class="attr">value:</span> <span class="number">123</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>    <span class="attr">writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>    <span class="attr">enumerable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>    <span class="attr">configurable:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">//</span>  <span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>描述对象的<code>enumerable</code>属性，称为”可枚举性“，如果该属性为<code>false</code>，就表示某些操作会忽略当前属性。</p>
<p>目前，有四个操作会忽略<code>enumerable</code>为<code>false</code>的属性。</p>
<ul>
<li><code>for...in</code>循环：只遍历对象自身的和继承的可枚举的属性。</li>
<li><code>Object.keys()</code>：返回对象自身的所有可枚举的属性的键名。</li>
<li><code>JSON.stringify()</code>：只串行化对象自身的可枚举的属性。</li>
<li><code>Object.assign()</code>： 忽略<code>enumerable</code>为<code>false</code>的属性，只拷贝对象自身的可枚举的属性。</li>
</ul>
<p>这四个操作之中，前三个是 ES5 就有的，最后一个<code>Object.assign()</code>是 ES6 新增的。其中，只有<code>for...in</code>会返回继承的属性，其他三个方法都会忽略继承的属性，只处理对象自身的属性。实际上，引入“可枚举”（<code>enumerable</code>）这个概念的最初目的，就是让某些属性可以规避掉<code>for...in</code>操作，不然所有内部属性和方法都会被遍历到。比如，对象原型的<code>toString</code>方法，以及数组的<code>length</code>属性，就通过“可枚举性”，从而避免被<code>for...in</code>遍历到。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(Object<span class="selector-class">.prototype</span>, <span class="string">'toString'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor([], <span class="string">'length'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>toString</code>和<code>length</code>属性的<code>enumerable</code>都是<code>false</code>，因此<code>for...in</code>不会遍历到这两个继承自原型的属性。</p>
<p>另外，ES6 规定，所有 Class 的原型的方法都是不可枚举的。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.getOwnPropertyDescriptor(class &#123;foo() &#123;&#125;&#125;<span class="selector-class">.prototype</span>, <span class="string">'foo'</span>).enumerable</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>总的来说，操作中引入继承的属性会让问题复杂化，大多数时候，我们只关心对象自身的属性。所以，尽量不要用<code>for...in</code>循环，而用<code>Object.keys()</code>代替。</p>
<h3 id="属性的遍历"><a href="#属性的遍历" class="headerlink" title="属性的遍历"></a>属性的遍历</h3><p>ES6 一共有 5 种方法可以遍历对象的属性。</p>
<p><strong>（1）for…in</strong></p>
<p><code>for...in</code>循环遍历对象自身的和继承的可枚举属性（不含 Symbol 属性）。</p>
<p><strong>（2）Object.keys(obj)</strong></p>
<p><code>Object.keys</code>返回一个数组，包括对象自身的（不含继承的）所有可枚举属性（不含 Symbol 属性）的键名。</p>
<p><strong>（3）Object.getOwnPropertyNames(obj)</strong></p>
<p><code>Object.getOwnPropertyNames</code>返回一个数组，包含对象自身的所有属性（不含 Symbol 属性，但是包括不可枚举属性）的键名。</p>
<p><strong>（4）Object.getOwnPropertySymbols(obj)</strong></p>
<p><code>Object.getOwnPropertySymbols</code>返回一个数组，包含对象自身的所有 Symbol 属性的键名。</p>
<p><strong>（5）Reflect.ownKeys(obj)</strong></p>
<p><code>Reflect.ownKeys</code>返回一个数组，包含对象自身的所有键名，不管键名是 Symbol 或字符串，也不管是否可枚举。</p>
<p>以上的 5 种方法遍历对象的键名，都遵守同样的属性遍历的次序规则。</p>
<ul>
<li>首先遍历所有数值键，按照数值升序排列。</li>
<li>其次遍历所有字符串键，按照加入时间升序排列。</li>
<li>最后遍历所有 Symbol 键，按照加入时间升序排列。<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">Reflect</span><span class="selector-class">.ownKeys</span>(&#123; <span class="selector-attr">[Symbol()]</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">b</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">10</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">2</span><span class="selector-pseudo">:0</span>, <span class="selector-tag">a</span><span class="selector-pseudo">:0</span> &#125;)</span><br><span class="line"><span class="comment">// ['2', '10', 'b', 'a', Symbol()]</span></span><br></pre></td></tr></table></figure>
</li>
</ul>
<p>上面代码中，<code>Reflect.ownKeys</code>方法返回一个数组，包含了参数对象的所有属性。这个数组的属性次序是这样的，首先是数值属性<code>2</code>和<code>10</code>，其次是字符串属性<code>b</code>和<code>a</code>，最后是 Symbol 属性。</p>
<h2 id="Object-getOwnPropertyDescriptors"><a href="#Object-getOwnPropertyDescriptors" class="headerlink" title="Object.getOwnPropertyDescriptors()"></a>Object.getOwnPropertyDescriptors()</h2><p>前面说过，<code>Object.getOwnPropertyDescriptor</code>方法会返回某个对象属性的描述对象（descriptor）。ES2017 引入了<code>Object.getOwnPropertyDescriptors</code>方法，返回指定对象所有自身属性（非继承属性）的描述对象。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">const</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">  foo:</span> <span class="number">123</span><span class="string">,</span></span><br><span class="line">  <span class="string">get</span> <span class="string">bar()</span> <span class="string">&#123;</span> <span class="string">return</span> <span class="string">'abc'</span> <span class="string">&#125;</span></span><br><span class="line"><span class="string">&#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="string">Object.getOwnPropertyDescriptors(obj)</span></span><br><span class="line"><span class="string">//</span> <span class="string">&#123;</span> <span class="attr">foo:</span></span><br><span class="line"><span class="string">//</span>    <span class="string">&#123;</span> <span class="attr">value:</span> <span class="number">123</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>      <span class="attr">writable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>      <span class="attr">enumerable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>      <span class="attr">configurable:</span> <span class="literal">true</span> <span class="string">&#125;,</span></span><br><span class="line"><span class="string">//</span>   <span class="attr">bar:</span></span><br><span class="line"><span class="string">//</span>    <span class="string">&#123;</span> <span class="attr">get:</span> <span class="string">[Function:</span> <span class="string">get</span> <span class="string">bar],</span></span><br><span class="line"><span class="string">//</span>      <span class="attr">set:</span> <span class="string">undefined,</span></span><br><span class="line"><span class="string">//</span>      <span class="attr">enumerable:</span> <span class="literal">true</span><span class="string">,</span></span><br><span class="line"><span class="string">//</span>      <span class="attr">configurable:</span> <span class="literal">true</span> <span class="string">&#125;</span> <span class="string">&#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>Object.getOwnPropertyDescriptors</code>方法返回一个对象，所有原对象的属性名都是该对象的属性名，对应的属性值就是该属性的描述对象。</p>
<p>该方法的实现非常容易。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getOwnPropertyDescriptors</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> result = &#123;&#125;;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Reflect</span>.ownKeys(obj)) &#123;</span><br><span class="line">    result[key] = <span class="built_in">Object</span>.getOwnPropertyDescriptor(obj, key);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>该方法的引入目的，主要是为了解决<code>Object.assign()</code>无法正确拷贝<code>get</code>属性和<code>set</code>属性的问题。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="function"><span class="keyword">set</span> <span class="title">foo</span>(<span class="params"><span class="keyword">value</span></span>) </span>&#123;</span><br><span class="line">    console.log(<span class="keyword">value</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target1 = &#123;&#125;;</span><br><span class="line">Object.assign(target1, source);</span><br><span class="line"></span><br><span class="line">Object.getOwnPropertyDescriptor(target1, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// &#123; value: undefined,</span></span><br><span class="line"><span class="comment">//   writable: true,</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>source</code>对象的<code>foo</code>属性的值是一个赋值函数，<code>Object.assign</code>方法将这个属性拷贝给<code>target1</code>对象，结果该属性的值变成了<code>undefined</code>。这是因为<code>Object.assign</code>方法总是拷贝一个属性的值，而不会拷贝它背后的赋值方法或取值方法。</p>
<p>这时，<code>Object.getOwnPropertyDescriptors</code>方法配合<code>Object.defineProperties</code>方法，就可以实现正确拷贝。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> source = &#123;</span><br><span class="line">  <span class="built_in">set</span> foo(value) &#123;</span><br><span class="line">    console.<span class="built_in">log</span>(value);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> target2 = &#123;&#125;;</span><br><span class="line"><span class="keyword">Object</span>.defineProperties(target2, <span class="keyword">Object</span>.getOwnPropertyDescriptors(source));</span><br><span class="line"><span class="keyword">Object</span>.getOwnPropertyDescriptor(target2, <span class="string">'foo'</span>)</span><br><span class="line"><span class="comment">// &#123; get: undefined,</span></span><br><span class="line"><span class="comment">//   set: [Function: set foo],</span></span><br><span class="line"><span class="comment">//   enumerable: true,</span></span><br><span class="line"><span class="comment">//   configurable: true &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，两个对象合并的逻辑可以写成一个函数。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> shallowMerge = <span class="function">(<span class="params">target, source</span>) =&gt;</span> <span class="built_in">Object</span>.defineProperties(</span><br><span class="line">  target,</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(source)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><code>Object.getOwnPropertyDescriptors</code>方法的另一个用处，是配合<code>Object.create</code>方法，将对象属性克隆到一个新对象。这属于浅拷贝。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> clone = <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj));</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> shallowClone = <span class="function">(<span class="params">obj</span>) =&gt;</span> <span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>上面代码会克隆对象<code>obj</code>。</p>
<p>另外，<code>Object.getOwnPropertyDescriptors</code>方法可以实现一个对象继承另一个对象。以前，继承另一个对象，常常写成下面这样。<br><figure class="highlight dts"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line"><span class="symbol">  __proto__:</span> prot,</span><br><span class="line"><span class="symbol">  foo:</span> <span class="number">123</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>ES6 规定<code>__proto__</code>只有浏览器要部署，其他环境不用部署。如果去除<code>__proto__</code>，上面代码就要改成下面这样。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(prot);</span><br><span class="line">obj.foo = <span class="number">123</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.assign(</span><br><span class="line">  <span class="built_in">Object</span>.create(prot),</span><br><span class="line">  &#123;</span><br><span class="line">    foo: <span class="number">123</span>,</span><br><span class="line">  &#125;</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p>有了<code>Object.getOwnPropertyDescriptors</code>，我们就有了另一种写法。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(</span><br><span class="line">  prot,</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(&#123;</span><br><span class="line">    foo: <span class="number">123</span>,</span><br><span class="line">  &#125;)</span><br><span class="line">);</span><br></pre></td></tr></table></figure></p>
<p><code>Object.getOwnPropertyDescriptors</code>也可以用来实现 Mixin（混入）模式。<br><figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> mix = <span class="function">(<span class="params">object</span>) =&gt;</span> (&#123;</span><br><span class="line">  <span class="keyword">with</span>: <span class="function">(<span class="params">...mixins</span>) =&gt;</span> mixins.reduce(</span><br><span class="line">    (c, mixin) =&gt; <span class="built_in">Object</span>.create(</span><br><span class="line">      c, <span class="built_in">Object</span>.getOwnPropertyDescriptors(mixin)</span><br><span class="line">    ), object)</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// multiple mixins example</span></span><br><span class="line"><span class="keyword">let</span> a = &#123;a: <span class="string">'a'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> b = &#123;b: <span class="string">'b'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> c = &#123;c: <span class="string">'c'</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> d = mix(c).with(a, b);</span><br><span class="line"></span><br><span class="line">d.c <span class="comment">// "c"</span></span><br><span class="line">d.b <span class="comment">// "b"</span></span><br><span class="line">d.a <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码返回一个新的对象<code>d</code>，代表了对象<code>a</code>和<code>b</code>被混入了对象<code>c</code>的操作。</p>
<p>出于完整性的考虑，<code>Object.getOwnPropertyDescriptors</code>进入标准以后，以后还会新增<code>Reflect.getOwnPropertyDescriptors</code>方法。</p>
<h2 id="proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf"><a href="#proto-属性，Object-setPrototypeOf-，Object-getPrototypeOf" class="headerlink" title="__proto__属性，Object.setPrototypeOf()，Object.getPrototypeOf()"></a><code>__proto__</code>属性，Object.setPrototypeOf()，Object.getPrototypeOf()</h2><p>JavaScript 语言的对象继承是通过原型链实现的。ES6 提供了更多原型对象的操作方法。</p>
<h3 id="proto-属性"><a href="#proto-属性" class="headerlink" title="__proto__属性"></a><code>__proto__</code>属性</h3><p><code>__proto__</code>属性（前后各两个下划线），用来读取或设置当前对象的<code>prototype</code>对象。目前，所有浏览器（包括 IE11）都部署了这个属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// es5 的写法</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  method: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;</span><br><span class="line">&#125;;</span><br><span class="line">obj.__proto__ = someOtherObj;</span><br><span class="line"></span><br><span class="line"><span class="comment">// es6 的写法</span></span><br><span class="line"><span class="keyword">var</span> obj = <span class="built_in">Object</span>.create(someOtherObj);</span><br><span class="line">obj.method = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123; ... &#125;;</span><br></pre></td></tr></table></figure></p>
<p>该属性没有写入 ES6 的正文，而是写入了附录，原因是<code>__proto__</code>前后的双下划线，说明它本质上是一个内部属性，而不是一个正式的对外的 API，只是由于浏览器广泛支持，才被加入了 ES6。标准明确规定，只有浏览器必须部署这个属性，其他运行环境不一定需要部署，而且新的代码最好认为这个属性是不存在的。因此，无论从语义的角度，还是从兼容性的角度，都不要使用这个属性，而是使用下面的<code>Object.setPrototypeOf()</code>（写操作）、<code>Object.getPrototypeOf()</code>（读操作）、<code>Object.create()</code>（生成操作）代替。</p>
<p>实现上，<code>__proto__</code>调用的是<code>Object.prototype.__proto__</code>，具体实现如下。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.defineProperty(<span class="built_in">Object</span>.prototype, <span class="string">'__proto__'</span>, &#123;</span><br><span class="line">  get() &#123;</span><br><span class="line">    <span class="keyword">let</span> _thisObj = <span class="built_in">Object</span>(<span class="keyword">this</span>);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Object</span>.getPrototypeOf(_thisObj);</span><br><span class="line">  &#125;,</span><br><span class="line">  set(proto) &#123;</span><br><span class="line">    <span class="keyword">if</span> (<span class="keyword">this</span> === <span class="literal">undefined</span> || <span class="keyword">this</span> === <span class="literal">null</span>) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(<span class="keyword">this</span>)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span> (!isObject(proto)) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">let</span> status = <span class="built_in">Reflect</span>.setPrototypeOf(<span class="keyword">this</span>, proto);</span><br><span class="line">    <span class="keyword">if</span> (!status) &#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>();</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">isObject</span>(<span class="params">value</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Object</span>(value) === value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>如果一个对象本身部署了<code>__proto__</code>属性，该属性的值就是对象的原型。<br><figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">Object.getPrototypeOf(&#123;</span> <span class="attr">__proto__:</span> <span class="literal">null</span> <span class="string">&#125;)</span></span><br><span class="line"><span class="string">//</span> <span class="literal">null</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Object-setPrototypeOf"><a href="#Object-setPrototypeOf" class="headerlink" title="Object.setPrototypeOf()"></a>Object.setPrototypeOf()</h3><p><code>Object.setPrototypeOf</code>方法的作用与<code>__proto__</code>相同，用来设置一个对象的<code>prototype</code>对象，返回参数对象本身。它是 ES6 正式推荐的设置原型对象的方法。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 格式</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(object, prototype)</span><br><span class="line"></span><br><span class="line"><span class="comment">// 用法</span></span><br><span class="line"><span class="keyword">const</span> o = <span class="built_in">Object</span>.setPrototypeOf(&#123;&#125;, <span class="keyword">null</span>);</span><br></pre></td></tr></table></figure></p>
<p>该方法等同于下面的函数。<br><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title"></span>(obj, proto) &#123;</span><br><span class="line">  obj.__proto__ = proto;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">obj</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>下面是一个例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> proto = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">x</span>: <span class="number">10</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">proto.y = <span class="number">20</span>;</span><br><span class="line">proto.z = <span class="number">40</span>;</span><br><span class="line"></span><br><span class="line">obj.x <span class="comment">// 10</span></span><br><span class="line">obj.y <span class="comment">// 20</span></span><br><span class="line">obj.z <span class="comment">// 40</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码将<code>proto</code>对象设为<code>obj</code>对象的原型，所以从<code>obj</code>对象可以读取<code>proto</code>对象的属性。</p>
<p>如果第一个参数不是对象，会自动转为对象。但是由于返回的还是第一个参数，所以这个操作不会产生任何效果。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="number">1</span>, &#123;&#125;) === <span class="number">1</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="string">'foo'</span>, &#123;&#125;) === <span class="string">'foo'</span> <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(<span class="keyword">true</span>, &#123;&#125;) === <span class="keyword">true</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure></p>
<p>由于<code>undefined</code>和<code>null</code>无法转为对象，所以如果第一个参数是<code>undefined</code>或<code>null</code>，就会报错。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.setPrototypeOf(<span class="literal">undefined</span>, &#123;&#125;)</span><br><span class="line"><span class="regexp">//</span> TypeError: Object.setPrototypeOf called <span class="literal">on</span> <span class="literal">null</span> <span class="keyword">or</span> <span class="literal">undefined</span></span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(<span class="literal">null</span>, &#123;&#125;)</span><br><span class="line"><span class="regexp">//</span> TypeError: Object.setPrototypeOf called <span class="literal">on</span> <span class="literal">null</span> <span class="keyword">or</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Object-getPrototypeOf"><a href="#Object-getPrototypeOf" class="headerlink" title="Object.getPrototypeOf()"></a>Object.getPrototypeOf()</h3><p>该方法与<code>Object.setPrototypeOf</code>方法配套，用于读取一个对象的原型对象。<br><figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Object</span>.getPrototypeOf(obj);</span><br></pre></td></tr></table></figure></p>
<p>下面是一个例子。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Rectangle</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> rec = <span class="keyword">new</span> Rectangle();</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(rec, <span class="built_in">Object</span>.prototype);</span><br><span class="line"><span class="built_in">Object</span>.getPrototypeOf(rec) === Rectangle.prototype</span><br><span class="line"><span class="comment">// false</span></span><br></pre></td></tr></table></figure></p>
<p>如果参数不是对象，会被自动转为对象。<br><figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 等同于 Object.getPrototypeOf(Number(<span class="number">1</span>))</span><br><span class="line">Object.getPrototypeOf(<span class="number">1</span>)</span><br><span class="line">// Number &#123;<span class="string">[[PrimitiveValue]]</span>: <span class="number">0</span>&#125;</span><br><span class="line"></span><br><span class="line">// 等同于 Object.getPrototypeOf(String(<span class="string">'foo'</span>))</span><br><span class="line">Object.getPrototypeOf(<span class="string">'foo'</span>)</span><br><span class="line">// String &#123;length: <span class="number">0</span>, <span class="string">[[PrimitiveValue]]</span>: <span class="string">""</span>&#125;</span><br><span class="line"></span><br><span class="line">// 等同于 Object.getPrototypeOf(Boolean(<span class="literal">true</span>))</span><br><span class="line">Object.getPrototypeOf(<span class="literal">true</span>)</span><br><span class="line">// Boolean &#123;<span class="string">[[PrimitiveValue]]</span>: <span class="literal">false</span>&#125;</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(<span class="number">1</span>) === Number.prototype // <span class="literal">true</span></span><br><span class="line">Object.getPrototypeOf(<span class="string">'foo'</span>) === String.prototype // <span class="literal">true</span></span><br><span class="line">Object.getPrototypeOf(<span class="literal">true</span>) === Boolean.prototype // <span class="literal">true</span></span><br></pre></td></tr></table></figure></p>
<p>如果参数是<code>undefined</code>或<code>null</code>，它们无法转为对象，所以会报错。<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Object.getPrototypeOf(<span class="literal">null</span>)</span><br><span class="line"><span class="regexp">//</span> TypeError: Cannot convert <span class="literal">undefined</span> <span class="keyword">or</span> <span class="literal">null</span> to object</span><br><span class="line"></span><br><span class="line">Object.getPrototypeOf(<span class="literal">undefined</span>)</span><br><span class="line"><span class="regexp">//</span> TypeError: Cannot convert <span class="literal">undefined</span> <span class="keyword">or</span> <span class="literal">null</span> to object</span><br></pre></td></tr></table></figure></p>
<h2 id="super-关键字"><a href="#super-关键字" class="headerlink" title="super 关键字"></a>super 关键字</h2><p>我们知道，<code>this</code>关键字总是指向函数所在的当前对象，ES6 又新增了另一个类似的关键字<code>super</code>，指向当前对象的原型对象。<br><figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  foo: <span class="string">'hello'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="string">'world'</span>,</span><br><span class="line">  <span class="built_in">find</span>() &#123;</span><br><span class="line">    <span class="built_in">return</span> super.foo;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Object.setPrototypeOf(obj, proto);</span><br><span class="line">obj.<span class="built_in">find</span>() <span class="comment">// "hello"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象<code>obj</code>的<code>find</code>方法之中，通过<code>super.foo</code>引用了原型对象<code>proto</code>的<code>foo</code>属性。</p>
<p>注意，<code>super</code>关键字表示原型对象时，只能用在对象的方法之中，用在其他地方都会报错。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="keyword">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">super</span>.foo</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  foo: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">super</span>.foo</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面三种<code>super</code>的用法都会报错，因为对于 JavaScript 引擎来说，这里的<code>super</code>都没有用在对象的方法之中。第一种写法是<code>super</code>用在属性里面，第二种和第三种写法是<code>super</code>用在一个函数里面，然后赋值给<code>foo</code>属性。目前，只有对象方法的简写法可以让 JavaScript 引擎确认，定义的是对象的方法。</p>
<p>JavaScript 引擎内部，<code>super.foo</code>等同于<code>Object.getPrototypeOf(this).foo</code>（属性）或<code>Object.getPrototypeOf(this).foo.call(this)</code>（方法）。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> proto = &#123;</span><br><span class="line">  x: <span class="string">'hello'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.x);</span><br><span class="line">  &#125;,</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  x: <span class="string">'world'</span>,</span><br><span class="line">  foo() &#123;</span><br><span class="line">    <span class="keyword">super</span>.foo();</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">Object</span>.setPrototypeOf(obj, proto);</span><br><span class="line"></span><br><span class="line">obj.foo() <span class="comment">// "world"</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>super.foo</code>指向原型对象<code>proto</code>的<code>foo</code>方法，但是绑定的<code>this</code>却还是当前对象<code>obj</code>，因此输出的就是<code>world</code>。</p>
<h2 id="Object-keys-，Object-values-，Object-entries"><a href="#Object-keys-，Object-values-，Object-entries" class="headerlink" title="Object.keys()，Object.values()，Object.entries()"></a>Object.keys()，Object.values()，Object.entries()</h2><h3 id="Object-keys"><a href="#Object-keys" class="headerlink" title="Object.keys()"></a>Object.keys()</h3><p>ES5 引入了<code>Object.keys</code>方法，返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键名。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var obj = &#123; foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> &#125;;</span><br><span class="line">Object.keys(obj)</span><br><span class="line"><span class="regexp">//</span> [<span class="string">"foo"</span>, <span class="string">"baz"</span>]</span><br></pre></td></tr></table></figure></p>
<p>ES2017 <a href="https://github.com/tc39/proposal-object-values-entries" target="_blank" rel="noopener">引入</a>了跟<code>Object.keys</code>配套的<code>Object.values</code>和<code>Object.entries</code>，作为遍历一个对象的补充手段，供<code>for...of</code>循环使用。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;keys, values, entries&#125; = Object;</span><br><span class="line"><span class="keyword">let</span> obj = &#123; a: <span class="number">1</span>, b: <span class="number">2</span>, c: <span class="number">3</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> keys(obj)) &#123;</span><br><span class="line">  console.log(key); // <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> <span class="keyword">value</span> <span class="keyword">of</span> values(obj)) &#123;</span><br><span class="line">  console.log(value); // <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key, <span class="keyword">value</span>] <span class="keyword">of</span> entries(obj)) &#123;</span><br><span class="line">  console.log([key, value]); // [<span class="string">'a'</span>, <span class="number">1</span>], [<span class="string">'b'</span>, <span class="number">2</span>], [<span class="string">'c'</span>, <span class="number">3</span>]</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h3 id="Object-values"><a href="#Object-values" class="headerlink" title="Object.values()"></a>Object.values()</h3><p><code>Object.values</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="built_in">Object</span>.values(obj)</span><br><span class="line"><span class="comment">// ["bar", 42]</span></span><br></pre></td></tr></table></figure></p>
<p>返回数组的成员顺序，与本章的《属性的遍历》部分介绍的排列规则一致。<br><figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; <span class="number">100</span>: <span class="string">'a'</span>, <span class="number">2</span>: <span class="string">'b'</span>, <span class="number">7</span>: <span class="string">'c'</span> &#125;<span class="comment">;</span></span><br><span class="line">Object.values(obj)</span><br><span class="line">// [<span class="string">"b"</span>, <span class="string">"c"</span>, <span class="string">"a"</span>]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，属性名为数值的属性，是按照数值大小，从小到大遍历的，因此返回的顺序是<code>b</code>、<code>c</code>、<code>a</code>。</p>
<p><code>Object.values</code>只返回对象自身的可遍历属性。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;p: &#123;value: <span class="number">42</span>&#125;&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>Object.create</code>方法的第二个参数添加的对象属性（属性<code>p</code>），如果不显式声明，默认是不可遍历的，因为<code>p</code>的属性描述对象的<code>enumerable</code>默认是<code>false</code>，<code>Object.values</code>不会返回这个属性。只要把<code>enumerable</code>改成<code>true</code>，<code>Object.values</code>就会返回属性<code>p</code>的值。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = <span class="built_in">Object</span>.create(&#123;&#125;, &#123;p:</span><br><span class="line">  &#123;</span><br><span class="line">    value: <span class="number">42</span>,</span><br><span class="line">    enumerable: <span class="keyword">true</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"><span class="built_in">Object</span>.values(obj) <span class="comment">// [42]</span></span><br></pre></td></tr></table></figure></p>
<p><code>Object.values</code>会过滤属性名为 Symbol 值的属性。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(&#123; [<span class="built_in">Symbol</span>()]: <span class="number">123</span>, foo: <span class="string">'abc'</span> &#125;);</span><br><span class="line"><span class="comment">// ['abc']</span></span><br></pre></td></tr></table></figure></p>
<p>如果<code>Object.values</code>方法的参数是一个字符串，会返回各个字符组成的一个数组。<br><figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Object.values(<span class="string">'foo'</span>)</span><br><span class="line"><span class="regexp">//</span> [<span class="string">'f'</span>, <span class="string">'o'</span>, <span class="string">'o'</span>]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，字符串会先转成一个类似数组的对象。字符串的每个字符，就是该对象的一个属性。因此，<code>Object.values</code>返回每个属性的键值，就是各个字符组成的一个数组。</p>
<p>如果参数不是对象，<code>Object.values</code>会先将其转为对象。由于数值和布尔值的包装对象，都不会为实例添加非继承的属性。所以，<code>Object.values</code>会返回空数组。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Object</span>.values(<span class="number">42</span>) <span class="comment">// []</span></span><br><span class="line"><span class="built_in">Object</span>.values(<span class="keyword">true</span>) <span class="comment">// []</span></span><br></pre></td></tr></table></figure></p>
<h3 id="Object-entries"><a href="#Object-entries" class="headerlink" title="Object.entries"></a>Object.entries</h3><p><code>Object.entries</code>方法返回一个数组，成员是参数对象自身的（不含继承的）所有可遍历（enumerable）属性的键值对数组。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123; foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="symbol">Object</span>.entries(obj)</span><br><span class="line">// [ [<span class="string">"foo"</span>, <span class="string">"bar"</span>], [<span class="string">"baz"</span>, <span class="number">42</span>] ]</span><br></pre></td></tr></table></figure></p>
<p>除了返回值不一样，该方法的行为与<code>Object.values</code>基本一致。</p>
<p>如果原对象的属性名是一个 Symbol 值，该属性会被忽略。<br><figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">Object</span>.entries(&#123; [<span class="symbol">Symbol</span>()]: <span class="number">123</span>, foo: <span class="string">'abc'</span> &#125;);</span><br><span class="line">// [ [ <span class="string">'foo'</span>, <span class="string">'abc'</span> ] ]</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，原对象有两个属性，<code>Object.entries</code>只输出属性名非 Symbol 值的属性。将来可能会有<code>Reflect.ownEntries()</code>方法，返回对象自身的所有属性。</p>
<p><code>Object.entries</code>的基本用途是遍历对象的属性。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; <span class="attr">one</span>: <span class="number">1</span>, <span class="attr">two</span>: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [k, v] <span class="keyword">of</span> <span class="built_in">Object</span>.entries(obj)) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(</span><br><span class="line">    <span class="string">`<span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(k)&#125;</span>: <span class="subst">$&#123;<span class="built_in">JSON</span>.stringify(v)&#125;</span>`</span></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "one": 1</span></span><br><span class="line"><span class="comment">// "two": 2</span></span><br></pre></td></tr></table></figure></p>
<p><code>Object.entries</code>方法的另一个用处是，将对象转为真正的<code>Map</code>结构。<br><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> obj = &#123; foo: <span class="string">'bar'</span>, baz: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map(<span class="keyword">Object</span>.entries(obj));</span><br><span class="line"><span class="built_in">map</span> <span class="comment">// Map &#123; foo: "bar", baz: 42 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>自己实现<code>Object.entries</code>方法，非常简单。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Generator函数的版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span>* <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    <span class="keyword">yield</span> [key, obj[key]];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 非Generator函数的版本</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">entries</span>(<span class="params">obj</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arr = [];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> key <span class="keyword">of</span> <span class="built_in">Object</span>.keys(obj)) &#123;</span><br><span class="line">    arr.push([key, obj[key]]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> arr;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<h2 id="对象的扩展运算符"><a href="#对象的扩展运算符" class="headerlink" title="对象的扩展运算符"></a>对象的扩展运算符</h2><p>《数组的扩展》一章中，已经介绍过扩展运算符（<code>...</code>）。<br><figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const [a, ...b] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// [2, 3]</span></span><br></pre></td></tr></table></figure></p>
<p>ES2018 将这个运算符<a href="https://github.com/sebmarkbage/ecmascript-rest-spread" target="_blank" rel="noopener">引入</a>了对象。</p>
<h3 id="解构赋值"><a href="#解构赋值" class="headerlink" title="解构赋值"></a>解构赋值</h3><p>对象的解构赋值用于从一个对象取值，相当于将目标对象自身的所有可遍历的（enumerable）、但尚未被读取的属性，分配到指定的对象上面。所有的键和它们的值，都会拷贝到新对象上面。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let &#123; x, y, ...z &#125; = &#123; <span class="string">x:</span> <span class="number">1</span>, <span class="string">y:</span> <span class="number">2</span>, <span class="string">a:</span> <span class="number">3</span>, <span class="string">b:</span> <span class="number">4</span> &#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line">z <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>z</code>是解构赋值所在的对象。它获取等号右边的所有尚未读取的键（<code>a</code>和<code>b</code>），将它们连同值一起拷贝过来。</p>
<p>由于解构赋值要求等号右边是一个对象，所以如果等号右边是<code>undefined</code>或<code>null</code>，就会报错，因为它们无法转为对象。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, y, <span class="params">...</span>z &#125; = <span class="built_in">null</span>; <span class="comment">// 运行时错误</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, y, <span class="params">...</span>z &#125; = undefined; <span class="comment">// 运行时错误</span></span><br></pre></td></tr></table></figure></p>
<p>解构赋值必须是最后一个参数，否则会报错。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; ...x, y, z &#125; = obj; <span class="comment">// 句法错误</span></span><br><span class="line"><span class="keyword">let</span> &#123; x, ...y, ...z &#125; = obj; <span class="comment">// 句法错误</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，解构赋值不是最后一个参数，所以会报错。</p>
<p>注意，解构赋值的拷贝是浅拷贝，即如果一个键的值是复合类型的值（数组、对象、函数）、那么解构赋值拷贝的是这个值的引用，而不是这个值的副本。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123; a: &#123; b: <span class="number">1</span> &#125; &#125;;</span><br><span class="line"><span class="keyword">let</span> &#123; ...x &#125; = obj;</span><br><span class="line">obj.a.b = <span class="number">2</span>;</span><br><span class="line">x.a.b // <span class="number">2</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>x</code>是解构赋值所在的对象，拷贝了对象<code>obj</code>的<code>a</code>属性。<code>a</code>属性引用了一个对象，修改这个对象的值，会影响到解构赋值对它的引用。</p>
<p>另外，扩展运算符的解构赋值，不能复制继承自原型对象的属性。<br><figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="meta">o1</span> = &#123; a: <span class="number">1</span> &#125;;</span><br><span class="line">let <span class="meta">o2</span> = &#123; b: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="meta">o2</span>.__proto__ = <span class="meta">o1</span>;</span><br><span class="line">let &#123; ...<span class="meta">o3</span> &#125; = <span class="meta">o2</span>;</span><br><span class="line"><span class="meta">o3</span> <span class="comment">// &#123; b: 2 &#125;</span></span><br><span class="line"><span class="meta">o3</span>.a <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，对象<code>o3</code>复制了<code>o2</code>，但是只复制了<code>o2</code>自身的属性，没有复制它的原型对象<code>o1</code>的属性。</p>
<p>下面是另一个例子。<br><figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const o = Object.create(&#123; x: <span class="type">1</span>, y: <span class="type">2 </span>&#125;);</span><br><span class="line">o.z = <span class="number">3</span>;  </span><br><span class="line">let &#123; x, ...<span class="keyword">new</span><span class="type">Obj</span> &#125; = o;</span><br><span class="line">let &#123; y, z &#125; = <span class="keyword">new</span><span class="type">Obj</span>;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// 3</span></span><br></pre></td></tr></table></figure></p>
<p>上面代码中，变量<code>x</code>是单纯的解构赋值，所以可以读取对象<code>o</code>继承的属性；变量<code>y</code>和<code>z</code>是扩展运算符的解构赋值，只能读取对象<code>o</code>自身的属性，所以变量<code>z</code>可以赋值成功，变量<code>y</code>取不到值。ES6 规定，变量声明语句之中，如果使用解构赋值，扩展运算符后面必须是一个变量名，而不能是一个解构赋值表达式，所以上面代码引入了中间变量<code>newObj</code>，如果写成下面这样会报错。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; x, ...&#123; y, z &#125; &#125; = o;</span><br><span class="line">// SyntaxError: ... must be followed <span class="keyword">by</span> an identifier <span class="keyword">in</span> declaration contexts</span><br></pre></td></tr></table></figure></p>
<p>解构赋值的一个用处，是扩展某个函数的参数，引入其他操作。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">baseFunction</span><span class="params">(&#123; a, b &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">wrapperFunction</span><span class="params">(&#123; x, y, <span class="rest_arg">...restConfig</span> &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// 使用 x 和 y 参数进行操作</span></span><br><span class="line">  <span class="comment">// 其余参数传给原始函数</span></span><br><span class="line">  <span class="keyword">return</span> baseFunction(restConfig);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，原始函数<code>baseFunction</code>接受<code>a</code>和<code>b</code>作为参数，函数<code>wrapperFunction</code>在<code>baseFunction</code>的基础上进行了扩展，能够接受多余的参数，并且保留原始函数的行为。</p>
<h3 id="扩展运算符"><a href="#扩展运算符" class="headerlink" title="扩展运算符"></a>扩展运算符</h3><p>对象的扩展运算符（<code>...</code>）用于取出参数对象的所有可遍历属性，拷贝到当前对象之中。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> z = &#123; a: <span class="number">3</span>, b: <span class="number">4</span> &#125;;</span><br><span class="line"><span class="keyword">let</span> n = &#123; ...z &#125;;</span><br><span class="line">n <span class="comment">// &#123; a: 3, b: 4 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>这等同于使用<code>Object.assign</code>方法。<br><figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aClone = &#123; ...a &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aClone = Object.<span class="keyword">assign</span>(&#123;&#125;, a);</span><br></pre></td></tr></table></figure></p>
<p>上面的例子只是拷贝了对象实例的属性，如果想完整克隆一个对象，还拷贝对象原型的属性，可以采用下面的写法。<br><figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> clone1 = &#123;</span><br><span class="line">  __proto__: <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  ...obj</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> clone2 = <span class="built_in">Object</span>.assign(</span><br><span class="line">  <span class="built_in">Object</span>.create(<span class="built_in">Object</span>.getPrototypeOf(obj)),</span><br><span class="line">  obj</span><br><span class="line">);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法三</span></span><br><span class="line"><span class="keyword">const</span> clone3 = <span class="built_in">Object</span>.create(</span><br><span class="line">  <span class="built_in">Object</span>.getPrototypeOf(obj),</span><br><span class="line">  <span class="built_in">Object</span>.getOwnPropertyDescriptors(obj)</span><br><span class="line">)</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，写法一的<code>__proto__</code>属性在非浏览器的环境不一定部署，因此推荐使用写法二和写法三。</p>
<p>扩展运算符可以用于合并两个对象。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> ab = &#123; ...a, ...b &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> ab = Object.assign(&#123;&#125;, a, b);</span><br></pre></td></tr></table></figure></p>
<p>如果用户自定义的属性，放在扩展运算符后面，则扩展运算符内部的同名属性会被覆盖掉。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, x: <span class="number">1</span>, y: <span class="number">2</span> &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = &#123; ...a, ...&#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125; &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>, y = <span class="number">2</span>, aWithOverrides = &#123; ...a, x, y &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">let</span> aWithOverrides = Object.assign(&#123;&#125;, a, &#123; x: <span class="number">1</span>, y: <span class="number">2</span> &#125;);</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>a</code>对象的<code>x</code>属性和<code>y</code>属性，拷贝到新对象后会被覆盖掉。</p>
<p>这用来修改现有对象部分的属性就很方便了。<br><figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> newVersion = &#123;</span><br><span class="line">  ...previousVersion,</span><br><span class="line">  name: <span class="string">'New Name'</span> <span class="comment">// Override the name property</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>上面代码中，<code>newVersion</code>对象自定义了<code>name</code>属性，其他属性全部复制自<code>previousVersion</code>对象。</p>
<p>如果把自定义属性放在扩展运算符前面，就变成了设置新对象的默认属性值。<br><figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let aWithDefaults = &#123; <span class="string">x:</span> <span class="number">1</span>, <span class="string">y:</span> <span class="number">2</span>, ...a &#125;;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">let aWithDefaults = Object.assign(&#123;&#125;, &#123; <span class="string">x:</span> <span class="number">1</span>, <span class="string">y:</span> <span class="number">2</span> &#125;, a);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">let aWithDefaults = Object.assign(&#123; <span class="string">x:</span> <span class="number">1</span>, <span class="string">y:</span> <span class="number">2</span> &#125;, a);</span><br></pre></td></tr></table></figure></p>
<p>与数组的扩展运算符一样，对象的扩展运算符后面可以跟表达式。<br><figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;</span><br><span class="line">  ...(x &gt; <span class="number">1</span> ? &#123;a: <span class="number">1</span>&#125; : &#123;&#125;),</span><br><span class="line">  b: <span class="number">2</span>,</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>如果扩展运算符后面是一个空对象，则没有任何效果。<br><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&#123;...&#123;&#125;, <span class="selector-tag">a</span>: <span class="number">1</span>&#125;</span><br><span class="line"><span class="comment">// &#123; a: 1 &#125;</span></span><br></pre></td></tr></table></figure></p>
<p>如果扩展运算符的参数是<code>null</code>或<code>undefined</code>，这两个值会被忽略，不会报错。<br><figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> emptyObject = &#123; <span class="params">...</span><span class="built_in">null</span>, <span class="params">...</span>undefined &#125;; <span class="comment">// 不报错</span></span><br></pre></td></tr></table></figure></p>
<p>扩展运算符的参数对象之中，如果有取值函数<code>get</code>，这个函数是会执行的。<br><figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 并不会抛出错误，因为 x 属性只是被定义，但没执行</span></span><br><span class="line"><span class="keyword">let</span> aWithXGetter = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  <span class="function"><span class="keyword">get</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'not throw yet'</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 会抛出错误，因为 x 属性被执行了</span></span><br><span class="line"><span class="keyword">let</span> runtimeError = &#123;</span><br><span class="line">  ...a,</span><br><span class="line">  ...&#123;</span><br><span class="line">    <span class="function"><span class="keyword">get</span> <span class="title">x</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> Error(<span class="string">'throw now'</span>);</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 08.数组的扩展]]></title>
      <url>/2018/06/15/ES6/08.%E6%95%B0%E7%BB%84%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="数组的扩展"><a href="#数组的扩展" class="headerlink" title="数组的扩展"></a>数组的扩展</h2><h3 id="1-扩展运算符"><a href="#1-扩展运算符" class="headerlink" title="1.扩展运算符"></a>1.扩展运算符</h3><h4 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h4><p>扩展运算符（spread）是三个点（…）。它好比 rest 参数的逆运算，将一个数组转为用逗号分隔的参数序列。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">console</span>.log(...[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// 1 2 3</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(<span class="number">1</span>, ...[<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>], <span class="number">5</span>)</span><br><span class="line"><span class="comment">// 1 2 3 4 5</span></span><br><span class="line"></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br><span class="line"><span class="comment">// [&lt;div&gt;, &lt;div&gt;, &lt;div&gt;]</span></span><br></pre></td></tr></table></figure>
<p>该运算符主要用于函数调用。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(array, <span class="rest_arg">...items</span>)</span> </span>&#123;</span><br><span class="line">  array.push(...items);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> numbers = [<span class="number">4</span>, <span class="number">38</span>];</span><br><span class="line">add(...numbers) <span class="comment">// 42</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，array.push(…items)和add(…numbers)这两行，都是函数的调用，它们的都使用了扩展运算符。该运算符将一个数组，变为参数序列。</p>
<p>扩展运算符与正常的函数参数可以结合使用，非常灵活。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">function f(v, w, x, y, z) &#123; &#125;</span><br><span class="line">const args = [<span class="number">0</span>, <span class="number">1</span>];</span><br><span class="line">f(<span class="number">-1</span>, ...args, <span class="number">2</span>, ...[<span class="number">3</span>]);</span><br></pre></td></tr></table></figure>
<p>扩展运算符后面还可以放置表达式。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">const arr = [</span><br><span class="line">  ...(x &gt; <span class="number">0</span> ? [<span class="string">'a'</span>] : []),</span><br><span class="line">  <span class="string">'b'</span>,</span><br><span class="line">];</span><br></pre></td></tr></table></figure>
<p>如果扩展运算符后面是一个空数组，则不产生任何效果。</p>
<figure class="highlight inform7"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">[...<span class="comment">[]</span>, 1]</span></span><br><span class="line">// <span class="comment">[1]</span></span><br></pre></td></tr></table></figure>
<h4 id="替代函数的-apply-方法"><a href="#替代函数的-apply-方法" class="headerlink" title="替代函数的 apply 方法"></a>替代函数的 apply 方法</h4><p>由于扩展运算符可以展开数组，所以不再需要apply方法，将数组转为函数的参数了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f.apply(<span class="literal">null</span>, args);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y, z</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> args = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">f(...args);</span><br></pre></td></tr></table></figure>
<p>下面是扩展运算符取代apply方法的一个实际的例子，应用Math.max方法，简化求出一个数组最大元素的写法。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 的写法</span></span><br><span class="line">Math.max.apply(null, [<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line">Math.max(...[<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>])</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">Math.max(<span class="number">14</span>, <span class="number">3</span>, <span class="number">77</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于 JavaScript 不提供求数组最大元素的函数，所以只能套用Math.max函数，将数组转为一个参数序列，然后求最大值。有了扩展运算符以后，就可以直接用Math.max了。</p>
<p>另一个例子是通过push函数，将一个数组添加到另一个数组的尾部。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的 写法</span></span><br><span class="line">var arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">var arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">Array.prototype.push.apply(arr1, arr2);</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 的写法</span></span><br><span class="line">let arr1 = [<span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">let arr2 = [<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line">arr1.push(...arr2);</span><br></pre></td></tr></table></figure>
<p>上面代码的 ES5 写法中，push方法的参数不能是数组，所以只好通过apply方法变通使用push方法。有了扩展运算符，就可以直接将数组传入push方法。</p>
<p>下面是另外一个例子。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="keyword">new</span> (<span class="built_in">Date</span>.bind.apply(<span class="built_in">Date</span>, [<span class="built_in">null</span>, <span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]))</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="keyword">new</span> <span class="built_in">Date</span>(...[<span class="number">2015</span>, <span class="number">1</span>, <span class="number">1</span>]);</span><br></pre></td></tr></table></figure>
<h4 id="扩展运算符的应用"><a href="#扩展运算符的应用" class="headerlink" title="扩展运算符的应用"></a>扩展运算符的应用</h4><p>（1）复制数组</p>
<p>数组是复合的数据类型，直接复制的话，只是复制了指向底层数据结构的指针，而不是克隆一个全新的数组。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">const a2 = a1;</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，a2并不是a1的克隆，而是指向同一份数据的另一个指针。修改a2，会直接导致a1的变化。</p>
<p>ES5 只能用变通方法来复制数组。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line">const a2 = a1.concat();</span><br><span class="line"></span><br><span class="line">a2[<span class="number">0</span>] = <span class="number">2</span>;</span><br><span class="line">a1 <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，a1会返回原数组的克隆，再修改a2就不会对a1产生影响。</p>
<p>扩展运算符提供了复制数组的简便写法。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a1 = [<span class="number">1</span>, <span class="number">2</span>];</span><br><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">const</span> a2 = [...a1];</span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">const</span> [...a2] = a1;</span><br></pre></td></tr></table></figure>
<p>上面的两种写法，a2都是a1的克隆。</p>
<p>（2）合并数组</p>
<p>扩展运算符提供了数组合并的新写法。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const arr1 = [<span class="string">'a'</span>, <span class="string">'b'</span>];</span><br><span class="line">const arr2 = [<span class="string">'c'</span>];</span><br><span class="line">const arr3 = [<span class="string">'d'</span>, <span class="string">'e'</span>];</span><br><span class="line"></span><br><span class="line">// <span class="symbol">ES5</span> 的合并数组</span><br><span class="line">arr1.concat(arr2, arr3);</span><br><span class="line">// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br><span class="line"></span><br><span class="line">// <span class="symbol">ES6</span> 的合并数组</span><br><span class="line">[...arr1, ...arr2, ...arr3]</span><br><span class="line">// [ <span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>, <span class="string">'d'</span>, <span class="string">'e'</span> ]</span><br></pre></td></tr></table></figure>
<p>不过，这两种方法都是浅拷贝，使用的时候需要注意。</p>
<figure class="highlight armasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">const</span> <span class="built_in">a1</span> = [&#123; foo: <span class="number">1</span> &#125;]<span class="comment">;</span></span><br><span class="line"><span class="symbol">const</span> <span class="built_in">a2</span> = [&#123; <span class="keyword">bar: </span><span class="number">2</span> &#125;]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">const</span> <span class="built_in">a3</span> = <span class="built_in">a1</span>.concat(<span class="built_in">a2</span>)<span class="comment">;</span></span><br><span class="line"><span class="symbol">const</span> <span class="built_in">a4</span> = [...a1, ...a2]<span class="comment">;</span></span><br><span class="line"></span><br><span class="line"><span class="symbol">a3</span>[<span class="number">0</span>] === <span class="built_in">a1</span>[<span class="number">0</span>] // true</span><br><span class="line"><span class="symbol">a4</span>[<span class="number">0</span>] === <span class="built_in">a1</span>[<span class="number">0</span>] // true</span><br></pre></td></tr></table></figure>
<p>上面代码中，a3和a4是用两种不同方法合并而成的新数组，但是它们的成员都是对原数组成员的引用，这就是浅拷贝。如果修改了原数组的成员，会同步反映到新数组。</p>
<p>（3）与解构赋值结合</p>
<p>扩展运算符可以与解构赋值结合起来，用于生成数组。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5</span></span><br><span class="line">a = <span class="type">list</span>[<span class="number">0</span>], rest = <span class="type">list</span>.slice(<span class="number">1</span>)</span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">[a, ...rest] = <span class="type">list</span></span><br></pre></td></tr></table></figure>
<p>下面是另外一些例子。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const [<span class="built_in">first</span>, ...<span class="built_in">rest</span>] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="built_in">first</span> // <span class="number">1</span></span><br><span class="line"><span class="built_in">rest</span>  // [<span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]</span><br><span class="line"></span><br><span class="line">const [<span class="built_in">first</span>, ...<span class="built_in">rest</span>] = [];</span><br><span class="line"><span class="built_in">first</span> // undefined</span><br><span class="line"><span class="built_in">rest</span>  // []</span><br><span class="line"></span><br><span class="line">const [<span class="built_in">first</span>, ...<span class="built_in">rest</span>] = [<span class="string">"foo"</span>];</span><br><span class="line"><span class="built_in">first</span>  // <span class="string">"foo"</span></span><br><span class="line"><span class="built_in">rest</span>   // []</span><br></pre></td></tr></table></figure>
<p>如果将扩展运算符用于数组赋值，只能放在参数的最后一位，否则会报错。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const [...butLast, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">const [first, ...middle, last] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>];</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>（4）字符串</p>
<p>扩展运算符还可以将字符串转为真正的数组。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...<span class="string">'hello'</span>]</span><br><span class="line">// [ <span class="string">"h"</span>, <span class="string">"e"</span>, <span class="string">"l"</span>, <span class="string">"l"</span>, <span class="string">"o"</span> ]</span><br></pre></td></tr></table></figure>
<p>上面的写法，有一个重要的好处，那就是能够正确识别四个字节的 Unicode 字符。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x\uD83D\uDE80y'</span><span class="selector-class">.length</span> <span class="comment">// 4</span></span><br><span class="line">[...<span class="string">'x\uD83D\uDE80y'</span>]<span class="selector-class">.length</span> <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第一种写法，JavaScript 会将四个字节的 Unicode 字符，识别为 2 个字符，采用扩展运算符就没有这个问题。因此，正确返回字符串长度的函数，可以像下面这样写。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">length</span><span class="params">(str)</span> &#123;</span></span><br><span class="line">  <span class="keyword">return</span> [...str].<span class="built_in">length</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">length</span>(<span class="string">'x\uD83D\uDE80y'</span>) <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>凡是涉及到操作四个字节的 Unicode 字符的函数，都有这个问题。因此，最好都用扩展运算符改写。</p>
<p>let str = ‘x\uD83D\uDE80y’;</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">str</span>.<span class="built_in">split</span>(<span class="string">''</span>).<span class="built_in">reverse</span>().<span class="built_in">join</span>(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// 'y\uDE80\uD83Dx'</span></span><br><span class="line"></span><br><span class="line">[...<span class="built_in">str</span>].<span class="built_in">reverse</span>().<span class="built_in">join</span>(<span class="string">''</span>)</span><br><span class="line"><span class="comment">// 'y\uD83D\uDE80x'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果不用扩展运算符，字符串的reverse操作就不正确。</p>
<p>（5）实现了 Iterator 接口的对象</p>
<p>任何 Iterator 接口的对象（参阅 Iterator 一章），都可以用扩展运算符转为真正的数组。</p>
<figure class="highlight smali"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let nodeList = document.querySelectorAll('div');</span><br><span class="line">let<span class="built_in"> array </span>= [...node<span class="class">List];</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，querySelectorAll方法返回的是一个nodeList对象。它不是数组，而是一个类似数组的对象。这时，扩展运算符可以将其转为真正的数组，原因就在于NodeList对象实现了 Iterator 。</p>
<p>对于那些没有部署 Iterator 接口的类似数组的对象，扩展运算符就无法将其转为真正的数组。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arrayLike = &#123;</span><br><span class="line">  <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">  <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">  <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">  length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// TypeError: Cannot spread non-iterable object.</span></span><br><span class="line"><span class="keyword">let</span> arr = [...arrayLike];</span><br></pre></td></tr></table></figure>
<p>上面代码中，arrayLike是一个类似数组的对象，但是没有部署 Iterator 接口，扩展运算符就会报错。这时，可以改为使用Array.from方法将arrayLike转为真正的数组。</p>
<p>（6）Map 和 Set 结构，Generator 函数</p>
<p>扩展运算符内部调用的是数据结构的 Iterator 接口，因此只要具有 Iterator 接口的对象，都可以使用扩展运算符，比如 Map 结构。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">map</span> = <span class="literal">new</span> <span class="built_in">Map</span>(<span class="meta">[</span></span><br><span class="line">  <span class="meta">[</span><span class="number">1</span>, <span class="string">'one'</span><span class="meta">]</span>,</span><br><span class="line">  <span class="meta">[</span><span class="number">2</span>, <span class="string">'two'</span><span class="meta">]</span>,</span><br><span class="line">  <span class="meta">[</span><span class="number">3</span>, <span class="string">'three'</span><span class="meta">]</span>,</span><br><span class="line">]);</span><br><span class="line"></span><br><span class="line">let arr = <span class="meta">[</span><span class="params">...</span><span class="built_in">map</span>.keys()<span class="meta">]</span>; // <span class="meta">[</span><span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span><span class="meta">]</span></span><br></pre></td></tr></table></figure>
<p>Generator 函数运行后，返回一个遍历器对象，因此也可以使用扩展运算符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> go = <span class="function"><span class="keyword">function</span>*(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">yield</span> <span class="number">3</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">[...go()] <span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量go是一个 Generator 函数，执行后返回的是一个遍历器对象，对这个遍历器对象执行扩展运算符，就会将内部遍历得到的值，转为一个数组。</p>
<p>如果对没有 Iterator 接口的对象，使用扩展运算符，将会报错。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const obj = &#123;a: <span class="number">1</span>, b: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="keyword">let</span> arr = [...obj]; <span class="comment">// TypeError: Cannot spread non-iterable object</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Array-from"><a href="#2-Array-from" class="headerlink" title="2.Array.from()"></a>2.Array.from()</h3><p>Array.from方法用于将两类对象转为真正的数组：类似数组的对象（array-like object）和可遍历（iterable）的对象（包括 ES6 新增的数据结构 Set 和 Map）。</p>
<p>下面是一个类似数组的对象，Array.from将它转为真正的数组。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">let arrayLike = &#123;</span><br><span class="line">    <span class="string">'0'</span>: <span class="string">'a'</span>,</span><br><span class="line">    <span class="string">'1'</span>: <span class="string">'b'</span>,</span><br><span class="line">    <span class="string">'2'</span>: <span class="string">'c'</span>,</span><br><span class="line">    length: <span class="number">3</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> ES5的写法</span><br><span class="line">var arr1 = [].slice.call(arrayLike); <span class="regexp">//</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> ES6的写法</span><br><span class="line">let arr2 = Array.from(arrayLike); <span class="regexp">//</span> [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<p>实际应用中，常见的类似数组的对象是 DOM 操作返回的 NodeList 集合，以及函数内部的arguments对象。Array.from都可以将它们转为真正的数组。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line"><span class="keyword">let</span> ps = <span class="built_in">document</span>.querySelectorAll(<span class="string">'p'</span>);</span><br><span class="line"><span class="built_in">Array</span>.from(ps).filter(<span class="function"><span class="params">p</span> =&gt;</span> &#123;</span><br><span class="line">  <span class="keyword">return</span> p.textContent.length &gt; <span class="number">100</span>;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> args = <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>);</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，querySelectorAll方法返回的是一个类似数组的对象，可以将这个对象转为真正的数组，再使用filter方法。</p>
<p>只要是部署了 Iterator 接口的数据结构，Array.from都能将其转为数组。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>.from(<span class="symbol">'hello</span>')</span><br><span class="line">// [<span class="string">'h'</span>, <span class="string">'e'</span>, <span class="string">'l'</span>, <span class="string">'l'</span>, <span class="string">'o'</span>]</span><br><span class="line"></span><br><span class="line">let namesSet = <span class="keyword">new</span> Set([<span class="string">'a'</span>, <span class="string">'b'</span>])</span><br><span class="line"><span class="keyword">Array</span>.from(namesSet) // [<span class="string">'a'</span>, <span class="string">'b'</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串和 Set 结构都具有 Iterator 接口，因此可以被Array.from转为真正的数组。</p>
<p>如果参数是一个真正的数组，Array.from会返回一个一模一样的新数组。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>])</span><br><span class="line"><span class="comment">// [1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>值得提醒的是，扩展运算符（…）也可以将某些数据结构转为数组。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments对象</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> args = [...arguments];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// NodeList对象</span></span><br><span class="line">[...document.querySelectorAll(<span class="string">'div'</span>)]</span><br></pre></td></tr></table></figure>
<p>扩展运算符背后调用的是遍历器接口（Symbol.iterator），如果一个对象没有部署这个接口，就无法转换。Array.from方法还支持类似数组的对象。所谓类似数组的对象，本质特征只有一点，即必须有length属性。因此，任何有length属性的对象，都可以通过Array.from方法转为数组，而此时扩展运算符就无法转换。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.<span class="keyword">from</span>(&#123; length: <span class="number">3</span> &#125;);</span><br><span class="line"><span class="regexp">//</span> [ <span class="literal">undefined</span>, <span class="literal">undefined</span>, <span class="literal">undefined</span> ]</span><br></pre></td></tr></table></figure>
<p>上面代码中，Array.from返回了一个具有三个成员的数组，每个位置的值都是undefined。扩展运算符转换不了这个对象。</p>
<p>对于还没有部署该方法的浏览器，可以用Array.prototype.slice方法替代。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> toArray = <span class="function">(<span class="params">(<span class="params"></span>) =&gt;</span></span></span><br><span class="line"><span class="function"><span class="params">  <span class="built_in">Array</span>.<span class="keyword">from</span> ? <span class="built_in">Array</span>.<span class="keyword">from</span> : obj =&gt; [].slice.call(<span class="params">obj</span>)</span></span></span><br><span class="line"><span class="function"><span class="params"></span>)<span class="params">()</span>;</span></span><br></pre></td></tr></table></figure>
<p>Array.from还可以接受第二个参数，作用类似于数组的map方法，用来对每个元素进行处理，将处理后的值放入返回的数组。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Array</span>.from(arrayLike, <span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="built_in">Array</span>.from(arrayLike).map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br><span class="line"></span><br><span class="line"><span class="built_in">Array</span>.from([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>], <span class="function">(<span class="params">x</span>) =&gt;</span> x * x)</span><br><span class="line"><span class="comment">// [1, 4, 9]</span></span><br></pre></td></tr></table></figure>
<p>下面的例子是取出一组 DOM 节点的文本内容。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> spans = <span class="built_in">document</span>.querySelectorAll(<span class="string">'span.name'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// map()</span></span><br><span class="line"><span class="keyword">let</span> names1 = <span class="built_in">Array</span>.prototype.map.call(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.textContent);</span><br><span class="line"></span><br><span class="line"><span class="comment">// Array.from()</span></span><br><span class="line"><span class="keyword">let</span> names2 = <span class="built_in">Array</span>.from(spans, <span class="function"><span class="params">s</span> =&gt;</span> s.textContent)</span><br></pre></td></tr></table></figure>
<p>下面的例子将数组中布尔值为false的成员转为0。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.from([<span class="number">1</span>, , <span class="number">2</span>, , <span class="number">3</span>], (n) =&gt; n || <span class="number">0</span>)</span><br><span class="line"><span class="comment">// [1, 0, 2, 0, 3]</span></span><br></pre></td></tr></table></figure>
<p>另一个例子是返回各种数据的类型。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">typesOf</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">arguments</span>, <span class="function"><span class="params">value</span> =&gt;</span> <span class="keyword">typeof</span> value)</span><br><span class="line">&#125;</span><br><span class="line">typesOf(<span class="literal">null</span>, [], <span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// ['object', 'object', 'number']</span></span><br></pre></td></tr></table></figure>
<p>如果map函数里面用到了this关键字，还可以传入Array.from的第三个参数，用来绑定this。</p>
<p>Array.from()可以将各种值转为真正的数组，并且还提供map功能。这实际上意味着，只要有一个原始的数据结构，你就可以先对它的值进行处理，然后转成规范的数组结构，进而就可以使用数量众多的数组方法。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.<span class="keyword">from</span>(&#123; length: <span class="number">2</span> &#125;, <span class="function"><span class="params">()</span> =&gt;</span> <span class="string">'jack'</span>)</span><br><span class="line"><span class="regexp">//</span> [<span class="string">'jack'</span>, <span class="string">'jack'</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码中，Array.from的第一个参数指定了第二个参数运行的次数。这种特性可以让该方法的用法变得非常灵活。</p>
<p>Array.from()的另一个应用是，将字符串转为数组，然后返回字符串的长度。因为它能正确处理各种 Unicode 字符，可以避免 JavaScript 将大于\uFFFF的 Unicode 字符，算作两个字符的 bug。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">countSymbols</span>(<span class="params">string</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.from(<span class="built_in">string</span>).length;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-Array-of"><a href="#3-Array-of" class="headerlink" title="3.Array.of()"></a>3.Array.of()</h3><p>Array.of方法用于将一组值，转换为数组。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>) <span class="comment">// [3,11,8]</span></span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">3</span>) <span class="comment">// [3]</span></span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">3</span>).length <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>这个方法的主要目的，是弥补数组构造函数Array()的不足。因为参数个数的不同，会导致Array()的行为有差异。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Array</span><span class="params">()</span></span> <span class="comment">// []</span></span><br><span class="line"><span class="function"><span class="title">Array</span><span class="params">(<span class="number">3</span>)</span></span> <span class="comment">// [, , ,]</span></span><br><span class="line"><span class="function"><span class="title">Array</span><span class="params">(<span class="number">3</span>, <span class="number">11</span>, <span class="number">8</span>)</span></span> <span class="comment">// [3, 11, 8]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Array方法没有参数、一个参数、三个参数时，返回结果都不一样。只有当参数个数不少于 2 个时，Array()才会返回由参数组成的新数组。参数个数只有一个时，实际上是指定数组的长度。</p>
<p>Array.of基本上可以用来替代Array()或new Array()，并且不存在由于参数不同而导致的重载。它的行为非常统一。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>() <span class="comment">// []</span></span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(undefined) <span class="comment">// [undefined]</span></span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">1</span>) <span class="comment">// [1]</span></span><br><span class="line"><span class="keyword">Array</span>.<span class="keyword">of</span>(<span class="number">1</span>, <span class="number">2</span>) <span class="comment">// [1, 2]</span></span><br></pre></td></tr></table></figure>
<p>Array.of总是返回参数值组成的数组。如果没有参数，就返回一个空数组。</p>
<p>Array.of方法可以用下面的代码模拟实现。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">ArrayOf</span>()&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">[].slice.call(arguments)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="4-数组实例的-copyWithin"><a href="#4-数组实例的-copyWithin" class="headerlink" title="4.数组实例的 copyWithin()"></a>4.数组实例的 copyWithin()</h3><p>数组实例的copyWithin方法，在当前数组内部，将指定位置的成员复制到其他位置（会覆盖原有成员），然后返回当前数组。也就是说，使用这个方法，会修改当前数组。</p>
<figure class="highlight elm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Array</span>.proto<span class="keyword">type</span>.copyWithin(target, start = 0, end = this.length)</span><br></pre></td></tr></table></figure>
<p>它接受三个参数。</p>
<ul>
<li>target（必需）：从该位置开始替换数据。如果为负值，表示倒数。</li>
<li>start（可选）：从该位置开始读取数据，默认为 0。如果为负值，表示倒数。</li>
<li>end（可选）：到该位置前停止读取数据，默认等于数组长度。如果为负值，表示倒数。<br>这三个参数都应该是数值，如果不是，会自动转为数值。</li>
</ul>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// [4, 5, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示将从 3 号位直到数组结束的成员（4 和 5），复制到从 0 号位开始的位置，结果覆盖了原来的 1 和 2。</p>
<p>下面是更多例子。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[<span class="meta">1, 2, 3, 4, 5</span>].copyWithin(<span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// -2相当于3号位，-1相当于4号位</span></span><br><span class="line">[<span class="meta">1, 2, 3, 4, 5</span>].copyWithin(<span class="number">0</span>, <span class="number">-2</span>, <span class="number">-1</span>)</span><br><span class="line"><span class="comment">// [4, 2, 3, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将3号位复制到0号位</span></span><br><span class="line">[<span class="meta"></span>].copyWithin.call(&#123;length: <span class="number">5</span>, <span class="number">3</span>: <span class="number">1</span>&#125;, <span class="number">0</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// &#123;0: 1, 3: 1, length: 5&#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将2号位到数组结束，复制到0号位</span></span><br><span class="line"><span class="keyword">let</span> i32a = <span class="keyword">new</span> Int32Array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]);</span><br><span class="line">i32a.copyWithin(<span class="number">0</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// Int32Array [3, 4, 5, 4, 5]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 对于没有部署 TypedArray 的 copyWithin 方法的平台</span></span><br><span class="line"><span class="comment">// 需要采用下面的写法</span></span><br><span class="line">[<span class="meta"></span>].copyWithin.call(<span class="keyword">new</span> Int32Array([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>]), <span class="number">0</span>, <span class="number">3</span>, <span class="number">4</span>);</span><br><span class="line"><span class="comment">// Int32Array [4, 2, 3, 4, 5]</span></span><br></pre></td></tr></table></figure>
<h3 id="5-数组实例的-find-和-findIndex"><a href="#5-数组实例的-find-和-findIndex" class="headerlink" title="5.数组实例的 find() 和 findIndex()"></a>5.数组实例的 find() 和 findIndex()</h3><p>数组实例的find方法，用于找出第一个符合条件的数组成员。它的参数是一个回调函数，所有数组成员依次执行该回调函数，直到找出第一个返回值为true的成员，然后返回该成员。如果没有符合条件的成员，则返回undefined。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">4</span>, <span class="number">-5</span>, <span class="number">10</span>].find((n) =&gt; n &lt; <span class="number">0</span>)</span><br><span class="line"><span class="comment">// -5</span></span><br></pre></td></tr></table></figure>
<p>上面代码找出数组中第一个小于 0 的成员。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].find(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，find方法的回调函数可以接受三个参数，依次为当前的值、当前的位置和原数组。</p>
<p>数组实例的findIndex方法的用法与find方法非常类似，返回第一个符合条件的数组成员的位置，如果所有成员都不符合条件，则返回-1。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">5</span>, <span class="number">10</span>, <span class="number">15</span>].findIndex(function(value, index, arr) &#123;</span><br><span class="line">  return value &gt; <span class="number">9</span>;</span><br><span class="line">&#125;) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>这两个方法都可以接受第二个参数，用来绑定回调函数的this对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">v</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v &gt; <span class="keyword">this</span>.age;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> person = &#123;<span class="attr">name</span>: <span class="string">'John'</span>, <span class="attr">age</span>: <span class="number">20</span>&#125;;</span><br><span class="line">[<span class="number">10</span>, <span class="number">12</span>, <span class="number">26</span>, <span class="number">15</span>].find(f, person);    <span class="comment">// 26</span></span><br></pre></td></tr></table></figure>
<p>上面的代码中，find函数接收了第二个参数person对象，回调函数中的this对象指向person对象。</p>
<p>另外，这两个方法都可以发现NaN，弥补了数组的indexOf方法的不足。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br><span class="line"></span><br><span class="line">[<span class="literal">NaN</span>].findIndex(<span class="function"><span class="params">y</span> =&gt;</span> <span class="built_in">Object</span>.is(<span class="literal">NaN</span>, y))</span><br><span class="line"><span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，indexOf方法无法识别数组的NaN成员，但是findIndex方法可以借助Object.is方法做到。</p>
<h3 id="6-数组实例的-fill"><a href="#6-数组实例的-fill" class="headerlink" title="6.数组实例的 fill()"></a>6.数组实例的 fill()</h3><p>fill方法使用给定值，填充一个数组。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].<span class="built_in">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">new</span> <span class="keyword">Array</span>(<span class="number">3</span>).<span class="built_in">fill</span>(<span class="number">7</span>)</span><br><span class="line"><span class="comment">// [7, 7, 7]</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明，fill方法用于空数组的初始化非常方便。数组中已有的元素，会被全部抹去。</p>
<p>fill方法还可以接受第二个和第三个参数，用于指定填充的起始位置和结束位置。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>].fill(<span class="number">7</span>, <span class="number">1</span>, <span class="number">2</span>)</span><br><span class="line">// [<span class="string">'a'</span>, <span class="number">7</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码表示，fill方法从 1 号位开始，向原数组填充 7，到 2 号位之前结束。</p>
<p>注意，如果填充的类型为对象，那么被赋值的是同一个内存地址的对象，而不是深拷贝对象。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">let arr = new <span class="symbol">Array</span>(<span class="number">3</span>).fill(&#123;name: <span class="string">"Mike"</span>&#125;);</span><br><span class="line">arr[<span class="number">0</span>].name = <span class="string">"Ben"</span>;</span><br><span class="line">arr</span><br><span class="line">// [&#123;name: <span class="string">"Ben"</span>&#125;, &#123;name: <span class="string">"Ben"</span>&#125;, &#123;name: <span class="string">"Ben"</span>&#125;]</span><br><span class="line"></span><br><span class="line">let arr = new <span class="symbol">Array</span>(<span class="number">3</span>).fill([]);</span><br><span class="line">arr[<span class="number">0</span>].push(<span class="number">5</span>);</span><br><span class="line">arr</span><br><span class="line">// [[<span class="number">5</span>], [<span class="number">5</span>], [<span class="number">5</span>]]</span><br></pre></td></tr></table></figure>
<h3 id="7-数组实例的-entries-，keys-和-values"><a href="#7-数组实例的-entries-，keys-和-values" class="headerlink" title="7.数组实例的 entries()，keys() 和 values()"></a>7.数组实例的 entries()，keys() 和 values()</h3><p>ES6 提供三个新的方法——entries()，keys()和values()——用于遍历数组。它们都返回一个遍历器对象（详见《Iterator》一章），可以用for…of循环进行遍历，唯一的区别是keys()是对键名的遍历、values()是对键值的遍历，entries()是对键值对的遍历。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> index <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].keys()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0</span></span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> elem <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].values()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 'a'</span></span><br><span class="line"><span class="comment">// 'b'</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [index, elem] <span class="keyword">of</span> [<span class="string">'a'</span>, <span class="string">'b'</span>].entries()) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(index, elem);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 0 "a"</span></span><br><span class="line"><span class="comment">// 1 "b"</span></span><br></pre></td></tr></table></figure>
<p>如果不使用for…of循环，可以手动调用遍历器对象的next方法，进行遍历。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> letter = [<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>];</span><br><span class="line"><span class="keyword">let</span> entries = letter.entries();</span><br><span class="line">console.log(entries.<span class="keyword">next</span>().<span class="keyword">value</span>); // [<span class="number">0</span>, <span class="string">'a'</span>]</span><br><span class="line">console.log(entries.<span class="keyword">next</span>().<span class="keyword">value</span>); // [<span class="number">1</span>, <span class="string">'b'</span>]</span><br><span class="line">console.log(entries.<span class="keyword">next</span>().<span class="keyword">value</span>); // [<span class="number">2</span>, <span class="string">'c'</span>]</span><br></pre></td></tr></table></figure>
<h3 id="8-数组实例的-includes"><a href="#8-数组实例的-includes" class="headerlink" title="8.数组实例的 includes()"></a>8.数组实例的 includes()</h3><p>Array.prototype.includes方法返回一个布尔值，表示某个数组是否包含给定的值，与字符串的includes方法类似。ES2016 引入了该方法。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">2</span>)     <span class="comment">// true</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">4</span>)     <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, NaN].includes(NaN) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">3</span>);  <span class="comment">// false</span></span><br><span class="line">[<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>].includes(<span class="number">3</span>, <span class="number">-1</span>); <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>没有该方法之前，我们通常使用数组的indexOf方法，检查是否包含某个值。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> <span class="comment">(arr.indexOf(el)</span> !== <span class="number">-1</span>) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>indexOf方法有两个缺点，一是不够语义化，它的含义是找到参数值的第一个出现位置，所以要去比较是否不等于-1，表达起来不够直观。二是，它内部使用严格相等运算符（===）进行判断，这会导致对NaN的误判。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].indexOf(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// -1</span></span><br></pre></td></tr></table></figure>
<p>includes使用的是不一样的判断算法，就没有这个问题。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="literal">NaN</span>].includes(<span class="literal">NaN</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>下面代码用来检查当前环境是否支持该方法，如果不支持，部署一个简易的替代版本。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const contains = (() =&gt;</span><br><span class="line">  Array.prototype.includes</span><br><span class="line">    ? (<span class="name">arr</span>, value) =&gt; arr.includes(<span class="name">value</span>)</span><br><span class="line">    : (<span class="name">arr</span>, value) =&gt; arr.some(<span class="name">el</span> =&gt; el === value)</span><br><span class="line">)()<span class="comment">;</span></span><br><span class="line">contains(['foo', 'bar'], 'baz')<span class="comment">; // =&gt; false</span></span><br></pre></td></tr></table></figure>
<p>另外，Map 和 Set 数据结构有一个has方法，需要注意与includes区分。</p>
<ul>
<li>Map 结构的has方法，是用来查找键名的，比如Map.prototype.has(key)、WeakMap.prototype.has(key)、Reflect.has(target, propertyKey)。</li>
<li>Set 结构的has方法，是用来查找值的，比如Set.prototype.has(value)、WeakSet.prototype.has(value)。</li>
</ul>
<h3 id="9-数组的空位"><a href="#9-数组的空位" class="headerlink" title="9.数组的空位"></a>9.数组的空位</h3><p>数组的空位指，数组的某一个位置没有任何值。比如，Array构造函数返回的数组都是空位。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">Array</span><span class="params">(<span class="number">3</span>)</span></span> <span class="comment">// [, , ,]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Array(3)返回一个具有 3 个空位的数组。</p>
<p>注意，空位不是undefined，一个位置的值等于undefined，依然是有值的。空位是没有任何值，in运算符可以说明这一点。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">0 </span>in [undefined, undefined, undefined] // true</span><br><span class="line"><span class="symbol">0 </span>in [, , ,] // false</span><br></pre></td></tr></table></figure>
<p>上面代码说明，第一个数组的 0 号位置是有值的，第二个数组的 0 号位置没有值。</p>
<p>ES5 对空位的处理，已经很不一致了，大多数情况下会忽略空位。</p>
<ul>
<li>forEach(), filter(), reduce(), every() 和some()都会跳过空位。</li>
<li>map()会跳过空位，但会保留这个值</li>
<li>join()和toString()会将空位视为undefined，而undefined和null会被处理成空字符串。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// forEach方法</span></span><br><span class="line">[,<span class="string">'a'</span>].forEach(<span class="function">(<span class="params">x,i</span>) =&gt;</span> <span class="built_in">console</span>.log(i)); <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// filter方法</span></span><br><span class="line">[<span class="string">'a'</span>,,<span class="string">'b'</span>].filter(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// ['a','b']</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// every方法</span></span><br><span class="line">[,<span class="string">'a'</span>].every(<span class="function"><span class="params">x</span> =&gt;</span> x===<span class="string">'a'</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// reduce方法</span></span><br><span class="line">[<span class="number">1</span>,,<span class="number">2</span>].reduce(<span class="function">(<span class="params">x,y</span>) =&gt;</span> <span class="keyword">return</span> x+y) <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// some方法</span></span><br><span class="line">[,<span class="string">'a'</span>].some(<span class="function"><span class="params">x</span> =&gt;</span> x !== <span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// map方法</span></span><br><span class="line">[,<span class="string">'a'</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> <span class="number">1</span>) <span class="comment">// [,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// join方法</span></span><br><span class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].join(<span class="string">'#'</span>) <span class="comment">// "#a##"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// toString方法</span></span><br><span class="line">[,<span class="string">'a'</span>,<span class="literal">undefined</span>,<span class="literal">null</span>].toString() <span class="comment">// ",a,,"</span></span><br></pre></td></tr></table></figure>
<p>ES6 则是明确将空位转为undefined。</p>
<p>Array.from方法会将数组的空位，转为undefined，也就是说，这个方法不会忽略空位。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Array.<span class="keyword">from</span>([<span class="string">'a'</span>,,<span class="string">'b'</span>])</span><br><span class="line"><span class="regexp">//</span> [ <span class="string">"a"</span>, <span class="literal">undefined</span>, <span class="string">"b"</span> ]</span><br></pre></td></tr></table></figure>
<p>扩展运算符（…）也会将空位转为undefined。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[...[<span class="string">'a'</span>,,<span class="string">'b'</span>]]</span><br><span class="line">// [ <span class="string">"a"</span>, undefined, <span class="string">"b"</span> ]</span><br></pre></td></tr></table></figure>
<p>copyWithin()会连空位一起拷贝。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">[,<span class="string">'a'</span>,<span class="string">'b'</span>,,].copyWithin(<span class="number">2</span>,<span class="number">0</span>) // [,<span class="string">"a"</span>,,<span class="string">"a"</span>]</span><br></pre></td></tr></table></figure>
<p>fill()会将空位视为正常的数组位置。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="keyword">Array</span>(<span class="number">3</span>).<span class="built_in">fill</span>(<span class="string">'a'</span>) <span class="comment">// ["a","a","a"]</span></span><br></pre></td></tr></table></figure>
<p>for…of循环也会遍历空位。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> arr = [, ,];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i <span class="keyword">of</span> arr) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 1</span></span><br><span class="line"><span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数组arr有两个空位，for…of并没有忽略它们。如果改成map方法遍历，空位是会跳过的。</p>
<p>entries()、keys()、values()、find()和findIndex()会将空位处理成undefined。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// entries()</span></span><br><span class="line">[...[,<span class="string">'a'</span>].entries()] <span class="comment">// [[0,undefined], [1,"a"]]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// keys()</span></span><br><span class="line">[...[,<span class="string">'a'</span>].keys()] <span class="comment">// [0,1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// values()</span></span><br><span class="line">[...[,<span class="string">'a'</span>].values()] <span class="comment">// [undefined,"a"]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// find()</span></span><br><span class="line">[,<span class="string">'a'</span>].find(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// findIndex()</span></span><br><span class="line">[,<span class="string">'a'</span>].findIndex(<span class="function"><span class="params">x</span> =&gt;</span> <span class="literal">true</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>由于空位的处理规则非常不统一，所以建议避免出现空位。</p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 07.函数的扩展]]></title>
      <url>/2018/06/15/ES6/07.%E5%87%BD%E6%95%B0%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="函数的扩展"><a href="#函数的扩展" class="headerlink" title="函数的扩展"></a>函数的扩展</h2><h3 id="1-函数的扩展"><a href="#1-函数的扩展" class="headerlink" title="1.函数的扩展"></a>1.函数的扩展</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 之前，不能直接为函数的参数指定默认值，只能采用变通的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  y = y || <span class="string">'World'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">log(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line">log(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello World</span></span><br></pre></td></tr></table></figure>
<p>上面代码检查函数log的参数y有没有赋值，如果没有，则指定默认值为World。这种写法的缺点在于，如果参数y赋值了，但是对应的布尔值为false，则该赋值不起作用。就像上面代码的最后一行，参数y等于空字符，结果被改为默认值。</p>
<p>为了避免这个问题，通常需要先判断一下参数y是否被赋值，如果没有，再等于默认值。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="keyword">typeof</span> y === <span class="string">'undefined'</span>) &#123;</span><br><span class="line">  y = <span class="string">'World'</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES6 允许为函数的参数设置默认值，即直接写在参数定义的后面。</p>
<figure class="highlight scilab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">log</span><span class="params">(x, y = 'World')</span> &#123;</span></span><br><span class="line">  console.<span class="built_in">log</span>(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>) <span class="comment">// Hello World</span></span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">'China'</span>) <span class="comment">// Hello China</span></span><br><span class="line"><span class="built_in">log</span>(<span class="string">'Hello'</span>, <span class="string">''</span>) <span class="comment">// Hello</span></span><br></pre></td></tr></table></figure>
<p>可以看到，ES6 的写法比 ES5 简洁许多，而且非常自然。下面是另一个例子。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Point</span><span class="params">(x = 0, y = 0)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.x = x;</span><br><span class="line">  <span class="keyword">this</span>.y = y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> p = <span class="keyword">new</span> Point();</span><br><span class="line">p <span class="comment">// &#123; x: 0, y: 0 &#125;</span></span><br></pre></td></tr></table></figure>
<p>除了简洁，ES6 的写法还有两个好处：首先，阅读代码的人，可以立刻意识到哪些参数是可以省略的，不用查看函数体或文档；其次，有利于将来的代码优化，即使未来的版本在对外接口中，彻底拿掉这个参数，也不会导致以前的代码无法运行。</p>
<p>参数变量是默认声明的，所以不能用let或const再次声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">1</span>; <span class="comment">// error</span></span><br><span class="line">  <span class="keyword">const</span> x = <span class="number">2</span>; <span class="comment">// error</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，参数变量x是默认声明的，在函数体中，不能用let或const再次声明，否则会报错。</p>
<p>使用参数默认值时，函数不能有同名参数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x, x, y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x, x, y = 1)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// SyntaxError: Duplicate parameter name not allowed in this context// 不报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x, x, y)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，一个容易忽略的地方是，参数默认值不是传值的，而是每次都重新计算默认值表达式的值。也就是说，参数默认值是惰性求值的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">99</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">p = x + <span class="number">1</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(p);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 100</span></span><br><span class="line"></span><br><span class="line">x = <span class="number">100</span>;</span><br><span class="line">foo() <span class="comment">// 101</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，参数p的默认值是x + 1。这时，每次调用函数foo，都会重新计算x + 1，而不是默认p等于 100。</p>
<h4 id="与解构赋值默认值结合使用"><a href="#与解构赋值默认值结合使用" class="headerlink" title="与解构赋值默认值结合使用"></a>与解构赋值默认值结合使用</h4><p>参数默认值可以与解构赋值的默认值，结合起来使用。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(&#123;x, y = 5&#125;)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  console.log(x, y);</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(&#123;&#125;)</span> // <span class="title">undefined</span> 5</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(&#123;x: 1&#125;)</span> // 1 5</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">(&#123;x: 1, y: 2&#125;)</span> // 1 2</span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span> // <span class="title">TypeError</span>:</span> Cannot <span class="keyword">read</span> <span class="keyword">property</span> <span class="string">'x'</span> <span class="keyword">of</span> undefined</span><br></pre></td></tr></table></figure>
<p>上面代码只使用了对象的解构赋值默认值，没有使用函数参数的默认值。只有当函数foo的参数是一个对象时，变量x和y才会通过解构赋值生成。如果函数foo调用时没提供参数，变量x和y就不会生成，从而报错。通过提供函数参数的默认值，就可以避免这种情况。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">&#123;x, y = <span class="number">5</span>&#125; = &#123;&#125;</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// undefined 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码指定，如果没有提供参数，函数foo的参数默认为一个空对象。</p>
<p>下面是另一个解构赋值默认值的例子。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125;) &#123;</span><br><span class="line">  console.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch('http://example.com', &#123;&#125;)</span><br><span class="line">// <span class="string">"<span class="keyword">GET</span>"</span></span><br><span class="line"></span><br><span class="line">fetch('http://example.com')</span><br><span class="line">// 报错</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果函数fetch的第二个参数是一个对象，就可以为它的三个属性设置默认值。这种写法不能省略第二个参数，如果结合函数参数的默认值，就可以省略第二个参数。这时，就出现了双重默认值。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function fetch(url, &#123; body = '', method = 'GET', headers = &#123;&#125; &#125; = &#123;&#125;) &#123;</span><br><span class="line">  console.log(method);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">fetch('http://example.com')</span><br><span class="line">// <span class="string">"<span class="keyword">GET</span>"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数fetch没有第二个参数时，函数参数的默认值就会生效，然后才是解构赋值的默认值生效，变量method才会取到默认值GET。</p>
<p>作为练习，请问下面两种写法有什么差别？</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m1</span><span class="params">(&#123;x = 0, y = 0&#125; = &#123;&#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">m2</span><span class="params">(&#123;x, y&#125; = &#123; x: 0, y: 0 &#125;)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种写法都对函数的参数设定了默认值，区别是写法一函数参数的默认值是空对象，但是设置了对象解构赋值的默认值；写法二函数参数的默认值是一个有具体属性的对象，但是没有设置对象解构赋值的默认值。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数没有参数的情况</span></span><br><span class="line"><span class="function"><span class="title">m1</span><span class="params">()</span></span> <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="function"><span class="title">m2</span><span class="params">()</span></span> <span class="comment">// [0, 0]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都有值的情况</span></span><br><span class="line"><span class="function"><span class="title">m1</span><span class="params">(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;)</span></span> <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="function"><span class="title">m2</span><span class="params">(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;)</span></span> <span class="comment">// [3, 8]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 有值，y 无值的情况</span></span><br><span class="line"><span class="function"><span class="title">m1</span><span class="params">(&#123;x: <span class="number">3</span>&#125;)</span></span> <span class="comment">// [3, 0]</span></span><br><span class="line"><span class="function"><span class="title">m2</span><span class="params">(&#123;x: <span class="number">3</span>&#125;)</span></span> <span class="comment">// [3, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// x 和 y 都无值的情况</span></span><br><span class="line"><span class="function"><span class="title">m1</span><span class="params">(&#123;&#125;)</span></span> <span class="comment">// [0, 0];</span></span><br><span class="line"><span class="function"><span class="title">m2</span><span class="params">(&#123;&#125;)</span></span> <span class="comment">// [undefined, undefined]</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">m1</span><span class="params">(&#123;z: <span class="number">3</span>&#125;)</span></span> <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="function"><span class="title">m2</span><span class="params">(&#123;z: <span class="number">3</span>&#125;)</span></span> <span class="comment">// [undefined, undefined]</span></span><br></pre></td></tr></table></figure>
<h4 id="参数默认值的位置"><a href="#参数默认值的位置" class="headerlink" title="参数默认值的位置"></a>参数默认值的位置</h4><p>通常情况下，定义了默认值的参数，应该是函数的尾参数。因为这样比较容易看出来，到底省略了哪些参数。如果非尾部的参数设置默认值，实际上这个参数是没法省略的。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 例一</span></span><br><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">f</span>(x = <span class="number">1</span>, y) &#123;</span><br><span class="line">  <span class="selector-tag">return</span> <span class="selector-attr">[x, y]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">f</span>() <span class="comment">// [1, undefined]</span></span><br><span class="line"><span class="selector-tag">f</span>(<span class="number">2</span>) <span class="comment">// [2, undefined])</span></span><br><span class="line"><span class="selector-tag">f</span>(, <span class="number">1</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="selector-tag">f</span>(undefined, <span class="number">1</span>) <span class="comment">// [1, 1]</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 例二</span></span><br><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">f</span>(x, y = <span class="number">5</span>, z) &#123;</span><br><span class="line">  <span class="selector-tag">return</span> <span class="selector-attr">[x, y, z]</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">f</span>() <span class="comment">// [undefined, 5, undefined]</span></span><br><span class="line"><span class="selector-tag">f</span>(<span class="number">1</span>) <span class="comment">// [1, 5, undefined]</span></span><br><span class="line"><span class="selector-tag">f</span>(<span class="number">1</span>, ,<span class="number">2</span>) <span class="comment">// 报错</span></span><br><span class="line"><span class="selector-tag">f</span>(<span class="number">1</span>, undefined, <span class="number">2</span>) <span class="comment">// [1, 5, 2]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，有默认值的参数都不是尾参数。这时，无法只省略该参数，而不省略它后面的参数，除非显式输入undefined。</p>
<p>如果传入undefined，将触发该参数等于默认值，null则没有这个效果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">x = <span class="number">5</span>, y = <span class="number">6</span></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(x, y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="literal">undefined</span>, <span class="literal">null</span>)</span><br></pre></td></tr></table></figure>
<p>上面代码中，x参数对应undefined，结果触发了默认值，y参数等于null，就没有触发默认值。</p>
<h4 id="函数的-length-属性"><a href="#函数的-length-属性" class="headerlink" title="函数的 length 属性"></a>函数的 length 属性</h4><p>指定了默认值以后，函数的length属性，将返回没有指定默认值的参数个数。也就是说，指定了默认值后，length属性将失真。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(function (a) &#123;&#125;)<span class="selector-class">.length</span> <span class="comment">// 1</span></span><br><span class="line">(function (<span class="selector-tag">a</span> = <span class="number">5</span>) &#123;&#125;)<span class="selector-class">.length</span> <span class="comment">// 0</span></span><br><span class="line">(function (<span class="selector-tag">a</span>, <span class="selector-tag">b</span>, c = <span class="number">5</span>) &#123;&#125;)<span class="selector-class">.length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，length属性的返回值，等于函数的参数个数减去指定了默认值的参数个数。比如，上面最后一个函数，定义了 3 个参数，其中有一个参数c指定了默认值，因此length属性等于3减去1，最后得到2。</p>
<p>这是因为length属性的含义是，该函数预期传入的参数个数。某个参数指定默认值以后，预期传入的参数个数就不包括这个参数了。同理，后文的 rest 参数也不会计入length属性。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(<span class="rest_arg">...args</span>)</span> </span>&#123;&#125;).length <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>如果设置了默认值的参数不是尾参数，那么length属性也不再计入后面的参数了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">(function (<span class="selector-tag">a</span> = <span class="number">0</span>, <span class="selector-tag">b</span>, c) &#123;&#125;)<span class="selector-class">.length</span> <span class="comment">// 0</span></span><br><span class="line">(function (<span class="selector-tag">a</span>, <span class="selector-tag">b</span> = <span class="number">1</span>, c) &#123;&#125;)<span class="selector-class">.length</span> <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="作用域"><a href="#作用域" class="headerlink" title="作用域"></a>作用域</h4><p>一旦设置了参数的默认值，函数进行声明初始化时，参数会形成一个单独的作用域（context）。等到初始化结束，这个作用域就会消失。这种语法行为，在不设置参数默认值时，是不会出现的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x, y = x</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(<span class="number">2</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，参数y的默认值等于变量x。调用函数f时，参数形成一个单独的作用域。在这个作用域里面，默认值变量x指向第一个参数x，而不是全局变量x，所以输出是2。</p>
<p>再看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数f调用时，参数y = x形成一个单独的作用域。这个作用域里面，变量x本身没有定义，所以指向外层的全局变量x。函数调用时，函数体内部的局部变量x影响不到默认值变量x。</p>
<p>如果此时，全局变量x不存在，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">y = x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> x = <span class="number">2</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(y);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f() <span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>
<p>下面这样写，也会报错。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x = x)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  // ...</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span> // <span class="title">ReferenceError</span>:</span> x <span class="keyword">is</span> <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>
<p>上面代码中，参数x = x形成一个单独作用域。实际执行的是let x = x，由于暂时性死区的原因，这行代码会报错”x 未定义“。</p>
<p>如果参数的默认值是一个函数，该函数的作用域也遵守这个规则。请看下面的例子。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let foo = <span class="string">'outer'</span><span class="comment">;</span></span><br><span class="line"></span><br><span class="line">function bar(<span class="function"><span class="keyword">func</span> = <span class="params">()</span> =&gt; <span class="title">foo</span>) &#123;</span></span><br><span class="line">  let foo = <span class="string">'inner'</span><span class="comment">;</span></span><br><span class="line">  console.<span class="built_in">log</span>(<span class="function"><span class="keyword">func</span><span class="params">()</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar()<span class="comment">; // outer</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数bar的参数func的默认值是一个匿名函数，返回值为变量foo。函数参数形成的单独作用域里面，并没有定义变量foo，所以foo指向外层的全局变量foo，因此输出outer。</p>
<p>如果写成下面这样，就会报错。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">function bar(<span class="function"><span class="keyword">func</span> = <span class="params">()</span> =&gt; <span class="title">foo</span>) &#123;</span></span><br><span class="line">  let foo = <span class="string">'inner'</span><span class="comment">;</span></span><br><span class="line">  console.<span class="built_in">log</span>(<span class="function"><span class="keyword">func</span><span class="params">()</span>);</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar() // ReferenceError: foo is <span class="literal">not</span> defined</span><br></pre></td></tr></table></figure>
<p>上面代码中，匿名函数里面的foo指向函数外层，但是函数外层并没有声明变量foo，所以就报错了。</p>
<p>下面是一个更复杂的例子。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span></span>(x, y = <span class="function"><span class="keyword">function</span></span>() &#123; x = <span class="number">2</span>; &#125;) &#123;</span><br><span class="line">  <span class="keyword">var</span> x = <span class="number">3</span>;</span><br><span class="line">  y();</span><br><span class="line">  console.log(x);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo() <span class="comment">// 3</span></span><br><span class="line">x <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数foo的参数形成一个单独作用域。这个作用域里面，首先声明了变量x，然后声明了变量y，y的默认值是一个匿名函数。这个匿名函数内部的变量x，指向同一个作用域的第一个参数x。函数foo内部又声明了一个内部变量x，该变量与第一个参数x由于不是同一个作用域，所以不是同一个变量，因此执行y后，内部变量x和外部全局变量x的值都没变。</p>
<p>如果将var x = 3的var去除，函数foo的内部变量x就指向第一个参数x，与匿名函数内部的x是一致的，所以最后输出的就是2，而外层的全局变量x依然不受影响。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(x, y = <span class="keyword">function</span>()</span> <span class="comment">&#123; x = 2; &#125;</span>) <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  x = 3;</span></span></span><br><span class="line"><span class="function"><span class="comment">  y();</span></span></span><br><span class="line"><span class="function"><span class="comment">  console.log(x);</span></span></span><br><span class="line"><span class="function"><span class="comment">&#125;</span></span></span><br><span class="line"><span class="function"></span></span><br><span class="line"><span class="function"><span class="title">foo</span><span class="params">()</span> <span class="comment">// 2</span></span></span><br><span class="line"><span class="function"><span class="title">x</span> <span class="comment">// 1</span></span></span><br></pre></td></tr></table></figure>
<h4 id="应用"><a href="#应用" class="headerlink" title="应用"></a>应用</h4><p>利用参数默认值，可以指定某一个参数不得省略，如果省略就抛出一个错误。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">throwIfMissing</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'Missing parameter'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params">mustBeProvided = throwIfMissing(</span>)) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> mustBeProvided;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo()</span><br><span class="line"><span class="comment">// Error: Missing parameter</span></span><br></pre></td></tr></table></figure>
<p>上面代码的foo函数，如果调用的时候没有参数，就会调用默认值throwIfMissing函数，从而抛出一个错误。</p>
<p>从上面代码还可以看到，参数mustBeProvided的默认值等于throwIfMissing函数的运行结果（注意函数名throwIfMissing之后有一对圆括号），这表明参数的默认值不是在定义时执行，而是在运行时执行。如果参数已经赋值，默认值中的函数就不会运行。</p>
<p>另外，可以将参数默认值设为undefined，表明这个参数是可以省略的。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">(optional = <span class="literal">undef</span>ined)</span> &#123;</span> ··· &#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-rest-参数"><a href="#2-rest-参数" class="headerlink" title="2.rest 参数"></a>2.rest 参数</h3><p>ES6 引入 rest 参数（形式为…变量名），用于获取函数的多余参数，这样就不需要使用arguments对象了。rest 参数搭配的变量是一个数组，该变量将多余的参数放入数组中。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">(<span class="rest_arg">...values</span>)</span> </span>&#123;</span><br><span class="line">  let sum = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">var</span> val of values) &#123;</span><br><span class="line">    sum += val;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> sum;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add(<span class="number">2</span>, <span class="number">5</span>, <span class="number">3</span>) <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码的add函数是一个求和函数，利用 rest 参数，可以向该函数传入任意数目的参数。</p>
<p>下面是一个 rest 参数代替arguments变量的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// arguments变量的写法</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sortNumbers</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Array</span>.prototype.slice.call(<span class="built_in">arguments</span>).sort();</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// rest参数的写法</span></span><br><span class="line"><span class="keyword">const</span> sortNumbers = <span class="function">(<span class="params">...numbers</span>) =&gt;</span> numbers.sort();</span><br></pre></td></tr></table></figure>
<p>上面代码的两种写法，比较后可以发现，rest 参数的写法更自然也更简洁。</p>
<p>arguments对象不是数组，而是一个类似数组的对象。所以为了使用数组的方法，必须使用Array.prototype.slice.call先将其转为数组。rest 参数就不存在这个问题，它就是一个真正的数组，数组特有的方法都可以使用。下面是一个利用 rest 参数改写数组push方法的例子。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">push</span><span class="params">(array, <span class="rest_arg">...items</span>)</span> </span>&#123;</span><br><span class="line">  items.forEach(<span class="function"><span class="keyword">function</span><span class="params">(item)</span> </span>&#123;</span><br><span class="line">    array.push(item);</span><br><span class="line">    console.log(item);</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line">push(a, <span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br></pre></td></tr></table></figure>
<p>注意，rest 参数之后不能再有其他参数（即只能是最后一个参数），否则会报错。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(a, <span class="rest_arg">...b</span>, c)</span> </span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>函数的length属性，不包括 rest 参数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(a)</span> </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(<span class="rest_arg">...a</span>)</span> </span>&#123;&#125;).length  <span class="comment">// 0</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">(a, <span class="rest_arg">...b</span>)</span> </span>&#123;&#125;).length  <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h3 id="3-严格模式"><a href="#3-严格模式" class="headerlink" title="3.严格模式"></a>3.严格模式</h3><p>从 ES5 开始，函数内部可以设定为严格模式。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>ES2016 做了一点修改，规定只要函数参数使用了默认值、解构赋值、或者扩展运算符，那么函数内部就不能显式设定为严格模式，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b = a</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function"><span class="keyword">function</span> (<span class="params">&#123;a, b&#125;</span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">const</span> doSomething = <span class="function">(<span class="params">...a</span>) =&gt;</span> &#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> obj = &#123;</span><br><span class="line">  <span class="comment">// 报错</span></span><br><span class="line">  doSomething(&#123;a, b&#125;) &#123;</span><br><span class="line"><span class="meta">    'use strict'</span>;</span><br><span class="line">    <span class="comment">// code</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样规定的原因是，函数内部的严格模式，同时适用于函数体和函数参数。但是，函数执行的时候，先执行函数参数，然后再执行函数体。这样就有一个不合理的地方，只有从函数体之中，才能知道参数是否应该以严格模式执行，但是参数却应该先于函数体执行。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">value = <span class="number">070</span></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">return</span> value;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，参数value的默认值是八进制数070，但是严格模式下不能用前缀0表示八进制，所以应该报错。但是实际上，JavaScript 引擎会先成功执行value = 070，然后进入函数体内部，发现需要用严格模式执行，这时才会报错。</p>
<p>虽然可以先解析函数体代码，再执行参数代码，但是这样无疑就增加了复杂性。因此，标准索性禁止了这种用法，只要参数使用了默认值、解构赋值、或者扩展运算符，就不能显式指定严格模式。</p>
<p>两种方法可以规避这种限制。第一种是设定全局性的严格模式，这是合法的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">doSomething</span>(<span class="params">a, b = a</span>) </span>&#123;</span><br><span class="line">  <span class="comment">// code</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>第二种是把函数包在一个无参数的立即执行函数里面。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> doSomething = (<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">value = <span class="number">42</span></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> value;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<h3 id="4-name-属性"><a href="#4-name-属性" class="headerlink" title="4.name 属性"></a>4.name 属性</h3><p>函数的name属性，返回该函数的函数名。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">foo.name <span class="comment">// "foo"</span></span><br></pre></td></tr></table></figure>
<p>这个属性早就被浏览器广泛支持，但是直到 ES6，才将其写入了标准。</p>
<p>需要注意的是，ES6 对这个属性的行为做出了一些修改。如果将一个匿名函数赋值给一个变量，ES5 的name属性，会返回空字符串，而 ES6 的name属性会返回实际的函数名。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="params">()</span> <span class="comment">&#123;&#125;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">f.<span class="keyword">name</span> <span class="comment">// ""</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">f.<span class="keyword">name</span> <span class="comment">// "f"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量f等于一个匿名函数，ES5 和 ES6 的name属性返回的值不一样。</p>
<p>如果将一个具名函数赋值给一个变量，则 ES5 和 ES6 的name属性都返回这个具名函数原本的名字。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">baz</span><span class="params">()</span> <span class="comment">&#123;&#125;</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line">bar.<span class="keyword">name</span> <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6</span></span><br><span class="line">bar.<span class="keyword">name</span> <span class="comment">// "baz"</span></span><br></pre></td></tr></table></figure>
<p>Function构造函数返回的函数实例，name属性的值为anonymous。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="keyword">new</span> <span class="keyword">Function</span>).name // <span class="string">"anonymous"</span></span><br></pre></td></tr></table></figure>
<p>bind返回的函数，name属性值会加上bound前缀。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> <span class="comment">&#123;&#125;</span>;</span></span><br><span class="line">foo.bind(<span class="comment">&#123;&#125;</span>).<span class="keyword">name</span> <span class="comment">// "bound foo"</span></span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span><span class="params">()</span><span class="comment">&#123;&#125;</span>).<span class="title">bind</span><span class="params">(<span class="comment">&#123;&#125;</span>)</span>.<span class="title">name</span> <span class="comment">// "bound "</span></span></span><br></pre></td></tr></table></figure>
<h3 id="5-箭头函数"><a href="#5-箭头函数" class="headerlink" title="5.箭头函数"></a>5.箭头函数</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 允许使用“箭头”（=&gt;）定义函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">v</span> =&gt;</span> v;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params">v</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> v;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果箭头函数不需要参数或需要多个参数，就使用一个圆括号代表参数部分。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="params">()</span> =&gt;</span> <span class="number">5</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123; <span class="keyword">return</span> <span class="number">5</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function">(<span class="params">num1, num2</span>) =&gt;</span> num1 + num2;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> sum = <span class="function"><span class="keyword">function</span>(<span class="params">num1, num2</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> num1 + num2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>如果箭头函数的代码块部分多于一条语句，就要使用大括号将它们括起来，并且使用return语句返回。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">var sum = <span class="function"><span class="params">(num1, num2)</span> =&gt;</span> &#123; <span class="keyword">return</span> num1 + num2; &#125;</span><br></pre></td></tr></table></figure>
<p>由于大括号被解释为代码块，所以如果箭头函数直接返回一个对象，必须在对象外面加上括号，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> &#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">let</span> getTempItem = <span class="function"><span class="params">id</span> =&gt;</span> (&#123; <span class="attr">id</span>: id, <span class="attr">name</span>: <span class="string">"Temp"</span> &#125;);</span><br></pre></td></tr></table></figure>
<p>下面是一种特殊情况，虽然可以运行，但会得到错误的结果。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let foo = <span class="function"><span class="params">()</span> =&gt;</span> &#123; a: <span class="number">1</span> &#125;;</span><br><span class="line">foo() <span class="regexp">//</span> <span class="literal">undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，原始意图是返回一个对象{ a: 1 }，但是由于引擎认为大括号是代码块，所以执行了一行语句a: 1。这时，a可以被解释为语句的标签，因此实际执行的语句是1;，然后函数就结束了，没有返回值。</p>
<p>如果箭头函数只有一行语句，且不需要返回值，可以采用下面的写法，就不用写大括号了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> fn = <span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">void</span> doesNotReturn();</span><br></pre></td></tr></table></figure>
<p>箭头函数可以与变量解构结合使用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> full = <span class="function">(<span class="params">&#123; first, last &#125;</span>) =&gt;</span> first + <span class="string">' '</span> + last;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">full</span>(<span class="params">person</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> person.first + <span class="string">' '</span> + person.last;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>箭头函数使得表达更加简洁。</p>
<figure class="highlight excel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">isEven</span> = <span class="built_in">n</span> =&gt; <span class="built_in">n</span> % <span class="number">2</span> == <span class="number">0</span>;</span><br><span class="line">const square = <span class="built_in">n</span> =&gt; <span class="built_in">n</span> * <span class="built_in">n</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码只用了两行，就定义了两个简单的工具函数。如果不用箭头函数，可能就要占用多行，而且还不如现在这样写醒目。</p>
<p>箭头函数的一个用处是简化回调函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x * x;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line">[<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>].map(<span class="function"><span class="params">x</span> =&gt;</span> x * x);</span><br></pre></td></tr></table></figure>
<p>另一个例子是</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 正常函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function"><span class="keyword">function</span> (<span class="params">a, b</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> a - b;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 箭头函数写法</span></span><br><span class="line"><span class="keyword">var</span> result = values.sort(<span class="function">(<span class="params">a, b</span>) =&gt;</span> a - b);</span><br></pre></td></tr></table></figure>
<p>下面是 rest 参数与箭头函数结合的例子。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">const numbers = (...nums) =&gt; nums;</span><br><span class="line"></span><br><span class="line">numbers(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,2,3,4,5]</span></span><br><span class="line"></span><br><span class="line">const headAndTail = (head, ...tail) =&gt; [head, tail];</span><br><span class="line"></span><br><span class="line">headAndTail(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>)</span><br><span class="line"><span class="comment">// [1,[2,3,4,5]]</span></span><br></pre></td></tr></table></figure>
<h4 id="使用注意点"><a href="#使用注意点" class="headerlink" title="使用注意点"></a>使用注意点</h4><p>箭头函数有几个使用注意点。</p>
<p>（1）函数体内的this对象，就是定义时所在的对象，而不是使用时所在的对象。</p>
<p>（2）不可以当作构造函数，也就是说，不可以使用new命令，否则会抛出一个错误。</p>
<p>（3）不可以使用arguments对象，该对象在函数体内不存在。如果要用，可以用 rest 参数代替。</p>
<p>（4）不可以使用yield命令，因此箭头函数不能用作 Generator 函数。</p>
<p>上面四点中，第一点尤其值得注意。this对象的指向是可变的，但是在箭头函数中，它是固定的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> id = <span class="number">21</span>;</span><br><span class="line"></span><br><span class="line">foo.call(&#123; <span class="attr">id</span>: <span class="number">42</span> &#125;);</span><br><span class="line"><span class="comment">// id: 42</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，setTimeout的参数是一个箭头函数，这个箭头函数的定义生效是在foo函数生成时，而它的真正执行要等到 100 毫秒后。如果是普通函数，执行时this应该指向全局对象window，这时应该输出21。但是，箭头函数导致this总是指向函数定义生效时所在的对象（本例是{id: 42}），所以输出的是42。</p>
<p>箭头函数可以让setTimeout里面的this，绑定定义时所在的作用域，而不是指向运行时所在的作用域。下面是另一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Timer</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">this</span>.s1 = <span class="number">0</span>;</span><br><span class="line">  <span class="keyword">this</span>.s2 = <span class="number">0</span>;</span><br><span class="line">  <span class="comment">// 箭头函数</span></span><br><span class="line">  setInterval(<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.s1++, <span class="number">1000</span>);</span><br><span class="line">  <span class="comment">// 普通函数</span></span><br><span class="line">  setInterval(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.s2++;</span><br><span class="line">  &#125;, <span class="number">1000</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> timer = <span class="keyword">new</span> Timer();</span><br><span class="line"></span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s1: '</span>, timer.s1), <span class="number">3100</span>);</span><br><span class="line">setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> <span class="built_in">console</span>.log(<span class="string">'s2: '</span>, timer.s2), <span class="number">3100</span>);</span><br><span class="line"><span class="comment">// s1: 3</span></span><br><span class="line"><span class="comment">// s2: 0</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Timer函数内部设置了两个定时器，分别使用了箭头函数和普通函数。前者的this绑定定义时所在的作用域（即Timer函数），后者的this指向运行时所在的作用域（即全局对象）。所以，3100 毫秒之后，timer.s1被更新了 3 次，而timer.s2一次都没更新。</p>
<p>箭头函数可以让this指向固定化，这种特性很有利于封装回调函数。下面是一个例子，DOM 事件的回调函数封装在一个对象里面。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> handler = &#123;</span><br><span class="line">  id: <span class="string">'123456'</span>,</span><br><span class="line"></span><br><span class="line">  init: <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">document</span>.addEventListener(<span class="string">'click'</span>,</span><br><span class="line">      event =&gt; <span class="keyword">this</span>.doSomething(event.type), <span class="literal">false</span>);</span><br><span class="line">  &#125;,</span><br><span class="line"></span><br><span class="line">  doSomething: <span class="function"><span class="keyword">function</span>(<span class="params"><span class="keyword">type</span></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'Handling '</span> + <span class="keyword">type</span>  + <span class="string">' for '</span> + <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码的init方法中，使用了箭头函数，这导致这个箭头函数里面的this，总是指向handler对象。否则，回调函数运行时，this.doSomething这一行会报错，因为此时this指向document对象。</p>
<p>this指向的固定化，并不是因为箭头函数内部有绑定this的机制，实际原因是箭头函数根本没有自己的this，导致内部的this就是外层代码块的this。正是因为它没有this，所以也就不能用作构造函数。</p>
<p>所以，箭头函数转成 ES5 的代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES6</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES5</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> _this = <span class="keyword">this</span>;</span><br><span class="line"></span><br><span class="line">  setTimeout(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'id:'</span>, _this.id);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，转换后的 ES5 版本清楚地说明了，箭头函数里面根本没有自己的this，而是引用外层的this。</p>
<p>请问下面的代码之中有几个this？</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">        <span class="built_in">console</span>.log(<span class="string">'id:'</span>, <span class="keyword">this</span>.id);</span><br><span class="line">      &#125;;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> f = foo.call(&#123;<span class="attr">id</span>: <span class="number">1</span>&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> t1 = f.call(&#123;<span class="attr">id</span>: <span class="number">2</span>&#125;)()(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t2 = f().call(&#123;<span class="attr">id</span>: <span class="number">3</span>&#125;)(); <span class="comment">// id: 1</span></span><br><span class="line"><span class="keyword">var</span> t3 = f()().call(&#123;<span class="attr">id</span>: <span class="number">4</span>&#125;); <span class="comment">// id: 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码之中，只有一个this，就是函数foo的this，所以t1、t2、t3都输出同样的结果。因为所有的内层函数都是箭头函数，都没有自己的this，它们的this其实都是最外层foo函数的this。</p>
<p>除了this，以下三个变量在箭头函数之中也是不存在的，指向外层函数的对应变量：arguments、super、new.target。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  setTimeout(<span class="function"><span class="params">()</span> =&gt;</span> &#123;</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'args:'</span>, <span class="built_in">arguments</span>);</span><br><span class="line">  &#125;, <span class="number">100</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">foo(<span class="number">2</span>, <span class="number">4</span>, <span class="number">6</span>, <span class="number">8</span>)</span><br><span class="line"><span class="comment">// args: [2, 4, 6, 8]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，箭头函数内部的变量arguments，其实是函数foo的arguments变量。</p>
<p>另外，由于箭头函数没有自己的this，所以当然也就不能用call()、apply()、bind()这些方法去改变this的指向。</p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [</span><br><span class="line">    (<span class="function"><span class="params">()</span> =&gt;</span> <span class="keyword">this</span>.x).bind(&#123; x: <span class="string">'inner'</span> &#125;)()</span><br><span class="line">  ];</span><br><span class="line">&#125;).call(&#123; x: <span class="string">'outer'</span> &#125;);</span><br><span class="line"><span class="comment">// ['outer']</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，箭头函数没有自己的this，所以bind方法无效，内部的this指向外部的this。</p>
<p>长期以来，JavaScript 语言的this对象一直是一个令人头痛的问题，在对象方法中使用this，必须非常小心。箭头函数”绑定”this，很大程度上解决了这个困扰。</p>
<h4 id="嵌套的箭头函数"><a href="#嵌套的箭头函数" class="headerlink" title="嵌套的箭头函数"></a>嵌套的箭头函数</h4><p>箭头函数内部，还可以再使用箭头函数。下面是一个 ES5 语法的多重嵌套函数。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">insert</span><span class="params">(value)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;into: <span class="function"><span class="keyword">function</span> <span class="params">(array)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> &#123;after: <span class="function"><span class="keyword">function</span> <span class="params">(afterValue)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">array</span>.splice(<span class="keyword">array</span>.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, value);</span><br><span class="line">      <span class="keyword">return</span> <span class="keyword">array</span>;</span><br><span class="line">    &#125;&#125;;</span><br><span class="line">  &#125;&#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">insert(<span class="number">2</span>).into([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); <span class="comment">//[1, 2, 3]</span></span><br></pre></td></tr></table></figure>
<p>上面这个函数，可以使用箭头函数改写。</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let <span class="keyword">insert</span> = (<span class="keyword">value</span>) =&gt; (&#123;<span class="keyword">into</span>: (<span class="keyword">array</span>) =&gt; (&#123;after: (afterValue) =&gt; &#123;</span><br><span class="line">  <span class="keyword">array</span>.splice(<span class="keyword">array</span>.indexOf(afterValue) + <span class="number">1</span>, <span class="number">0</span>, <span class="keyword">value</span>);</span><br><span class="line">  return array;</span><br><span class="line">&#125;&#125;)&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">insert</span>(<span class="number">2</span>).<span class="keyword">into</span>([<span class="number">1</span>, <span class="number">3</span>]).after(<span class="number">1</span>); //[1, 2, 3]</span><br></pre></td></tr></table></figure>
<p>下面是一个部署管道机制（pipeline）的例子，即前一个函数的输出是后一个函数的输入。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> pipeline = <span class="function">(<span class="params">...funcs</span>) =&gt;</span></span><br><span class="line">  val =&gt; funcs.reduce(<span class="function">(<span class="params">a, b</span>) =&gt;</span> b(a), val);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"><span class="keyword">const</span> addThenMult = pipeline(plus1, mult2);</span><br><span class="line"></span><br><span class="line">addThenMult(<span class="number">5</span>)</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>如果觉得上面的写法可读性比较差，也可以采用下面的写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> plus1 = <span class="function"><span class="params">a</span> =&gt;</span> a + <span class="number">1</span>;</span><br><span class="line"><span class="keyword">const</span> mult2 = <span class="function"><span class="params">a</span> =&gt;</span> a * <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">mult2(plus1(<span class="number">5</span>))</span><br><span class="line"><span class="comment">// 12</span></span><br></pre></td></tr></table></figure>
<p>箭头函数还有一个功能，就是可以很方便地改写 λ 演算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// λ演算的写法</span></span><br><span class="line">fix = λf.(λx.f(λv.x(x)(v)))(λx.f(λv.x(x)(v)))</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line"><span class="keyword">var</span> fix = <span class="function"><span class="params">f</span> =&gt;</span> (<span class="function"><span class="params">x</span> =&gt;</span> f(<span class="function"><span class="params">v</span> =&gt;</span> x(x)(v)))</span><br><span class="line">               (<span class="function"><span class="params">x</span> =&gt;</span> f(<span class="function"><span class="params">v</span> =&gt;</span> x(x)(v)));</span><br></pre></td></tr></table></figure>
<p>上面两种写法，几乎是一一对应的。由于 λ 演算对于计算机科学非常重要，这使得我们可以用 ES6 作为替代工具，探索计算机科学。</p>
<h3 id="6-双冒号运算符"><a href="#6-双冒号运算符" class="headerlink" title="6.双冒号运算符"></a>6.双冒号运算符</h3><p>箭头函数可以绑定this对象，大大减少了显式绑定this对象的写法（call、apply、bind）。但是，箭头函数并不适用于所有场合，所以现在有一个提案，提出了“函数绑定”（function bind）运算符，用来取代call、apply、bind调用。</p>
<p>函数绑定运算符是并排的两个冒号（::），双冒号左边是一个对象，右边是一个函数。该运算符会自动将左边的对象，作为上下文环境（即this对象），绑定到右边的函数上面。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">foo::bar;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.bind(foo);</span><br><span class="line"></span><br><span class="line">foo::bar(...arguments);</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">bar.apply(foo, arguments);</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> hasOwnProperty = Object.prototype.hasOwnProperty;</span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">hasOwn</span><span class="params">(obj, key)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> obj::hasOwnProperty(key);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>如果双冒号左边为空，右边是一个对象的方法，则等于将该方法绑定在该对象上面。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">method</span> = <span class="title">obj</span>:</span>:obj.foo;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> <span class="function"><span class="keyword">method</span> = :</span>:obj.foo;</span><br><span class="line"></span><br><span class="line">let log = ::console.log;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">var</span> log = console.log.bind(console);</span><br></pre></td></tr></table></figure>
<p>如果双冒号运算符的运算结果，还是一个对象，就可以采用链式写法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> &#123; map, takeWhile, forEach &#125; <span class="keyword">from</span> <span class="string">"iterlib"</span>;</span><br><span class="line"></span><br><span class="line">getPlayers()</span><br><span class="line">::map(<span class="function"><span class="params">x</span> =&gt;</span> x.character())</span><br><span class="line">::takeWhile(<span class="function"><span class="params">x</span> =&gt;</span> x.strength &gt; <span class="number">100</span>)</span><br><span class="line">::forEach(<span class="function"><span class="params">x</span> =&gt;</span> <span class="built_in">console</span>.log(x));</span><br></pre></td></tr></table></figure>
<h3 id="7-尾调用优化"><a href="#7-尾调用优化" class="headerlink" title="7.尾调用优化"></a>7.尾调用优化</h3><h4 id="什么是尾调用？"><a href="#什么是尾调用？" class="headerlink" title="什么是尾调用？"></a>什么是尾调用？</h4><p>尾调用（Tail Call）是函数式编程的一个重要概念，本身非常简单，一句话就能说清楚，就是指某个函数的最后一步是调用另一个函数。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">f</span>(x)&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">g(x)</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数f的最后一步是调用函数g，这就叫尾调用。</p>
<p>以下三种情况，都不属于尾调用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">let</span> y = g(x);</span><br><span class="line">  <span class="keyword">return</span> y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(x) + <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况三</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params">x</span>)</span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，情况一是调用函数g之后，还有赋值操作，所以不属于尾调用，即使语义完全一样。情况二也属于调用后还有操作，即使写在一行内。情况三等同于下面的代码。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span></span>&#123;</span><br><span class="line">  g(x);</span><br><span class="line">  <span class="keyword">return</span> <span class="literal">undefined</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>尾调用不一定出现在函数尾部，只要是最后一步操作即可。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (x &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> m(x)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> n(x);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，函数m和n都属于尾调用，因为它们都是函数f的最后一步操作。</p>
<h4 id="尾调用优化"><a href="#尾调用优化" class="headerlink" title="尾调用优化"></a>尾调用优化</h4><p>尾调用之所以与其他调用不同，就在于它的特殊的调用位置。</p>
<p>我们知道，函数调用会在内存形成一个“调用记录”，又称“调用帧”（call frame），保存调用位置和内部变量等信息。如果在函数A的内部调用函数B，那么在A的调用帧上方，还会形成一个B的调用帧。等到B运行结束，将结果返回到A，B的调用帧才会消失。如果函数B内部还调用函数C，那就还有一个C的调用帧，以此类推。所有的调用帧，就形成一个“调用栈”（call stack）。</p>
<p>尾调用由于是函数的最后一步操作，所以不需要保留外层函数的调用帧，因为调用位置、内部变量等信息都不会再用到了，只要直接用内层函数的调用帧，取代外层函数的调用帧就可以了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> m = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">2</span>;</span><br><span class="line">  <span class="keyword">return</span> g(m + n);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> g(<span class="number">3</span>);</span><br><span class="line">&#125;</span><br><span class="line">f();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">g(<span class="number">3</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果函数g不是尾调用，函数f就需要保存内部变量m和n的值、g的调用位置等信息。但由于调用g之后，函数f就结束了，所以执行到最后一步，完全可以删除f(x)的调用帧，只保留g(3)的调用帧。</p>
<p>这就叫做“尾调用优化”（Tail call optimization），即只保留内层函数的调用帧。如果所有函数都是尾调用，那么完全可以做到每次执行时，调用帧只有一项，这将大大节省内存。这就是“尾调用优化”的意义。</p>
<p>注意，只有不再用到外层函数的内部变量，内层函数的调用帧才会取代外层函数的调用帧，否则就无法进行“尾调用优化”。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">addOne</span><span class="params">(a)</span></span>&#123;</span><br><span class="line">  <span class="keyword">var</span> one = <span class="number">1</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">inner</span><span class="params">(b)</span></span>&#123;</span><br><span class="line">    <span class="keyword">return</span> b + one;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> inner(a);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数不会进行尾调用优化，因为内层函数inner用到了外层函数addOne的内部变量one。</p>
<h4 id="尾递归"><a href="#尾递归" class="headerlink" title="尾递归"></a>尾递归</h4><p>函数调用自身，称为递归。如果尾调用自身，就称为尾递归。</p>
<p>递归非常耗费内存，因为需要同时保存成千上百个调用帧，很容易发生“栈溢出”错误（stack overflow）。但对于尾递归来说，由于只存在一个调用帧，所以永远不会发生“栈溢出”错误。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">return</span> n * factorial(n - <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>上面代码是一个阶乘函数，计算n的阶乘，最多需要保存n个调用记录，复杂度 O(n) 。</p>
<p>如果改写成尾递归，只保留一个调用记录，复杂度 O(1) 。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n, total)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>, <span class="number">1</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>还有一个比较著名的例子，就是计算 Fibonacci 数列，也能充分说明尾递归优化的重要性。</p>
<p>非尾递归的 Fibonacci 数列实现如下。</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">function</span> <span class="selector-tag">Fibonacci</span> (n) &#123;</span><br><span class="line">  <span class="selector-tag">if</span> ( n &lt;= <span class="number">1</span> ) &#123;<span class="selector-tag">return</span> <span class="selector-tag">1</span>&#125;;</span><br><span class="line"></span><br><span class="line">  <span class="selector-tag">return</span> <span class="selector-tag">Fibonacci</span>(n - <span class="number">1</span>) + <span class="selector-tag">Fibonacci</span>(n - <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="selector-tag">Fibonacci</span>(<span class="number">10</span>) <span class="comment">// 89</span></span><br><span class="line"><span class="selector-tag">Fibonacci</span>(<span class="number">100</span>) <span class="comment">// 堆栈溢出</span></span><br><span class="line"><span class="selector-tag">Fibonacci</span>(<span class="number">500</span>) <span class="comment">// 堆栈溢出</span></span><br></pre></td></tr></table></figure>
<p>尾递归优化过的 Fibonacci 数列实现如下。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function Fibonacci2 (n , ac1 = <span class="number">1</span> , ac2 = <span class="number">1</span>) &#123;</span><br><span class="line">  if( n &lt;= <span class="number">1</span> ) &#123;return ac2&#125;;</span><br><span class="line"></span><br><span class="line">  return Fibonacci2 (n - <span class="number">1</span>, ac2, ac1 + ac2);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">Fibonacci2(<span class="number">100</span>) <span class="comment">// 573147844013817200000</span></span><br><span class="line">Fibonacci2(<span class="number">1000</span>) <span class="comment">// 7.0330367711422765e+208</span></span><br><span class="line">Fibonacci2(<span class="number">10000</span>) <span class="comment">// Infinity</span></span><br></pre></td></tr></table></figure>
<p>由此可见，“尾调用优化”对递归操作意义重大，所以一些函数式编程语言将其写入了语言规格。ES6 是如此，第一次明确规定，所有 ECMAScript 的实现，都必须部署“尾调用优化”。这就是说，ES6 中只要使用尾递归，就不会发生栈溢出，相对节省内存。</p>
<h4 id="递归函数的改写"><a href="#递归函数的改写" class="headerlink" title="递归函数的改写"></a>递归函数的改写</h4><p>尾递归的实现，往往需要改写递归函数，确保最后一步只调用自身。做到这一点的方法，就是把所有用到的内部变量改写成函数的参数。比如上面的例子，阶乘函数 factorial 需要用到一个中间变量total，那就把这个中间变量改写成函数的参数。这样做的缺点就是不太直观，第一眼很难看出来，为什么计算5的阶乘，需要传入两个参数5和1？</p>
<p>两个方法可以解决这个问题。方法一是在尾递归函数之外，再提供一个正常形式的函数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span><span class="params">(n, total)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n, <span class="number">1</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>上面代码通过一个正常形式的阶乘函数factorial，调用尾递归函数tailFactorial，看起来就正常多了。</p>
<p>函数式编程有一个概念，叫做柯里化（currying），意思是将多参数的函数转换成单参数的形式。这里也可以使用柯里化。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">currying</span><span class="params">(fn, n)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="params">(m)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> fn.call(<span class="keyword">this</span>, m, n);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tailFactorial</span><span class="params">(n, total)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> tailFactorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> factorial = currying(tailFactorial, <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>上面代码通过柯里化，将尾递归函数tailFactorial变为只接受一个参数的factorial。</p>
<p>第二种方法就简单多了，就是采用 ES6 的函数默认值。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">factorial</span><span class="params">(n, total = 1)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (n === <span class="number">1</span>) <span class="keyword">return</span> total;</span><br><span class="line">  <span class="keyword">return</span> factorial(n - <span class="number">1</span>, n * total);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">factorial(<span class="number">5</span>) <span class="comment">// 120</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，参数total有默认值1，所以调用时不用提供这个值。</p>
<p>总结一下，递归本质上是一种循环操作。纯粹的函数式编程语言没有循环操作命令，所有的循环都用递归实现，这就是为什么尾递归对这些语言极其重要。对于其他支持“尾调用优化”的语言（比如 Lua，ES6），只需要知道循环可以用递归代替，而一旦使用递归，就最好使用尾递归。</p>
<h4 id="严格模式"><a href="#严格模式" class="headerlink" title="严格模式"></a>严格模式</h4><p>ES6 的尾调用优化只在严格模式下开启，正常模式是无效的。</p>
<p>这是因为在正常模式下，函数内部有两个变量，可以跟踪函数的调用栈。</p>
<ul>
<li>func.arguments：返回调用时函数的参数。</li>
<li>func.caller：返回调用当前函数的那个函数。</li>
</ul>
<p>尾调用优化发生时，函数的调用栈会改写，因此上面两个变量就会失真。严格模式禁用这两个变量，所以尾调用模式仅在严格模式下生效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">restricted</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  restricted.caller;    <span class="comment">// 报错</span></span><br><span class="line">  restricted.arguments; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line">restricted();</span><br></pre></td></tr></table></figure>
<h4 id="尾递归优化的实现"><a href="#尾递归优化的实现" class="headerlink" title="尾递归优化的实现"></a>尾递归优化的实现</h4><p>尾递归优化只在严格模式下生效，那么正常模式下，或者那些不支持该功能的环境中，有没有办法也使用尾递归优化呢？回答是可以的，就是自己实现尾递归优化。</p>
<p>它的原理非常简单。尾递归之所以需要优化，原因是调用栈太多，造成溢出，那么只要减少调用栈，就不会溢出。怎么做可以减少调用栈呢？就是采用“循环”换掉“递归”。</p>
<p>下面是一个正常的递归函数。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">sum</span>(x, y) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>(x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">sum</span>(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line">// Uncaught RangeError: Maximum <span class="keyword">call</span> stack <span class="built_in">size</span> exceeded(…)</span><br></pre></td></tr></table></figure>
<p>上面代码中，sum是一个递归函数，参数x是需要累加的值，参数y控制递归次数。一旦指定sum递归 100000 次，就会报错，提示超出调用栈的最大次数。</p>
<p>蹦床函数（trampoline）可以将递归执行转为循环执行。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trampoline</span><span class="params">(f)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">while</span> (f &amp;&amp; f <span class="keyword">instanceof</span> <span class="function"><span class="keyword">Function</span>) </span>&#123;</span><br><span class="line">    f = f();</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> f;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面就是蹦床函数的一个实现，它接受一个函数f作为参数。只要f执行后返回一个函数，就继续执行。注意，这里是返回一个函数，然后执行该函数，而不是函数里面调用函数，这样就避免了递归执行，从而就消除了调用栈过大的问题。</p>
<p>然后，要做的就是将原来的递归函数，改写为每一步返回另一个函数。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span></span> <span class="built_in">sum</span>(x, y) &#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">sum</span>.<span class="keyword">bind</span>(null, x + <span class="number">1</span>, y - <span class="number">1</span>);</span><br><span class="line">  &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，sum函数的每次执行，都会返回自身的另一个版本。</p>
<p>现在，使用蹦床函数执行sum，就不会发生调用栈溢出。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">trampoline</span><span class="params">(sum(<span class="number">1</span>, <span class="number">100000</span>)</span></span>)</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure>
<p>蹦床函数并不是真正的尾递归优化，下面的实现才是。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tco</span>(<span class="params">f</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> value;</span><br><span class="line">  <span class="keyword">var</span> active = <span class="literal">false</span>;</span><br><span class="line">  <span class="keyword">var</span> accumulated = [];</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> <span class="title">accumulator</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    accumulated.push(<span class="built_in">arguments</span>);</span><br><span class="line">    <span class="keyword">if</span> (!active) &#123;</span><br><span class="line">      active = <span class="literal">true</span>;</span><br><span class="line">      <span class="keyword">while</span> (accumulated.length) &#123;</span><br><span class="line">        value = f.apply(<span class="keyword">this</span>, accumulated.shift());</span><br><span class="line">      &#125;</span><br><span class="line">      active = <span class="literal">false</span>;</span><br><span class="line">      <span class="keyword">return</span> value;</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> sum = tco(<span class="function"><span class="keyword">function</span>(<span class="params">x, y</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (y &gt; <span class="number">0</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> sum(x + <span class="number">1</span>, y - <span class="number">1</span>)</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> x</span><br><span class="line">  &#125;</span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line">sum(<span class="number">1</span>, <span class="number">100000</span>)</span><br><span class="line"><span class="comment">// 100001</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，tco函数是尾递归优化的实现，它的奥妙就在于状态变量active。默认情况下，这个变量是不激活的。一旦进入尾递归优化的过程，这个变量就激活了。然后，每一轮递归sum返回的都是undefined，所以就避免了递归执行；而accumulated数组存放每一轮sum执行的参数，总是有值的，这就保证了accumulator函数内部的while循环总是会执行。这样就很巧妙地将“递归”改成了“循环”，而后一轮的参数会取代前一轮的参数，保证了调用栈只有一层。</p>
<h3 id="8-函数参数的尾逗号"><a href="#8-函数参数的尾逗号" class="headerlink" title="8.函数参数的尾逗号"></a>8.函数参数的尾逗号</h3><p>ES2017 允许函数的最后一个参数有尾逗号（trailing comma）。</p>
<p>此前，函数定义和调用时，都不允许最后一个参数后面出现逗号。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clownsEverywhere</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  param1,</span></span></span><br><span class="line"><span class="function"><span class="params">  param2</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">  <span class="string">'foo'</span>,</span><br><span class="line">  <span class="string">'bar'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果在param2或bar后面加一个逗号，就会报错。</p>
<p>如果像上面这样，将参数写成多行（即每个参数占据一行），以后修改代码的时候，想为函数clownsEverywhere添加第三个参数，或者调整参数的次序，就势必要在原来最后一个参数后面添加一个逗号。这对于版本管理系统来说，就会显示添加逗号的那一行也发生了变动。这看上去有点冗余，因此新的语法允许定义和调用时，尾部直接有一个逗号。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">clownsEverywhere</span><span class="params">(</span></span></span><br><span class="line"><span class="function"><span class="params">  param1,</span></span></span><br><span class="line"><span class="function"><span class="params">  param2,</span></span></span><br><span class="line"><span class="function"><span class="params">)</span> </span>&#123; <span class="comment">/* ... */</span> &#125;</span><br><span class="line"></span><br><span class="line">clownsEverywhere(</span><br><span class="line">  <span class="string">'foo'</span>,</span><br><span class="line">  <span class="string">'bar'</span>,</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>这样的规定也使得，函数参数与数组和对象的尾逗号规则，保持一致了。</p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 06.数值的扩展]]></title>
      <url>/2018/06/12/ES6/06.%E6%95%B0%E5%80%BC%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="数值的扩展"><a href="#数值的扩展" class="headerlink" title="数值的扩展"></a>数值的扩展</h2><h3 id="1-二进制和八进制表示法"><a href="#1-二进制和八进制表示法" class="headerlink" title="1.二进制和八进制表示法"></a>1.二进制和八进制表示法</h3><p>ES6 提供了二进制和八进制数值的新的写法，分别用前缀0b（或0B）和0o（或0O）表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0b111110111</span> === <span class="number">503</span> <span class="comment">// true</span></span><br><span class="line"><span class="number">0o767</span> === <span class="number">503</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>从 ES5 开始，在严格模式之中，八进制就不再允许使用前缀0表示，ES6 进一步明确，要使用前缀0o表示。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 非严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 严格模式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line"><span class="meta">  'use strict'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="number">0o11</span> === <span class="number">011</span>);</span><br><span class="line">&#125;)() <span class="comment">// Uncaught SyntaxError: Octal literals are not allowed in strict mode.</span></span><br></pre></td></tr></table></figure>
<p>如果要将0b和0o前缀的字符串数值转为十进制，要使用Number方法。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number('<span class="number">0b111</span>')  // <span class="number">7</span></span><br><span class="line">Number('<span class="number">0o10</span>')  // <span class="number">8</span></span><br></pre></td></tr></table></figure>
<h3 id="2-Number-isFinite-Number-isNaN"><a href="#2-Number-isFinite-Number-isNaN" class="headerlink" title="2.Number.isFinite(), Number.isNaN()"></a>2.Number.isFinite(), Number.isNaN()</h3><p>ES6 在Number对象上，新提供了Number.isFinite()和Number.isNaN()两个方法。</p>
<p>Number.isFinite()用来检查一个数值是否为有限的（finite），即不是Infinity。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">15</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="number">0.8</span>); <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">NaN</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(-<span class="literal">Infinity</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'foo'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="string">'15'</span>); <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isFinite(<span class="literal">true</span>); <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>注意，如果参数类型不是数值，Number.isFinite一律返回false。</p>
<p>Number.isNaN()用来检查一个值是否为NaN。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">15</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'15'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="literal">true</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="number">9</span>/<span class="literal">NaN</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="number">0</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isNaN(<span class="string">'true'</span> / <span class="string">'true'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>如果参数类型不是NaN，Number.isNaN一律返回false。</p>
<p>它们与传统的全局方法isFinite()和isNaN()的区别在于，传统方法先调用Number()将非数值的值转为数值，再进行判断，而这两个新方法只对数值有效，Number.isFinite()对于非数值一律返回false, Number.isNaN()只有对于NaN才返回true，非NaN一律返回false。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">isFinite</span><span class="params">(<span class="number">25</span>)</span></span> <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="title">isFinite</span><span class="params">(<span class="string">"25"</span>)</span></span> <span class="comment">// true</span></span><br><span class="line">Number.isFinite(<span class="number">25</span>) <span class="comment">// true</span></span><br><span class="line">Number.isFinite(<span class="string">"25"</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="title">isNaN</span><span class="params">(NaN)</span></span> <span class="comment">// true</span></span><br><span class="line"><span class="function"><span class="title">isNaN</span><span class="params">(<span class="string">"NaN"</span>)</span></span> <span class="comment">// true</span></span><br><span class="line">Number.isNaN(NaN) <span class="comment">// true</span></span><br><span class="line">Number.isNaN(<span class="string">"NaN"</span>) <span class="comment">// false</span></span><br><span class="line">Number.isNaN(<span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="3-Number-parseInt-Number-parseFloat"><a href="#3-Number-parseInt-Number-parseFloat" class="headerlink" title="3.Number.parseInt(), Number.parseFloat()"></a>3.Number.parseInt(), Number.parseFloat()</h3><p>ES6 将全局方法parseInt()和parseFloat()，移植到Number对象上面，行为完全保持不变。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5的写法</span></span><br><span class="line"><span class="function"><span class="title">parseInt</span><span class="params">(<span class="string">'12.34'</span>)</span></span> <span class="comment">// 12</span></span><br><span class="line"><span class="function"><span class="title">parseFloat</span><span class="params">(<span class="string">'123.45#'</span>)</span></span> <span class="comment">// 123.45</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6的写法</span></span><br><span class="line">Number.parseInt(<span class="string">'12.34'</span>) <span class="comment">// 12</span></span><br><span class="line">Number.parseFloat(<span class="string">'123.45#'</span>) <span class="comment">// 123.45</span></span><br></pre></td></tr></table></figure>
<p>这样做的目的，是逐步减少全局性方法，使得语言逐步模块化。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Number.<span class="built_in">parseInt</span> === <span class="built_in">parseInt</span> <span class="comment">// true</span></span><br><span class="line">Number.<span class="built_in">parseFloat</span> === <span class="built_in">parseFloat</span> <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="4-Number-isInteger"><a href="#4-Number-isInteger" class="headerlink" title="4.Number.isInteger()"></a>4.Number.isInteger()</h3><p>Number.isInteger()用来判断一个数值是否为整数。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) // <span class="literal">true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.1</span>) // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>JavaScript 内部，整数和浮点数采用的是同样的储存方法，所以 25 和 25.0 被视为同一个值。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25</span>) // <span class="literal">true</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">25.0</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>如果参数不是数值，Number.isInteger返回false。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger() // <span class="literal">false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">null</span>) // <span class="literal">false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="string">'15'</span>) // <span class="literal">false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="literal">true</span>) // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>注意，由于 JavaScript 采用 IEEE 754 标准，数值存储为64位双精度格式，数值精度最多可以达到 53 个二进制位（1 个隐藏位与 52 个有效位）。如果数值的精度超过这个限度，第54位及后面的位就会被丢弃，这种情况下，Number.isInteger可能会误判。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">3.0000000000000002</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，Number.isInteger的参数明明不是整数，但是会返回true。原因就是这个小数的精度达到了小数点后16个十进制位，转成二进制位超过了53个二进制位，导致最后的那个2被丢弃了。</p>
<p>类似的情况还有，如果一个数值的绝对值小于Number.MIN_VALUE（5E-324），即小于 JavaScript 能够分辨的最小值，会被自动转为 0。这时，Number.isInteger也会误判。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5E-324</span>) // <span class="literal">false</span></span><br><span class="line"><span class="built_in">Number</span>.isInteger(<span class="number">5E-325</span>) // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，5E-325由于值太小，会被自动转为0，因此返回true。</p>
<p>总之，如果对数据精度的要求较高，不建议使用Number.isInteger()判断一个数值是否为整数。</p>
<h3 id="5-Number-EPSILON"><a href="#5-Number-EPSILON" class="headerlink" title="5.Number.EPSILON"></a>5.Number.EPSILON</h3><p>ES6 在Number对象上面，新增一个极小的常量Number.EPSILON。根据规格，它表示 1 与大于 1 的最小浮点数之间的差。</p>
<p>对于 64 位浮点数来说，大于 1 的最小浮点数相当于二进制的1.00..001，小数点后面有连续 51 个零。这个值减去 1 之后，就等于 2 的 -52 次方。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.EPSILON === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">-52</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON</span><br><span class="line"><span class="comment">// 2.220446049250313e-16</span></span><br><span class="line"><span class="built_in">Number</span>.EPSILON.toFixed(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// "0.00000000000000022204"</span></span><br></pre></td></tr></table></figure>
<p>Number.EPSILON实际上是 JavaScript 能够表示的最小精度。误差如果小于这个值，就可以认为已经没有意义了，即不存在误差了。</p>
<p>引入一个这么小的量的目的，在于为浮点数计算，设置一个误差范围。我们知道浮点数计算是不精确的。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span></span><br><span class="line"><span class="comment">// 0.30000000000000004</span></span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> - <span class="number">0.3</span></span><br><span class="line"><span class="comment">// 5.551115123125783e-17</span></span><br><span class="line"></span><br><span class="line"><span class="number">5.551115123125783e-17</span>.toFixed(<span class="number">20</span>)</span><br><span class="line"><span class="comment">// '0.00000000000000005551'</span></span><br></pre></td></tr></table></figure>
<p>上面代码解释了，为什么比较0.1 + 0.2与0.3得到的结果是false。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>Number.EPSILON可以用来设置“能够接受的误差范围”。比如，误差范围设为 2 的-50 次方（即Number.EPSILON * Math.pow(2, 2)），即如果两个浮点数的差小于这个值，我们就认为这两个浮点数相等。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">5.551115123125783e-17</span> &lt; Number.EPSILON * Math.pow(<span class="number">2</span>, <span class="number">2</span>)</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>因此，Number.EPSILON的实质是一个可以接受的最小误差范围。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">function withinErrorMargin (left, right) &#123;</span><br><span class="line">  return Math.abs(left - right) &lt; Number.EPSILON * Math.pow(<span class="number">2</span>, <span class="number">2</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="number">0.1</span> + <span class="number">0.2</span> === <span class="number">0.3</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">0.1</span> + <span class="number">0.2</span>, <span class="number">0.3</span>) <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="number">1.1</span> + <span class="number">1.3</span> === <span class="number">2.4</span> <span class="comment">// false</span></span><br><span class="line">withinErrorMargin(<span class="number">1.1</span> + <span class="number">1.3</span>, <span class="number">2.4</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面的代码为浮点数运算，部署了一个误差检查函数。</p>
<h3 id="6-安全整数和-Number-isSafeInteger"><a href="#6-安全整数和-Number-isSafeInteger" class="headerlink" title="6.安全整数和 Number.isSafeInteger()"></a>6.安全整数和 Number.isSafeInteger()</h3><p>JavaScript 能够准确表示的整数范围在-2^53到2^53之间（不含两个端点），超过这个范围，无法精确表示这个值。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">2</span>, <span class="number">53</span>) <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line"><span class="number">9007199254740992</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"><span class="number">9007199254740993</span>  <span class="comment">// 9007199254740992</span></span><br><span class="line"></span><br><span class="line">Math.pow(<span class="number">2</span>, <span class="number">53</span>) === Math.pow(<span class="number">2</span>, <span class="number">53</span>) + <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，超出 2 的 53 次方之后，一个数就不精确了。</p>
<p>ES6 引入了Number.MAX_SAFE_INTEGER和Number.MIN_SAFE_INTEGER这两个常量，用来表示这个范围的上下限。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="built_in">Math</span>.pow(<span class="number">2</span>, <span class="number">53</span>) - <span class="number">1</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MAX_SAFE_INTEGER === <span class="number">9007199254740991</span></span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === -<span class="built_in">Number</span>.MAX_SAFE_INTEGER</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.MIN_SAFE_INTEGER === <span class="number">-9007199254740991</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，可以看到 JavaScript 能够精确表示的极限。</p>
<p>Number.isSafeInteger()则是用来判断一个整数是否落在这个范围之内。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="string">'a'</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">null</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">NaN</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(-<span class="literal">Infinity</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">3</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">1.2</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740990</span>) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="number">9007199254740992</span>) <span class="comment">// false</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER - <span class="number">1</span>) <span class="comment">// false</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MIN_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER) <span class="comment">// true</span></span><br><span class="line"><span class="built_in">Number</span>.isSafeInteger(<span class="built_in">Number</span>.MAX_SAFE_INTEGER + <span class="number">1</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这个函数的实现很简单，就是跟安全整数的两个边界值比较一下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Number</span>.isSafeInteger = <span class="function"><span class="keyword">function</span> (<span class="params">n</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (<span class="keyword">typeof</span> n === <span class="string">'number'</span> &amp;&amp;</span><br><span class="line">    <span class="built_in">Math</span>.round(n) === n &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.MIN_SAFE_INTEGER &lt;= n &amp;&amp;</span><br><span class="line">    n &lt;= <span class="built_in">Number</span>.MAX_SAFE_INTEGER);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>实际使用这个函数时，需要注意。验证运算结果是否落在安全整数的范围内，不要只验证运算结果，而要同时验证参与运算的每个值。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">Number.isSafeInteger(<span class="number">9007199254740993</span>)</span><br><span class="line"><span class="comment">// false</span></span><br><span class="line">Number.isSafeInteger(<span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line">Number.isSafeInteger(<span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// true</span></span><br><span class="line"><span class="number">9007199254740993</span> - <span class="number">990</span></span><br><span class="line"><span class="comment">// 返回结果 9007199254740002</span></span><br><span class="line"><span class="comment">// 正确答案应该是 9007199254740003</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，9007199254740993不是一个安全整数，但是Number.isSafeInteger会返回结果，显示计算结果是安全的。这是因为，这个数超出了精度范围，导致在计算机内部，以9007199254740992的形式储存。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">9007199254740993</span> === <span class="number">9007199254740992</span></span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>所以，如果只验证运算结果是否为安全整数，很可能得到错误结果。下面的函数可以同时验证两个运算数和运算结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">trusty</span> (<span class="params">left, right, result</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(left) &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(right) &amp;&amp;</span><br><span class="line">    <span class="built_in">Number</span>.isSafeInteger(result)</span><br><span class="line">  ) &#123;</span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">RangeError</span>(<span class="string">'Operation cannot be trusted!'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">trusty(<span class="number">9007199254740993</span>, <span class="number">990</span>, <span class="number">9007199254740993</span> - <span class="number">990</span>)</span><br><span class="line"><span class="comment">// RangeError: Operation cannot be trusted!</span></span><br><span class="line"></span><br><span class="line">trusty(<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>)</span><br><span class="line"><span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<h3 id="7-Math-对象的扩展"><a href="#7-Math-对象的扩展" class="headerlink" title="7.Math 对象的扩展"></a>7.Math 对象的扩展</h3><p>ES6 在 Math 对象上新增了 17 个与数学相关的方法。所有这些方法都是静态方法，只能在 Math 对象上调用。</p>
<h4 id="Math-trunc"><a href="#Math-trunc" class="headerlink" title="Math.trunc()"></a>Math.trunc()</h4><p>Math.trunc方法用于去除一个数的小数部分，返回整数部分。</p>
<figure class="highlight gams"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.<span class="built-in">trunc</span>(<span class="number">4.1</span>) <span class="comment">// 4</span></span><br><span class="line">Math.<span class="built-in">trunc</span>(<span class="number">4.9</span>) <span class="comment">// 4</span></span><br><span class="line">Math.<span class="built-in">trunc</span>(<span class="number">-4.1</span>) <span class="comment">// -4</span></span><br><span class="line">Math.<span class="built-in">trunc</span>(<span class="number">-4.9</span>) <span class="comment">// -4</span></span><br><span class="line">Math.<span class="built-in">trunc</span>(<span class="number">-0.1234</span>) <span class="comment">// -0</span></span><br></pre></td></tr></table></figure>
<p>对于非数值，Math.trunc内部使用Number方法将其先转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'123.456'</span>) <span class="comment">// 123</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">true</span>) <span class="comment">//1</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">false</span>) <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">null</span>) <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>对于空值和无法截取整数的值，返回NaN。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">NaN</span>);      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="string">'foo'</span>);    <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc();         <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.trunc(<span class="literal">undefined</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.trunc = <span class="built_in">Math</span>.trunc || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? <span class="built_in">Math</span>.ceil(x) : <span class="built_in">Math</span>.floor(x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Math-sign"><a href="#Math-sign" class="headerlink" title="Math.sign()"></a>Math.sign()</h4><p>Math.sign方法用来判断一个数到底是正数、负数、还是零。对于非数值，会先将其转换为数值。</p>
<p>它会返回五种值。</p>
<ul>
<li>参数为正数，返回+1；</li>
<li>参数为负数，返回-1；</li>
<li>参数为 0，返回0；</li>
<li>参数为-0，返回-0;</li>
<li>其他值，返回NaN。</li>
</ul>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-5</span>) <span class="comment">// -1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">5</span>) <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">0</span>) <span class="comment">// +0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="number">-0</span>) <span class="comment">// -0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">NaN</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>如果参数是非数值，会自动转为数值。对于那些无法转为数值的值，会返回NaN。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign(<span class="string">''</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">true</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">false</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">null</span>)  <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">'9'</span>)  <span class="comment">// +1</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="string">'foo'</span>)  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign()  <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.sign(<span class="literal">undefined</span>)  <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.sign = <span class="built_in">Math</span>.sign || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  x = +x; <span class="comment">// convert to a number</span></span><br><span class="line">  <span class="keyword">if</span> (x === <span class="number">0</span> || <span class="built_in">isNaN</span>(x)) &#123;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> x &gt; <span class="number">0</span> ? <span class="number">1</span> : <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Math-cbrt"><a href="#Math-cbrt" class="headerlink" title="Math.cbrt()"></a>Math.cbrt()</h4><p>Math.cbrt方法用于计算一个数的立方根。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.cbrt<span class="comment">(-1)</span> <span class="comment">// -1</span></span><br><span class="line">Math.cbrt<span class="comment">(0)</span>  <span class="comment">// 0</span></span><br><span class="line">Math.cbrt<span class="comment">(1)</span>  <span class="comment">// 1</span></span><br><span class="line">Math.cbrt<span class="comment">(2)</span>  <span class="comment">// 1.2599210498948734</span></span><br></pre></td></tr></table></figure>
<p>对于非数值，Math.cbrt方法内部也是先使用Number方法将其转为数值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt(<span class="string">'8'</span>) <span class="comment">// 2</span></span><br><span class="line"><span class="built_in">Math</span>.cbrt(<span class="string">'hello'</span>) <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.cbrt = <span class="built_in">Math</span>.cbrt || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> y = <span class="built_in">Math</span>.pow(<span class="built_in">Math</span>.abs(x), <span class="number">1</span>/<span class="number">3</span>);</span><br><span class="line">  <span class="keyword">return</span> x &lt; <span class="number">0</span> ? -y : y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Math-clz32"><a href="#Math-clz32" class="headerlink" title="Math.clz32()"></a>Math.clz32()</h4><p>JavaScript 的整数使用 32 位二进制形式表示，Math.clz32方法返回一个数的 32 位无符号整数形式有多少个前导 0。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32(<span class="number">0</span>) // <span class="number">32</span></span><br><span class="line">Math.clz32(<span class="number">1</span>) // <span class="number">31</span></span><br><span class="line">Math.clz32(<span class="number">1000</span>) // <span class="number">22</span></span><br><span class="line">Math.clz32(<span class="number">0b01000000000000000000000000000000</span>) // <span class="number">1</span></span><br><span class="line">Math.clz32(<span class="number">0b00100000000000000000000000000000</span>) // <span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，0 的二进制形式全为 0，所以有 32 个前导 0；1 的二进制形式是0b1，只占 1 位，所以 32 位之中有 31 个前导 0；1000 的二进制形式是0b1111101000，一共有 10 位，所以 32 位之中有 22 个前导 0。</p>
<p>clz32这个函数名就来自”count leading zero bits in 32-bit binary representation of a number“（计算一个数的 32 位二进制形式的前导 0 的个数）的缩写。</p>
<p>左移运算符（&lt;&lt;）与Math.clz32方法直接相关。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.clz32(<span class="number">0</span>) <span class="comment">// 32</span></span><br><span class="line">Math.clz32(<span class="number">1</span>) <span class="comment">// 31</span></span><br><span class="line">Math.clz32(<span class="number">1</span> &lt;&lt; <span class="number">1</span>) <span class="comment">// 30</span></span><br><span class="line">Math.clz32(<span class="number">1</span> &lt;&lt; <span class="number">2</span>) <span class="comment">// 29</span></span><br><span class="line">Math.clz32(<span class="number">1</span> &lt;&lt; <span class="number">29</span>) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>对于小数，Math.clz32方法只考虑整数部分。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.clz<span class="number">32</span><span class="comment">(3.2)</span> <span class="comment">// 30</span></span><br><span class="line">Math.clz<span class="number">32</span><span class="comment">(3.9)</span> <span class="comment">// 30</span></span><br></pre></td></tr></table></figure>
<p>对于空值或其他类型的值，Math.clz32方法会将它们先转为数值，然后再计算。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.clz32() <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">NaN</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">Infinity</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">null</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="string">'foo'</span>) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32([]) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(&#123;&#125;) <span class="comment">// 32</span></span><br><span class="line"><span class="built_in">Math</span>.clz32(<span class="literal">true</span>) <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<h4 id="Math-imul"><a href="#Math-imul" class="headerlink" title="Math.imul()"></a>Math.imul()</h4><p>Math.imul方法返回两个数以 32 位带符号整数形式相乘的结果，返回的也是一个 32 位的带符号整数。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.imul(<span class="number">2</span>, <span class="number">4</span>)   <span class="comment">// 8</span></span><br><span class="line">Math.imul(<span class="number">-1</span>, <span class="number">8</span>)  <span class="comment">// -8</span></span><br><span class="line">Math.imul(<span class="number">-2</span>, <span class="number">-2</span>) <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>如果只考虑最后 32 位，大多数情况下，Math.imul(a, b)与a <em> b的结果是相同的，即该方法等同于(a </em> b)|0的效果（超过 32 位的部分溢出）。之所以需要部署这个方法，是因为 JavaScript 有精度限制，超过 2 的 53 次方的值无法精确表示。这就是说，对于那些很大的数的乘法，低位数值往往都是不精确的，Math.imul方法可以返回正确的低位数值。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">(<span class="number">0x7fffffff</span> * <span class="number">0x7fffffff</span>)|<span class="number">0</span> <span class="comment">// 0</span></span><br></pre></td></tr></table></figure>
<p>上面这个乘法算式，返回结果为 0。但是由于这两个二进制数的最低位都是 1，所以这个结果肯定是不正确的，因为根据二进制乘法，计算结果的二进制最低位应该也是 1。这个错误就是因为它们的乘积超过了 2 的 53 次方，JavaScript 无法保存额外的精度，就把低位的值都变成了 0。Math.imul方法可以返回正确的值 1。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Math.imul(<span class="number">0x7fffffff</span>, <span class="number">0x7fffffff</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<h4 id="Math-fround"><a href="#Math-fround" class="headerlink" title="Math.fround()"></a>Math.fround()</h4><p>Math.fround方法返回一个数的32位单精度浮点数形式。</p>
<p>对于32位单精度格式来说，数值精度是24个二进制位（1 位隐藏位与 23 位有效位），所以对于 -224 至 224 之间的整数（不含两个端点），返回结果与参数本身一致。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.fround(<span class="number">0</span>)   <span class="comment">// 0</span></span><br><span class="line">Math.fround(<span class="number">1</span>)   <span class="comment">// 1</span></span><br><span class="line">Math.fround(<span class="number">2</span> ** <span class="number">24</span> - <span class="number">1</span>)   <span class="comment">// 16777215</span></span><br></pre></td></tr></table></figure>
<p>如果参数的绝对值大于 224，返回的结果便开始丢失精度。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">Math.fround(<span class="number">2</span> ** <span class="number">24</span>)       <span class="comment">// 16777216</span></span><br><span class="line">Math.fround(<span class="number">2</span> ** <span class="number">24</span> + <span class="number">1</span>)   <span class="comment">// 16777216</span></span><br></pre></td></tr></table></figure>
<p>Math.fround方法的主要作用，是将64位双精度浮点数转为32位单精度浮点数。如果小数的精度超过24个二进制位，返回值就会不同于原值，否则返回值不变（即与64位双精度值一致）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 未丢失有效精度</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.125</span>) <span class="comment">// 1.125</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">7.25</span>)  <span class="comment">// 7.25</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 丢失精度</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.3</span>)   <span class="comment">// 0.30000001192092896</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">0.7</span>)   <span class="comment">// 0.699999988079071</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="number">1.0000000123</span>) <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>对于 NaN 和 Infinity，此方法返回原值。对于其它类型的非数值，Math.fround 方法会先将其转为数值，再返回单精度浮点数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">NaN</span>)      <span class="comment">// NaN</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">Infinity</span>) <span class="comment">// Infinity</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="string">'5'</span>)      <span class="comment">// 5</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">true</span>)     <span class="comment">// 1</span></span><br><span class="line"><span class="built_in">Math</span>.fround(<span class="literal">null</span>)     <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround([])       <span class="comment">// 0</span></span><br><span class="line"><span class="built_in">Math</span>.fround(&#123;&#125;)       <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.fround = <span class="built_in">Math</span>.fround || <span class="function"><span class="keyword">function</span> (<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">new</span> <span class="built_in">Float32Array</span>([x])[<span class="number">0</span>];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="Math-hypot"><a href="#Math-hypot" class="headerlink" title="Math.hypot()"></a>Math.hypot()</h4><p>Math.hypot方法返回所有参数的平方和的平方根。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.hypot(<span class="number">3</span>, <span class="number">4</span>);        <span class="comment">// 5</span></span><br><span class="line">Math.hypot(<span class="number">3</span>, <span class="number">4</span>, <span class="number">5</span>);     <span class="comment">// 7.0710678118654755</span></span><br><span class="line">Math.hypot();            <span class="comment">// 0</span></span><br><span class="line">Math.hypot(NaN);         <span class="comment">// NaN</span></span><br><span class="line">Math.hypot(<span class="number">3</span>, <span class="number">4</span>, 'foo'); <span class="comment">// NaN</span></span><br><span class="line">Math.hypot(<span class="number">3</span>, <span class="number">4</span>, '<span class="number">5</span>');   <span class="comment">// 7.0710678118654755</span></span><br><span class="line">Math.hypot(<span class="number">-3</span>);          <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，3 的平方加上 4 的平方，等于 5 的平方。</p>
<p>如果参数不是数值，Math.hypot方法会将其转为数值。只要有一个参数无法转为数值，就会返回 NaN。</p>
<h4 id="对数方法"><a href="#对数方法" class="headerlink" title="对数方法"></a>对数方法</h4><p>ES6 新增了 4 个对数相关方法。</p>
<p>（1） Math.expm1()</p>
<p>Math.expm1(x)返回 ex - 1，即Math.exp(x) - 1。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">Math.exp<span class="name">m1</span><span class="comment">(-1)</span> <span class="comment">// -0.6321205588285577</span></span><br><span class="line">Math.exp<span class="name">m1</span><span class="comment">(0)</span>  <span class="comment">// 0</span></span><br><span class="line">Math.exp<span class="name">m1</span><span class="comment">(1)</span>  <span class="comment">// 1.718281828459045</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.expm1 = <span class="built_in">Math</span>.expm1 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.exp(x) - <span class="number">1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（2）Math.log1p()</p>
<p>Math.log1p(x)方法返回1 + x的自然对数，即Math.log(1 + x)。如果x小于-1，返回NaN。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">Math.lo<span class="name">g1</span>p<span class="comment">(1)</span>  <span class="comment">// 0.6931471805599453</span></span><br><span class="line">Math.lo<span class="name">g1</span>p<span class="comment">(0)</span>  <span class="comment">// 0</span></span><br><span class="line">Math.lo<span class="name">g1</span>p<span class="comment">(-1)</span> <span class="comment">// -Infinity</span></span><br><span class="line">Math.lo<span class="name">g1</span>p<span class="comment">(-2)</span> <span class="comment">// NaN</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log1p = <span class="built_in">Math</span>.log1p || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(<span class="number">1</span> + x);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（3）Math.log10()</p>
<p>Math.log10(x)返回以 10 为底的x的对数。如果x小于 0，则返回 NaN。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.lo<span class="name">g10</span><span class="comment">(2)</span>      <span class="comment">// 0.3010299956639812</span></span><br><span class="line">Math.lo<span class="name">g10</span><span class="comment">(1)</span>      <span class="comment">// 0</span></span><br><span class="line">Math.lo<span class="name">g10</span><span class="comment">(0)</span>      <span class="comment">// -Infinity</span></span><br><span class="line">Math.lo<span class="name">g10</span><span class="comment">(-2)</span>     <span class="comment">// NaN</span></span><br><span class="line">Math.lo<span class="name">g10</span><span class="comment">(100000)</span> <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log10 = <span class="built_in">Math</span>.log10 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(x) / <span class="built_in">Math</span>.LN10;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>（4）Math.log2()</p>
<p>Math.log2(x)返回以 2 为底的x的对数。如果x小于 0，则返回 NaN。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">Math.lo<span class="name">g2</span><span class="comment">(3)</span>       <span class="comment">// 1.584962500721156</span></span><br><span class="line">Math.lo<span class="name">g2</span><span class="comment">(2)</span>       <span class="comment">// 1</span></span><br><span class="line">Math.lo<span class="name">g2</span><span class="comment">(1)</span>       <span class="comment">// 0</span></span><br><span class="line">Math.lo<span class="name">g2</span><span class="comment">(0)</span>       <span class="comment">// -Infinity</span></span><br><span class="line">Math.lo<span class="name">g2</span><span class="comment">(-2)</span>      <span class="comment">// NaN</span></span><br><span class="line">Math.lo<span class="name">g2</span><span class="comment">(1024)</span>    <span class="comment">// 10</span></span><br><span class="line">Math.lo<span class="name">g2</span><span class="comment">(1 &lt;&lt; 29)</span> <span class="comment">// 29</span></span><br></pre></td></tr></table></figure>
<p>对于没有部署这个方法的环境，可以用下面的代码模拟。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">Math</span>.log2 = <span class="built_in">Math</span>.log2 || <span class="function"><span class="keyword">function</span>(<span class="params">x</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.log(x) / <span class="built_in">Math</span>.LN2;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="双曲函数方法"><a href="#双曲函数方法" class="headerlink" title="双曲函数方法"></a>双曲函数方法</h4><p>ES6 新增了 6 个双曲函数方法。</p>
<ul>
<li>Math.sinh(x) 返回x的双曲正弦（hyperbolic sine）</li>
<li>Math.cosh(x) 返回x的双曲余弦（hyperbolic cosine）</li>
<li>Math.tanh(x) 返回x的双曲正切（hyperbolic tangent）</li>
<li>Math.asinh(x) 返回x的反双曲正弦（inverse hyperbolic sine）</li>
<li>Math.acosh(x) 返回x的反双曲余弦（inverse hyperbolic cosine）</li>
<li>Math.atanh(x) 返回x的反双曲正切（inverse hyperbolic tangent）</li>
</ul>
<h3 id="8-指数运算符"><a href="#8-指数运算符" class="headerlink" title="8.指数运算符"></a>8.指数运算符</h3><p>ES2016 新增了一个指数运算符（**）。</p>
<figure class="highlight basic"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="symbol">2 </span>** <span class="number">2</span> // <span class="number">4</span></span><br><span class="line"><span class="symbol">2 </span>** <span class="number">3</span> // <span class="number">8</span></span><br></pre></td></tr></table></figure>
<p>指数运算符可以与等号结合，形成一个新的赋值运算符（**=）。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let a = <span class="number">1.5</span>;</span><br><span class="line">a **= <span class="number">2</span>;</span><br><span class="line"><span class="comment">// 等同于 a = a * a;</span></span><br><span class="line"></span><br><span class="line">let b = <span class="number">4</span>;</span><br><span class="line">b **= <span class="number">3</span>;</span><br><span class="line"><span class="comment">// 等同于 b = b * b * b;</span></span><br></pre></td></tr></table></figure>
<p>注意，在 V8 引擎中，指数运算符与Math.pow的实现不相同，对于特别大的运算结果，两者会有细微的差异。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">Math.pow(<span class="number">99</span>, <span class="number">99</span>)</span><br><span class="line"><span class="comment">// 3.697296376497263e+197</span></span><br><span class="line"></span><br><span class="line"><span class="number">99</span> ** <span class="number">99</span></span><br><span class="line"><span class="comment">// 3.697296376497268e+197</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，两个运算结果的最后一位有效数字是有差异的。</p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 05.正则的扩展]]></title>
      <url>/2018/06/12/ES6/05.%E6%AD%A3%E5%88%99%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="正则的扩展"><a href="#正则的扩展" class="headerlink" title="正则的扩展"></a>正则的扩展</h2><h3 id="1-RegExp-构造函数"><a href="#1-RegExp-构造函数" class="headerlink" title="1.RegExp 构造函数"></a>1.RegExp 构造函数</h3><p>在 ES5 中，RegExp构造函数的参数有两种情况。</p>
<p>第一种情况是，参数是字符串，这时第二个参数表示正则表达式的修饰符（flag）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="string">'xyz'</span>, <span class="string">'i'</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>
<p>第二种情况是，参数是一个正则表示式，这时会返回一个原有正则表达式的拷贝。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/i</span>);</span><br><span class="line"><span class="comment">// 等价于</span></span><br><span class="line"><span class="keyword">var</span> regex = <span class="regexp">/xyz/i</span>;</span><br></pre></td></tr></table></figure>
<p>但是，ES5 不允许此时使用第二个参数添加修饰符，否则会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> regex = <span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/xyz/</span>, <span class="string">'i'</span>);</span><br><span class="line"><span class="comment">// Uncaught TypeError: Cannot supply flags when constructing one RegExp from another</span></span><br></pre></td></tr></table></figure>
<p>ES6 改变了这种行为。如果RegExp构造函数第一个参数是一个正则对象，那么可以使用第二个参数指定修饰符。而且，返回的正则表达式会忽略原有的正则表达式的修饰符，只使用新指定的修饰符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">new</span> <span class="built_in">RegExp</span>(<span class="regexp">/abc/ig</span>, <span class="string">'i'</span>).flags</span><br><span class="line"><span class="comment">// "i"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，原有正则对象的修饰符是ig，它会被第二个参数i覆盖。</p>
<h3 id="2-字符串的正则方法"><a href="#2-字符串的正则方法" class="headerlink" title="2.字符串的正则方法"></a>2.字符串的正则方法</h3><p>字符串对象共有 4 个方法，可以使用正则表达式：match()、replace()、search()和split()。</p>
<p>ES6 将这 4 个方法，在语言内部全部调用RegExp的实例方法，从而做到所有与正则相关的方法，全都定义在RegExp对象上。</p>
<ul>
<li>String.prototype.match 调用 RegExp.prototype[Symbol.match]</li>
<li>String.prototype.replace 调用 RegExp.prototype[Symbol.replace]</li>
<li>String.prototype.search 调用 RegExp.prototype[Symbol.search]</li>
<li>String.prototype.split 调用 RegExp.prototype[Symbol.split]</li>
</ul>
<h3 id="3-u-修饰符"><a href="#3-u-修饰符" class="headerlink" title="3.u 修饰符"></a>3.u 修饰符</h3><p>ES6 对正则表达式添加了u修饰符，含义为“Unicode 模式”，用来正确处理大于\uFFFF的 Unicode 字符。也就是说，会正确处理四个字节的 UTF-16 编码。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/^\uD83D/u</span>.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="regexp">//</span> false</span><br><span class="line"><span class="regexp">/^\uD83D/</span>.test(<span class="string">'\uD83D\uDC2A'</span>) <span class="regexp">//</span> true</span><br></pre></td></tr></table></figure>
<p>上面代码中，\uD83D\uDC2A是一个四个字节的 UTF-16 编码，代表一个字符。但是，ES5 不支持四个字节的 UTF-16 编码，会将其识别为两个字符，导致第二行代码结果为true。加了u修饰符以后，ES6 就会识别其为一个字符，所以第一行代码结果为false。</p>
<p>一旦加上u修饰符号，就会修改下面这些正则表达式的行为。</p>
<p>（1）点字符</p>
<p>点（.）字符在正则表达式中，含义是除了换行符以外的任意单个字符。对于码点大于0xFFFF的 Unicode 字符，点字符不能识别，必须加上u修饰符。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">var s = '𠮷';</span><br><span class="line"></span><br><span class="line">/^.$<span class="string">/.test</span><span class="params">(s)</span> <span class="string">//</span> <span class="literal">false</span></span><br><span class="line">/^.$<span class="string">/u.test</span><span class="params">(s)</span> <span class="string">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果不添加u修饰符，正则表达式就会认为字符串为两个字符，从而匹配失败。</p>
<p>（2）Unicode 字符表示法</p>
<p>ES6 新增了使用大括号表示 Unicode 字符，这种表示法在正则表达式中必须加上u修饰符，才能识别当中的大括号，否则会被解读为量词。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/\u&#123;61&#125;/</span>.test(<span class="string">'a'</span>) <span class="regexp">//</span> false</span><br><span class="line"><span class="regexp">/\u&#123;61&#125;/u</span>.test(<span class="string">'a'</span>) <span class="regexp">//</span> true</span><br><span class="line"><span class="regexp">/\u&#123;20BB7&#125;/u</span>.test(<span class="string">'𠮷'</span>) <span class="regexp">//</span> true</span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果不加u修饰符，正则表达式无法识别\u{61}这种表示法，只会认为这匹配 61 个连续的u。</p>
<p>（3）量词</p>
<p>使用u修饰符后，所有量词都会正确识别码点大于0xFFFF的 Unicode 字符。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/a</span>&#123;2&#125;<span class="string">/.test</span><span class="params">('aa')</span> <span class="string">//</span> <span class="literal">true</span></span><br><span class="line"><span class="string">/a</span>&#123;2&#125;<span class="string">/u.test</span><span class="params">('aa')</span> <span class="string">//</span> <span class="literal">true</span></span><br><span class="line">/𠮷&#123;2&#125;<span class="string">/.test</span><span class="params">('𠮷𠮷')</span> <span class="string">//</span> <span class="literal">false</span></span><br><span class="line">/𠮷&#123;2&#125;<span class="string">/u.test</span><span class="params">('𠮷𠮷')</span> <span class="string">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>（4）预定义模式</p>
<p>u修饰符也影响到预定义模式，能否正确识别码点大于0xFFFF的 Unicode 字符。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/^\S$/</span>.test(<span class="string">'𠮷'</span>) <span class="regexp">//</span> false</span><br><span class="line"><span class="regexp">/^\S$/u</span>.test(<span class="string">'𠮷'</span>) <span class="regexp">//</span> true</span><br></pre></td></tr></table></figure>
<p>上面代码的\S是预定义模式，匹配所有非空白字符。只有加了u修饰符，它才能正确匹配码点大于0xFFFF的 Unicode 字符。</p>
<p>利用这一点，可以写出一个正确返回字符串长度的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">codePointLength</span>(<span class="params">text</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> result = text.match(<span class="regexp">/[\s\S]/gu</span>);</span><br><span class="line">  <span class="keyword">return</span> result ? result.length : <span class="number">0</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> s = <span class="string">'𠮷𠮷'</span>;</span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 4</span></span><br><span class="line">codePointLength(s) <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>（5）i 修饰符</p>
<p>有些 Unicode 字符的编码不同，但是字型很相近，比如，\u004B与\u212A都是大写的K。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/[a-z]/i</span>.test(<span class="string">'\u212A'</span>) <span class="regexp">//</span> false</span><br><span class="line"><span class="regexp">/[a-z]/iu</span>.test(<span class="string">'\u212A'</span>) <span class="regexp">//</span> true</span><br></pre></td></tr></table></figure>
<p>上面代码中，不加u修饰符，就无法识别非规范的K字符。</p>
<h3 id="4-RegExp-prototype-unicode-属性"><a href="#4-RegExp-prototype-unicode-属性" class="headerlink" title="4.RegExp.prototype.unicode 属性"></a>4.RegExp.prototype.unicode 属性</h3><p>正则实例对象新增unicode属性，表示是否设置了u修饰符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> r1 = <span class="regexp">/hello/</span>;</span><br><span class="line"><span class="keyword">const</span> r2 = <span class="regexp">/hello/u</span>;</span><br><span class="line"></span><br><span class="line">r1.unicode <span class="comment">// false</span></span><br><span class="line">r2.unicode <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式是否设置了u修饰符，可以从unicode属性看出来。</p>
<h3 id="5-y-修饰符"><a href="#5-y-修饰符" class="headerlink" title="5.y 修饰符"></a>5.y 修饰符</h3><p>除了u修饰符，ES6 还为正则表达式添加了y修饰符，叫做“粘连”（sticky）修饰符。</p>
<p>y修饰符的作用与g修饰符类似，也是全局匹配，后一次匹配都从上一次匹配成功的下一个位置开始。不同之处在于，g修饰符只要剩余位置中存在匹配就可，而y修饰符确保匹配必须从剩余的第一个位置开始，这也就是“粘连”的涵义。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">var s = 'aaa_aa_a';</span><br><span class="line">var r1 = <span class="string">/a</span>+<span class="string">/g</span>;</span><br><span class="line">var r2 = <span class="string">/a</span>+<span class="string">/y</span>;</span><br><span class="line"></span><br><span class="line">r1.exec<span class="params">(s)</span> <span class="string">//</span> [<span class="string">"aaa"</span>]</span><br><span class="line">r2.exec<span class="params">(s)</span> <span class="string">//</span> [<span class="string">"aaa"</span>]</span><br><span class="line"></span><br><span class="line">r1.exec<span class="params">(s)</span> <span class="string">//</span> [<span class="string">"aa"</span>]</span><br><span class="line">r2.exec<span class="params">(s)</span> <span class="string">//</span> null</span><br></pre></td></tr></table></figure>
<p>上面代码有两个正则表达式，一个使用g修饰符，另一个使用y修饰符。这两个正则表达式各执行了两次，第一次执行的时候，两者行为相同，剩余字符串都是_aa_a。由于g修饰没有位置要求，所以第二次执行会返回结果，而y修饰符要求匹配必须从头部开始，所以返回null。</p>
<p>如果改一下正则表达式，保证每次都能头部匹配，y修饰符就会返回结果了。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">'aaa_aa_a'</span>;</span><br><span class="line">var r = <span class="regexp">/a+_/y</span>;</span><br><span class="line"></span><br><span class="line">r.exec(s) <span class="regexp">//</span> [<span class="string">"aaa_"</span>]</span><br><span class="line">r.exec(s) <span class="regexp">//</span> [<span class="string">"aa_"</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码每次匹配，都是从剩余字符串的头部开始。</p>
<p>使用lastIndex属性，可以更好地说明y修饰符。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const REGEX = /a/g;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置（y）开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 匹配成功</span></span><br><span class="line">const <span class="keyword">match</span> = REGEX.<span class="keyword">exec</span>(<span class="string">'xaya'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 在3号位置匹配成功</span></span><br><span class="line"><span class="keyword">match</span>.index <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 下一次匹配从4号位开始</span></span><br><span class="line">REGEX.lastIndex <span class="comment">// 4</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 4号位开始匹配失败</span></span><br><span class="line">REGEX.<span class="keyword">exec</span>(<span class="string">'xaya'</span>) <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，lastIndex属性指定每次搜索的开始位置，g修饰符从这个位置开始向后搜索，直到发现匹配为止。</p>
<p>y修饰符同样遵守lastIndex属性，但是要求必须在lastIndex指定的位置发现匹配。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const REGEX = /a/y;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从2号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 不是粘连，匹配失败</span></span><br><span class="line">REGEX.<span class="keyword">exec</span>(<span class="string">'xaya'</span>) <span class="comment">// null</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 指定从3号位置开始匹配</span></span><br><span class="line">REGEX.lastIndex = <span class="number">3</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 3号位置是粘连，匹配成功</span></span><br><span class="line">const <span class="keyword">match</span> = REGEX.<span class="keyword">exec</span>(<span class="string">'xaya'</span>);</span><br><span class="line"><span class="keyword">match</span>.index <span class="comment">// 3</span></span><br><span class="line">REGEX.lastIndex <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>实际上，y修饰符号隐含了头部匹配的标志^。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/b/y</span>.exec(<span class="string">'aba'</span>)</span><br><span class="line"><span class="regexp">//</span> null</span><br></pre></td></tr></table></figure>
<p>上面代码由于不能保证头部匹配，所以返回null。y修饰符的设计本意，就是让头部匹配的标志^在全局匹配中都有效。</p>
<p>下面是字符串对象的replace方法的例子。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">const REGEX = <span class="regexp">/a/gy</span>;</span><br><span class="line"><span class="string">'aaxa'</span>.replace(REGEX, <span class="string">'-'</span>) <span class="regexp">//</span> <span class="string">'--xa'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，最后一个a因为不是出现在下一次匹配的头部，所以不会被替换。</p>
<p>单单一个y修饰符对match方法，只能返回第一个匹配，必须与g修饰符联用，才能返回所有匹配。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'a1a2a3'</span>.match(<span class="regexp">/a\d/y</span>) <span class="regexp">//</span> [<span class="string">"a1"</span>]</span><br><span class="line"><span class="string">'a1a2a3'</span>.match(<span class="regexp">/a\d/gy</span>) <span class="regexp">//</span> [<span class="string">"a1"</span>, <span class="string">"a2"</span>, <span class="string">"a3"</span>]</span><br></pre></td></tr></table></figure>
<p>y修饰符的一个应用，是从字符串提取 token（词元），y修饰符确保了匹配之间不会有漏掉的字符。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line">const TOKEN_Y = /\s*(\+|[<span class="number">0</span><span class="number">-9</span>]+)\s*/y;</span><br><span class="line">const TOKEN_G  = /\s*(\+|[<span class="number">0</span><span class="number">-9</span>]+)\s*/g;</span><br><span class="line"></span><br><span class="line">tokenize(TOKEN_Y, <span class="string">'3 + 4'</span>)</span><br><span class="line">// [ <span class="string">'3'</span>, <span class="string">'+'</span>, <span class="string">'4'</span> ]</span><br><span class="line">tokenize(TOKEN_G, <span class="string">'3 + 4'</span>)</span><br><span class="line">// [ <span class="string">'3'</span>, <span class="string">'+'</span>, <span class="string">'4'</span> ]</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tokenize</span><span class="params">(TOKEN_REGEX, str)</span></span> &#123;</span><br><span class="line">  let result = [];</span><br><span class="line">  let <span class="built_in">match</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="built_in">match</span> = TOKEN_REGEX.exec(str)) &#123;</span><br><span class="line">    result.push(<span class="built_in">match</span>[<span class="number">1</span>]);</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果字符串里面没有非法字符，y修饰符与g修饰符的提取结果是一样的。但是，一旦出现非法字符，两者的行为就不一样了。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tokenize</span><span class="params">(TOKEN_Y, <span class="string">'3x + 4'</span>)</span></span></span><br><span class="line"><span class="comment">// [ '3' ]</span></span><br><span class="line"><span class="function"><span class="title">tokenize</span><span class="params">(TOKEN_G, <span class="string">'3x + 4'</span>)</span></span></span><br><span class="line"><span class="comment">// [ '3', '+', '4' ]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，g修饰符会忽略非法字符，而y修饰符不会，这样就很容易发现错误。</p>
<h3 id="6-RegExp-prototype-sticky-属性"><a href="#6-RegExp-prototype-sticky-属性" class="headerlink" title="6.RegExp.prototype.sticky 属性"></a>6.RegExp.prototype.sticky 属性</h3><p>与y修饰符相匹配，ES6 的正则实例对象多了sticky属性，表示是否设置了y修饰符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> r = <span class="regexp">/hello\d/y</span>;</span><br><span class="line">r.sticky <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="7-RegExp-prototype-flags-属性"><a href="#7-RegExp-prototype-flags-属性" class="headerlink" title="7.RegExp.prototype.flags 属性"></a>7.RegExp.prototype.flags 属性</h3><p>ES6 为正则表达式新增了flags属性，会返回正则表达式的修饰符。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> ES5 的 source 属性</span><br><span class="line"><span class="regexp">//</span> 返回正则表达式的正文</span><br><span class="line"><span class="regexp">/abc/ig</span>.source</span><br><span class="line"><span class="regexp">//</span> <span class="string">"abc"</span></span><br><span class="line"></span><br><span class="line"><span class="regexp">//</span> ES6 的 flags 属性</span><br><span class="line"><span class="regexp">//</span> 返回正则表达式的修饰符</span><br><span class="line"><span class="regexp">/abc/ig</span>.flags</span><br><span class="line"><span class="regexp">//</span> <span class="string">'gi'</span></span><br></pre></td></tr></table></figure>
<h3 id="8-s-修饰符：dotAll-模式"><a href="#8-s-修饰符：dotAll-模式" class="headerlink" title="8.s 修饰符：dotAll 模式"></a>8.s 修饰符：dotAll 模式</h3><p>正则表达式中，点（.）是一个特殊字符，代表任意的单个字符，但是有两个例外。一个是四个字节的 UTF-16 字符，这个可以用u修饰符解决；另一个是行终止符（line terminator character）。</p>
<p>所谓行终止符，就是该字符表示一行的终结。以下四个字符属于”行终止符“。</p>
<ul>
<li>U+000A 换行符（\n）</li>
<li>U+000D 回车符（\r）</li>
<li>U+2028 行分隔符（line separator）</li>
<li>U+2029 段分隔符（paragraph separator）</li>
</ul>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/foo.bar/</span>.test(<span class="string">'foo\nbar'</span>)</span><br><span class="line"><span class="regexp">//</span> false</span><br></pre></td></tr></table></figure>
<p>上面代码中，因为.不匹配\n，所以正则表达式返回false。</p>
<p>但是，很多时候我们希望匹配的是任意单个字符，这时有一种变通的写法。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">/foo</span>[^]bar/<span class="string">.test</span><span class="params">('foo\nbar')</span></span><br><span class="line"><span class="string">//</span> <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>这种解决方案毕竟不太符合直觉，ES2018 <a href="https://github.com/tc39/proposal-regexp-dotall-flag" target="_blank" rel="noopener">引入</a>s修饰符，使得.可以匹配任意单个字符。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/foo.bar/</span>s.test(<span class="string">'foo\nbar'</span>) <span class="regexp">//</span> true</span><br></pre></td></tr></table></figure>
<p>这被称为dotAll模式，即点（dot）代表一切字符。所以，正则表达式还引入了一个dotAll属性，返回一个布尔值，表示该正则表达式是否处在dotAll模式。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">const re = <span class="regexp">/foo.bar/</span>s;</span><br><span class="line"><span class="regexp">//</span> 另一种写法</span><br><span class="line"><span class="regexp">//</span> const re = new RegExp(<span class="string">'foo.bar'</span>, <span class="string">'s'</span>);</span><br><span class="line"></span><br><span class="line">re.test(<span class="string">'foo\nbar'</span>) <span class="regexp">//</span> true</span><br><span class="line">re.dotAll <span class="regexp">//</span> true</span><br><span class="line">re.flags <span class="regexp">//</span> <span class="string">'s'</span></span><br></pre></td></tr></table></figure>
<p>/s修饰符和多行修饰符/m不冲突，两者一起使用的情况下，.匹配所有字符，而^和$匹配每一行的行首和行尾。</p>
<h3 id="9-后行断言"><a href="#9-后行断言" class="headerlink" title="9.后行断言"></a>9.后行断言</h3><p>JavaScript 语言的正则表达式，只支持先行断言（lookahead）和先行否定断言（negative lookahead），不支持后行断言（lookbehind）和后行否定断言（negative lookbehind）。ES2018 引入<a href="https://github.com/tc39/proposal-regexp-lookbehind" target="_blank" rel="noopener">后行断言</a>，V8 引擎 4.9 版（Chrome 62）已经支持。</p>
<p>”先行断言“指的是，x只有在y前面才匹配，必须写成/x(?=y)/。比如，只匹配百分号之前的数字，要写成/\d+(?=%)/。”先行否定断言“指的是，x只有不在y前面才匹配，必须写成/x(?!y)/。比如，只匹配不在百分号之前的数字，要写成/\d+(?!%)/。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/\d+(?=%)/</span>.exec(<span class="string">'100% of US presidents have been male'</span>)  <span class="regexp">//</span> [<span class="string">"100"</span>]</span><br><span class="line"><span class="regexp">/\d+(?!%)/</span>.exec(<span class="string">'that’s all 44 of them'</span>)                 <span class="regexp">//</span> [<span class="string">"44"</span>]</span><br></pre></td></tr></table></figure>
<p>上面两个字符串，如果互换正则表达式，就不会得到相同结果。另外，还可以看到，”先行断言“括号之中的部分（(?=%)），是不计入返回结果的。</p>
<p>“后行断言”正好与“先行断言”相反，x只有在y后面才匹配，必须写成/(?&lt;=y)x/。比如，只匹配美元符号之后的数字，要写成/(?&lt;=\$)\d+/。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/(?=\$)\d+/</span>.exec(<span class="string">'Benjamin Franklin is on the $100 bill'</span>)  <span class="regexp">//</span> [<span class="string">"100"</span>]</span><br><span class="line"><span class="regexp">/(?&lt;!\$)\d+/</span>.exec(<span class="string">'it’s is worth about €90'</span>)                <span class="regexp">//</span> [<span class="string">"90"</span>]</span><br></pre></td></tr></table></figure>
<p>上面的例子中，“后行断言”的括号之中的部分（(?&lt;=\$)），也是不计入返回结果。</p>
<p>下面的例子是使用后行断言进行字符串替换。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">const RE_DOLLAR_PREFIX = <span class="regexp">/(?&lt;=\$)foo/g</span>;</span><br><span class="line"><span class="string">'$foo %foo foo'</span>.replace(RE_DOLLAR_PREFIX, <span class="string">'bar'</span>);</span><br><span class="line"><span class="regexp">//</span> <span class="string">'$bar %foo foo'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，只有在美元符号后面的foo才会被替换。</p>
<p>“后行断言”的实现，需要先匹配/(?&lt;=y)x/的x，然后再回到左边，匹配y的部分。这种“先右后左”的执行顺序，与所有其他正则操作相反，导致了一些不符合预期的行为。</p>
<p>首先，后行断言的组匹配，与正常情况下结果是不一样的。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/(?&lt;=(\d+)(\d+))$/</span>.exec(<span class="string">'1053'</span>) <span class="regexp">//</span> [<span class="string">""</span>, <span class="string">"1"</span>, <span class="string">"053"</span>]</span><br><span class="line"><span class="regexp">/^(\d+)(\d+)$/</span>.exec(<span class="string">'1053'</span>) <span class="regexp">//</span> [<span class="string">"1053"</span>, <span class="string">"105"</span>, <span class="string">"3"</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码中，需要捕捉两个组匹配。没有“后行断言”时，第一个括号是贪婪模式，第二个括号只能捕获一个字符，所以结果是105和3。而“后行断言”时，由于执行顺序是从右到左，第二个括号是贪婪模式，第一个括号只能捕获一个字符，所以结果是1和053。</p>
<p>其次，“后行断言”的反斜杠引用，也与通常的顺序相反，必须放在对应的那个括号之前。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">/(?&lt;=(o)d\1)r/</span>.exec(<span class="string">'hodor'</span>)  <span class="regexp">//</span> null</span><br><span class="line"><span class="regexp">/(?&lt;=\1d(o))r/</span>.exec(<span class="string">'hodor'</span>)  <span class="regexp">//</span> [<span class="string">"r"</span>, <span class="string">"o"</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码中，如果后行断言的反斜杠引用（\1）放在括号的后面，就不会得到匹配结果，必须放在前面才可以。因为后行断言是先从左到右扫描，发现匹配以后再回过头，从右到左完成反斜杠引用。</p>
<h3 id="10-Unicode-属性类"><a href="#10-Unicode-属性类" class="headerlink" title="10.Unicode 属性类"></a>10.Unicode 属性类</h3><p>ES2018 引入了一种新的类的写法\p{…}和\P{…}，允许正则表达式匹配符合 Unicode 某种属性的所有字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regexGreekSymbol = <span class="regexp">/\p&#123;Script=Greek&#125;/u</span>;</span><br><span class="line">regexGreekSymbol.test(<span class="string">'π'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，\p{Script=Greek}指定匹配一个希腊文字母，所以匹配π成功。</p>
<p>Unicode 属性类要指定属性名和属性值。</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">\p&#123;<span class="attribute">UnicodePropertyName</span>=UnicodePropertyValue&#125;</span><br></pre></td></tr></table></figure>
<p>对于某些属性，可以只写属性名，或者只写属性值。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">\<span class="name">p</span><span class="string">&#123;UnicodePropertyName&#125;</span></span></span><br><span class="line"><span class="tag">\<span class="name">p</span><span class="string">&#123;UnicodePropertyValue&#125;</span></span></span><br></pre></td></tr></table></figure>
<p>\P{…}是\p{…}的反向匹配，即匹配不满足条件的字符。</p>
<p>注意，这两种类只对 Unicode 有效，所以使用的时候一定要加上u修饰符。如果不加u修饰符，正则表达式使用\p和\P会报错，ECMAScript 预留了这两个类。</p>
<p>由于 Unicode 的各种属性非常多，所以这种新的类的表达能力非常强。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Decimal_Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">'𝟏𝟐𝟑𝟜𝟝𝟞𝟩𝟪𝟫𝟬𝟭𝟮𝟯𝟺𝟻𝟼'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，属性类指定匹配所有十进制字符，可以看到各种字型的十进制字符都会匹配成功。</p>
<p>\p{Number}甚至能匹配罗马数字。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 匹配所有数字</span></span><br><span class="line"><span class="keyword">const</span> regex = <span class="regexp">/^\p&#123;Number&#125;+$/u</span>;</span><br><span class="line">regex.test(<span class="string">'²³¹¼½¾'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'㉛㉜㉝'</span>) <span class="comment">// true</span></span><br><span class="line">regex.test(<span class="string">'ⅠⅡⅢⅣⅤⅥⅦⅧⅨⅩⅪⅫ'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>下面是其他一些例子。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">// 匹配所有空格</span><br><span class="line"><span class="tag">\<span class="name">p</span><span class="string">&#123;White_Space&#125;</span></span></span><br><span class="line"></span><br><span class="line">// 匹配各种文字的所有字母，等同于 Unicode 版的 <span class="tag">\<span class="name">w</span></span></span><br><span class="line">[<span class="tag">\<span class="name">p</span><span class="string">&#123;Alphabetic&#125;</span></span><span class="tag">\<span class="name">p</span><span class="string">&#123;Mark&#125;</span></span><span class="tag">\<span class="name">p</span><span class="string">&#123;Decimal_Number&#125;</span></span><span class="tag">\<span class="name">p</span><span class="string">&#123;Connector_Punctuation&#125;</span></span><span class="tag">\<span class="name">p</span><span class="string">&#123;Join_Control&#125;</span></span>]</span><br><span class="line"></span><br><span class="line">// 匹配各种文字的所有非字母的字符，等同于 Unicode 版的 <span class="tag">\<span class="name">W</span></span></span><br><span class="line">[^<span class="tag">\<span class="name">p</span><span class="string">&#123;Alphabetic&#125;</span></span><span class="tag">\<span class="name">p</span><span class="string">&#123;Mark&#125;</span></span><span class="tag">\<span class="name">p</span><span class="string">&#123;Decimal_Number&#125;</span></span><span class="tag">\<span class="name">p</span><span class="string">&#123;Connector_Punctuation&#125;</span></span><span class="tag">\<span class="name">p</span><span class="string">&#123;Join_Control&#125;</span></span>]</span><br><span class="line"></span><br><span class="line">// 匹配 Emoji</span><br><span class="line">/<span class="tag">\<span class="name">p</span><span class="string">&#123;Emoji_Modifier_Base&#125;</span></span><span class="tag">\<span class="name">p</span><span class="string">&#123;Emoji_Modifier&#125;</span></span>?|<span class="tag">\<span class="name">p</span><span class="string">&#123;Emoji_Presentation&#125;</span></span>|<span class="tag">\<span class="name">p</span><span class="string">&#123;Emoji&#125;</span></span><span class="tag">\<span class="name">uFE</span></span>0F/gu</span><br><span class="line"></span><br><span class="line">// 匹配所有的箭头字符</span><br><span class="line">const regexArrows = /^<span class="tag">\<span class="name">p</span><span class="string">&#123;Block=Arrows&#125;</span></span>+<span class="formula">$/u;</span></span><br><span class="line"><span class="formula">regexArrows.test('←↑→↓↔↕↖↗↘↙⇏⇐⇑⇒⇓⇔⇕⇖⇗⇘⇙⇧⇩') // true</span></span><br></pre></td></tr></table></figure>
<h3 id="11-具名组匹配"><a href="#11-具名组匹配" class="headerlink" title="11.具名组匹配"></a>11.具名组匹配</h3><h4 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h4><p>正则表达式使用圆括号进行组匹配。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">const RE_DATE = /(<span class="tag">\<span class="name">d</span><span class="string">&#123;4&#125;</span></span>)-(<span class="tag">\<span class="name">d</span><span class="string">&#123;2&#125;</span></span>)-(<span class="tag">\<span class="name">d</span><span class="string">&#123;2&#125;</span></span>)/;</span><br></pre></td></tr></table></figure>
<p>上面代码中，正则表达式里面有三组圆括号。使用exec方法，就可以将这三组匹配结果提取出来。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const RE_DATE = /(\d&#123;<span class="number">4</span>&#125;)-(\d&#123;<span class="number">2</span>&#125;)-(\d&#123;<span class="number">2</span>&#125;)/;</span><br><span class="line"></span><br><span class="line">const matchObj = RE_DATE.exec('<span class="number">1999</span><span class="number">-12</span><span class="number">-31</span>');</span><br><span class="line">const year = matchObj[<span class="number">1</span>]; <span class="comment">// 1999</span></span><br><span class="line">const month = matchObj[<span class="number">2</span>]; <span class="comment">// 12</span></span><br><span class="line">const day = matchObj[<span class="number">3</span>]; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<p>组匹配的一个问题是，每一组的匹配含义不容易看出来，而且只能用数字序号（比如matchObj[1]）引用，要是组的顺序变了，引用的时候就必须修改序号。</p>
<p>ES2018 引入了具名组匹配（Named Capture Groups），允许为每一个组匹配指定一个名字，既便于阅读代码，又便于引用。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_DATE = /(?&lt;<span class="built_in">year</span>&gt;\d&#123;<span class="number">4</span>&#125;)-(?&lt;<span class="built_in">month</span>&gt;\d&#123;<span class="number">2</span>&#125;)-(?&lt;<span class="built_in">day</span>&gt;\d&#123;<span class="number">2</span>&#125;)/;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> matchObj = RE_DATE.exec(<span class="string">'1999-12-31'</span>);</span><br><span class="line"><span class="keyword">const</span> <span class="built_in">year</span> = matchObj.groups.<span class="built_in">year</span>; <span class="comment">// 1999</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">month</span> = matchObj.groups.<span class="built_in">month</span>; <span class="comment">// 12</span></span><br><span class="line"><span class="keyword">const</span> <span class="built_in">day</span> = matchObj.groups.<span class="built_in">day</span>; <span class="comment">// 31</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，“具名组匹配”在圆括号内部，模式的头部添加“问号 + 尖括号 + 组名”（?<year>），然后就可以在exec方法返回结果的groups属性上引用该组名。同时，数字序号（matchObj[1]）依然有效。</year></p>
<p>具名组匹配等于为每一组匹配加上了 ID，便于描述匹配的目的。如果组的顺序变了，也不用改变匹配后的处理代码。</p>
<p>如果具名组没有匹配，那么对应的groups对象属性会是undefined。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_OPT_A = /^(?&lt;<span class="keyword">as</span>&gt;a+)?$/;</span><br><span class="line"><span class="keyword">const</span> matchObj = RE_OPT_A.exec(<span class="string">''</span>);</span><br><span class="line"></span><br><span class="line">matchObj.groups.<span class="keyword">as</span> <span class="comment">// undefined</span></span><br><span class="line"><span class="string">'as'</span> <span class="keyword">in</span> matchObj.groups <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，具名组as没有找到匹配，那么matchObj.groups.as属性值就是undefined，并且as这个键名在groups是始终存在的。</p>
<h4 id="解构赋值和替换"><a href="#解构赋值和替换" class="headerlink" title="解构赋值和替换"></a>解构赋值和替换</h4><p>有了具名组匹配以后，可以使用解构赋值直接从匹配结果上为变量赋值。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123;groups: &#123;<span class="keyword">one</span>, <span class="keyword">two</span>&#125;&#125; = /^(?&lt;<span class="keyword">one</span>&gt;.*):(?&lt;<span class="keyword">two</span>&gt;.*)$/<span class="keyword">u</span>.exec('foo:bar');</span><br><span class="line"><span class="keyword">one</span>  <span class="comment">// foo</span></span><br><span class="line"><span class="keyword">two</span>  <span class="comment">// bar</span></span><br></pre></td></tr></table></figure>
<p>字符串替换时，使用$&lt;组名&gt;引用具名组。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">let re = /(?<span class="tag">&lt;<span class="name">year</span>&gt;</span>\d</span><span class="template-variable">&#123;4&#125;</span><span class="xml">)-(?<span class="tag">&lt;<span class="name">month</span>&gt;</span>\d</span><span class="template-variable">&#123;2&#125;</span><span class="xml">)-(?<span class="tag">&lt;<span class="name">day</span>&gt;</span>\d</span><span class="template-variable">&#123;2&#125;</span><span class="xml">)/u;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">'2015-01-02'.replace(re, '$<span class="tag">&lt;<span class="name">day</span>&gt;</span>/$<span class="tag">&lt;<span class="name">month</span>&gt;</span>/$<span class="tag">&lt;<span class="name">year</span>&gt;</span>')</span></span><br><span class="line"><span class="xml">// '02/01/2015'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，replace方法的第二个参数是一个字符串，而不是正则表达式。</p>
<p>replace方法的第二个参数也可以是函数，该函数的参数序列如下。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'2015-01-02'</span>.replace(re, (</span><br><span class="line">   matched, <span class="comment">// 整个匹配结果 2015-01-02</span></span><br><span class="line">   capture1, <span class="comment">// 第一个组匹配 2015</span></span><br><span class="line">   capture2, <span class="comment">// 第二个组匹配 01</span></span><br><span class="line">   capture3, <span class="comment">// 第三个组匹配 02</span></span><br><span class="line">   position, <span class="comment">// 匹配开始的位置 0</span></span><br><span class="line">   S, <span class="comment">// 原字符串 2015-01-02</span></span><br><span class="line">   groups <span class="comment">// 具名组构成的一个对象 &#123;year, month, day&#125;</span></span><br><span class="line"> ) =&gt; &#123;</span><br><span class="line"> let &#123;<span class="built_in">day</span>, <span class="built_in">month</span>, <span class="built_in">year</span>&#125; = args[args.length - <span class="number">1</span>];</span><br><span class="line"> <span class="keyword">return</span> `$&#123;<span class="built_in">day</span>&#125;/$&#123;<span class="built_in">month</span>&#125;/$&#123;<span class="built_in">year</span>&#125;`;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>具名组匹配在原来的基础上，新增了最后一个函数参数：具名组构成的一个对象。函数内部可以直接对这个对象进行解构赋值。</p>
<h4 id="引用"><a href="#引用" class="headerlink" title="引用"></a>引用</h4><p>如果要在正则表达式内部引用某个“具名组匹配”，可以使用\k&lt;组名&gt;的写法。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = /^(?&lt;<span class="keyword">word</span>&gt;[a-z]+)!\k&lt;<span class="keyword">word</span>&gt;$/;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>数字引用（\1）依然有效。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = /^(?&lt;<span class="keyword">word</span>&gt;[a-z]+)!\<span class="number">1</span>$/;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>这两种引用语法还可以同时使用。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> RE_TWICE = /^(?&lt;<span class="keyword">word</span>&gt;[a-z]+)!\k&lt;<span class="keyword">word</span>&gt;!\<span class="number">1</span>$/;</span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc!abc'</span>) <span class="comment">// true</span></span><br><span class="line">RE_TWICE.test(<span class="string">'abc!abc!ab'</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<h3 id="12-String-prototype-matchAll"><a href="#12-String-prototype-matchAll" class="headerlink" title="12.String.prototype.matchAll"></a>12.String.prototype.matchAll</h3><p>如果一个正则表达式在字符串里面有多个匹配，现在一般使用g修饰符或y修饰符，在循环里面逐一取出。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">var regex = /t(e)(st(\d?))/g;</span><br><span class="line">var <span class="built_in">string</span> = <span class="string">'test1test2test3'</span>;</span><br><span class="line"></span><br><span class="line">var matches = [];</span><br><span class="line">var <span class="built_in">match</span>;</span><br><span class="line"><span class="keyword">while</span> (<span class="built_in">match</span> = regex.exec(<span class="built_in">string</span>)) &#123;</span><br><span class="line">  matches.push(<span class="built_in">match</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">matches</span><br><span class="line">// [</span><br><span class="line">//   [<span class="string">"test1"</span>, <span class="string">"e"</span>, <span class="string">"st1"</span>, <span class="string">"1"</span>, index: <span class="number">0</span>, <span class="built_in">input</span>: <span class="string">"test1test2test3"</span>],</span><br><span class="line">//   [<span class="string">"test2"</span>, <span class="string">"e"</span>, <span class="string">"st2"</span>, <span class="string">"2"</span>, index: <span class="number">5</span>, <span class="built_in">input</span>: <span class="string">"test1test2test3"</span>],</span><br><span class="line">//   [<span class="string">"test3"</span>, <span class="string">"e"</span>, <span class="string">"st3"</span>, <span class="string">"3"</span>, index: <span class="number">10</span>, <span class="built_in">input</span>: <span class="string">"test1test2test3"</span>]</span><br><span class="line">// ]</span><br></pre></td></tr></table></figure>
<p>上面代码中，while循环取出每一轮的正则匹配，一共三轮。</p>
<p>目前有一个提案，增加了String.prototype.matchAll方法，可以一次性取出所有匹配。不过，它返回的是一个遍历器（Iterator），而不是数组。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">const <span class="built_in">string</span> = <span class="string">'test1test2test3'</span>;</span><br><span class="line"></span><br><span class="line">// g 修饰符加不加都可以</span><br><span class="line">const regex = /t(e)(st(\d?))/g;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (const <span class="built_in">match</span> of <span class="built_in">string</span>.matchAll(regex)) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">match</span>);</span><br><span class="line">&#125;</span><br><span class="line">// [<span class="string">"test1"</span>, <span class="string">"e"</span>, <span class="string">"st1"</span>, <span class="string">"1"</span>, index: <span class="number">0</span>, <span class="built_in">input</span>: <span class="string">"test1test2test3"</span>]</span><br><span class="line">// [<span class="string">"test2"</span>, <span class="string">"e"</span>, <span class="string">"st2"</span>, <span class="string">"2"</span>, index: <span class="number">5</span>, <span class="built_in">input</span>: <span class="string">"test1test2test3"</span>]</span><br><span class="line">// [<span class="string">"test3"</span>, <span class="string">"e"</span>, <span class="string">"st3"</span>, <span class="string">"3"</span>, index: <span class="number">10</span>, <span class="built_in">input</span>: <span class="string">"test1test2test3"</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码中，由于string.matchAll(regex)返回的是遍历器，所以可以用for…of循环取出。相对于返回数组，返回遍历器的好处在于，如果匹配结果是一个很大的数组，那么遍历器比较节省资源。</p>
<p>遍历器转为数组是非常简单的，使用…运算符和Array.from方法就可以了。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转为数组方法一</span></span><br><span class="line">[<span class="meta">...string.matchAll(regex)</span>]</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转为数组方法二</span></span><br><span class="line">Array.<span class="keyword">from</span>(<span class="keyword">string</span>.matchAll(regex));</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 04.字符串的扩展]]></title>
      <url>/2018/06/11/ES6/04.%E5%AD%97%E7%AC%A6%E4%B8%B2%E7%9A%84%E6%89%A9%E5%B1%95/</url>
      <content type="html"><![CDATA[<h2 id="字符串的扩展"><a href="#字符串的扩展" class="headerlink" title="字符串的扩展"></a>字符串的扩展</h2><p>ES6 加强了对 Unicode 的支持，并且扩展了字符串对象。</p>
<h3 id="1-字符的-Unicode-表示法"><a href="#1-字符的-Unicode-表示法" class="headerlink" title="1.字符的 Unicode 表示法"></a>1.字符的 Unicode 表示法</h3><p>JavaScript 允许采用\uxxxx形式表示一个字符，其中xxxx表示字符的 Unicode 码点。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\u0061"</span></span><br><span class="line"><span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>
<p>但是，这种表示法只限于码点在\u0000~\uFFFF之间的字符。超出这个范围的字符，必须用两个双字节的形式表示。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"\uD842\uDFB7"</span></span><br><span class="line"><span class="regexp">//</span> <span class="string">"𠮷"</span></span><br><span class="line"></span><br><span class="line"><span class="string">"\u20BB7"</span></span><br><span class="line"><span class="regexp">//</span> <span class="string">" 7"</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，如果直接在\u后面跟上超过0xFFFF的数值（比如\u20BB7），JavaScript 会理解成\u20BB+7。由于\u20BB是一个不可打印字符，所以只会显示一个空格，后面跟着一个7。</p>
<p>ES6 对这一点做出了改进，只要将码点放入大括号，就能正确解读该字符。</p>
<figure class="highlight tex"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">"<span class="tag">\<span class="name">u</span><span class="string">&#123;20BB7&#125;</span></span>"</span><br><span class="line">// "𠮷"</span><br><span class="line"></span><br><span class="line">"<span class="tag">\<span class="name">u</span><span class="string">&#123;41&#125;</span></span><span class="tag">\<span class="name">u</span><span class="string">&#123;42&#125;</span></span><span class="tag">\<span class="name">u</span><span class="string">&#123;43&#125;</span></span>"</span><br><span class="line">// "ABC"</span><br><span class="line"></span><br><span class="line">let hello = 123;</span><br><span class="line">hell<span class="tag">\<span class="name">u</span><span class="string">&#123;6F&#125;</span></span> // 123</span><br><span class="line"></span><br><span class="line">'<span class="tag">\<span class="name">u</span><span class="string">&#123;1F680&#125;</span></span>' === '<span class="tag">\<span class="name">uD</span></span>83D<span class="tag">\<span class="name">uDE</span></span>80'</span><br><span class="line">// true</span><br></pre></td></tr></table></figure>
<p>上面代码中，最后一个例子表明，大括号表示法与四字节的 UTF-16 编码是等价的。</p>
<p>有了这种表示法之后，JavaScript 共有 6 种方法可以表示一个字符。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">'\z' === 'z'  <span class="comment">// true</span></span><br><span class="line">'\172' === 'z' <span class="comment">// true</span></span><br><span class="line">'\x7A' === 'z' <span class="comment">// true</span></span><br><span class="line">'\u007A' === 'z' <span class="comment">// true</span></span><br><span class="line">'\u&#123;7A&#125;' === 'z' <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<h3 id="2-codePointAt"><a href="#2-codePointAt" class="headerlink" title="2.codePointAt()"></a>2.codePointAt()</h3><p>JavaScript 内部，字符以 UTF-16 的格式储存，每个字符固定为2个字节。对于那些需要4个字节储存的字符（Unicode 码点大于0xFFFF的字符），JavaScript 会认为它们是两个字符。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var s = <span class="string">"𠮷"</span>;</span><br><span class="line"></span><br><span class="line">s.length <span class="comment">// 2</span></span><br><span class="line">s.charAt(<span class="number">0</span>) <span class="comment">// ''</span></span><br><span class="line">s.charAt(<span class="number">1</span>) <span class="comment">// ''</span></span><br><span class="line">s.charCodeAt(<span class="number">0</span>) <span class="comment">// 55362</span></span><br><span class="line">s.charCodeAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，汉字“𠮷”（注意，这个字不是“吉祥”的“吉”）的码点是0x20BB7，UTF-16 编码为0xD842 0xDFB7（十进制为55362 57271），需要4个字节储存。对于这种4个字节的字符，JavaScript 不能正确处理，字符串长度会误判为2，而且charAt方法无法读取整个字符，charCodeAt方法只能分别返回前两个字节和后两个字节的值。</p>
<p>ES6 提供了codePointAt方法，能够正确处理 4 个字节储存的字符，返回一个字符的码点。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let s = '𠮷a';</span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">0</span>) <span class="comment">// 134071</span></span><br><span class="line">s.codePointAt(<span class="number">1</span>) <span class="comment">// 57271</span></span><br><span class="line"></span><br><span class="line">s.codePointAt(<span class="number">2</span>) <span class="comment">// 97</span></span><br></pre></td></tr></table></figure>
<p>codePointAt方法的参数，是字符在字符串中的位置（从 0 开始）。上面代码中，JavaScript 将“𠮷a”视为三个字符，codePointAt 方法在第一个字符上，正确地识别了“𠮷”，返回了它的十进制码点 134071（即十六进制的20BB7）。在第二个字符（即“𠮷”的后两个字节）和第三个字符“a”上，codePointAt方法的结果与charCodeAt方法相同。</p>
<p>总之，codePointAt方法会正确返回 32 位的 UTF-16 字符的码点。对于那些两个字节储存的常规字符，它的返回结果与charCodeAt方法相同。</p>
<p>codePointAt方法返回的是码点的十进制值，如果想要十六进制的值，可以使用toString方法转换一下。</p>
<figure class="highlight jboss-cli"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">let s = '𠮷a';</span><br><span class="line"></span><br><span class="line">s.codePointAt<span class="params">(0)</span><span class="string">.toString</span><span class="params">(16)</span> <span class="string">//</span> <span class="string">"20bb7"</span></span><br><span class="line">s.codePointAt<span class="params">(2)</span><span class="string">.toString</span><span class="params">(16)</span> <span class="string">//</span> <span class="string">"61"</span></span><br></pre></td></tr></table></figure>
<p>你可能注意到了，codePointAt方法的参数，仍然是不正确的。比如，上面代码中，字符a在字符串s的正确位置序号应该是 1，但是必须向codePointAt方法传入 2。解决这个问题的一个办法是使用for…of循环，因为它会正确识别 32 位的 UTF-16 字符。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> s = <span class="string">'𠮷a'</span>;</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> ch <span class="keyword">of</span> s) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(ch.codePointAt(<span class="number">0</span>).toString(<span class="number">16</span>));</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// 20bb7</span></span><br><span class="line"><span class="comment">// 61</span></span><br></pre></td></tr></table></figure>
<p>codePointAt方法是测试一个字符由两个字节还是由四个字节组成的最简单方法。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">is32Bit</span>(c) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">c.codePointAt(0)</span> &gt; <span class="number">0</span>xFFFF;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">is32Bit(<span class="string">"𠮷"</span>) // <span class="literal">true</span></span><br><span class="line">is32Bit(<span class="string">"a"</span>) // <span class="literal">false</span></span><br></pre></td></tr></table></figure>
<h3 id="3-String-fromCodePoint"><a href="#3-String-fromCodePoint" class="headerlink" title="3.String.fromCodePoint()"></a>3.String.fromCodePoint()</h3><p>ES5 提供String.fromCharCode方法，用于从码点返回对应字符，但是这个方法不能识别 32 位的 UTF-16 字符（Unicode 编号大于0xFFFF）。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>.fromCharCode(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "ஷ"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，String.fromCharCode不能识别大于0xFFFF的码点，所以0x20BB7就发生了溢出，最高位2被舍弃了，最后返回码点U+0BB7对应的字符，而不是码点U+20BB7对应的字符。</p>
<p>ES6 提供了String.fromCodePoint方法，可以识别大于0xFFFF的字符，弥补了String.fromCharCode方法的不足。在作用上，正好与codePointAt方法相反。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">String.fromCodePoint(<span class="number">0x20BB7</span>)</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br><span class="line">String.fromCodePoint(<span class="number">0x78</span>, <span class="number">0x1f680</span>, <span class="number">0x79</span>) === 'x\uD83D\uDE80y'</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果String.fromCodePoint方法有多个参数，则它们会被合并成一个字符串返回。</p>
<p>注意，fromCodePoint方法定义在String对象上，而codePointAt方法定义在字符串的实例对象上。</p>
<h3 id="4-字符串的遍历器接口"><a href="#4-字符串的遍历器接口" class="headerlink" title="4.字符串的遍历器接口"></a>4.字符串的遍历器接口</h3><p>ES6 为字符串添加了遍历器接口（详见《Iterator》一章），使得字符串可以被for…of循环遍历。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (let codePoint of <span class="string">'foo'</span>) &#123;</span><br><span class="line">  console.log(codePoint)</span><br><span class="line">&#125;</span><br><span class="line"><span class="regexp">//</span> <span class="string">"f"</span></span><br><span class="line"><span class="regexp">//</span> <span class="string">"o"</span></span><br><span class="line"><span class="regexp">//</span> <span class="string">"o"</span></span><br></pre></td></tr></table></figure>
<p>除了遍历字符串，这个遍历器最大的优点是可以识别大于0xFFFF的码点，传统的for循环无法识别这样的码点。</p>
<figure class="highlight openscad"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> <span class="built_in">text</span> = String.fromCodePoint(<span class="number">0</span>x20BB7);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i = <span class="number">0</span>; i &lt; <span class="built_in">text</span>.length; i++) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">text</span>[i]);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"><span class="comment">// " "</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="built_in">let</span> i of <span class="built_in">text</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，字符串text只有一个字符，但是for循环会认为它包含两个字符（都不可打印），而for…of循环会正确识别出这一个字符。</p>
<h3 id="5-at"><a href="#5-at" class="headerlink" title="5.at()"></a>5.at()</h3><p>ES5 对字符串对象提供charAt方法，返回字符串给定位置的字符。该方法不能识别码点大于0xFFFF的字符。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.charAt<span class="comment">(0)</span> <span class="comment">// "a"</span></span><br><span class="line"><span class="string">'𠮷'</span>.charAt<span class="comment">(0)</span> <span class="comment">// "\uD842"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中的第二条语句，charAt方法期望返回的是用2个字节表示的字符，但汉字“𠮷”占用了4个字节，charAt(0)表示获取这4个字节中的前2个字节，很显然，这是无法正常显示的。</p>
<p>目前，有一个提案，提出字符串实例的at方法，可以识别 Unicode 编号大于0xFFFF的字符，返回正确的字符。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'abc'</span>.at<span class="comment">(0)</span> <span class="comment">// "a"</span></span><br><span class="line"><span class="string">'𠮷'</span>.at<span class="comment">(0)</span> <span class="comment">// "𠮷"</span></span><br></pre></td></tr></table></figure>
<p>这个方法可以通过<a href="https://github.com/es-shims/String.prototype.at" target="_blank" rel="noopener">垫片库</a>实现。</p>
<h3 id="6-normalize"><a href="#6-normalize" class="headerlink" title="6.normalize()"></a>6.normalize()</h3><p>许多欧洲语言有语调符号和重音符号。为了表示它们，Unicode 提供了两种方法。一种是直接提供带重音符号的字符，比如Ǒ（\u01D1）。另一种是提供合成符号（combining character），即原字符与重音符号的合成，两个字符合成一个字符，比如O（\u004F）和ˇ（\u030C）合成Ǒ（\u004F\u030C）。</p>
<p>这两种表示方法，在视觉和语义上都等价，但是 JavaScript 不能识别。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>===<span class="string">'\u004F\u030C'</span> <span class="comment">//false</span></span><br><span class="line"></span><br><span class="line"><span class="string">'\u01D1'</span><span class="selector-class">.length</span> <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span><span class="selector-class">.length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，JavaScript 将合成字符视为两个字符，导致两种表示方法不相等。</p>
<p>ES6 提供字符串实例的normalize()方法，用来将字符的不同表示方法统一为同样的形式，这称为 Unicode 正规化。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u01D1'</span>.<span class="keyword">normalize</span>() === <span class="string">'\u004F\u030C'</span>.<span class="keyword">normalize</span>()</span><br><span class="line"><span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>normalize方法可以接受一个参数来指定normalize的方式，参数的四个可选值如下。</p>
<ul>
<li>NFC，默认参数，表示“标准等价合成”（Normalization Form Canonical Composition），返回多个简单字符的合成字符。所谓“标准等价”指的是视觉和语义上的等价。</li>
<li>NFD，表示“标准等价分解”（Normalization Form Canonical Decomposition），即在标准等价的前提下，返回合成字符分解的多个简单字符。</li>
<li>NFKC，表示“兼容等价合成”（Normalization Form Compatibility Composition），返回合成字符。所谓“兼容等价”指的是语义上存在等价，但视觉上不等价，比如“囍”和“喜喜”。（这只是用来举例，normalize方法不能识别中文。）</li>
<li>NFKD，表示“兼容等价分解”（Normalization Form Compatibility Decomposition），即在兼容等价的前提下，返回合成字符分解的多个简单字符。</li>
</ul>
<figure class="highlight rsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'\u004F\u030C'</span>.<span class="built_in">normalize</span>(<span class="string">'NFC'</span>).<span class="built_in">length</span> <span class="comment">// 1</span></span><br><span class="line"><span class="string">'\u004F\u030C'</span>.<span class="built_in">normalize</span>(<span class="string">'NFD'</span>).<span class="built_in">length</span> <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，NFC参数返回字符的合成形式，NFD参数返回字符的分解形式。</p>
<p>不过，normalize方法目前不能识别三个或三个以上字符的合成。这种情况下，还是只能使用正则表达式，通过 Unicode 编号区间判断。</p>
<h3 id="7-includes-startsWith-endsWith"><a href="#7-includes-startsWith-endsWith" class="headerlink" title="7.includes(), startsWith(), endsWith()"></a>7.includes(), startsWith(), endsWith()</h3><p>传统上，JavaScript 只有indexOf方法，可以用来确定一个字符串是否包含在另一个字符串中。ES6 又提供了三种新方法。</p>
<ul>
<li>includes()：返回布尔值，表示是否找到了参数字符串。</li>
<li>startsWith()：返回布尔值，表示参数字符串是否在原字符串的头部。</li>
<li>endsWith()：返回布尔值，表示参数字符串是否在原字符串的尾部。</li>
</ul>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="keyword">startsWith</span>(<span class="string">'Hello'</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="keyword">endsWith</span>(<span class="string">'!'</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'o'</span>) <span class="comment">// true</span></span><br></pre></td></tr></table></figure>
<p>这三个方法都支持第二个参数，表示开始搜索的位置。</p>
<figure class="highlight mel"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">let s = <span class="string">'Hello world!'</span>;</span><br><span class="line"></span><br><span class="line">s.<span class="keyword">startsWith</span>(<span class="string">'world'</span>, <span class="number">6</span>) <span class="comment">// true</span></span><br><span class="line">s.<span class="keyword">endsWith</span>(<span class="string">'Hello'</span>, <span class="number">5</span>) <span class="comment">// true</span></span><br><span class="line">s.includes(<span class="string">'Hello'</span>, <span class="number">6</span>) <span class="comment">// false</span></span><br></pre></td></tr></table></figure>
<p>上面代码表示，使用第二个参数n时，endsWith的行为与其他两个方法有所不同。它针对前n个字符，而其他两个方法针对从第n个位置直到字符串结束。</p>
<h3 id="8-repeat"><a href="#8-repeat" class="headerlink" title="8.repeat()"></a>8.repeat()</h3><p>repeat方法返回一个新字符串，表示将原字符串重复n次。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.<span class="keyword">repeat</span><span class="comment">(3)</span> <span class="comment">// "xxx"</span></span><br><span class="line"><span class="string">'hello'</span>.<span class="keyword">repeat</span><span class="comment">(2)</span> <span class="comment">// "hellohello"</span></span><br><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(0)</span> <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>
<p>参数如果是小数，会被取整。</p>
<p>如果repeat的参数是负数或者Infinity，会报错。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(Infinity)</span></span><br><span class="line"><span class="comment">// RangeError</span></span><br><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(-1)</span></span><br><span class="line"><span class="comment">// RangeError</span></span><br></pre></td></tr></table></figure>
<p>但是，如果参数是 0 到-1 之间的小数，则等同于 0，这是因为会先进行取整运算。0 到-1 之间的小数，取整以后等于-0，repeat视同为 0。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(-0.9)</span> <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>
<p>参数NaN等同于 0。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.<span class="keyword">repeat</span><span class="comment">(NaN)</span> <span class="comment">// ""</span></span><br></pre></td></tr></table></figure>
<p>如果repeat的参数是字符串，则会先转换成数字。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'na'</span>) <span class="regexp">//</span> <span class="string">""</span></span><br><span class="line"><span class="string">'na'</span>.repeat(<span class="string">'3'</span>) <span class="regexp">//</span> <span class="string">"nanana"</span></span><br></pre></td></tr></table></figure>
<h3 id="9-padStart-，padEnd"><a href="#9-padStart-，padEnd" class="headerlink" title="9.padStart()，padEnd()"></a>9.padStart()，padEnd()</h3><p>ES2017 引入了字符串补全长度的功能。如果某个字符串不够指定长度，会在头部或尾部补全。padStart()用于头部补全，padEnd()用于尾部补全。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'ababx'</span></span><br><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'abax'</span></span><br><span class="line"></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">5</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'xabab'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'xaba'</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，padStart和padEnd一共接受两个参数，第一个参数用来指定字符串的最小长度，第二个参数是用来补全的字符串。</p>
<p>如果原字符串的长度，等于或大于指定的最小长度，则返回原字符串。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'xxx'</span>.padStart(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'xxx'</span></span><br><span class="line"><span class="string">'xxx'</span>.padEnd(<span class="number">2</span>, <span class="string">'ab'</span>) <span class="regexp">//</span> <span class="string">'xxx'</span></span><br></pre></td></tr></table></figure>
<p>如果用来补全的字符串与原字符串，两者的长度之和超过了指定的最小长度，则会截去超出位数的补全字符串。</p>
<figure class="highlight 1c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">'abc'.padStart(<span class="number">10</span>, '<span class="number">0123456789</span>')</span><br><span class="line"><span class="comment">// '0123456abc'</span></span><br></pre></td></tr></table></figure>
<p>如果省略第二个参数，默认使用空格补全长度。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'x'</span>.padStart(<span class="number">4</span>) <span class="regexp">//</span> <span class="string">'   x'</span></span><br><span class="line"><span class="string">'x'</span>.padEnd(<span class="number">4</span>) <span class="regexp">//</span> <span class="string">'x   '</span></span><br></pre></td></tr></table></figure>
<p>padStart的常见用途是为数值补全指定位数。下面代码生成 10 位的数值字符串。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'1'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="regexp">//</span> <span class="string">"0000000001"</span></span><br><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="regexp">//</span> <span class="string">"0000000012"</span></span><br><span class="line"><span class="string">'123456'</span>.padStart(<span class="number">10</span>, <span class="string">'0'</span>) <span class="regexp">//</span> <span class="string">"0000123456"</span></span><br></pre></td></tr></table></figure>
<p>另一个用途是提示字符串格式。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">'12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="regexp">//</span> <span class="string">"YYYY-MM-12"</span></span><br><span class="line"><span class="string">'09-12'</span>.padStart(<span class="number">10</span>, <span class="string">'YYYY-MM-DD'</span>) <span class="regexp">//</span> <span class="string">"YYYY-09-12"</span></span><br></pre></td></tr></table></figure>
<h3 id="10-matchAll"><a href="#10-matchAll" class="headerlink" title="10.matchAll()"></a>10.matchAll()</h3><p>matchAll方法返回一个正则表达式在当前字符串的所有匹配，详见《正则的扩展》的一章。</p>
<h3 id="11-模板字符串"><a href="#11-模板字符串" class="headerlink" title="11.模板字符串"></a>11.模板字符串</h3><p>传统的 JavaScript 语言，输出模板通常是这样写的。</p>
<figure class="highlight vbnet"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$(<span class="comment">'#result').append(</span></span><br><span class="line">  <span class="comment">'There are <span class="doctag">&lt;b&gt;</span>' + basket.count + '<span class="doctag">&lt;/b&gt;</span> ' +</span></span><br><span class="line">  <span class="comment">'items in your basket, ' +</span></span><br><span class="line">  <span class="comment">'<span class="doctag">&lt;em&gt;</span>' + basket.onSale +</span></span><br><span class="line">  <span class="comment">'<span class="doctag">&lt;/em&gt;</span> are on sale!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>上面这种写法相当繁琐不方便，ES6 引入了模板字符串解决这个问题。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">$('#result').append(`</span></span><br><span class="line"><span class="xml">  There are <span class="tag">&lt;<span class="name">b</span>&gt;</span>$</span><span class="template-variable">&#123;basket.count&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">b</span>&gt;</span> items</span></span><br><span class="line"><span class="xml">   in your basket, <span class="tag">&lt;<span class="name">em</span>&gt;</span>$</span><span class="template-variable">&#123;basket.onSale&#125;</span><span class="xml"><span class="tag">&lt;/<span class="name">em</span>&gt;</span></span></span><br><span class="line"><span class="xml">  are on sale!</span></span><br><span class="line"><span class="xml">`);</span></span><br></pre></td></tr></table></figure>
<p>模板字符串（template string）是增强版的字符串，用反引号（`）标识。它可以当作普通字符串使用，也可以用来定义多行字符串，或者在字符串中嵌入变量。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 普通字符串</span></span><br><span class="line">`<span class="built_in">In</span> JavaScript <span class="string">'\n'</span> is a line-feed.`</span><br><span class="line"></span><br><span class="line"><span class="comment">// 多行字符串</span></span><br><span class="line">`<span class="built_in">In</span> JavaScript this is</span><br><span class="line"> <span class="built_in">not</span> legal.`</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(`string <span class="built_in">text</span> line <span class="number">1</span></span><br><span class="line">string <span class="built_in">text</span> line <span class="number">2</span>`);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串中嵌入变量</span></span><br><span class="line">let <span class="built_in">name</span> = <span class="string">"Bob"</span>, <span class="built_in">time</span> = <span class="string">"today"</span>;</span><br><span class="line">`Hello $&#123;<span class="built_in">name</span>&#125;, how are you $&#123;<span class="built_in">time</span>&#125;?`</span><br></pre></td></tr></table></figure>
<p>上面代码中的模板字符串，都是用反引号表示。如果在模板字符串中需要使用反引号，则前面要用反斜杠转义。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> greeting = `\`Yo\` World!`;</span><br></pre></td></tr></table></figure>
<p>如果使用模板字符串表示多行字符串，所有的空格和缩进都会被保留在输出之中。</p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$('<span class="comment">#list').html(`</span></span><br><span class="line"><span class="variable">&lt;ul&gt;</span></span><br><span class="line">  <span class="variable">&lt;li&gt;</span>first<span class="variable">&lt;/li&gt;</span></span><br><span class="line">  <span class="variable">&lt;li&gt;</span>second<span class="variable">&lt;/li&gt;</span></span><br><span class="line"><span class="variable">&lt;/ul&gt;</span></span><br><span class="line">`);</span><br></pre></td></tr></table></figure>
<p>上面代码中，所有模板字符串的空格和换行，都是被保留的，比如<ul>标签前面会有一个换行。如果你不想要这个换行，可以使用trim方法消除它。</ul></p>
<figure class="highlight gherkin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">$('<span class="comment">#list').html(`</span></span><br><span class="line"><span class="variable">&lt;ul&gt;</span></span><br><span class="line">  <span class="variable">&lt;li&gt;</span>first<span class="variable">&lt;/li&gt;</span></span><br><span class="line">  <span class="variable">&lt;li&gt;</span>second<span class="variable">&lt;/li&gt;</span></span><br><span class="line"><span class="variable">&lt;/ul&gt;</span></span><br><span class="line">`.trim());</span><br></pre></td></tr></table></figure>
<p>模板字符串中嵌入变量，需要将变量名写在${}之中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">authorize</span>(<span class="params">user, action</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (!user.hasPrivilege(action)) &#123;</span><br><span class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(</span><br><span class="line">      <span class="comment">// 传统写法为</span></span><br><span class="line">      <span class="comment">// 'User '</span></span><br><span class="line">      <span class="comment">// + user.name</span></span><br><span class="line">      <span class="comment">// + ' is not authorized to do '</span></span><br><span class="line">      <span class="comment">// + action</span></span><br><span class="line">      <span class="comment">// + '.'</span></span><br><span class="line">      <span class="string">`User <span class="subst">$&#123;user.name&#125;</span> is not authorized to do <span class="subst">$&#123;action&#125;</span>.`</span>);</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>大括号内部可以放入任意的 JavaScript 表达式，可以进行运算，以及引用对象属性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> x = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> y = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y&#125;</span> = <span class="subst">$&#123;x + y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 2 = 3"</span></span><br><span class="line"></span><br><span class="line"><span class="string">`<span class="subst">$&#123;x&#125;</span> + <span class="subst">$&#123;y * <span class="number">2</span>&#125;</span> = <span class="subst">$&#123;x + y * <span class="number">2</span>&#125;</span>`</span></span><br><span class="line"><span class="comment">// "1 + 4 = 5"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> obj = &#123;<span class="attr">x</span>: <span class="number">1</span>, <span class="attr">y</span>: <span class="number">2</span>&#125;;</span><br><span class="line"><span class="string">`<span class="subst">$&#123;obj.x + obj.y&#125;</span>`</span></span><br><span class="line"><span class="comment">// "3"</span></span><br></pre></td></tr></table></figure>
<p>模板字符串之中还能调用函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">fn</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="string">"Hello World"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">`foo <span class="subst">$&#123;fn()&#125;</span> bar`</span></span><br><span class="line"><span class="comment">// foo Hello World bar</span></span><br></pre></td></tr></table></figure>
<p>如果大括号中的值不是字符串，将按照一般的规则转为字符串。比如，大括号中是一个对象，将默认调用对象的toString方法。</p>
<p>如果模板字符串中的变量没有声明，将报错。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 变量place没有声明</span></span><br><span class="line"><span class="keyword">let</span> msg = `Hello, $&#123;place&#125;`;</span><br><span class="line"><span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>由于模板字符串的大括号内部，就是执行 JavaScript 代码，因此如果大括号内部是一个字符串，将会原样输出。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">`Hello $&#123;<span class="string">'World'</span>&#125;`</span><br><span class="line"><span class="comment">// "Hello World"</span></span><br></pre></td></tr></table></figure>
<p>模板字符串甚至还能嵌套。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">const tmpl = addrs =&gt; `</span><br><span class="line">  <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">  $&#123;addrs.map(addr =&gt; `</span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;addr.first&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">    <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>$&#123;addr.last&#125;<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">  `).join('')&#125;</span><br><span class="line">  <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br><span class="line">`;</span><br></pre></td></tr></table></figure>
<p>上面代码中，模板字符串的变量之中，又嵌入了另一个模板字符串，使用方法如下。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line">const data = [</span><br><span class="line">    &#123; first: '<span class="tag">&lt;<span class="name">Jane</span>&gt;</span>', last: 'Bond' &#125;,</span><br><span class="line">    &#123; first: 'Lars', last: '<span class="tag">&lt;<span class="name">Croft</span>&gt;</span>' &#125;,</span><br><span class="line">];</span><br><span class="line"></span><br><span class="line">console.log(tmpl(data));</span><br><span class="line">// <span class="tag">&lt;<span class="name">table</span>&gt;</span></span><br><span class="line">//</span><br><span class="line">//   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">Jane</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">//   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Bond<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">//</span><br><span class="line">//   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span>Lars<span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">//   <span class="tag">&lt;<span class="name">tr</span>&gt;</span><span class="tag">&lt;<span class="name">td</span>&gt;</span><span class="tag">&lt;<span class="name">Croft</span>&gt;</span><span class="tag">&lt;/<span class="name">td</span>&gt;</span><span class="tag">&lt;/<span class="name">tr</span>&gt;</span></span><br><span class="line">//</span><br><span class="line">// <span class="tag">&lt;/<span class="name">table</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>如果需要引用模板字符串本身，在需要时执行，可以像下面这样写。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 写法一</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'return '</span> + <span class="string">'`Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">new</span> <span class="function"><span class="keyword">Function</span><span class="params">(<span class="string">'name'</span>, str)</span></span>;</span><br><span class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 写法二</span></span><br><span class="line"><span class="keyword">let</span> str = <span class="string">'(name) =&gt; `Hello $&#123;name&#125;!`'</span>;</span><br><span class="line"><span class="keyword">let</span> func = <span class="keyword">eval</span>.call(<span class="keyword">null</span>, str);</span><br><span class="line">func(<span class="string">'Jack'</span>) <span class="comment">// "Hello Jack!"</span></span><br></pre></td></tr></table></figure>
<h3 id="12-实例：模板编译"><a href="#12-实例：模板编译" class="headerlink" title="12.实例：模板编译"></a>12.实例：模板编译</h3><p>下面，我们来看一个通过模板字符串，生成正式模板的实例。</p>
<figure class="highlight erb"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">let template = `</span></span><br><span class="line"><span class="xml"><span class="tag">&lt;<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> <span class="keyword">for</span>(let i=<span class="number">0</span>; i &lt; data.supplies.length; i++) &#123; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">li</span>&gt;</span><span class="tag">&lt;<span class="name">%=</span></span></span><span class="ruby"> data.supplies[i] </span><span class="xml"><span class="tag">%&gt;</span><span class="tag">&lt;/<span class="name">li</span>&gt;</span></span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">%</span></span></span><span class="ruby"> &#125; </span><span class="xml"><span class="tag">%&gt;</span></span></span><br><span class="line"><span class="xml"><span class="tag">&lt;/<span class="name">ul</span>&gt;</span></span></span><br><span class="line"><span class="xml">`;</span></span><br></pre></td></tr></table></figure>
<p>上面代码在模板字符串之中，放置了一个常规模板。该模板使用&lt;%…%&gt;放置 JavaScript 代码，使用&lt;%= … %&gt;输出 JavaScript 表达式。</p>
<p>怎么编译这个模板字符串呢？</p>
<p>一种思路是将其转换为 JavaScript 表达式字符串。</p>
<figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">echo</span>(<span class="string">'&lt;ul&gt;'</span>);</span><br><span class="line"><span class="keyword">for</span>(<span class="built_in">let</span> i=0; i &lt; data.supplies.length; i++) &#123;</span><br><span class="line">  <span class="built_in">echo</span>(<span class="string">'&lt;li&gt;'</span>);</span><br><span class="line">  <span class="built_in">echo</span>(data.supplies[i]);</span><br><span class="line">  <span class="built_in">echo</span>(<span class="string">'&lt;/li&gt;'</span>);</span><br><span class="line">&#125;;</span><br><span class="line"><span class="built_in">echo</span>(<span class="string">'&lt;/ul&gt;'</span>);</span><br></pre></td></tr></table></figure>
<p>这个转换使用正则表达式就行了。</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">let evalExpr</span> = /&lt;%=(.+?)%&gt;/g;</span><br><span class="line"><span class="attribute">let expr</span> = /&lt;%([\s\S]+?)%&gt;/g;</span><br><span class="line"></span><br><span class="line"><span class="attribute">template</span> = template</span><br><span class="line">  .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</span><br><span class="line">  .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</span><br><span class="line"></span><br><span class="line"><span class="attribute">template</span> = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br></pre></td></tr></table></figure>
<p>然后，将template封装在一个函数里面返回，就可以了。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line">let script =</span><br><span class="line">`(<span class="function"><span class="keyword">function</span> <span class="title">parse</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">  let <span class="built_in">output</span> = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">echo</span><span class="params">(html)</span></span>&#123;</span><br><span class="line">    <span class="built_in">output</span> += html;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  $&#123; template &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="built_in">output</span>;</span><br><span class="line">&#125;)`;</span><br><span class="line"></span><br><span class="line"><span class="keyword">return</span> script;</span><br></pre></td></tr></table></figure>
<p>将上面的内容拼装成一个模板编译函数compile。</p>
<figure class="highlight zephir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compile</span><span class="params">(template)</span></span>&#123;</span><br><span class="line">  <span class="keyword">const</span> evalExpr = /&lt;%=(.+?)%&gt;/g;</span><br><span class="line">  <span class="keyword">const</span> expr = /&lt;%([\s\S]+?)%&gt;/g;</span><br><span class="line"></span><br><span class="line">  template = template</span><br><span class="line">    .replace(evalExpr, <span class="string">'`); \n  echo( $1 ); \n  echo(`'</span>)</span><br><span class="line">    .replace(expr, <span class="string">'`); \n $1 \n  echo(`'</span>);</span><br><span class="line"></span><br><span class="line">  template = <span class="string">'echo(`'</span> + template + <span class="string">'`);'</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> script =</span><br><span class="line">  `(<span class="function"><span class="keyword">function</span> <span class="title">parse</span><span class="params">(data)</span></span>&#123;</span><br><span class="line">    <span class="keyword">let</span> output = <span class="string">""</span>;</span><br><span class="line"></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">echo</span><span class="params">(html)</span></span>&#123;</span><br><span class="line">      output += html;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    $&#123; template &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> output;</span><br><span class="line">  &#125;)`;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> script;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>compile函数的用法如下。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="built_in">parse</span> = eval(<span class="keyword">compile</span>(template));</span><br><span class="line">div.innerHTML = <span class="built_in">parse</span>(&#123; supplies: [ <span class="string">"broom"</span>, <span class="string">"mop"</span>, <span class="string">"cleaner"</span> ] &#125;);</span><br><span class="line"><span class="comment">//   &lt;ul&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;broom&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;mop&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//     &lt;li&gt;cleaner&lt;/li&gt;</span></span><br><span class="line"><span class="comment">//   &lt;/ul&gt;</span></span><br></pre></td></tr></table></figure>
<h3 id="13-标签模板"><a href="#13-标签模板" class="headerlink" title="13.标签模板"></a>13.标签模板</h3><p>模板字符串的功能，不仅仅是上面这些。它可以紧跟在一个函数名后面，该函数将被调用来处理这个模板字符串。这被称为“标签模板”功能（tagged template）。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">alert`<span class="number">123</span>`</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="function"><span class="title">alert</span><span class="params">(<span class="number">123</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>标签模板其实不是模板，而是函数调用的一种特殊形式。“标签”指的就是函数，紧跟在后面的模板字符串就是它的参数。</p>
<p>但是，如果模板字符里面有变量，就不是简单的调用了，而是会将模板字符串先处理成多个参数，再调用函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b &#125;</span>`</span>;</span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line">tag([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>);</span><br></pre></td></tr></table></figure>
<p>上面代码中，模板字符串前面有一个标识名tag，它是一个函数。整个表达式的返回值，就是tag函数处理模板字符串后的返回值。</p>
<p>函数tag依次会接收到多个参数。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(stringArr, value1, value2)</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span><span class="params">(stringArr, <span class="rest_arg">...values</span>)</span></span>&#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>tag函数的第一个参数是一个数组，该数组的成员是模板字符串中那些没有变量替换的部分，也就是说，变量替换只发生在数组的第一个成员与第二个成员之间、第二个成员与第三个成员之间，以此类推。</p>
<p>tag函数的其他参数，都是模板字符串各个变量被替换后的值。由于本例中，模板字符串含有两个变量，因此tag会接受到value1和value2两个参数。</p>
<p>tag函数所有参数的实际值如下。</p>
<ul>
<li>第一个参数：[‘Hello ‘, ‘ world ‘, ‘’]</li>
<li>第二个参数: 15</li>
<li>第三个参数：50</li>
</ul>
<p>也就是说，tag函数实际上以下面的形式调用。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="title">tag</span><span class="params">([<span class="string">'Hello '</span>, <span class="string">' world '</span>, <span class="string">''</span>], <span class="number">15</span>, <span class="number">50</span>)</span></span></span><br></pre></td></tr></table></figure>
<p>我们可以按照需要编写tag函数的代码。下面是tag函数的一种写法，以及运行结果。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">5</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">10</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">s, v1, v2</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">0</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">1</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(s[<span class="number">2</span>]);</span><br><span class="line">  <span class="built_in">console</span>.log(v1);</span><br><span class="line">  <span class="built_in">console</span>.log(v2);</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> <span class="string">"OK"</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">tag<span class="string">`Hello <span class="subst">$&#123; a + b &#125;</span> world <span class="subst">$&#123; a * b&#125;</span>`</span>;</span><br><span class="line"><span class="comment">// "Hello "</span></span><br><span class="line"><span class="comment">// " world "</span></span><br><span class="line"><span class="comment">// ""</span></span><br><span class="line"><span class="comment">// 15</span></span><br><span class="line"><span class="comment">// 50</span></span><br><span class="line"><span class="comment">// "OK"</span></span><br></pre></td></tr></table></figure>
<p>下面是一个更复杂的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> total = <span class="number">30</span>;</span><br><span class="line"><span class="keyword">let</span> msg = passthru<span class="string">`The total is <span class="subst">$&#123;total&#125;</span> (<span class="subst">$&#123;total*<span class="number">1.05</span>&#125;</span> with tax)`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span>(<span class="params">literals</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> result = <span class="string">''</span>;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="number">0</span>;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">while</span> (i &lt; literals.length) &#123;</span><br><span class="line">    result += literals[i++];</span><br><span class="line">    <span class="keyword">if</span> (i &lt; <span class="built_in">arguments</span>.length) &#123;</span><br><span class="line">      result += <span class="built_in">arguments</span>[i];</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> result;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">msg <span class="comment">// "The total is 30 (31.5 with tax)"</span></span><br></pre></td></tr></table></figure>
<p>上面这个例子展示了，如何将各个参数按照原来的位置拼合回去。</p>
<p>passthru函数采用 rest 参数的写法如下。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">passthru</span><span class="params">(literals, <span class="rest_arg">...values</span>)</span> </span>&#123;</span><br><span class="line">  let output = <span class="string">""</span>;</span><br><span class="line">  let index;</span><br><span class="line">  <span class="keyword">for</span> (index = <span class="number">0</span>; index &lt; values.length; index++) &#123;</span><br><span class="line">    output += literals[index] + values[index];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += literals[index]</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>“标签模板”的一个重要应用，就是过滤 HTML 字符串，防止用户输入恶意内容。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> message =</span><br><span class="line">  SaferHTML<span class="string">`&lt;p&gt;<span class="subst">$&#123;sender&#125;</span> has sent you a message.&lt;/p&gt;`</span>;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">SaferHTML</span>(<span class="params">templateData</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> s = templateData[<span class="number">0</span>];</span><br><span class="line">  <span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">1</span>; i &lt; <span class="built_in">arguments</span>.length; i++) &#123;</span><br><span class="line">    <span class="keyword">let</span> arg = <span class="built_in">String</span>(<span class="built_in">arguments</span>[i]);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Escape special characters in the substitution.</span></span><br><span class="line">    s += arg.replace(<span class="regexp">/&amp;/g</span>, <span class="string">"&amp;amp;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&lt;/g</span>, <span class="string">"&amp;lt;"</span>)</span><br><span class="line">            .replace(<span class="regexp">/&gt;/g</span>, <span class="string">"&amp;gt;"</span>);</span><br><span class="line"></span><br><span class="line">    <span class="comment">// Don't escape special characters in the template.</span></span><br><span class="line">    s += templateData[i];</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> s;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，sender变量往往是用户提供的，经过SaferHTML函数处理，里面的特殊字符都会被转义。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">let sender = '<span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="actionscript">alert(<span class="string">"abc"</span>)</span><span class="tag">&lt;/<span class="name">script</span>&gt;</span>'; // 恶意代码</span></span><br><span class="line"><span class="xml">let message = SaferHTML`<span class="tag">&lt;<span class="name">p</span>&gt;</span>$</span><span class="template-variable">&#123;sender&#125;</span><span class="xml"> has sent you a message.<span class="tag">&lt;/<span class="name">p</span>&gt;</span>`;</span></span><br><span class="line"><span class="xml"></span></span><br><span class="line"><span class="xml">message</span></span><br><span class="line"><span class="xml">// <span class="tag">&lt;<span class="name">p</span>&gt;</span>&amp;lt;script&amp;gt;alert("abc")&amp;lt;/script&amp;gt; has sent you a message.<span class="tag">&lt;/<span class="name">p</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>标签模板的另一个应用，就是多语言转换（国际化处理）。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">i18n`Welcome to <span class="variable">$&#123;siteName&#125;</span>, you are visitor number <span class="variable">$&#123;visitorNumber&#125;</span>!`</span><br><span class="line"><span class="regexp">//</span> <span class="string">"欢迎访问xxx，您是第xxxx位访问者！"</span></span><br></pre></td></tr></table></figure>
<p>模板字符串本身并不能取代 Mustache 之类的模板库，因为没有条件判断和循环处理功能，但是通过标签函数，你可以自己添加这些功能。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 下面的hashTemplate函数</span></span><br><span class="line"><span class="comment">// 是一个自定义的模板处理函数</span></span><br><span class="line"><span class="keyword">let</span> libraryHtml = hashTemplate`</span><br><span class="line">  &lt;ul&gt;</span><br><span class="line">    #for book <span class="keyword">in</span> $&#123;myBooks&#125;</span><br><span class="line">      &lt;li&gt;&lt;i&gt;#&#123;book.title&#125;&lt;/i&gt; by #&#123;book.author&#125;&lt;/li&gt;</span><br><span class="line">    #end</span><br><span class="line">  &lt;/ul&gt;</span><br><span class="line">`;</span><br></pre></td></tr></table></figure>
<p>除此之外，你甚至可以使用标签模板，在 JavaScript 语言之中嵌入其他语言。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">jsx`</span></span><br><span class="line"><span class="xml">  <span class="tag">&lt;<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">    <span class="tag">&lt;<span class="name">input</span></span></span></span><br><span class="line"><span class="xml">      ref='input'</span></span><br><span class="line"><span class="xml">      onChange='$</span><span class="template-variable">&#123;this.handleChange&#125;</span><span class="xml">'</span></span><br><span class="line"><span class="xml">      defaultValue='$</span><span class="template-variable">&#123;this.state.value&#125;</span><span class="xml">' /&gt;</span></span><br><span class="line"><span class="xml">      $</span><span class="template-variable">&#123;this.state.value&#125;</span><span class="xml"></span></span><br><span class="line"><span class="xml">   <span class="tag">&lt;/<span class="name">div</span>&gt;</span></span></span><br><span class="line"><span class="xml">`</span></span><br></pre></td></tr></table></figure>
<p>上面的代码通过jsx函数，将一个 DOM 字符串转为 React 对象。你可以在 Github 找到jsx函数的具体实现。</p>
<p>下面则是一个假想的例子，通过java函数，在 JavaScript 代码之中运行 Java 代码。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">java`</span><br><span class="line"><span class="keyword">class</span> <span class="title">HelloWorldApp</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title">main</span>(<span class="params">String[] args</span>) </span>&#123;</span><br><span class="line">    System.<span class="keyword">out</span>.println(“Hello World!”); <span class="comment">// Display the string.</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">`</span><br><span class="line">HelloWorldApp.main();</span><br></pre></td></tr></table></figure>
<p>模板处理函数的第一个参数（模板字符串数组），还有一个raw属性。</p>
<figure class="highlight prolog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">console.log<span class="string">`123`</span></span><br><span class="line">// [<span class="string">"123"</span>, raw: <span class="symbol">Array</span>[<span class="number">1</span>]]</span><br></pre></td></tr></table></figure>
<p>上面代码中，console.log接受的参数，实际上是一个数组。该数组有一个raw属性，保存的是转义后的原字符串。</p>
<p>请看下面的例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">tag<span class="string">`First line\nSecond line`</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strings</span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(strings.raw[<span class="number">0</span>]);</span><br><span class="line">  <span class="comment">// strings.raw[0] 为 "First line\\nSecond line"</span></span><br><span class="line">  <span class="comment">// 打印输出 "First line\nSecond line"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，tag函数的第一个参数strings，有一个raw属性，也指向一个数组。该数组的成员与strings数组完全一致。比如，strings数组是[“First line\nSecond line”]，那么strings.raw数组就是[“First line\nSecond line”]。两者唯一的区别，就是字符串里面的斜杠都被转义了。比如，strings.raw 数组会将\n视为\和n两个字符，而不是换行符。这是为了方便取得转义之前的原始模板而设计的。</p>
<h3 id="14-String-raw"><a href="#14-String-raw" class="headerlink" title="14.String.raw()"></a>14.String.raw()</h3><p>ES6 还为原生的 String 对象，提供了一个raw方法。</p>
<p>String.raw方法，往往用来充当模板字符串的处理函数，返回一个斜杠都被转义（即斜杠前面再加一个斜杠）的字符串，对应于替换变量后的模板字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\n<span class="subst">$&#123;<span class="number">2</span>+<span class="number">3</span>&#125;</span>!`</span>;</span><br><span class="line"><span class="comment">// 返回 "Hi\\n5!"</span></span><br><span class="line"></span><br><span class="line"><span class="built_in">String</span>.raw<span class="string">`Hi\u000A!`</span>;</span><br><span class="line"><span class="comment">// 返回 "Hi\\u000A!"</span></span><br></pre></td></tr></table></figure>
<p>如果原字符串的斜杠已经转义，那么String.raw会进行再次转义。</p>
<figure class="highlight autohotkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">String.raw`Hi\\n`</span><br><span class="line">// 返回 <span class="string">"Hi\\\\n"</span></span><br></pre></td></tr></table></figure>
<p>String.raw方法可以作为处理模板字符串的基本方法，它会将所有变量替换，而且对斜杠进行转义，方便下一步作为字符串来使用。</p>
<p>String.raw方法也可以作为正常的函数使用。这时，它的第一个参数，应该是一个具有raw属性的对象，且raw属性的值应该是一个数组。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">String</span>.raw(&#123; raw: <span class="string">'test'</span> &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line"><span class="comment">// 't0e1s2t'</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 等同于</span></span><br><span class="line"><span class="keyword">String</span>.raw(&#123; raw: [<span class="string">'t'</span>,<span class="string">'e'</span>,<span class="string">'s'</span>,<span class="string">'t'</span>] &#125;, <span class="number">0</span>, <span class="number">1</span>, <span class="number">2</span>);</span><br></pre></td></tr></table></figure>
<p>作为函数，String.raw的代码实现基本如下。</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">String.raw = function (strings, ...values) &#123;</span><br><span class="line">  let output = '';</span><br><span class="line">  let <span class="keyword">index</span>;</span><br><span class="line">  for (<span class="keyword">index</span> = <span class="number">0</span>; <span class="keyword">index</span> &lt; <span class="keyword">values</span>.<span class="built_in">length</span>; <span class="keyword">index</span>++) &#123;</span><br><span class="line">    output += strings.<span class="keyword">raw</span>[<span class="keyword">index</span>] + <span class="keyword">values</span>[<span class="keyword">index</span>];</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  output += strings.raw[<span class="keyword">index</span>]</span><br><span class="line">  <span class="keyword">return</span> output;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="15-模板字符串的限制"><a href="#15-模板字符串的限制" class="headerlink" title="15.模板字符串的限制"></a>15.模板字符串的限制</h3><p>前面提到标签模板里面，可以内嵌其他语言。但是，模板字符串默认会将字符串转义，导致无法嵌入其他语言。</p>
<p>举例来说，标签模板里面可以嵌入 LaTEX 语言。</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">latex</span></span>(strings) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">let document = latex`</span><br><span class="line">\<span class="keyword">new</span><span class="type">command</span>&#123;\fun&#125;&#123;\textbf&#123;Fun!&#125;&#125;  <span class="comment">// 正常工作</span></span><br><span class="line">\<span class="keyword">new</span><span class="type">command</span>&#123;\unicode&#125;&#123;\textbf&#123;Unicode!&#125;&#125; <span class="comment">// 报错</span></span><br><span class="line">\<span class="keyword">new</span><span class="type">command</span>&#123;\xerxes&#125;&#123;\textbf&#123;King!&#125;&#125; <span class="comment">// 报错</span></span><br><span class="line"></span><br><span class="line">Breve over the h goes \u&#123;h&#125;ere <span class="comment">// 报错</span></span><br><span class="line">`</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量document内嵌的模板字符串，对于 LaTEX 语言来说完全是合法的，但是 JavaScript 引擎会报错。原因就在于字符串的转义。</p>
<p>模板字符串会将\u00FF和\u{42}当作 Unicode 字符进行转义，所以\unicode解析时报错；而\x56会被当作十六进制字符串转义，所以\xerxes会报错。也就是说，\u和\x在 LaTEX 里面有特殊含义，但是 JavaScript 将它们转义了。</p>
<p>为了解决这个问题，ES2018 放松了对标签模板里面的字符串转义的限制。如果遇到不合法的字符串转义，就返回undefined，而不是报错，并且从raw属性上面可以得到原始字符串。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tag</span>(<span class="params">strs</span>) </span>&#123;</span><br><span class="line">  strs[<span class="number">0</span>] === <span class="literal">undefined</span></span><br><span class="line">  strs.raw[<span class="number">0</span>] === <span class="string">"\\unicode and \\u&#123;55&#125;"</span>;</span><br><span class="line">&#125;</span><br><span class="line">tag<span class="string">`\unicode and \u&#123;55&#125;`</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，模板字符串原本是应该报错的，但是由于放松了对字符串转义的限制，所以不报错了，JavaScript 引擎将第一个字符设置为undefined，但是raw属性依然可以得到原始字符串，因此tag函数还是可以对原字符串进行处理。</p>
<p>注意，这种对字符串转义的放松，只在标签模板解析字符串时生效，不是标签模板的场合，依然会报错。</p>
<figure class="highlight clean"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> bad = `bad escape sequence: \unicode`; <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 03.变量的解构赋值]]></title>
      <url>/2018/06/11/ES6/03.%E5%8F%98%E9%87%8F%E7%9A%84%E8%A7%A3%E6%9E%84%E8%B5%8B%E5%80%BC/</url>
      <content type="html"><![CDATA[<h2 id="变量的解构赋值"><a href="#变量的解构赋值" class="headerlink" title="变量的解构赋值"></a>变量的解构赋值</h2><h3 id="1-变量的解构赋值"><a href="#1-变量的解构赋值" class="headerlink" title="1.变量的解构赋值"></a>1.变量的解构赋值</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p>ES6 允许按照一定模式，从数组和对象中提取值，对变量进行赋值，这被称为解构（Destructuring）。</p>
<p>以前，为变量赋值，只能直接指定值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> b = <span class="number">2</span>;</span><br><span class="line"><span class="keyword">let</span> c = <span class="number">3</span>;</span><br></pre></td></tr></table></figure>
<p>ES6 允许写成下面这样。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">let [a, b, c] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码表示，可以从数组中提取值，按照对应位置，对变量赋值。</p>
<p>本质上，这种写法属于“模式匹配”，只要等号两边的模式相同，左边的变量就会被赋予对应的值。下面是一些使用嵌套数组进行解构的例子。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line">let [foo, [[bar], baz]] = [<span class="number">1</span>, [[<span class="number">2</span>], <span class="number">3</span>]];</span><br><span class="line">foo <span class="comment">// 1</span></span><br><span class="line">bar <span class="comment">// 2</span></span><br><span class="line">baz <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">let [ , , third] = [<span class="string">"foo"</span>, <span class="string">"bar"</span>, <span class="string">"baz"</span>];</span><br><span class="line">third <span class="comment">// "baz"</span></span><br><span class="line"></span><br><span class="line">let [x, , y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line">let [head, ...tail] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</span><br><span class="line">head <span class="comment">// 1</span></span><br><span class="line">tail <span class="comment">// [2, 3, 4]</span></span><br><span class="line"></span><br><span class="line">let [x, y, ...z] = ['a'];</span><br><span class="line">x <span class="comment">// "a"</span></span><br><span class="line">y <span class="comment">// undefined</span></span><br><span class="line">z <span class="comment">// []</span></span><br></pre></td></tr></table></figure>
<p>如果解构不成功，变量的值就等于undefined。</p>
<figure class="highlight accesslog"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let <span class="string">[foo]</span> = <span class="string">[]</span>;</span><br><span class="line">let <span class="string">[bar, foo]</span> = <span class="string">[1]</span>;</span><br></pre></td></tr></table></figure>
<p>以上两种情况都属于解构不成功，foo的值都会等于undefined。</p>
<p>另一种情况是不完全解构，即等号左边的模式，只匹配一部分的等号右边的数组。这种情况下，解构依然可以成功。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">let [x, y] = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 2</span></span><br><span class="line"></span><br><span class="line">let [a, [b], d] = [<span class="number">1</span>, [<span class="number">2</span>, <span class="number">3</span>], <span class="number">4</span>];</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line">b <span class="comment">// 2</span></span><br><span class="line">d <span class="comment">// 4</span></span><br></pre></td></tr></table></figure>
<p>上面两个例子，都属于不完全解构，但是可以成功。</p>
<p>如果等号的右边不是数组（或者严格地说，不是可遍历的结构，参见《Iterator》一章），那么将会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">false</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">NaN</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">undefined</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = <span class="literal">null</span>;</span><br><span class="line"><span class="keyword">let</span> [foo] = &#123;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面的语句都会报错，因为等号右边的值，要么转为对象以后不具备 Iterator 接口（前五个表达式），要么本身就不具备 Iterator 接口（最后一个表达式）。</p>
<p>对于 Set 结构，也可以使用数组的解构赋值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x, y, z] = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'a'</span>, <span class="string">'b'</span>, <span class="string">'c'</span>]);</span><br><span class="line">x <span class="comment">// "a"</span></span><br></pre></td></tr></table></figure>
<p>事实上，只要某种数据结构具有 Iterator 接口，都可以采用数组形式的解构赋值。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">function* fibs() &#123;</span><br><span class="line">  <span class="built_in">let</span> a = <span class="number">0</span>;</span><br><span class="line">  <span class="built_in">let</span> b = <span class="number">1</span>;</span><br><span class="line">  <span class="keyword">while</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    yield a;</span><br><span class="line">    [a, b] = [b, a + b];</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">let</span> [<span class="built_in">first</span>, <span class="built_in">second</span>, <span class="built_in">third</span>, <span class="built_in">fourth</span>, <span class="built_in">fifth</span>, <span class="built_in">sixth</span>] = fibs();</span><br><span class="line"><span class="built_in">sixth</span> // <span class="number">5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，fibs是一个 Generator 函数（参见《Generator 函数》一章），原生具有 Iterator 接口。解构赋值会依次从这个接口获取值。</p>
<h4 id="默认值"><a href="#默认值" class="headerlink" title="默认值"></a>默认值</h4><p>解构赋值允许指定默认值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [foo = <span class="literal">true</span>] = [];</span><br><span class="line">foo <span class="comment">// true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>]; <span class="comment">// x='a', y='b'</span></span><br><span class="line"><span class="keyword">let</span> [x, y = <span class="string">'b'</span>] = [<span class="string">'a'</span>, <span class="literal">undefined</span>]; <span class="comment">// x='a', y='b'</span></span><br></pre></td></tr></table></figure>
<p>注意，ES6 内部使用严格相等运算符（===），判断一个位置是否有值。所以，只有当一个数组成员严格等于undefined，默认值才会生效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">undefined</span>];</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = <span class="number">1</span>] = [<span class="literal">null</span>];</span><br><span class="line">x <span class="comment">// null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，如果一个数组成员是null，默认值就不会生效，因为null不严格等于undefined。</p>
<p>如果默认值是一个表达式，那么这个表达式是惰性求值的，即只有在用到的时候，才会求值。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(<span class="string">'aaa'</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> [x = f()] = [<span class="number">1</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码中，因为x能取到值，所以函数f根本不会执行。上面的代码其实等价于下面的代码。</p>
<figure class="highlight markdown"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">let x;</span><br><span class="line">if ([<span class="string">1</span>][<span class="symbol">0</span>] === undefined) &#123;</span><br><span class="line">  x = f();</span><br><span class="line">&#125; else &#123;</span><br><span class="line">  x = [<span class="string">1</span>][<span class="symbol">0</span>];</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>默认值可以引用解构赋值的其他变量，但该变量必须已经声明。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> [<span class="attr">x</span> = <span class="number">1</span>, <span class="attr">y</span> = x] = [];     // <span class="attr">x=1;</span> <span class="attr">y=1</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">x</span> = <span class="number">1</span>, <span class="attr">y</span> = x] = [<span class="number">2</span>];    // <span class="attr">x=2;</span> <span class="attr">y=2</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">x</span> = <span class="number">1</span>, <span class="attr">y</span> = x] = [<span class="number">1</span>, <span class="number">2</span>]; // <span class="attr">x=1;</span> <span class="attr">y=2</span></span><br><span class="line"><span class="keyword">let</span> [<span class="attr">x</span> = y, <span class="attr">y</span> = <span class="number">1</span>] = [];     // ReferenceError: y is not defined</span><br></pre></td></tr></table></figure>
<p>上面最后一个表达式之所以会报错，是因为x用y做默认值时，y还没有声明。</p>
<h3 id="2-对象的解构赋值"><a href="#2-对象的解构赋值" class="headerlink" title="2.对象的解构赋值"></a>2.对象的解构赋值</h3><p>解构不仅可以用于数组，还可以用于对象。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo, <span class="built_in">bar</span> &#125; = &#123; foo: <span class="string">"aaa"</span>, <span class="built_in">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line"><span class="built_in">bar</span> <span class="comment">// "bbb"</span></span><br></pre></td></tr></table></figure>
<p>对象的解构与数组有一个重要的不同。数组的元素是按次序排列的，变量的取值由它的位置决定；而对象的属性没有次序，变量必须与属性同名，才能取到正确的值。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="built_in">bar</span>, foo &#125; = &#123; foo: <span class="string">"aaa"</span>, <span class="built_in">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">foo <span class="comment">// "aaa"</span></span><br><span class="line"><span class="built_in">bar</span> <span class="comment">// "bbb"</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; baz &#125; = &#123; foo: <span class="string">"aaa"</span>, <span class="built_in">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码的第一个例子，等号左边的两个变量的次序，与等号右边两个同名属性的次序不一致，但是对取值完全没有影响。第二个例子的变量没有对应的同名属性，导致取不到值，最后等于undefined。</p>
<p>如果变量名与属性名不一致，必须写成下面这样。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let &#123; <span class="string">foo:</span> baz &#125; = &#123; <span class="string">foo:</span> <span class="string">'aaa'</span>, <span class="string">bar:</span> <span class="string">'bbb'</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line"></span><br><span class="line">let obj = &#123; <span class="string">first:</span> <span class="string">'hello'</span>, <span class="string">last:</span> <span class="string">'world'</span> &#125;;</span><br><span class="line">let &#123; <span class="string">first:</span> f, <span class="string">last:</span> l &#125; = obj;</span><br><span class="line">f <span class="comment">// 'hello'</span></span><br><span class="line">l <span class="comment">// 'world'</span></span><br></pre></td></tr></table></figure>
<p>这实际上说明，对象的解构赋值是下面形式的简写（参见《对象的扩展》一章）。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; foo: foo, <span class="built_in">bar</span>: <span class="built_in">bar</span> &#125; = &#123; foo: <span class="string">"aaa"</span>, <span class="built_in">bar</span>: <span class="string">"bbb"</span> &#125;;</span><br></pre></td></tr></table></figure>
<p>也就是说，对象的解构赋值的内部机制，是先找到同名属性，然后再赋给对应的变量。真正被赋值的是后者，而不是前者。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">let &#123; <span class="string">foo:</span> baz &#125; = &#123; <span class="string">foo:</span> <span class="string">"aaa"</span>, <span class="string">bar:</span> <span class="string">"bbb"</span> &#125;;</span><br><span class="line">baz <span class="comment">// "aaa"</span></span><br><span class="line">foo <span class="comment">// error: foo is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，foo是匹配的模式，baz才是变量。真正被赋值的是变量baz，而不是模式foo。</p>
<p>与数组一样，解构也可以用于嵌套结构的对象。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; y: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // <span class="string">"Hello"</span></span><br><span class="line">y // <span class="string">"World"</span></span><br></pre></td></tr></table></figure>
<p>注意，这时p是模式，不是变量，因此不会被赋值。如果p也要作为变量赋值，可以写成下面这样。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> obj = &#123;</span><br><span class="line">  p: [</span><br><span class="line">    <span class="string">'Hello'</span>,</span><br><span class="line">    &#123; y: <span class="string">'World'</span> &#125;</span><br><span class="line">  ]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; p, p: [x, &#123; y &#125;] &#125; = obj;</span><br><span class="line">x // <span class="string">"Hello"</span></span><br><span class="line">y // <span class="string">"World"</span></span><br><span class="line">p // [<span class="string">"Hello"</span>, &#123;y: <span class="string">"World"</span>&#125;]</span><br></pre></td></tr></table></figure>
<p>下面是另一个例子。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line">const <span class="keyword">node</span> <span class="title">= &#123;</span></span><br><span class="line"><span class="title">  loc</span>: &#123;</span><br><span class="line">    <span class="literal">start</span>: &#123;</span><br><span class="line">      line: <span class="number">1</span>,</span><br><span class="line">      column: <span class="number">5</span></span><br><span class="line">    &#125;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; loc, loc: &#123; <span class="literal">start</span> &#125;, loc: &#123; <span class="literal">start</span>: &#123; line &#125;&#125; &#125; = <span class="keyword">node</span><span class="title">;</span></span><br><span class="line"><span class="title">line</span> // <span class="number">1</span></span><br><span class="line">loc  // Object &#123;<span class="literal">start</span>: Object&#125;</span><br><span class="line"><span class="literal">start</span> // Object &#123;line: <span class="number">1</span>, column: <span class="number">5</span>&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码有三次解构赋值，分别是对loc、start、line三个属性的解构赋值。注意，最后一次对line属性的解构赋值之中，只有line是变量，loc和start都是模式，不是变量。</p>
<p>下面是嵌套赋值的例子。</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">let obj = &#123;&#125;;</span><br><span class="line">let arr = [];</span><br><span class="line"></span><br><span class="line">(&#123; <span class="string">foo:</span> obj.prop, <span class="string">bar:</span> arr[<span class="number">0</span>] &#125; = &#123; <span class="string">foo:</span> <span class="number">123</span>, <span class="string">bar:</span> <span class="literal">true</span> &#125;);</span><br><span class="line"></span><br><span class="line">obj <span class="comment">// &#123;prop:123&#125;</span></span><br><span class="line">arr <span class="comment">// [true]</span></span><br></pre></td></tr></table></figure>
<p>对象的解构也可以指定默认值。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> &#123;x = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">x <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x, y = <span class="number">5</span>&#125; = &#123;x: <span class="number">1</span>&#125;;</span><br><span class="line">x <span class="comment">// 1</span></span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x: y = <span class="number">3</span>&#125; = &#123;&#125;;</span><br><span class="line">y <span class="comment">// 3</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123;x: y = <span class="number">3</span>&#125; = &#123;x: <span class="number">5</span>&#125;;</span><br><span class="line">y <span class="comment">// 5</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> &#123; message: msg = <span class="string">'Something went wrong'</span> &#125; = &#123;&#125;;</span><br><span class="line">msg <span class="comment">// "Something went wrong"</span></span><br></pre></td></tr></table></figure>
<p>默认值生效的条件是，对象的属性值严格等于undefined。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">var &#123;<span class="keyword">x</span> = <span class="number">3</span>&#125; = &#123;<span class="keyword">x</span>: undefined&#125;<span class="comment">;</span></span><br><span class="line"><span class="comment">x // 3</span></span><br><span class="line"><span class="comment"></span></span><br><span class="line"><span class="comment">var &#123;x = 3&#125; = &#123;x: null&#125;;</span></span><br><span class="line"><span class="comment">x // null</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，属性x等于null，因为null与undefined不严格相等，所以是个有效的赋值，导致默认值3不会生效。</p>
<p>如果解构失败，变量的值等于undefined。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;foo&#125; = &#123;bar: <span class="string">'baz'</span>&#125;;</span><br><span class="line">foo // undefined</span><br></pre></td></tr></table></figure>
<p>如果解构模式是嵌套的对象，而且子对象所在的父属性不存在，那么将会报错。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// 报错</span><br><span class="line"><span class="keyword">let</span> &#123;foo: &#123;bar&#125;&#125; = &#123;baz: <span class="string">'baz'</span>&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码中，等号左边对象的foo属性，对应一个子对象。该子对象的bar属性，解构时会报错。原因很简单，因为foo这时等于undefined，再取子属性就会报错，请看下面的代码。</p>
<figure class="highlight sqf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let <span class="variable">_tmp</span> = &#123;baz: <span class="string">'baz'</span>&#125;;</span><br><span class="line"><span class="variable">_tmp</span>.foo.bar <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>如果要将一个已经声明的变量用于解构赋值，必须非常小心。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 错误的写法</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br><span class="line">&#123;x&#125; = &#123;x: <span class="number">1</span>&#125;;</span><br><span class="line"><span class="comment">// SyntaxError: syntax error</span></span><br></pre></td></tr></table></figure>
<p>上面代码的写法会报错，因为 JavaScript 引擎会将{x}理解成一个代码块，从而发生语法错误。只有不将大括号写在行首，避免 JavaScript 将其解释为代码块，才能解决这个问题。</p>
<figure class="highlight llvm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">// 正确的写法</span><br><span class="line">let <span class="keyword">x</span><span class="comment">;</span></span><br><span class="line"><span class="comment">(&#123;x&#125; = &#123;x: 1&#125;);</span></span><br></pre></td></tr></table></figure>
<p>上面代码将整个解构赋值语句，放在一个圆括号里面，就可以正确执行。关于圆括号与解构赋值的关系，参见下文。</p>
<p>解构赋值允许等号左边的模式之中，不放置任何变量名。因此，可以写出非常古怪的赋值表达式。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">(&#123;&#125; = [<span class="literal">true</span>, <span class="literal">false</span>])<span class="comment">;</span></span><br><span class="line">(&#123;&#125; = 'abc')<span class="comment">;</span></span><br><span class="line">(&#123;&#125; = [])<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>上面的表达式虽然毫无意义，但是语法是合法的，可以执行。</p>
<p>对象的解构赋值，可以很方便地将现有对象的方法，赋值到某个变量。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123; <span class="built_in">log</span>, <span class="built_in">sin</span>, <span class="built_in">cos</span> &#125; = Math;</span><br></pre></td></tr></table></figure>
<p>上面代码将Math对象的对数、正弦、余弦三个方法，赋值到对应的变量上，使用起来就会方便很多。</p>
<p>由于数组本质是特殊的对象，因此可以对数组进行对象属性的解构。</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line"><span class="built_in">let</span> &#123;<span class="number">0</span> : <span class="built_in">first</span>, [arr.<span class="built_in">length</span> - <span class="number">1</span>] : <span class="built_in">last</span>&#125; = arr;</span><br><span class="line"><span class="built_in">first</span> // <span class="number">1</span></span><br><span class="line"><span class="built_in">last</span> // <span class="number">3</span></span><br></pre></td></tr></table></figure>
<p>上面代码对数组进行对象解构。数组arr的0键对应的值是1，[arr.length - 1]就是2键，对应的值是3。方括号这种写法，属于“属性名表达式”（参见《对象的扩展》一章）</p>
<h3 id="3-字符串的解构赋值"><a href="#3-字符串的解构赋值" class="headerlink" title="3.字符串的解构赋值"></a>3.字符串的解构赋值</h3><p>字符串也可以解构赋值。这是因为此时，字符串被转换成了一个类似数组的对象。</p>
<figure class="highlight awk"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">const [a, b, c, d, e] = <span class="string">'hello'</span>;</span><br><span class="line">a <span class="regexp">//</span> <span class="string">"h"</span></span><br><span class="line">b <span class="regexp">//</span> <span class="string">"e"</span></span><br><span class="line">c <span class="regexp">//</span> <span class="string">"l"</span></span><br><span class="line">d <span class="regexp">//</span> <span class="string">"l"</span></span><br><span class="line">e <span class="regexp">//</span> <span class="string">"o"</span></span><br></pre></td></tr></table></figure>
<p>类似数组的对象都有一个length属性，因此还可以对这个属性解构赋值。</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">let &#123;length : <span class="built_in">len</span>&#125; = <span class="string">'hello'</span>;</span><br><span class="line"><span class="built_in">len</span> <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<h3 id="4-数值和布尔值的解构赋值"><a href="#4-数值和布尔值的解构赋值" class="headerlink" title="4.数值和布尔值的解构赋值"></a>4.数值和布尔值的解构赋值</h3><p>解构赋值时，如果等号右边是数值和布尔值，则会先转为对象。</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> &#123;<span class="built_in">toString</span>: s&#125; = <span class="number">123</span>;</span><br><span class="line"><span class="attr">s</span> === Number.prototype.<span class="built_in">toString</span> // <span class="literal">true</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;<span class="built_in">toString</span>: s&#125; = <span class="literal">true</span>;</span><br><span class="line"><span class="attr">s</span> === Boolean.prototype.<span class="built_in">toString</span> // <span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</p>
<p>解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于undefined和null无法转为对象，所以对它们进行解构赋值，都会报错。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">上面代码中，数值和布尔值的包装对象都有toString属性，因此变量s都能取到值。</span><br><span class="line"></span><br><span class="line">解构赋值的规则是，只要等号右边的值不是对象或数组，就先将其转为对象。由于<span class="literal">undefined</span>和<span class="literal">null</span>无法转为对象，所以对它们进行解构赋值，都会报错。</span><br></pre></td></tr></table></figure>
<h3 id="5-函数参数的解构赋值"><a href="#5-函数参数的解构赋值" class="headerlink" title="5.函数参数的解构赋值"></a>5.函数参数的解构赋值</h3><p>函数的参数也可以使用解构赋值。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span><span class="params">([x, y])</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">add([<span class="number">1</span>, <span class="number">2</span>]); <span class="comment">// 3</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数add的参数表面上是一个数组，但在传入参数的那一刻，数组参数就被解构成变量x和y。对于函数内部的代码来说，它们能感受到的参数就是x和y。</p>
<p>下面是另一个例子。</p>
<figure class="highlight lua"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">[[1, 2], [3, 4]]</span>.map(([a, b]) =&gt; a + b);</span><br></pre></td></tr></table></figure>
<p>函数参数的解构也可以使用默认值。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">move</span>(&#123;x = <span class="number">0</span>, y = <span class="number">0</span>&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>&#125;); <span class="comment">// [3, 0]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;&#125;); <span class="comment">// [0, 0]</span></span><br><span class="line"><span class="built_in">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，函数move的参数是一个对象，通过对这个对象进行解构，得到变量x和y的值。如果解构失败，x和y等于默认值。</p>
<p>注意，下面的写法会得到不一样的结果。</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">function <span class="built_in">move</span>(&#123;x, y&#125; = &#123; x: <span class="number">0</span>, y: <span class="number">0</span> &#125;) &#123;</span><br><span class="line">  <span class="built_in">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>, y: <span class="number">8</span>&#125;); <span class="comment">// [3, 8]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;x: <span class="number">3</span>&#125;); <span class="comment">// [3, undefined]</span></span><br><span class="line"><span class="built_in">move</span>(&#123;&#125;); <span class="comment">// [undefined, undefined]</span></span><br><span class="line"><span class="built_in">move</span>(); <span class="comment">// [0, 0]</span></span><br></pre></td></tr></table></figure>
<p>上面代码是为函数move的参数指定默认值，而不是为变量x和y指定默认值，所以会得到与前一种写法不同的结果。</p>
<p>undefined就会触发函数参数的默认值。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">[<span class="number">1</span>, <span class="literal">undefined</span>, <span class="number">3</span>].map(<span class="function"><span class="params">(x = <span class="string">'yes'</span>)</span> =&gt;</span> x);</span><br><span class="line"><span class="regexp">//</span> [ <span class="number">1</span>, <span class="string">'yes'</span>, <span class="number">3</span> ]</span><br></pre></td></tr></table></figure>
<h3 id="圆括号问题"><a href="#圆括号问题" class="headerlink" title="圆括号问题"></a>圆括号问题</h3><p>解构赋值虽然很方便，但是解析起来并不容易。对于编译器来说，一个式子到底是模式，还是表达式，没有办法从一开始就知道，必须解析到（或解析不到）等号才能知道。</p>
<p>由此带来的问题是，如果模式中出现圆括号怎么处理。ES6 的规则是，只要有可能导致解构的歧义，就不得使用圆括号。</p>
<p>但是，这条规则实际上不那么容易辨别，处理起来相当麻烦。因此，建议只要有可能，就不要在模式中放置圆括号。</p>
<h4 id="不能使用圆括号的情况"><a href="#不能使用圆括号的情况" class="headerlink" title="不能使用圆括号的情况"></a>不能使用圆括号的情况</h4><p>以下三种解构赋值不得使用圆括号。</p>
<p>（1）变量声明语句</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">// 全部报错</span><br><span class="line"><span class="keyword">let</span> [(a)] = [<span class="number">1</span>];</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123;x: (c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> (&#123;x: c&#125;) = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x: c)&#125; = &#123;&#125;;</span><br><span class="line"><span class="keyword">let</span> &#123;(x): c&#125; = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> &#123; o: (&#123; p: p &#125;) &#125; = &#123; o: &#123; p: <span class="number">2</span> &#125; &#125;;</span><br></pre></td></tr></table></figure>
<p>（2）函数参数</p>
<p>函数参数也属于变量声明，因此不能带有圆括号。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([<span class="params">(z)</span>])</span> </span>&#123; <span class="keyword">return</span> z; &#125;</span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([z,<span class="params">(x)</span>])</span> </span>&#123; <span class="keyword">return</span> x; &#125;</span><br></pre></td></tr></table></figure>
<p>（3）赋值语句的模式</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 全部报错</span></span><br><span class="line"><span class="comment">(&#123; p: a &#125;)</span> = &#123; p: <span class="number">42</span> &#125;;</span><br><span class="line"><span class="comment">([a])</span> = [<span class="number">5</span>];</span><br></pre></td></tr></table></figure>
<p>上面代码将整个模式放在圆括号之中，导致报错。</p>
<figure class="highlight dust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="xml">// 报错</span></span><br><span class="line"><span class="xml">[(</span><span class="template-variable">&#123; p: a &#125;</span><span class="xml">), </span><span class="template-variable">&#123; x: c &#125;</span><span class="xml">] = [</span><span class="template-variable">&#123;&#125;</span><span class="xml">, </span><span class="template-variable">&#123;&#125;</span><span class="xml">];</span></span><br></pre></td></tr></table></figure>
<p>上面代码将一部分模式放在圆括号之中，导致报错。</p>
<h4 id="可以使用圆括号的情况"><a href="#可以使用圆括号的情况" class="headerlink" title="可以使用圆括号的情况"></a>可以使用圆括号的情况</h4><p>可以使用圆括号的情况只有一种：赋值语句的非模式部分，可以使用圆括号。</p>
<figure class="highlight gcode"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">[<span class="comment">(b)</span>] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br><span class="line"><span class="comment">(&#123; p: (d)</span> &#125; = &#123;&#125;); <span class="comment">// 正确</span></span><br><span class="line">[<span class="comment">(parseInt.prop)</span>] = [<span class="number">3</span>]; <span class="comment">// 正确</span></span><br></pre></td></tr></table></figure>
<p>上面三行语句都可以正确执行，因为首先它们都是赋值语句，而不是声明语句；其次它们的圆括号都不属于模式的一部分。第一行语句中，模式是取数组的第一个成员，跟圆括号无关；第二行语句中，模式是p，而不是d；第三行语句与第一行语句的性质一致。</p>
<h3 id="7-用途"><a href="#7-用途" class="headerlink" title="7.用途"></a>7.用途</h3><p>变量的解构赋值用途很多。</p>
<p>（1）交换变量的值</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">let</span> <span class="attr">x</span> = <span class="number">1</span>;</span><br><span class="line"><span class="keyword">let</span> <span class="attr">y</span> = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line">[x, y] = [y, x];</span><br></pre></td></tr></table></figure>
<p>上面代码交换变量x和y的值，这样的写法不仅简洁，而且易读，语义非常清晰。</p>
<p>（2）从函数返回多个值</p>
<p>函数只能返回一个值，如果要返回多个值，只能将它们放在数组或对象里返回。有了解构赋值，取出这些值就非常方便。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 返回一个数组</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> [a, b, c] = example();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 返回一个对象</span></span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">example</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    foo: <span class="number">1</span>,</span><br><span class="line">    bar: <span class="number">2</span></span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">let</span> &#123; foo, bar &#125; = example();</span><br></pre></td></tr></table></figure>
<p>（3）函数参数的定义</p>
<p>解构赋值可以方便地将一组参数与变量名对应起来。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 参数是一组有次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">([x, y, z])</span> <span class="comment">&#123; ... &#125;</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">([1, 2, 3])</span>;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 参数是一组无次序的值</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">(<span class="comment">&#123;x, y, z&#125;</span>)</span> <span class="comment">&#123; ... &#125;</span></span></span><br><span class="line"><span class="function"><span class="title">f</span><span class="params">(<span class="comment">&#123;z: 3, y: 2, x: 1&#125;</span>)</span>;</span></span><br></pre></td></tr></table></figure>
<p>（4）提取 JSON 数据</p>
<p>解构赋值对提取 JSON 对象中的数据，尤其有用。</p>
<figure class="highlight fortran"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">let jsonData = &#123;</span><br><span class="line">  id: <span class="number">42</span>,</span><br><span class="line">  <span class="keyword">status</span>: <span class="string">"OK"</span>,</span><br><span class="line">  <span class="keyword">data</span>: [<span class="number">867</span>, <span class="number">5309</span>]</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">let &#123; id, <span class="keyword">status</span>, <span class="keyword">data</span>: <span class="keyword">number</span> &#125; = jsonData;</span><br><span class="line"></span><br><span class="line">console.<span class="built_in">log</span>(id, <span class="keyword">status</span>, <span class="keyword">number</span>);</span><br><span class="line">// <span class="number">42</span>, <span class="string">"OK"</span>, [<span class="number">867</span>, <span class="number">5309</span>]</span><br></pre></td></tr></table></figure>
<p>上面代码可以快速提取 JSON 数据的值。</p>
<p>（5）函数参数的默认值</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">jQuery.ajax = <span class="function"><span class="keyword">function</span> </span>(url, &#123;</span><br><span class="line">  async = <span class="literal">true</span>,</span><br><span class="line">  beforeSend = <span class="function"><span class="keyword">function</span> </span>() &#123;&#125;,</span><br><span class="line">  cache = <span class="literal">true</span>,</span><br><span class="line">  complete = <span class="function"><span class="keyword">function</span> </span>() &#123;&#125;,</span><br><span class="line">  crossDomain = <span class="literal">false</span>,</span><br><span class="line">  global = <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// ... more config</span></span><br><span class="line">&#125; = &#123;&#125;) &#123;</span><br><span class="line">  <span class="comment">// ... do stuff</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>指定参数的默认值，就避免了在函数体内部再写var foo = config.foo || ‘default foo’;这样的语句。</p>
<p>（6）遍历 Map 结构</p>
<p>任何部署了 Iterator 接口的对象，都可以用for…of循环遍历。Map 结构原生支持 Iterator 接口，配合变量的解构赋值，获取键名和键值就非常方便。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> <span class="built_in">map</span> = <span class="keyword">new</span> Map();</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'first'</span>, <span class="string">'hello'</span>);</span><br><span class="line"><span class="built_in">map</span>.<span class="built_in">set</span>(<span class="string">'second'</span>, <span class="string">'world'</span>);</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (let [<span class="built_in">key</span>, value] of <span class="built_in">map</span>) &#123;</span><br><span class="line">  console.<span class="built_in">log</span>(<span class="built_in">key</span> + <span class="string">" is "</span> + value);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// first is hello</span></span><br><span class="line"><span class="comment">// second is world</span></span><br></pre></td></tr></table></figure>
<p>如果只想获取键名，或者只想获取键值，可以写成下面这样。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 获取键名</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [key] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 获取键值</span></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> [,<span class="keyword">value</span>] <span class="keyword">of</span> map) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>（7）输入模块的指定方法</p>
<p>加载模块时，往往需要指定输入哪些方法。解构赋值使得输入语句非常清晰。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> &#123; SourceMapConsumer, SourceNode &#125; = <span class="built_in">require</span>(<span class="string">"source-map"</span>);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 02.let 和 const 命令]]></title>
      <url>/2018/06/08/ES6/02.let%E5%92%8Cconst%E5%91%BD%E4%BB%A4/</url>
      <content type="html"><![CDATA[<h2 id="Let-和-Const-命令"><a href="#Let-和-Const-命令" class="headerlink" title="Let 和 Const 命令"></a>Let 和 Const 命令</h2><h3 id="1-Let-命令"><a href="#1-Let-命令" class="headerlink" title="1. Let 命令"></a>1. Let 命令</h3><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法:"></a>基本用法:</h4><p>ES6 新增了let命令，用来声明变量。它的用法类似于var，但是所声明的变量，只在let命令所在的代码块内有效。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> b = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">a <span class="comment">// ReferenceError: a is not defined.</span></span><br><span class="line">b <span class="comment">// 1</span></span><br></pre></td></tr></table></figure>
<p>上面代码在代码块之中，分别用let和var声明了两个变量。然后在代码块之外调用这两个变量，结果let声明的变量报错，var声明的变量返回了正确的值。这表明，let声明的变量只在它所在的代码块有效。</p>
<p>for循环的计数器，就很合适使用let命令。</p>
<figure class="highlight elixir"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (let i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  /<span class="regexp">/ ...</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">console.log(i);</span></span><br><span class="line"><span class="regexp">/</span><span class="regexp">/ ReferenceError: i is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，计数器i只在for循环体内有效，在循环体外引用就会报错。</p>
<p>下面的代码如果使用var，最后输出的是10。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 10</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量i是var命令声明的，在全局范围内都有效，所以全局只有一个变量i。每一次循环，变量i的值都会发生改变，而循环内被赋给数组a的函数内部的console.log(i)，里面的i指向的就是全局的i。也就是说，所有数组a的成员里面的i，指向的都是同一个i，导致运行时输出的是最后一轮的i的值，也就是 10。</p>
<p>如果使用let，声明的变量仅在块级作用域内有效，最后输出的是 6。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = [];</span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">10</span>; i++) &#123;</span><br><span class="line">  a[i] = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="built_in">console</span>.log(i);</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">a[<span class="number">6</span>](); <span class="comment">// 6</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量i是let声明的，当前的i只在本轮循环有效，所以每一次循环的i其实都是一个新的变量，所以最后输出的是6。你可能会问，如果每一轮循环的变量i都是重新声明的，那它怎么知道上一轮循环的值，从而计算出本轮循环的值？这是因为 JavaScript 引擎内部会记住上一轮循环的值，初始化本轮的变量i时，就在上一轮循环的基础上进行计算。</p>
<p>另外，for循环还有一个特别之处，就是设置循环变量的那部分是一个父作用域，而循环体内部是一个单独的子作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="keyword">let</span> i = <span class="number">0</span>; i &lt; <span class="number">3</span>; i++) &#123;</span><br><span class="line">  <span class="keyword">let</span> i = <span class="string">'abc'</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(i);</span><br><span class="line">&#125;</span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br><span class="line"><span class="comment">// abc</span></span><br></pre></td></tr></table></figure>
<p>上面代码正确运行，输出了 3 次abc。这表明函数内部的变量i与循环变量i不在同一个作用域，有各自单独的作用域。</p>
<h4 id="不存在变量提升"><a href="#不存在变量提升" class="headerlink" title="不存在变量提升"></a>不存在变量提升</h4><p>var命令会发生”变量提升“现象，即变量可以在声明之前使用，值为undefined。这种现象多多少少是有些奇怪的，按照一般的逻辑，变量应该在声明语句之后才可以使用。</p>
<p>为了纠正这种现象，let命令改变了语法行为，它所声明的变量一定要在声明后使用，否则报错。</p>
<figure class="highlight gauss"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// var 的情况</span></span><br><span class="line">console.<span class="built_in">log</span>(foo); <span class="comment">// 输出undefined</span></span><br><span class="line">var foo = <span class="number">2</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// let 的情况</span></span><br><span class="line">console.<span class="built_in">log</span>(<span class="built_in">bar</span>); <span class="comment">// 报错ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> <span class="built_in">bar</span> = <span class="number">2</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量foo用var命令声明，会发生变量提升，即脚本开始运行时，变量foo已经存在了，但是没有值，所以会输出undefined。变量bar用let命令声明，不会发生变量提升。这表示在声明它之前，变量bar是不存在的，这时如果用到它，就会抛出一个错误。</p>
<h4 id="暂时性死区"><a href="#暂时性死区" class="headerlink" title="暂时性死区"></a>暂时性死区</h4><p>只要块级作用域内存在let命令，它所声明的变量就“绑定”（binding）这个区域，不再受外部的影响。</p>
<p>上面代码中，存在全局变量tmp，但是块级作用域内let又声明了一个局部变量tmp，导致后者绑定这个块级作用域，所以在let声明变量前，对tmp赋值会报错。</p>
<p>ES6 明确规定，如果区块中存在let和const命令，这个区块对这些命令声明的变量，从一开始就形成了封闭作用域。凡是在声明之前就使用这些变量，就会报错。</p>
<p>总之，在代码块内，使用let命令声明变量之前，该变量都是不可用的。这在语法上，称为“暂时性死区”（temporal dead zone，简称 TDZ）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="comment">// TDZ开始</span></span><br><span class="line">  tmp = <span class="string">'abc'</span>; <span class="comment">// ReferenceError</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// ReferenceError</span></span><br><span class="line"></span><br><span class="line">  <span class="keyword">let</span> tmp; <span class="comment">// TDZ结束</span></span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// undefined</span></span><br><span class="line"></span><br><span class="line">  tmp = <span class="number">123</span>;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp); <span class="comment">// 123</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，在let命令声明变量tmp之前，都属于变量tmp的“死区”。</p>
<p>“暂时性死区”也意味着typeof不再是一个百分之百安全的操作。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> x; <span class="comment">// ReferenceError</span></span><br><span class="line"><span class="keyword">let</span> x;</span><br></pre></td></tr></table></figure>
<p>上面代码中，变量x使用let命令声明，所以在声明之前，都属于x的“死区”，只要用到该变量就会报错。因此，typeof运行时就会抛出一个ReferenceError。</p>
<p>作为比较，如果一个变量根本没有被声明，使用typeof反而不会报错。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">typeof</span> undeclared_variable <span class="comment">// "undefined"</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，undeclared variable是一个不存在的变量名，结果返回“undefined”。所以，在没有let之前，typeof运算符是百分之百安全的，永远不会报错。现在这一点不成立了。这样的设计是为了让大家养成良好的编程习惯，变量一定要在声明之后使用，否则就报错。</p>
<p>有些“死区”比较隐蔽，不太容易发现。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(x = y, y = 2)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">bar(); <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，调用bar函数之所以报错（某些实现可能不报错），是因为参数x默认值等于另一个参数y，而此时y还没有声明，属于”死区“。如果y的默认值是x，就不会报错，因为此时x已经声明了。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">bar</span><span class="params">(x = 2, y = x)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> [x, y];</span><br><span class="line">&#125;</span><br><span class="line">bar(); <span class="comment">// [2, 2]</span></span><br></pre></td></tr></table></figure>
<p>另外，下面的代码也会报错，与var的行为不同。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="keyword">var</span> x = x;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="keyword">let</span> x = x;</span><br><span class="line"><span class="comment">// ReferenceError: x is not defined</span></span><br></pre></td></tr></table></figure>
<p>上面代码报错，也是因为暂时性死区。使用let声明变量时，只要变量在还没有声明完成前使用，就会报错。上面这行就属于这个情况，在变量x的声明语句还没有执行完成前，就去取x的值，导致报错”x 未定义“。</p>
<p>ES6 规定暂时性死区和let、const语句不出现变量提升，主要是为了减少运行时错误，防止在变量声明前就使用这个变量，从而导致意料之外的行为。这样的错误在 ES5 是很常见的，现在有了这种规定，避免此类错误就很容易了。</p>
<p>总之，暂时性死区的本质就是，只要一进入当前作用域，所要使用的变量就已经存在了，但是不可获取，只有等到声明变量的那一行代码出现，才可以获取和使用该变量。</p>
<h4 id="不允许重复声明"><a href="#不允许重复声明" class="headerlink" title="不允许重复声明"></a>不允许重复声明</h4><p>let不允许在相同作用域内，重复声明同一个变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">10</span>;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="number">1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>因此，不能在函数内部重新声明参数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> arg; <span class="comment">// 报错</span></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">func</span>(<span class="params">arg</span>) </span>&#123;</span><br><span class="line">  &#123;</span><br><span class="line">    <span class="keyword">let</span> arg; <span class="comment">// 不报错</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="2-块级作用域"><a href="#2-块级作用域" class="headerlink" title="2.块级作用域"></a>2.块级作用域</h3><h4 id="为什么需要块级作用域"><a href="#为什么需要块级作用域" class="headerlink" title="为什么需要块级作用域"></a>为什么需要块级作用域</h4><p>ES5 只有全局作用域和函数作用域，没有块级作用域，这带来很多不合理的场景。</p>
<p>第一种场景，内层变量可能会覆盖外层变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> tmp = <span class="keyword">new</span> <span class="built_in">Date</span>();</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="built_in">console</span>.log(tmp);</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="keyword">var</span> tmp = <span class="string">'hello world'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">f(); <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码的原意是，if代码块的外部使用外层的tmp变量，内部使用内层的tmp变量。但是，函数f执行后，输出结果为undefined，原因在于变量提升，导致内层的tmp变量覆盖了外层的tmp变量。</p>
<p>第二种场景，用来计数的循环变量泄露为全局变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> s = <span class="string">'hello'</span>;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; s.length; i++) &#123;</span><br><span class="line">  <span class="built_in">console</span>.log(s[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">console</span>.log(i); <span class="comment">// 5</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，变量i只用来控制循环，但是循环结束后，它并没有消失，泄露成了全局变量。</p>
<h4 id="ES6-的块级作用域"><a href="#ES6-的块级作用域" class="headerlink" title="ES6 的块级作用域"></a>ES6 的块级作用域</h4><p>let实际上为 JavaScript 新增了块级作用域。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f1</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">let</span> n = <span class="number">5</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">    <span class="keyword">let</span> n = <span class="number">10</span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="built_in">console</span>.log(n); <span class="comment">// 5</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面的函数有两个代码块，都声明了变量n，运行后输出 5。这表示外层代码块不受内层代码块的影响。如果两次都使用var定义变量n，最后输出的值才是 10。</p>
<p>ES6 允许块级作用域的任意嵌套。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;&#123;let insane = <span class="string">'Hello World'</span>&#125;&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>上面代码使用了一个五层的块级作用域。外层作用域无法读取内层作用域的变量。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  &#123;let insane = 'Hello World'&#125;</span><br><span class="line">  console.log(<span class="name">insane</span>)<span class="comment">; // 报错</span></span><br><span class="line">&#125;&#125;&#125;&#125;<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>内层作用域可以定义外层作用域的同名变量。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;&#123;&#123;&#123;</span><br><span class="line">  let insane = <span class="string">'Hello World'</span>;</span><br><span class="line">  &#123;let insane = <span class="string">'Hello World'</span>&#125;</span><br><span class="line">&#125;&#125;&#125;&#125;;</span><br></pre></td></tr></table></figure>
<p>块级作用域的出现，实际上使得获得广泛应用的立即执行函数表达式（IIFE）不再必要了。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// IIFE 写法</span></span><br><span class="line">(function () &#123;</span><br><span class="line">  <span class="built_in">var</span> tmp = <span class="params">...</span>;</span><br><span class="line">  <span class="params">...</span></span><br><span class="line">&#125;());</span><br><span class="line"></span><br><span class="line"><span class="comment">// 块级作用域写法</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> tmp = <span class="params">...</span>;</span><br><span class="line">  <span class="params">...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="块级作用域与函数声明"><a href="#块级作用域与函数声明" class="headerlink" title="块级作用域与函数声明"></a>块级作用域与函数声明</h4><p>函数能不能在块级作用域之中声明？这是一个相当令人混淆的问题。</p>
<p>ES5 规定，函数只能在顶层作用域和函数作用域之中声明，不能在块级作用域声明。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 情况一</span></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 情况二</span></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span><span class="params">()</span> </span>&#123;&#125;</span><br><span class="line">&#125; <span class="keyword">catch</span>(e) &#123;</span><br><span class="line">  <span class="comment">// ...</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面两种函数声明，根据 ES5 的规定都是非法的。</p>
<p>但是，浏览器没有遵守这个规定，为了兼容以前的旧代码，还是支持在块级作用域之中声明函数，因此上面两种情况实际都能运行，不会报错。</p>
<p>ES6 引入了块级作用域，明确允许在块级作用域之中声明函数。ES6 规定，块级作用域之中，函数声明语句的行为类似于let，在块级作用域之外不可引用。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>上面代码在 ES5 中运行，会得到“I am inside!”，因为在if内声明的函数f会被提升到函数头部，实际运行的代码如下。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// ES5 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">  &#125;</span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br></pre></td></tr></table></figure>
<p>ES6 就完全不一样了，理论上会得到“I am outside!”。因为块级作用域内声明的函数类似于let，对作用域之外没有影响。但是，如果你真的在 ES6 浏览器中运行一下上面的代码，是会报错的，这是为什么呢？</p>
<p>原来，如果改变了块级作用域内声明的函数的处理规则，显然会对老代码产生很大影响。为了减轻因此产生的不兼容问题，ES6 在<a href="http://www.ecma-international.org/ecma-262/6.0/index.html#sec-block-level-function-declarations-web-legacy-compatibility-semantics" target="_blank" rel="noopener">附录B</a>里面规定，浏览器的实现可以不遵守上面的规定，有自己的<a href="http://stackoverflow.com/questions/31419897/what-are-the-precise-semantics-of-block-level-functions-in-es6" target="_blank" rel="noopener">行为方式</a>。</p>
<ul>
<li>允许在块级作用域内声明函数。</li>
<li>函数声明类似于var，即会提升到全局作用域或函数作用域的头部。</li>
<li>同时，函数声明还会提升到所在的块级作用域的头部。</li>
</ul>
<p>注意，上面三条规则只对 ES6 的浏览器实现有效，其他环境的实现不用遵守，还是将块级作用域的函数声明当作let处理。</p>
<p>根据这三条规则，在浏览器的 ES6 环境中，块级作用域内声明的函数，行为类似于var声明的变量。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line"></span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="comment">// 重复声明一次函数f</span></span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>
<p>上面的代码在符合 ES6 的浏览器中，都会报错，因为实际运行的是下面的代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 浏览器的 ES6 环境</span></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am outside!'</span>); &#125;</span><br><span class="line">(<span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> f = <span class="literal">undefined</span>;</span><br><span class="line">  <span class="keyword">if</span> (<span class="literal">false</span>) &#123;</span><br><span class="line">    <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123; <span class="built_in">console</span>.log(<span class="string">'I am inside!'</span>); &#125;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  f();</span><br><span class="line">&#125;());</span><br><span class="line"><span class="comment">// Uncaught TypeError: f is not a function</span></span><br></pre></td></tr></table></figure>
<p>考虑到环境导致的行为差异太大，应该避免在块级作用域内声明函数。如果确实需要，也应该写成函数表达式，而不是函数声明语句。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 函数声明语句</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 函数表达式</span></span><br><span class="line">&#123;</span><br><span class="line">  <span class="keyword">let</span> a = <span class="string">'secret'</span>;</span><br><span class="line">  <span class="keyword">let</span> f = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> a;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>另外，还有一个需要注意的地方。ES6 的块级作用域允许声明函数的规则，只在使用大括号的情况下成立，如果没有使用大括号，就会报错。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 不报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 报错</span></span><br><span class="line"><span class="meta">'use strict'</span>;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>)</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">f</span>(<span class="params"></span>) </span>&#123;&#125;</span><br></pre></td></tr></table></figure>
<h3 id="3-const命令"><a href="#3-const命令" class="headerlink" title="3.const命令"></a>3.const命令</h3><h4 id="基本用法-1"><a href="#基本用法-1" class="headerlink" title="基本用法"></a>基本用法</h4><p>const声明一个只读的常量。一旦声明，常量的值就不能改变。</p>
<figure class="highlight lsl"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">const <span class="literal">PI</span> = <span class="number">3.1415</span>;</span><br><span class="line"><span class="literal">PI</span> <span class="comment">// 3.1415</span></span><br><span class="line"></span><br><span class="line"><span class="literal">PI</span> = <span class="number">3</span>;</span><br><span class="line"><span class="comment">// TypeError: Assignment to constant variable.</span></span><br></pre></td></tr></table></figure>
<p>上面代码表明改变常量的值会报错。</p>
<p>const声明的变量不得改变值，这意味着，const一旦声明变量，就必须立即初始化，不能留到以后赋值。</p>
<figure class="highlight autoit"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo<span class="comment">;</span></span><br><span class="line">// SyntaxError: Missing initializer <span class="keyword">in</span> <span class="keyword">const</span> declaration</span><br></pre></td></tr></table></figure>
<p>上面代码表示，对于const来说，只声明不赋值，就会报错。</p>
<p>const的作用域与let命令相同：只在声明所在的块级作用域内有效。</p>
<figure class="highlight monkey"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="keyword">const</span> <span class="built_in">MAX</span> = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="built_in">MAX</span> // Uncaught ReferenceError: <span class="built_in">MAX</span> is <span class="keyword">not</span> defined</span><br></pre></td></tr></table></figure>
<p>const命令声明的常量也是不提升，同样存在暂时性死区，只能在声明的位置后面使用。</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  console.<span class="keyword">log</span>(<span class="keyword">MAX</span>); <span class="comment">// ReferenceError</span></span><br><span class="line">  const <span class="keyword">MAX</span> = <span class="number">5</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码在常量MAX声明之前就调用，结果报错。</p>
<p>const声明的常量，也与let一样不可重复声明。</p>
<figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> message = <span class="string">"Hello!"</span>;</span><br><span class="line"><span class="keyword">let</span> age = <span class="number">25</span>;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 以下两行都会报错</span></span><br><span class="line"><span class="keyword">const</span> message = <span class="string">"Goodbye!"</span>;</span><br><span class="line"><span class="keyword">const</span> age = <span class="number">30</span>;</span><br></pre></td></tr></table></figure>
<h3 id="本质"><a href="#本质" class="headerlink" title="本质"></a>本质</h3><p>const实际上保证的，并不是变量的值不得改动，而是变量指向的那个内存地址不得改动。对于简单类型的数据（数值、字符串、布尔值），值就保存在变量指向的那个内存地址，因此等同于常量。但对于复合类型的数据（主要是对象和数组），变量指向的内存地址，保存的只是一个指针，const只能保证这个指针是固定的，至于它指向的数据结构是不是可变的，就完全不能控制了。因此，将一个对象声明为常量必须非常小心。</p>
<figure class="highlight stata"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = &#123;&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">// 为 foo 添加一个属性，可以成功</span></span><br><span class="line">foo.<span class="keyword">prop</span> = 123;</span><br><span class="line">foo.<span class="keyword">prop</span> <span class="comment">// 123</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 foo 指向另一个对象，就会报错</span></span><br><span class="line">foo = &#123;&#125;; <span class="comment">// TypeError: "foo" is read-only</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量foo储存的是一个地址，这个地址指向一个对象。不可变的只是这个地址，即不能把foo指向另一个地址，但对象本身是可变的，所以依然可以为其添加新属性。</p>
<p>下面是另一个例子。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> a = [];</span><br><span class="line">a.push(<span class="string">'Hello'</span>); <span class="comment">// 可执行</span></span><br><span class="line">a.length = <span class="number">0</span>;    <span class="comment">// 可执行</span></span><br><span class="line">a = [<span class="string">'Dave'</span>];    <span class="comment">// 报错</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，常量a是一个数组，这个数组本身是可写的，但是如果将另一个数组赋值给a，就会报错。</p>
<p>如果真的想将对象冻结，应该使用Object.freeze方法。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> foo = <span class="built_in">Object</span>.freeze(&#123;&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 常规模式时，下面一行不起作用；</span></span><br><span class="line"><span class="comment">// 严格模式时，该行会报错</span></span><br><span class="line">foo.prop = <span class="number">123</span>;</span><br></pre></td></tr></table></figure>
<p>上面代码中，常量foo指向一个冻结的对象，所以添加新属性不起作用，严格模式时还会报错。</p>
<p>除了将对象本身冻结，对象的属性也应该冻结。下面是一个将对象彻底冻结的函数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> constantize = <span class="function">(<span class="params">obj</span>) =&gt;</span> &#123;</span><br><span class="line">  <span class="built_in">Object</span>.freeze(obj);</span><br><span class="line">  <span class="built_in">Object</span>.keys(obj).forEach( <span class="function">(<span class="params">key, i</span>) =&gt;</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> ( <span class="keyword">typeof</span> obj[key] === <span class="string">'object'</span> ) &#123;</span><br><span class="line">      constantize( obj[key] );</span><br><span class="line">    &#125;</span><br><span class="line">  &#125;);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h4 id="ES6-声明变量的六种方法"><a href="#ES6-声明变量的六种方法" class="headerlink" title="ES6 声明变量的六种方法"></a>ES6 声明变量的六种方法</h4><p>ES5 只有两种声明变量的方法：var命令和function命令。ES6 除了添加let和const命令，后面章节还会提到，另外两种声明变量的方法：import命令和class命令。所以，ES6 一共有 6 种声明变量的方法。</p>
<h3 id="4-顶层对象的属性"><a href="#4-顶层对象的属性" class="headerlink" title="4.顶层对象的属性"></a>4.顶层对象的属性</h3><p>顶层对象，在浏览器环境指的是window对象，在 Node 指的是global对象。ES5 之中，顶层对象的属性与全局变量是等价的。</p>
<figure class="highlight dart"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">window</span>.a = <span class="number">1</span>;</span><br><span class="line">a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line">a = <span class="number">2</span>;</span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 2</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，顶层对象的属性赋值与全局变量的赋值，是同一件事。</p>
<p>顶层对象的属性与全局变量挂钩，被认为是 JavaScript 语言最大的设计败笔之一。这样的设计带来了几个很大的问题，首先是没法在编译时就报出变量未声明的错误，只有运行时才能知道（因为全局变量可能是顶层对象的属性创造的，而属性的创造是动态的）；其次，程序员很容易不知不觉地就创建了全局变量（比如打字出错）；最后，顶层对象的属性是到处可以读写的，这非常不利于模块化编程。另一方面，window对象有实体含义，指的是浏览器的窗口对象，顶层对象是一个有实体含义的对象，也是不合适的。</p>
<p>ES6 为了改变这一点，一方面规定，为了保持兼容性，var命令和function命令声明的全局变量，依旧是顶层对象的属性；另一方面规定，let命令、const命令、class命令声明的全局变量，不属于顶层对象的属性。也就是说，从 ES6 开始，全局变量将逐步与顶层对象的属性脱钩。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> a = <span class="number">1</span>;</span><br><span class="line"><span class="comment">// 如果在 Node 的 REPL 环境，可以写成 global.a</span></span><br><span class="line"><span class="comment">// 或者采用通用方法，写成 this.a</span></span><br><span class="line"><span class="built_in">window</span>.a <span class="comment">// 1</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">let</span> b = <span class="number">1</span>;</span><br><span class="line"><span class="built_in">window</span>.b <span class="comment">// undefined</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，全局变量a由var命令声明，所以它是顶层对象的属性；全局变量b由let命令声明，所以它不是顶层对象的属性，返回undefined。</p>
<h3 id="5-global对象"><a href="#5-global对象" class="headerlink" title="5.global对象"></a>5.global对象</h3><p>ES5 的顶层对象，本身也是一个问题，因为它在各种实现里面是不统一的。</p>
<ul>
<li>浏览器里面，顶层对象是window，但 Node 和 Web Worker 没有window。</li>
<li>浏览器和 Web Worker 里面，self也指向顶层对象，但是 Node 没有self。</li>
<li>Node 里面，顶层对象是global，但其他环境都不支持。</li>
</ul>
<p>同一段代码为了能够在各种环境，都能取到顶层对象，现在一般是使用this变量，但是有局限性。</p>
<ul>
<li>全局环境中，this会返回顶层对象。但是，Node 模块和 ES6 模块中，this返回的是当前模块。</li>
<li>函数里面的this，如果函数不是作为对象的方法运行，而是单纯作为函数运行，this会指向顶层对象。但是，严格模式下，这时this会返回undefined。</li>
<li>不管是严格模式，还是普通模式，new Function(‘return this’)()，总是会返回全局对象。但是，如果浏览器用了 CSP（Content Security Policy，内容安全政策），那么eval、new Function这些方法都可能无法使用。</li>
</ul>
<p>综上所述，很难找到一种方法，可以在所有情况下，都取到顶层对象。下面是两种勉强可以使用的方法。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 方法一</span></span><br><span class="line">(<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span></span><br><span class="line">   ? <span class="built_in">window</span></span><br><span class="line">   : (<span class="keyword">typeof</span> process === <span class="string">'object'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> <span class="built_in">require</span> === <span class="string">'function'</span> &amp;&amp;</span><br><span class="line">      <span class="keyword">typeof</span> global === <span class="string">'object'</span>)</span><br><span class="line">     ? global</span><br><span class="line">     : <span class="keyword">this</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 方法二</span></span><br><span class="line"><span class="keyword">var</span> getGlobal = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> self !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> self; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> <span class="built_in">window</span> !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> <span class="built_in">window</span>; &#125;</span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> global !== <span class="string">'undefined'</span>) &#123; <span class="keyword">return</span> global; &#125;</span><br><span class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'unable to locate global object'</span>);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>现在有一个<a href="https://github.com/tc39/proposal-global" target="_blank" rel="noopener">提案</a>，在语言标准的层面，引入global作为顶层对象。也就是说，在所有环境下，global都是存在的，都可以从它拿到顶层对象。</p>
<p>垫片库system.global模拟了这个提案，可以在所有环境拿到global。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'system.global/shim'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line"><span class="keyword">import</span> shim <span class="keyword">from</span> <span class="string">'system.global/shim'</span>; shim();</span><br></pre></td></tr></table></figure>
<p>上面代码可以保证各种环境里面，global对象都是存在的。</p>
<figure class="highlight oxygene"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// CommonJS 的写法</span></span><br><span class="line"><span class="keyword">var</span> <span class="keyword">global</span> = <span class="keyword">require</span>(<span class="string">'system.global'</span>)();</span><br><span class="line"></span><br><span class="line"><span class="comment">// ES6 模块的写法</span></span><br><span class="line">import getGlobal <span class="keyword">from</span> <span class="string">'system.global'</span>;</span><br><span class="line"><span class="keyword">const</span> <span class="keyword">global</span> = getGlobal();</span><br></pre></td></tr></table></figure>
<p>上面代码将顶层对象放入变量global。</p>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ES6 -- 01.ECMAScript 6 简介]]></title>
      <url>/2018/06/08/ES6/01.ECMAScript/</url>
      <content type="html"><![CDATA[<h2 id="ECMAScript-6-简介"><a href="#ECMAScript-6-简介" class="headerlink" title="ECMAScript 6 简介"></a>ECMAScript 6 简介</h2><p>ECMAScript 6.0（以下简称 ES6）是 JavaScript 语言的下一代标准，已经在 2015 年 6 月正式发布了。它的目标，是使得 JavaScript 语言可以用来编写复杂的大型应用程序，成为企业级开发语言。</p>
<hr>
<h3 id="1-ECMAScript-和-JavaScript-的关系"><a href="#1-ECMAScript-和-JavaScript-的关系" class="headerlink" title="1.ECMAScript 和 JavaScript 的关系"></a>1.ECMAScript 和 JavaScript 的关系</h3><p>一个常见的问题是，ECMAScript 和 JavaScript 到底是什么关系？</p>
<p>要讲清楚这个问题，需要回顾历史。1996 年 11 月，JavaScript 的创造者 Netscape 公司，决定将 JavaScript 提交给标准化组织 ECMA，希望这种语言能够成为国际标准。次年，ECMA 发布 262 号标准文件（ECMA-262）的第一版，规定了浏览器脚本语言的标准，并将这种语言称为 ECMAScript，这个版本就是 1.0 版。</p>
<p>该标准从一开始就是针对 JavaScript 语言制定的，但是之所以不叫 JavaScript，有两个原因。一是商标，Java 是 Sun 公司的商标，根据授权协议，只有 Netscape 公司可以合法地使用 JavaScript 这个名字，且 JavaScript 本身也已经被 Netscape 公司注册为商标。二是想体现这门语言的制定者是 ECMA，不是 Netscape，这样有利于保证这门语言的开放性和中立性。</p>
<p>因此，ECMAScript 和 JavaScript 的关系是，前者是后者的规格，后者是前者的一种实现（另外的 ECMAScript 方言还有 Jscript 和 ActionScript）。日常场合，这两个词是可以互换的。</p>
<h3 id="2-ES6-与-ECMAScript-2015-的关系"><a href="#2-ES6-与-ECMAScript-2015-的关系" class="headerlink" title="2.ES6 与 ECMAScript 2015 的关系"></a>2.ES6 与 ECMAScript 2015 的关系</h3><p>ECMAScript 2015（简称 ES2015）这个词，也是经常可以看到的。它与 ES6 是什么关系呢？</p>
<p>2011 年，ECMAScript 5.1 版发布后，就开始制定 6.0 版了。因此，ES6 这个词的原意，就是指 JavaScript 语言的下一个版本。</p>
<p>但是，因为这个版本引入的语法功能太多，而且制定过程当中，还有很多组织和个人不断提交新功能。事情很快就变得清楚了，不可能在一个版本里面包括所有将要引入的功能。常规的做法是先发布 6.0 版，过一段时间再发 6.1 版，然后是 6.2 版、6.3 版等等。</p>
<p>但是，标准的制定者不想这样做。他们想让标准的升级成为常规流程：任何人在任何时候，都可以向标准委员会提交新语法的提案，然后标准委员会每个月开一次会，评估这些提案是否可以接受，需要哪些改进。如果经过多次会议以后，一个提案足够成熟了，就可以正式进入标准了。这就是说，标准的版本升级成为了一个不断滚动的流程，每个月都会有变动。</p>
<p>标准委员会最终决定，标准在每年的 6 月份正式发布一次，作为当年的正式版本。接下来的时间，就在这个版本的基础上做改动，直到下一年的 6 月份，草案就自然变成了新一年的版本。这样一来，就不需要以前的版本号了，只要用年份标记就可以了。</p>
<p>ES6 的第一个版本，就这样在 2015 年 6 月发布了，正式名称就是《ECMAScript 2015 标准》（简称 ES2015）。2016 年 6 月，小幅修订的《ECMAScript 2016 标准》（简称 ES2016）如期发布，这个版本可以看作是 ES6.1 版，因为两者的差异非常小（只新增了数组实例的includes方法和指数运算符），基本上是同一个标准。根据计划，2017 年 6 月发布 ES2017 标准。</p>
<p>因此，ES6 既是一个历史名词，也是一个泛指，含义是 5.1 版以后的 JavaScript 的下一代标准，涵盖了 ES2015、ES2016、ES2017 等等，而 ES2015 则是正式名称，特指该年发布的正式版本的语言标准。本书中提到 ES6 的地方，一般是指 ES2015 标准，但有时也是泛指“下一代 JavaScript 语言”。</p>
<h3 id="3-语法提案的批准流程"><a href="#3-语法提案的批准流程" class="headerlink" title="3.语法提案的批准流程"></a>3.语法提案的批准流程</h3><p>任何人都可以向标准委员会（又称 TC39 委员会）提案，要求修改语言标准。</p>
<p>一种新的语法从提案到变成正式标准，需要经历五个阶段。每个阶段的变动都需要由 TC39 委员会批准。</p>
<ul>
<li>Stage 0 - Strawman（展示阶段）</li>
<li>Stage 1 - Proposal（征求意见阶段）</li>
<li>Stage 2 - Draft（草案阶段）</li>
<li>Stage 3 - Candidate（候选人阶段）</li>
<li>Stage 4 - Finished（定案阶段）</li>
</ul>
<p>一个提案只要能进入 Stage 2，就差不多肯定会包括在以后的正式标准里面。ECMAScript 当前的所有提案，可以在 TC39 的官方网站<a href="https://github.com/tc39/ecma262" target="_blank" rel="noopener">Github.com/tc39/ecma262</a>查看。</p>
<p>本书的写作目标之一，是跟踪 ECMAScript 语言的最新进展，介绍 5.1 版本以后所有的新语法。对于那些明确或很有希望，将要列入标准的新语法，都将予以介绍。</p>
<h3 id="4-ECMAScript-的历史"><a href="#4-ECMAScript-的历史" class="headerlink" title="4.ECMAScript 的历史"></a>4.ECMAScript 的历史</h3><p>ES6 从开始制定到最后发布，整整用了 15 年。</p>
<p>前面提到，ECMAScript 1.0 是 1997 年发布的，接下来的两年，连续发布了 ECMAScript 2.0（1998 年 6 月）和 ECMAScript 3.0（1999 年 12 月）。3.0 版是一个巨大的成功，在业界得到广泛支持，成为通行标准，奠定了 JavaScript 语言的基本语法，以后的版本完全继承。直到今天，初学者一开始学习 JavaScript，其实就是在学 3.0 版的语法。</p>
<p>2000 年，ECMAScript 4.0 开始酝酿。这个版本最后没有通过，但是它的大部分内容被 ES6 继承了。因此，ES6 制定的起点其实是 2000 年。</p>
<p>为什么 ES4 没有通过呢？因为这个版本太激进了，对 ES3 做了彻底升级，导致标准委员会的一些成员不愿意接受。ECMA 的第 39 号技术专家委员会（Technical Committee 39，简称 TC39）负责制订 ECMAScript 标准，成员包括 Microsoft、Mozilla、Google 等大公司。</p>
<p>2007 年 10 月，ECMAScript 4.0 版草案发布，本来预计次年 8 月发布正式版本。但是，各方对于是否通过这个标准，发生了严重分歧。以 Yahoo、Microsoft、Google 为首的大公司，反对 JavaScript 的大幅升级，主张小幅改动；以 JavaScript 创造者 Brendan Eich 为首的 Mozilla 公司，则坚持当前的草案。</p>
<p>2008 年 7 月，由于对于下一个版本应该包括哪些功能，各方分歧太大，争论过于激烈，ECMA 开会决定，中止 ECMAScript 4.0 的开发，将其中涉及现有功能改善的一小部分，发布为 ECMAScript 3.1，而将其他激进的设想扩大范围，放入以后的版本，由于会议的气氛，该版本的项目代号起名为 Harmony（和谐）。会后不久，ECMAScript 3.1 就改名为 ECMAScript 5。</p>
<p>2009 年 12 月，ECMAScript 5.0 版正式发布。Harmony 项目则一分为二，一些较为可行的设想定名为 JavaScript.next 继续开发，后来演变成 ECMAScript 6；一些不是很成熟的设想，则被视为 JavaScript.next.next，在更远的将来再考虑推出。TC39 委员会的总体考虑是，ES5 与 ES3 基本保持兼容，较大的语法修正和新功能加入，将由 JavaScript.next 完成。当时，JavaScript.next 指的是 ES6，第六版发布以后，就指 ES7。TC39 的判断是，ES5 会在 2013 年的年中成为 JavaScript 开发的主流标准，并在此后五年中一直保持这个位置。</p>
<p>2011 年 6 月，ECMAscript 5.1 版发布，并且成为 ISO 国际标准（ISO/IEC 16262:2011）。</p>
<p>2013 年 3 月，ECMAScript 6 草案冻结，不再添加新功能。新的功能设想将被放到 ECMAScript 7。</p>
<p>2013 年 12 月，ECMAScript 6 草案发布。然后是 12 个月的讨论期，听取各方反馈。</p>
<p>2015 年 6 月，ECMAScript 6 正式通过，成为国际标准。从 2000 年算起，这时已经过去了 15 年。</p>
<h3 id="5-部署进度"><a href="#5-部署进度" class="headerlink" title="5.部署进度"></a>5.部署进度</h3><p>各大浏览器的最新版本，对 ES6 的支持可以查看<a href="https://kangax.github.io/es5-compat-table/es6/" target="_blank" rel="noopener">kangax.github.io/es5-compat-table/es6/</a>。随着时间的推移，支持度已经越来越高了，超过 90%的 ES6 语法特性都实现了。</p>
<p>Node 是 JavaScript 的服务器运行环境（runtime）。它对 ES6 的支持度更高。除了那些默认打开的功能，还有一些语法功能已经实现了，但是默认没有打开。使用下面的命令，可以查看 Node 已经实现的 ES6 特性。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ node --v8-options | grep harmony</span><br></pre></td></tr></table></figure>
<p>上面命令的输出结果，会因为版本的不同而有所不同。</p>
<h3 id="6-Babel-转码器"><a href="#6-Babel-转码器" class="headerlink" title="6.Babel 转码器"></a>6.Babel 转码器</h3><p>Babel 是一个广泛使用的 ES6 转码器，可以将 ES6 代码转为 ES5 代码，从而在现有环境执行。这意味着，你可以用 ES6 的方式编写程序，又不用担心现有环境是否支持。下面是一个例子。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 转码前</span></span><br><span class="line">input.map(<span class="function"><span class="params">item</span> =&gt;</span> item + <span class="number">1</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 转码后</span></span><br><span class="line">input.map(<span class="function"><span class="keyword">function</span> (<span class="params">item</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> item + <span class="number">1</span>;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>上面的原始代码用了箭头函数，Babel 将其转为普通函数，就能在不支持箭头函数的 JavaScript 环境执行了。</p>
<h4 id="配置文件-babelrc"><a href="#配置文件-babelrc" class="headerlink" title="配置文件.babelrc"></a>配置文件.babelrc</h4><p>Babel 的配置文件是.babelrc，存放在项目的根目录下。使用 Babel 的第一步，就是配置这个文件。</p>
<p>该文件用来设置转码规则和插件，基本格式如下。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"presets"</span>: [],</span><br><span class="line">  <span class="attr">"plugins"</span>: []</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>presets字段设定转码规则，官方提供以下的规则集，你可以根据需要安装。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 最新转码规则</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install --save-dev babel-preset-latest</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> react 转码规则</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install --save-dev babel-preset-react</span></span><br><span class="line"></span><br><span class="line"><span class="meta">#</span><span class="bash"> 不同阶段语法提案的转码规则（共有4个阶段），选装一个</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install --save-dev babel-preset-stage-0</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install --save-dev babel-preset-stage-1</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install --save-dev babel-preset-stage-2</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install --save-dev babel-preset-stage-3</span></span><br></pre></td></tr></table></figure>
<p>然后，将这些规则加入.babelrc。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">   <span class="attr">"presets"</span>: [</span><br><span class="line">     <span class="string">"latest"</span>,</span><br><span class="line">     <span class="string">"react"</span>,</span><br><span class="line">     <span class="string">"stage-2"</span></span><br><span class="line">   ],</span><br><span class="line">   <span class="attr">"plugins"</span>: []</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>注意，以下所有 Babel 工具和模块的使用，都必须先写好.babelrc。</p>
<h4 id="命令行转码babel-cli"><a href="#命令行转码babel-cli" class="headerlink" title="命令行转码babel-cli"></a>命令行转码babel-cli</h4><p>Babel 提供babel-cli工具，用于命令行转码。</p>
<p>它的安装命令如下。</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ <span class="built_in">npm</span> install --<span class="built_in">global</span> babel-cli</span><br></pre></td></tr></table></figure>
<p>基本用法如下。</p>
<figure class="highlight crystal"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment"># 转码结果输出到标准输出</span></span><br><span class="line">$ babel example.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 转码结果写入一个文件</span></span><br><span class="line"><span class="comment"># --out-file 或 -o 参数指定输出文件</span></span><br><span class="line">$ babel example.js --<span class="keyword">out</span>-file compiled.js</span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ babel example.js -o compiled.js</span><br><span class="line"></span><br><span class="line"><span class="comment"># 整个目录转码</span></span><br><span class="line"><span class="comment"># --out-dir 或 -d 参数指定输出目录</span></span><br><span class="line">$ babel src --<span class="keyword">out</span>-dir <span class="class"><span class="keyword">lib</span></span></span><br><span class="line"><span class="comment"># 或者</span></span><br><span class="line">$ babel src -d <span class="class"><span class="keyword">lib</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment"># -s 参数生成source map文件</span></span><br><span class="line">$ babel src -d <span class="class"><span class="keyword">lib</span> -<span class="title">s</span></span></span><br></pre></td></tr></table></figure>
<p>上面代码是在全局环境下，进行 Babel 转码。这意味着，如果项目要运行，全局环境必须有 Babel，也就是说项目产生了对环境的依赖。另一方面，这样做也无法支持不同项目使用不同版本的 Babel。</p>
<p>一个解决办法是将babel-cli安装在项目之中。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#</span><span class="bash"> 安装</span></span><br><span class="line"><span class="meta">$</span><span class="bash"> npm install --save-dev babel-cli</span></span><br></pre></td></tr></table></figure>
<p>然后，改写package.json。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  // ...</span><br><span class="line">  <span class="string">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="string">"babel-cli"</span>: <span class="string">"^6.0.0"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="string">"scripts"</span>: &#123;</span><br><span class="line">    <span class="string">"build"</span>: <span class="string">"babel src -d lib"</span></span><br><span class="line">  &#125;,</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>转码的时候，就执行下面的命令。</p>
<figure class="highlight dockerfile"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">run</span><span class="bash"> build</span></span><br></pre></td></tr></table></figure>
<h4 id="babel-node"><a href="#babel-node" class="headerlink" title="babel-node"></a>babel-node</h4><p>babel-cli工具自带一个babel-node命令，提供一个支持 ES6 的 REPL 环境。它支持 Node 的 REPL 环境的所有功能，而且可以直接运行 ES6 代码。</p>
<p>它不用单独安装，而是随babel-cli一起安装。然后，执行babel-node就进入 REPL 环境。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ babel-<span class="keyword">node</span><span class="title"></span></span><br><span class="line"><span class="title">&gt; (x</span> =&gt; x * <span class="number">2</span>)(<span class="number">1</span>)</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>babel-node命令可以直接运行 ES6 脚本。将上面的代码放入脚本文件es6.js，然后直接运行。</p>
<figure class="highlight crmsh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$ babel-<span class="keyword">node</span> <span class="title">es6</span>.js</span><br><span class="line"><span class="number">2</span></span><br></pre></td></tr></table></figure>
<p>babel-node也可以安装在项目中。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> babel-cli</span><br></pre></td></tr></table></figure>
<p>然后，改写package.json。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"script-name"</span>: <span class="string">"babel-node script.js"</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面代码中，使用babel-node替代node，这样script.js本身就不用做任何转码处理。</p>
<h4 id="babel-register"><a href="#babel-register" class="headerlink" title="babel-register"></a>babel-register</h4><p>babel-register模块改写require命令，为它加上一个钩子。此后，每当使用require加载.js、.jsx、.es和.es6后缀名的文件，就会先用 Babel 进行转码。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> babel-register</span><br></pre></td></tr></table></figure>
<p>使用时，必须首先加载babel-register。</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">require(<span class="string">"babel-register"</span>)<span class="comment">;</span></span><br><span class="line">require(<span class="string">"./index.js"</span>)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>然后，就不需要手动对index.js转码了。</p>
<p>需要注意的是，babel-register只会对require命令加载的文件转码，而不会对当前文件转码。另外，由于它是实时转码，所以只适合在开发环境使用。</p>
<h4 id="babel-core"><a href="#babel-core" class="headerlink" title="babel-core"></a>babel-core</h4><p>如果某些代码需要调用 Babel 的 API 进行转码，就要使用babel-core模块。</p>
<p>安装命令如下。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install </span><span class="keyword">babel-core </span>--save</span><br></pre></td></tr></table></figure>
<p>然后，在项目中就可以调用babel-core。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> babel = <span class="built_in">require</span>(<span class="string">'babel-core'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 字符串转码</span></span><br><span class="line">babel.transform(<span class="string">'code();'</span>, options);</span><br><span class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件转码（异步）</span></span><br><span class="line">babel.transformFile(<span class="string">'filename.js'</span>, options, <span class="function"><span class="keyword">function</span>(<span class="params">err, result</span>) </span>&#123;</span><br><span class="line">  result; <span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 文件转码（同步）</span></span><br><span class="line">babel.transformFileSync(<span class="string">'filename.js'</span>, options);</span><br><span class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Babel AST转码</span></span><br><span class="line">babel.transformFromAst(ast, code, options);</span><br><span class="line"><span class="comment">// =&gt; &#123; code, map, ast &#125;</span></span><br></pre></td></tr></table></figure>
<p>配置对象options，可以参看官方文档<a href="http://babeljs.io/docs/usage/options/" target="_blank" rel="noopener">http://babeljs.io/docs/usage/options/</a>。</p>
<p>下面是一个例子。</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">var es6Code = <span class="symbol">'let</span> x = n =&gt; n + <span class="number">1</span>';</span><br><span class="line">var es5Code = require(<span class="symbol">'babel</span>-core')</span><br><span class="line">  .transform(es6Code, &#123;</span><br><span class="line">    presets: [<span class="symbol">'latest</span>']</span><br><span class="line">  &#125;)</span><br><span class="line">  .code;</span><br><span class="line">// '<span class="string">"use strict"</span>;\n\nvar x = <span class="keyword">function</span> <span class="title">x</span>(n) &#123;\n  <span class="keyword">return</span> <span class="type">n</span> + <span class="number">1</span>;\n&#125;;'</span><br></pre></td></tr></table></figure>
<p>上面代码中，transform方法的第一个参数是一个字符串，表示需要被转换的 ES6 代码，第二个参数是转换的配置对象。</p>
<h4 id="babel-polyfill"><a href="#babel-polyfill" class="headerlink" title="babel-polyfill"></a>babel-polyfill</h4><p>Babel 默认只转换新的 JavaScript 句法（syntax），而不转换新的 API，比如Iterator、Generator、Set、Maps、Proxy、Reflect、Symbol、Promise等全局对象，以及一些定义在全局对象上的方法（比如Object.assign）都不会转码。</p>
<p>举例来说，ES6 在Array对象上新增了Array.from方法。Babel 就不会转码这个方法。如果想让这个方法运行，必须使用babel-polyfill，为当前环境提供一个垫片。</p>
<p>安装命令如下。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install --save babel-polyfill</span></span><br></pre></td></tr></table></figure>
<p>然后，在脚本头部，加入如下一行代码。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> <span class="string">'babel-polyfill'</span>;</span><br><span class="line"><span class="comment">// 或者</span></span><br><span class="line"><span class="built_in">require</span>(<span class="string">'babel-polyfill'</span>);</span><br></pre></td></tr></table></figure>
<p>Babel 默认不转码的 API 非常多，详细清单可以查看babel-plugin-transform-runtime模块的<a href="https://github.com/babel/babel/blob/master/packages/babel-plugin-transform-runtime/src/definitions.js" target="_blank" rel="noopener">definitions.js</a>文件。</p>
<h4 id="浏览器环境"><a href="#浏览器环境" class="headerlink" title="浏览器环境"></a>浏览器环境</h4><p>Babel 也可以用于浏览器环境。但是，从 Babel 6.0 开始，不再直接提供浏览器版本，而是要用构建工具构建出来。如果你没有或不想使用构建工具，可以使用babel-standalone模块提供的浏览器版本，将其插入网页。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://cdnjs.cloudflare.com/ajax/libs/babel-standalone/6.4.4/babel.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"text/babel"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript"><span class="comment">// Your ES6 code</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>注意，网页实时将 ES6 代码转为 ES5，对性能会有影响。生产环境需要加载已经转码完成的脚本。</p>
<p>下面是如何将代码打包成浏览器可以使用的脚本，以Babel配合Browserify为例。首先，安装babelify模块。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm <span class="keyword">install </span>--save-dev <span class="keyword">babelify </span><span class="keyword">babel-preset-latest</span></span><br></pre></td></tr></table></figure>
<p>然后，再用命令行转换 ES6 脚本。</p>
<figure class="highlight mipsasm"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">$  <span class="keyword">browserify </span><span class="keyword">script.js </span>-o <span class="keyword">bundle.js </span>\</span><br><span class="line">  -t [ <span class="keyword">babelify </span>--presets [ latest ] ]</span><br></pre></td></tr></table></figure>
<p>上面代码将 ES6 脚本script.js，转为bundle.js，浏览器直接加载后者就可以了。</p>
<p>在package.json设置下面的代码，就不用每次命令行都输入参数了。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"browserify"</span>: &#123;</span><br><span class="line">    <span class="attr">"transform"</span>: [[<span class="string">"babelify"</span>, &#123; <span class="attr">"presets"</span>: [<span class="string">"latest"</span>] &#125;]]</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h4 id="在线转换"><a href="#在线转换" class="headerlink" title="在线转换"></a>在线转换</h4><p>Babel 提供一个<a href="https://babeljs.io/repl/" target="_blank" rel="noopener">REPL 在线编译器</a>，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
<h4 id="与其他工具的配合"><a href="#与其他工具的配合" class="headerlink" title="与其他工具的配合"></a>与其他工具的配合</h4><p>许多工具需要 Babel 进行前置转码，这里举两个例子：ESLint 和 Mocha。</p>
<p>ESLint 用于静态检查代码的语法和风格，安装命令如下。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ npm install --<span class="built_in">save</span>-<span class="built_in">dev</span> eslint babel-eslint</span><br></pre></td></tr></table></figure>
<p>然后，在项目根目录下，新建一个配置文件.eslintrc，在其中加入parser字段。</p>
<figure class="highlight clojure"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="string">"parser"</span>: <span class="string">"babel-eslint"</span>,</span><br><span class="line">  <span class="string">"rules"</span>: &#123;</span><br><span class="line">    ...</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>再在package.json之中，加入相应的scripts脚本。</p>
<figure class="highlight json"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">&#123;</span><br><span class="line">  <span class="attr">"name"</span>: <span class="string">"my-module"</span>,</span><br><span class="line">  <span class="attr">"scripts"</span>: &#123;</span><br><span class="line">    <span class="attr">"lint"</span>: <span class="string">"eslint my-files.js"</span></span><br><span class="line">  &#125;,</span><br><span class="line">  <span class="attr">"devDependencies"</span>: &#123;</span><br><span class="line">    <span class="attr">"babel-eslint"</span>: <span class="string">"..."</span>,</span><br><span class="line">    <span class="attr">"eslint"</span>: <span class="string">"..."</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Mocha 则是一个测试框架，如果需要执行使用 ES6 语法的测试脚本，可以修改package.json的scripts.test。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">"scripts"</span>: &#123;</span><br><span class="line">  <span class="string">"test"</span>: <span class="string">"mocha --ui qunit --compilers js:babel-core/register"</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>上面命令中，–compilers参数指定脚本的转码器，规定后缀名为js的文件，都需要使用babel-core/register先转码。</p>
<h3 id="7-Traceur-转码器"><a href="#7-Traceur-转码器" class="headerlink" title="7.Traceur 转码器"></a>7.Traceur 转码器</h3><p>Google 公司的<a href="https://github.com/google/traceur-compiler" target="_blank" rel="noopener">Traceur</a>转码器，也可以将 ES6 代码转为 ES5 代码。</p>
<h4 id="直接插入网页"><a href="#直接插入网页" class="headerlink" title="直接插入网页"></a>直接插入网页</h4><p>Traceur 允许将 ES6 代码直接插入网页。首先，必须在网页头部加载 Traceur 库文件。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://google.github.io/traceur-compiler/bin/traceur.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://google.github.io/traceur-compiler/bin/BrowserSystem.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://google.github.io/traceur-compiler/src/bootstrap.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  <span class="meta"><span class="meta-keyword">import</span> './Greeter.js';</span></span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，一共有 4 个script标签。第一个是加载 Traceur 的库文件，第二个和第三个是将这个库文件用于浏览器环境，第四个则是加载用户脚本，这个脚本里面可以使用 ES6 代码。</p>
<p>注意，第四个script标签的type属性的值是module，而不是text/javascript。这是 Traceur 编译器识别 ES6 代码的标志，编译器会自动将所有type=module的代码编译为 ES5，然后再交给浏览器执行。</p>
<p>除了引用外部 ES6 脚本，也可以直接在网页中放置 ES6 代码。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">type</span>=<span class="string">"module"</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  <span class="class"><span class="keyword">class</span> <span class="title">Calc</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="keyword">constructor</span>() &#123;</span></span><br><span class="line"><span class="javascript">      <span class="built_in">console</span>.log(<span class="string">'Calc constructor'</span>);</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">    add(a, b) &#123;</span></span><br><span class="line"><span class="actionscript">      <span class="keyword">return</span> a + b;</span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> c = <span class="keyword">new</span> Calc();</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(c.add(<span class="number">4</span>,<span class="number">5</span>));</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>正常情况下，上面代码会在控制台打印出9。</p>
<p>如果想对 Traceur 的行为有精确控制，可以采用下面参数配置的写法。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  <span class="comment">// Create the System object</span></span></span><br><span class="line"><span class="javascript">  <span class="built_in">window</span>.System = <span class="keyword">new</span> traceur.runtime.BrowserTraceurLoader();</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// Set some experimental options</span></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> metadata = &#123;</span></span><br><span class="line"><span class="undefined">    traceurOptions: &#123;</span></span><br><span class="line"><span class="actionscript">      experimental: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      properTailCalls: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      symbols: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      arrayComprehension: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      asyncFunctions: <span class="literal">true</span>,</span></span><br><span class="line"><span class="undefined">      asyncGenerators: exponentiation,</span></span><br><span class="line"><span class="actionscript">      forOn: <span class="literal">true</span>,</span></span><br><span class="line"><span class="actionscript">      generatorComprehension: <span class="literal">true</span></span></span><br><span class="line"><span class="undefined">    &#125;</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="actionscript">  <span class="comment">// Load your module</span></span></span><br><span class="line"><span class="actionscript">  System.import(<span class="string">'./myModule.js'</span>, &#123;metadata: metadata&#125;).catch(<span class="function"><span class="keyword">function</span><span class="params">(ex)</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.error(<span class="string">'Import failed'</span>, ex.stack || ex);</span></span><br><span class="line"><span class="undefined">  &#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>上面代码中，首先生成 Traceur 的全局对象window.System，然后System.import方法可以用来加载 ES6。加载的时候，需要传入一个配置对象metadata，该对象的traceurOptions属性可以配置支持 ES6 功能。如果设为experimental: true，就表示除了 ES6 以外，还支持一些实验性的新功能。</p>
<h4 id="在线转换-1"><a href="#在线转换-1" class="headerlink" title="在线转换"></a>在线转换</h4><p>Traceur 也提供一个<a href="http://google.github.io/traceur-compiler/demo/repl.html" target="_blank" rel="noopener">在线编译器</a>，可以在线将 ES6 代码转为 ES5 代码。转换后的代码，可以直接作为 ES5 代码插入网页运行。</p>
<p>上面的例子转为 ES5 代码运行，就是下面这个样子。</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://google.github.io/traceur-compiler/bin/traceur.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://google.github.io/traceur-compiler/bin/BrowserSystem.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">"https://google.github.io/traceur-compiler/src/bootstrap.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="actionscript">$traceurRuntime.ModuleStore.getAnonymousModule(<span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript"><span class="meta">  "use strict"</span>;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> Calc = <span class="function"><span class="keyword">function</span> <span class="title">Calc</span><span class="params">()</span> </span>&#123;</span></span><br><span class="line"><span class="javascript">    <span class="built_in">console</span>.log(<span class="string">'Calc constructor'</span>);</span></span><br><span class="line"><span class="undefined">  &#125;;</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  ($traceurRuntime.createClass)(Calc, &#123;add: <span class="function"><span class="keyword">function</span><span class="params">(a, b)</span> </span>&#123;</span></span><br><span class="line"><span class="actionscript">    <span class="keyword">return</span> a + b;</span></span><br><span class="line"><span class="undefined">  &#125;&#125;, &#123;&#125;);</span></span><br><span class="line"><span class="undefined"></span></span><br><span class="line"><span class="actionscript">  <span class="keyword">var</span> c = <span class="keyword">new</span> Calc();</span></span><br><span class="line"><span class="javascript">  <span class="built_in">console</span>.log(c.add(<span class="number">4</span>, <span class="number">5</span>));</span></span><br><span class="line"><span class="actionscript">  <span class="keyword">return</span> &#123;&#125;;</span></span><br><span class="line"><span class="undefined">&#125;);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<h4 id="命令行转换"><a href="#命令行转换" class="headerlink" title="命令行转换"></a>命令行转换</h4><p>作为命令行工具使用时，Traceur 是一个 Node 的模块，首先需要用 npm 安装。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">$</span><span class="bash"> npm install -g traceur</span></span><br></pre></td></tr></table></figure>
<p>安装成功后，就可以在命令行下使用 Traceur 了。</p>
<p>Traceur 直接运行 ES6 脚本文件，会在标准输出显示运行结果，以前面的calc.js为例。</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">$ traceur calc.js</span><br><span class="line">Calc <span class="function"><span class="keyword">constructor</span></span></span><br><span class="line"><span class="function">9</span></span><br></pre></td></tr></table></figure>
<p>如果要将 ES6 脚本转为 ES5 保存，要采用下面的写法。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ traceur --script calc<span class="selector-class">.es6</span><span class="selector-class">.js</span> --out calc<span class="selector-class">.es5</span><span class="selector-class">.js</span></span><br></pre></td></tr></table></figure>
<p>上面代码的–script选项表示指定输入文件，–out选项表示指定输出文件。</p>
<p>为了防止有些特性编译不成功，最好加上–experimental选项。</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">$ traceur --script calc<span class="selector-class">.es6</span><span class="selector-class">.js</span> --out calc<span class="selector-class">.es5</span><span class="selector-class">.js</span> --experimental</span><br></pre></td></tr></table></figure>
<p>命令行下转换生成的文件，就可以直接放到浏览器中运行。</p>
<h4 id="Node-环境的用法"><a href="#Node-环境的用法" class="headerlink" title="Node 环境的用法"></a>Node 环境的用法</h4><p>Traceur 的 Node 用法如下（假定已安装traceur模块）。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> traceur = <span class="built_in">require</span>(<span class="string">'traceur'</span>);</span><br><span class="line"><span class="keyword">var</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</span><br><span class="line"></span><br><span class="line"><span class="comment">// 将 ES6 脚本转为字符串</span></span><br><span class="line"><span class="keyword">var</span> contents = fs.readFileSync(<span class="string">'es6-file.js'</span>).toString();</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> result = traceur.compile(contents, &#123;</span><br><span class="line">  filename: <span class="string">'es6-file.js'</span>,</span><br><span class="line">  sourceMap: <span class="literal">true</span>,</span><br><span class="line">  <span class="comment">// 其他设置</span></span><br><span class="line">  modules: <span class="string">'commonjs'</span></span><br><span class="line">&#125;);</span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (result.error)</span><br><span class="line">  <span class="keyword">throw</span> result.error;</span><br><span class="line"></span><br><span class="line"><span class="comment">// result 对象的 js 属性就是转换后的 ES5 代码</span></span><br><span class="line">fs.writeFileSync(<span class="string">'out.js'</span>, result.js);</span><br><span class="line"><span class="comment">// sourceMap 属性对应 map 文件</span></span><br><span class="line">fs.writeFileSync(<span class="string">'out.js.map'</span>, result.sourceMap);</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> ES6 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> ES6 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 06.Handling Events]]></title>
      <url>/2018/05/11/react/02.Quick_Start/06.Handling_Events/</url>
      <content type="html"><![CDATA[<h2 id="Handling-Events-处理事件"><a href="#Handling-Events-处理事件" class="headerlink" title="Handling Events(处理事件)"></a>Handling Events(处理事件)</h2><p>Handling events with React elements is very similar to handling events on DOM elements. There are some syntactic differences:</p>
<p>用React元素处理事件与在DOM元素上处理事件非常相似。这里有一些语法不同：</p>
<ul>
<li>React events are named using camelCase, rather than lowercase.</li>
<li>With JSX you pass a function as the event handler, rather than a string.</li>
</ul>
<hr>
<ul>
<li>React事件使用驼峰命名法，而不是小写字母命名法。</li>
<li>使用JSX作为您函数事件处理的参数，而不是字符串。</li>
</ul>
<p>For example, the HTML:</p>
<p>例如，HTML：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&lt;button onclick=<span class="string">"activateLasers()"</span>&gt;</span><br><span class="line">  Activate Lasers</span><br><span class="line">&lt;<span class="regexp">/button&gt;</span></span><br></pre></td></tr></table></figure>
<p>is slightly different in React:</p>
<p>在React中有点不同：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">button</span> <span class="attr">onClick</span>=<span class="string">&#123;activateLasers&#125;</span>&gt;</span></span><br><span class="line">  Activate Lasers</span><br><span class="line"><span class="tag">&lt;/<span class="name">button</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Another difference is that you cannot return false to prevent default behavior in React. You must call preventDefault explicitly. For example, with plain HTML, to prevent the default link behavior of opening a new page, you can write:</p>
<p>另一个不同是您不能返回false来阻止React中的默认事件。您必须明确地调用preventDefault。例如，在HTML代码中，为了阻止默认点击事件，打开一个新的页面的表现，您可以这么写：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">a</span> <span class="attr">href</span>=<span class="string">"#"</span> <span class="attr">onclick</span>=<span class="string">"console.log('The link was clicked.'); return false"</span>&gt;</span></span><br><span class="line">  Click me</span><br><span class="line"><span class="tag">&lt;/<span class="name">a</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>In React, this could instead be:</p>
<p>在React中，应当是这样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">ActionLink</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">handleClick</span>(<span class="params">e</span>) </span>&#123;</span><br><span class="line">    e.preventDefault();</span><br><span class="line">    <span class="built_in">console</span>.log(<span class="string">'The link was clicked.'</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;a href=<span class="string">"#"</span> onClick=&#123;handleClick&#125;&gt;</span><br><span class="line">      Click me</span><br><span class="line">    &lt;<span class="regexp">/a&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Here, e is a synthetic event. React defines these synthetic events according to the <a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C spec</a>, so you don’t need to worry about cross-browser compatibility. See the <a href="https://reactjs.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent</a> reference guide to learn more.</p>
<p>这里，e代表了一个事件。React根据<a href="https://www.w3.org/TR/DOM-Level-3-Events/" target="_blank" rel="noopener">W3C</a>规范定义了这些事件，因此您不必担心跨浏览器兼容性。 请参阅<a href="https://reactjs.org/docs/events.html" target="_blank" rel="noopener">SyntheticEvent</a>参考指南以了解更多信息。</p>
<p>When using React you should generally not need to call addEventListener to add listeners to a DOM element after it is created. Instead, just provide a listener when the element is initially rendered.</p>
<p>在使用React时，通常不需要调用addEventListener在创建DOM元素后向其添加监听器。相反，只需在元素初始呈现时添加监听器。</p>
<p>When you define a component using an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>, a common pattern is for an event handler to be a method on the class. For example, this Toggle component renders a button that lets the user toggle between “ON” and “OFF” states:</p>
<p>当您使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6的类</a>来定义一个组件时，一个常见的模式是让一个事件处理器成为该类的一个方法。 例如，这个Toggle组件呈现一个按钮，让用户在“ON”和“OFF”状态之间切换：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Toggle</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  constructor(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;isToggleOn: <span class="literal">true</span>&#125;;</span><br><span class="line"></span><br><span class="line">    <span class="comment">// This binding is necessary to make `this` work in the callback</span></span><br><span class="line">    <span class="keyword">this</span>.handleClick = <span class="keyword">this</span>.handleClick.bind(<span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(prevState =&gt; (&#123;</span><br><span class="line">      isToggleOn: !prevState.isToggleOn</span><br><span class="line">    &#125;));</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        &#123;<span class="keyword">this</span>.state.isToggleOn ? <span class="symbol">'O</span>N' : <span class="symbol">'OF</span>F'&#125;</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">ReactDOM</span>.render(</span><br><span class="line">  &lt;<span class="type">Toggle</span> /&gt;,</span><br><span class="line">  document.getElementById(<span class="symbol">'roo</span>t')</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/xEmzGg?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>You have to be careful about the meaning of this in JSX callbacks. In JavaScript, class methods are not <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">bound</a> by default. If you forget to bind this.handleClick and pass it to onClick, this will be undefined when the function is actually called.</p>
<p>您必须在JSX回调中注意这一点的含义。在JavaScript中，类方法默认没有<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">绑定</a>。如果您忘记绑定this.handleClick并将其传递给onClick，则在实际调用该函数时，这将是未定义的。</p>
<p>This is not React-specific behavior; it is a part of how functions work in JavaScript. Generally, if you refer to a method without () after it, such as onClick={this.handleClick}, you should bind that method.</p>
<p>这不是React特定的表现; 在JavaScript中它是函数的一部分。一般来说，如果你在它后面引用一个没有()的方法，比如onClick = {this.handleClick}，你就应该绑定该方法。</p>
<p>If calling bind annoys you, there are two ways you can get around this. If you are using the experimental <a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">public class fields syntax</a>, you can use class fields to correctly bind callbacks:</p>
<p>如果调用bind会让你感到困扰，那么有两种方法可以解决这个问题。 如果您使用的是尝试性的<a href="https://babeljs.io/docs/plugins/transform-class-properties/" target="_blank" rel="noopener">公共类字段语法</a>，则可以使用类字段来正确地绑定回调：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="comment">// This syntax ensures `this` is bound within handleClick.</span></span><br><span class="line">  <span class="comment">// Warning: this is *experimental* syntax.</span></span><br><span class="line">  handleClick = () =&gt; &#123;</span><br><span class="line">    console.log(<span class="symbol">'this</span> is:', <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;<span class="keyword">this</span>.handleClick&#125;&gt;</span><br><span class="line">        <span class="type">Click</span> me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This syntax is enabled by default in <a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>.</p>
<p>这种语法在<a href="https://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a>中是默认启用的。</p>
<p>If you aren’t using class fields syntax, you can use an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow function</a> in the callback:</p>
<p>如果您不使用类字段语法，则可以在回调中使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">LoggingButton</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  handleClick() &#123;</span><br><span class="line">    console.log(<span class="symbol">'this</span> is:', <span class="keyword">this</span>);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="comment">// This syntax ensures `this` is bound within handleClick</span></span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;button onClick=&#123;(e) =&gt; <span class="keyword">this</span>.handleClick(e)&#125;&gt;</span><br><span class="line">        <span class="type">Click</span> me</span><br><span class="line">      &lt;/button&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The problem with this syntax is that a different callback is created each time the LoggingButton renders. In most cases, this is fine. However, if this callback is passed as a prop to lower components, those components might do an extra re-rendering. We generally recommend binding in the constructor or using the class fields syntax, to avoid this sort of performance problem.</p>
<p>这个语法的问题是每次LoggingButton呈现时都会创建一个不同的回调函数。 在大多数情况下，这没有问题。但是，如果将此回调作为参数传递给较低组件，则这些组件可能会重新渲染。我们通常建议在构造函数中绑定或使用类字段语法来避免此类性能问题。</p>
<h3 id="Passing-Arguments-to-Event-Handlers-将参数传递给事件处理程序"><a href="#Passing-Arguments-to-Event-Handlers-将参数传递给事件处理程序" class="headerlink" title="Passing Arguments to Event Handlers(将参数传递给事件处理程序)"></a>Passing Arguments to Event Handlers(将参数传递给事件处理程序)</h3><p>Inside a loop it is common to want to pass an extra parameter to an event handler. For example, if id is the row ID, either of the following would work:</p>
<p>在循环内部，通常需要将一个额外的参数传递给事件处理程序。 例如，如果id是行ID，则以下任一项都可以工作</p>
<figure class="highlight hsp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">button</span> <span class="keyword">onClick</span>=&#123;(e) =&gt; this.deleteRow(id, e)&#125;&gt;<span class="keyword">Delete</span> Row&lt;/<span class="keyword">button</span>&gt;</span><br><span class="line">&lt;<span class="keyword">button</span> <span class="keyword">onClick</span>=&#123;this.deleteRow.bind(this, id)&#125;&gt;<span class="keyword">Delete</span> Row&lt;/<span class="keyword">button</span>&gt;</span><br></pre></td></tr></table></figure>
<p>The above two lines are equivalent, and use <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow functions</a> and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">Function.prototype.bind</a> respectively.</p>
<p>以上两行都是相等的，分别使用了<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_objects/Function/bind" target="_blank" rel="noopener">Function.prototype.bind</a>。</p>
<p>In both cases, the e argument representing the React event will be passed as a second argument after the ID. With an arrow function, we have to pass it explicitly, but with bind any further arguments are automatically forwarded.</p>
<p>在这两种情况下，e参数代表了React事件，并将作为ID之后的第二个参数传递。使用箭头函数，我们必须明确地传递它，但是任何额外的参数都会自动绑定起来，并自动转发。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 05.State and Lifecycle]]></title>
      <url>/2018/05/11/react/02.Quick_Start/05.State_and_Lifecycle/</url>
      <content type="html"><![CDATA[<h2 id="State-and-Lifecycle"><a href="#State-and-Lifecycle" class="headerlink" title="State and Lifecycle"></a>State and Lifecycle</h2><p>Consider the ticking clock example from <a href="https://reactjs.org/docs/rendering-elements.html#updating-the-rendered-element" target="_blank" rel="noopener">one of the previous sections</a>.</p>
<p>考虑在<a href="https://reactjs.org/docs/rendering-elements.html#updating-the-rendered-element" target="_blank" rel="noopener">前几章节</a>中涉及到的秒钟案例。</p>
<p>So far we have only learned one way to update the UI.</p>
<p>直到现在，我们都只学了一种更新UI的方法。</p>
<p>We call ReactDOM.render() to change the rendered output:</p>
<p>我们会调用ReactDOM.render()来更新渲染输出:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    element,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/gwoJZk?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>In this section, we will learn how to make the Clock component truly reusable and encapsulated. It will set up its own timer and update itself every second.</p>
<p>这一章节中，我们将学到如何构建一个真正可复用和封装良好的Clock组件。它每秒都会被重新设置并更新其本身。</p>
<p>We can start by encapsulating how the clock looks:</p>
<p>我们可以简单的构建出钟表最开始的样式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Clock</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;props.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  ReactDOM.render(</span><br><span class="line">    &lt;Clock date=&#123;<span class="keyword">new</span> <span class="built_in">Date</span>()&#125; /&gt;,</span><br><span class="line">    <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/dpdoYR?editors=0010" target="_blank" rel="noopener">Try it on CodePen</a></p>
<p>However, it misses a crucial requirement: the fact that the Clock sets up a timer and updates the UI every second should be an implementation detail of the Clock.</p>
<p>然而，它忘了一个重要的先决条件：事实就是设置一个计时器并每秒都更新UI是Clock本身应该实现的一个细节。</p>
<p>Ideally we want to write this once and have the Clock update itself:</p>
<p>理想情况下，我们只想写一次Clock并由其本身完成更新：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>To implement this, we need to add “state” to the Clock component.</p>
<p>为了实现这个目标，我们应该为Clock组件添加“状态”。</p>
<p>State is similar to props, but it is private and fully controlled by the component.</p>
<p>状态和属性相似，但是它是私密的，并且完全由组件控制。</p>
<p>We <a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">mentioned before</a> that components defined as classes have some additional features. Local state is exactly that: a feature available only to classes.</p>
<p>我们<a href="https://reactjs.org/docs/components-and-props.html#functional-and-class-components" target="_blank" rel="noopener">之前提到</a>，当组件被定义为类时会有一些额外的特性。本地状态就是其中一种：一个只对类有效的特性。</p>
<h3 id="Converting-a-Function-to-a-Class-将一个函数转化为类"><a href="#Converting-a-Function-to-a-Class-将一个函数转化为类" class="headerlink" title="Converting a Function to a Class(将一个函数转化为类)"></a>Converting a Function to a Class(将一个函数转化为类)</h3><p>You can convert a functional component like Clock to a class in five steps:</p>
<p>您可以通过以下五步将一个函数组件转化为类：</p>
<ol>
<li>Create an ES6 class, with the same name, that extends React.Component.</li>
<li>Add a single empty method to it called render().</li>
<li>Move the body of the function into the render() method.</li>
<li>Replace props with this.props in the render() body.</li>
<li>Delete the remaining empty function declaration.</li>
</ol>
<hr>
<ol>
<li>创建一个具有相同名字，由React.Component扩展出来的ES6的类。</li>
<li>添加一个单一的空的方法，并由render()调用。</li>
<li>将函数主体移动到render()方法中。</li>
<li>在render()主体内，用this.props取代props。</li>
<li>删除剩余的空的函数声明。</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.props.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/zKRGpo?editors=001" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Clock is now defined as a class rather than a function.</p>
<p>Clock现在被定义为一个类而不是函数。</p>
<p>This lets us use additional features such as local state and lifecycle hooks.</p>
<p>这样可以让我们添加一些额外的特性，如本地状态和生命周期钩子。</p>
<h3 id="Adding-Local-State-to-a-Class-向一个类中添加本地状态"><a href="#Adding-Local-State-to-a-Class-向一个类中添加本地状态" class="headerlink" title="Adding Local State to a Class(向一个类中添加本地状态)"></a>Adding Local State to a Class(向一个类中添加本地状态)</h3><p>We will move the date from props to state in three steps:</p>
<p>我们将用三步将时间从属性移动到状态里：</p>
<ol>
<li>Replace this.props.date with this.state.date in the render() method:(在render()方法中用this.state.date取代this.props.date)</li>
</ol>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;<span class="type">Hello</span>, world!&lt;/h1&gt;</span><br><span class="line">        &lt;h2&gt;<span class="type">It</span> is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;/h2&gt;</span><br><span class="line">      &lt;/div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<ol>
<li>Add a <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes#Constructor" target="_blank" rel="noopener">class constructor</a> that assigns the initial this.state:(添加一个类的构造函数来初始化this.state)</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Note how we pass props to the base constructor:</p>
<p>注意我们是如何将参数传给基本的构造函数的：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">(props)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">   super(props);</span></span></span><br><span class="line"><span class="function"><span class="comment">   this.state = &#123;date: new Date()&#125;</span>;</span></span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Class components should always call the base constructor with props.</p>
<p>类组件应该永远由带有参数的基本的构造函数来调用。</p>
<ol>
<li>Remove the date prop from the Clock element:(从Clock中移除时间属性)</li>
</ol>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>We will later add the timer code back to the component itself.</p>
<p>我们稍后会将计时器组件代码到这个组件本身中。</p>
<p>The result looks like this:</p>
<p>最后的结果大致如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/KgQpJd?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Next, we’ll make the Clock set up its own timer and update itself every second.</p>
<p>接下来，我们将为Clock设置它自己的计时器并每秒都更新它。</p>
<h3 id="Adding-Lifecycle-Methods-to-a-Class-为类添加生命周期方法"><a href="#Adding-Lifecycle-Methods-to-a-Class-为类添加生命周期方法" class="headerlink" title="Adding Lifecycle Methods to a Class(为类添加生命周期方法)"></a>Adding Lifecycle Methods to a Class(为类添加生命周期方法)</h3><p>In applications with many components, it’s very important to free up resources taken by the components when they are destroyed.</p>
<p>在具有多个组件的应用程序中在销毁组件时释放所占用的资源是非常重要的。</p>
<p>We want to <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener">set up a timer</a> whenever the Clock is rendered to the DOM for the first time. This is called “mounting” in React.</p>
<p>我们想当Clock在被DOM初次渲染时<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/setInterval" target="_blank" rel="noopener">设置一个计时器</a>，这在React中叫做“挂载”。</p>
<p>We also want to <a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval" target="_blank" rel="noopener">clear that timer</a> whenever the DOM produced by the Clock is removed. This is called “unmounting” in React.</p>
<p>我们也想在Clock在被DOM中移除时<a href="https://developer.mozilla.org/en-US/docs/Web/API/WindowTimers/clearInterval" target="_blank" rel="noopener">清除计时器</a>。这在React中叫做“解挂”。</p>
<p>We can declare special methods on the component class to run some code when a component mounts and unmounts:</p>
<p>当组件被挂载和解挂时，我们可以在组件类中声明特殊的方法来运行一些代码：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line"></span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>These methods are called “lifecycle hooks”.</p>
<p>这些方法叫做“生命周期钩子”。</p>
<p>The componentDidMount() hook runs after the component output has been rendered to the DOM. This is a good place to set up a timer:</p>
<p>componentDidMount()钩子会在组件输出被渲染到DOM后执行。这是一个好的设置计时器的时间点：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">componentDidMount() &#123;</span><br><span class="line">   <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">     () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">     <span class="number">1000</span></span><br><span class="line">   );</span><br><span class="line"> &#125;</span><br></pre></td></tr></table></figure>
<p>Note how we save the timer ID right on this.</p>
<p>现在我们在其上设置计时器的ID。</p>
<p>While this.props is set up by React itself and this.state has a special meaning, you are free to add additional fields to the class manually if you need to store something that doesn’t participate in the data flow (like a timer ID).</p>
<p>因为this.props由React自己设置，this.state具有特殊含义，但如果您需要存储不参与数据流的内容（例如计时器ID），则需要手动将其他字段添加到类中）。</p>
<p>We will tear down the timer in the componentWillUnmount() lifecycle hook:</p>
<p>我们将会在componentWillUnmount()生命周期钩子中卸载计时器：</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Finally, we will implement a method called tick() that the Clock component will run every second.</p>
<p>最后，我们将会应用一个叫做tick()的方法让Clock组件每秒都运行。</p>
<p>It will use this.setState() to schedule updates to the component local state:</p>
<p>它会使用this.setState()来设置更新计时器的本地状态：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Clock</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  <span class="keyword">constructor</span>(props) &#123;</span><br><span class="line">    <span class="keyword">super</span>(props);</span><br><span class="line">    <span class="keyword">this</span>.state = &#123;<span class="attr">date</span>: <span class="keyword">new</span> <span class="built_in">Date</span>()&#125;;</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentDidMount() &#123;</span><br><span class="line">    <span class="keyword">this</span>.timerID = setInterval(</span><br><span class="line">      () =&gt; <span class="keyword">this</span>.tick(),</span><br><span class="line">      <span class="number">1000</span></span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  componentWillUnmount() &#123;</span><br><span class="line">    clearInterval(<span class="keyword">this</span>.timerID);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  tick() &#123;</span><br><span class="line">    <span class="keyword">this</span>.setState(&#123;</span><br><span class="line">      date: <span class="keyword">new</span> <span class="built_in">Date</span>()</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br><span class="line"></span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> (</span><br><span class="line">      &lt;div&gt;</span><br><span class="line">        &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">        &lt;h2&gt;It is &#123;<span class="keyword">this</span>.state.date.toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    );</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;Clock /&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/amqdNA?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Now the clock ticks every second.</p>
<p>现在，钟表将会每秒都运行。</p>
<p>Let’s quickly recap what’s going on and the order in which the methods are called:</p>
<p>让我们简单回顾一下在这个方法被调用时发生了什么，和它们的次序是什么：</p>
<ol>
<li>When Clock is passed to ReactDOM.render(), React calls the constructor of the Clock component. Since Clock needs to display the current time, it initializes this.state with an object including the current time. We will later update this state.</li>
<li>React then calls the Clock component’s render() method. This is how React learns what should be displayed on the screen. React then updates the DOM to match the Clock’s render output.</li>
<li>When the Clock output is inserted in the DOM, React calls the componentDidMount() lifecycle hook. Inside it, the Clock component asks the browser to set up a timer to call the component’s tick() method once a second.</li>
<li>Every second the browser calls the tick() method. Inside it, the Clock component schedules a UI update by calling setState() with an object containing the current time. Thanks to the setState() call, React knows the state has changed, and calls the render() method again to learn what should be on the screen. This time, this.state.date in the render() method will be different, and so the render output will include the updated time. React updates the DOM accordingly.</li>
<li>If the Clock component is ever removed from the DOM, React calls the componentWillUnmount() lifecycle hook so the timer is stopped.</li>
</ol>
<hr>
<ol>
<li>当Clock传递给ReactDOM.render()时，React调用Clock组件的构造函数。由于Clock需要显示当前时间，因此它会使用包含当前时间的对象初始化this.state。我们稍后将更新这个状态。</li>
<li>然后React调用Clock组件的render()方法。这就是React如何在屏幕上显示对应的内容。然后React更新DOM以匹配时钟的渲染输出。</li>
<li>当时钟输出插入到DOM中时，React调用componentDidMount()生命周期钩子。在它里面，Clock组件要求浏览器设置一个定时器，每秒调用一次该组件的tick（）方法。</li>
<li>浏览器每秒钟都会调用tick()方法。在它里面，Clock组件通过调用setState()和包含当前时间的对象来调度UI更新。因为setState()已经被调用，React知道状态已经改变，并再次调用render()方法在屏幕上显示应有的内容。这一次，render()方法中的this.state.date将会不同，所以渲染的结果包含更新的时间。并且React会相应地更新DOM。</li>
<li>如果Clock组件从DOM中删除，React将调用componentWillUnmount()生命周期钩子，定时器也随之停止。</li>
</ol>
<h3 id="Using-State-Correctly-正确地使用状态"><a href="#Using-State-Correctly-正确地使用状态" class="headerlink" title="Using State Correctly(正确地使用状态)"></a>Using State Correctly(正确地使用状态)</h3><p>There are three things you should know about setState().</p>
<p>您应当知道有关setState()的三个事情。</p>
<h4 id="Do-Not-Modify-State-Directly-不要直接调整状态"><a href="#Do-Not-Modify-State-Directly-不要直接调整状态" class="headerlink" title="Do Not Modify State Directly(不要直接调整状态)"></a>Do Not Modify State Directly(不要直接调整状态)</h4><p>There are three things you should know about setState().</p>
<p>有关setState()，您应当知道三件事情。</p>
<h4 id="Do-Not-Modify-State-Directly-不要直接调整状态-1"><a href="#Do-Not-Modify-State-Directly-不要直接调整状态-1" class="headerlink" title="Do Not Modify State Directly(不要直接调整状态)"></a>Do Not Modify State Directly(不要直接调整状态)</h4><p>For example, this will not re-render a component:</p>
<p>例如，下列代码不会重新渲染组件：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">// Wrong</span><br><span class="line">this.<span class="keyword">state</span>.comment = 'Hello';</span><br></pre></td></tr></table></figure>
<p>Instead, use setState():</p>
<p>相反的，您应当使用setState():</p>
<figure class="highlight groovy"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;<span class="string">comment:</span> <span class="string">'Hello'</span>&#125;);</span><br></pre></td></tr></table></figure>
<p>The only place where you can assign this.state is the constructor.</p>
<p>您唯一能设置this.state的地方就是构造函数。</p>
<h4 id="State-Updates-May-Be-Asynchronous-状态更新可能是异步的"><a href="#State-Updates-May-Be-Asynchronous-状态更新可能是异步的" class="headerlink" title="State Updates May Be Asynchronous(状态更新可能是异步的)"></a>State Updates May Be Asynchronous(状态更新可能是异步的)</h4><p>React may batch multiple setState() calls into a single update for performance.</p>
<p>React可能会批量处理多个setState(),以便为单个更新提高性能。</p>
<p>Because this.props and this.state may be updated asynchronously, you should not rely on their values for calculating the next state.</p>
<p>因为this.props和this.state可能会异步更新，所以不应该依赖它们的值来计算下一个状态。</p>
<p>For example, this code may fail to update the counter:</p>
<p>例如，此代码可能无法更新计数器:</p>
<figure class="highlight kotlin"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Wrong</span></span><br><span class="line"><span class="keyword">this</span>.setState(&#123;</span><br><span class="line">  counter: <span class="keyword">this</span>.state.counter + <span class="keyword">this</span>.props.increment,</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<p>To fix it, use a second form of setState() that accepts a function rather than an object. That function will receive the previous state as the first argument, and the props at the time the update is applied as the second argument:</p>
<p>为了修复它，我们可以使用接受函数的setState()而不是一个对象。该函数将接收前一个状态作为第一个参数，并将更新应用时的状态作为第二个参数：</p>
<figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="regexp">//</span> Correct</span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="params">(prevState, props)</span> =&gt;</span> (&#123;</span><br><span class="line">  counter: prevState.counter + props.increment</span><br><span class="line">&#125;));</span><br></pre></td></tr></table></figure>
<p>We used an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow function</a> above, but it also works with regular functions:</p>
<p>我们在此使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，但是它也对常规函数起作用：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Correct</span></span><br><span class="line"><span class="keyword">this</span>.setState(<span class="function"><span class="keyword">function</span><span class="params">(prevState, props)</span> </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> &#123;</span><br><span class="line">    counter: prevState.counter + props.increment</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;);</span><br></pre></td></tr></table></figure>
<h4 id="State-Updates-are-Merged-状态更新已合并"><a href="#State-Updates-are-Merged-状态更新已合并" class="headerlink" title="State Updates are Merged(状态更新已合并)"></a>State Updates are Merged(状态更新已合并)</h4><p>When you call setState(), React merges the object you provide into the current state.</p>
<p>当您调用setState()时，React会合并您当前状态下提供的对象。</p>
<p>For example, your state may contain several independent variables:</p>
<p>例如，您的状态可能包含几个相互独立的变量：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">constructor</span><span class="params">(props)</span> <span class="comment">&#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  super(props);</span></span></span><br><span class="line"><span class="function"><span class="comment">  this.state = &#123;</span></span></span><br><span class="line"><span class="function"><span class="comment">  posts: [],</span></span></span><br><span class="line"><span class="function"><span class="comment">  comments: []</span></span></span><br><span class="line"><span class="function"><span class="comment">  &#125;</span>;</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Then you can update them independently with separate setState() calls:</p>
<p>然后您可以独立地使用setState()调用来更新它们：</p>
<figure class="highlight less"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-tag">componentDidMount</span>() &#123;</span><br><span class="line">    <span class="selector-tag">fetchPosts</span>()<span class="selector-class">.then</span>(response =&gt; &#123;</span><br><span class="line">      <span class="selector-tag">this</span><span class="selector-class">.setState</span>(&#123;</span><br><span class="line">        <span class="attribute">posts</span>: response.posts</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line"></span><br><span class="line">    <span class="selector-tag">fetchComments</span>()<span class="selector-class">.then</span>(response =&gt; &#123;</span><br><span class="line">      <span class="selector-tag">this</span><span class="selector-class">.setState</span>(&#123;</span><br><span class="line">        <span class="attribute">comments</span>: response.comments</span><br><span class="line">      &#125;);</span><br><span class="line">    &#125;);</span><br><span class="line">  &#125;</span><br></pre></td></tr></table></figure>
<p>The merging is shallow, so this.setState({comments}) leaves this.state.posts intact, but completely replaces this.state.comments.</p>
<p>合并是浅层的，所以this.setState({comments})会完整保留this.state.posts，但完全取代了this.state.comments。</p>
<h3 id="The-Data-Flows-Down-数据流失向下的"><a href="#The-Data-Flows-Down-数据流失向下的" class="headerlink" title="The Data Flows Down(数据流失向下的)"></a>The Data Flows Down(数据流失向下的)</h3><p>Neither parent nor child components can know if a certain component is stateful or stateless, and they shouldn’t care whether it is defined as a function or a class.</p>
<p>父组件和孩组件都不知道某个组件是有状态的还是无状态的，并且它们不应该关心它是被定义为一个函数还是一个类。</p>
<p>This is why state is often called local or encapsulated. It is not accessible to any component other than the one that owns and sets it.</p>
<p>这就是为什么状态通常被称作本地的或被封装的。除了包含和设置它的组件之外，其他任何组件都无法访问它。</p>
<p>A component may choose to pass its state down as props to its child components:</p>
<p>组件可以选择将其状态作为参数传递给其子组件：</p>
<figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="variable">&lt;h2&gt;</span>It is &#123;this.<span class="keyword">state</span>.date.<span class="keyword">to</span>LocaleTimeString()&#125;.&lt;/h2&gt;</span><br></pre></td></tr></table></figure>
<p>This also works for user-defined components:</p>
<p>这对用户自定义的组件也有效：</p>
<figure class="highlight axapta"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;FormattedDate <span class="keyword">date</span>=&#123;<span class="keyword">this</span>.state.<span class="keyword">date</span>&#125; /&gt;</span><br></pre></td></tr></table></figure>
<p>The FormattedDate component would receive the date in its props and wouldn’t know whether it came from the Clock’s state, from the Clock’s props, or was typed by hand:</p>
<p>FormattedDate组件应当在它们的属性中接受数据并不会知道它是来自Clock的状态，Clock的属性还是人为输入的。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">FormattedDate</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h2</span>&gt;</span>It is &#123;props.date.toLocaleTimeString()&#125;.<span class="tag">&lt;/<span class="name">h2</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/zKRqNB?editors=0010" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>This is commonly called a “top-down” or “unidirectional” data flow. Any state is always owned by some specific component, and any data or UI derived from that state can only affect components “below” them in the tree.</p>
<p>通常这被称之为“自顶向下”或者“无方向”的数据流。任何状态总是由某个特定组件拥有，并且从该状态派生的任何数据或UI只能影响树中“在其下”的组件。</p>
<p>If you imagine a component tree as a waterfall of props, each component’s state is like an additional water source that joins it at an arbitrary point but also flows down.</p>
<p>如果将组件树想象成参数的瀑布，则每个组件的状态就像是一个额外的水源，它可以在任意点加入它，但也会向下流。</p>
<p>To show that all components are truly isolated, we can create an App component that renders three Clocks:</p>
<p>为了显示所有组件都是真正隔离的，我们可以创建一个呈现三个Clock的App组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">App</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">      &lt;Clock /&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  &lt;App /</span>&gt;,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="http://codepen.io/gaearon/pen/vXdGmd?editors=0010" target="_blank" rel="noopener">Try it on CondePen.</a></p>
<p>Each Clock sets up its own timer and updates independently.</p>
<p>每个表都会独立地设置它本身的计时器并独立更新。</p>
<p>In React apps, whether a component is stateful or stateless is considered an implementation detail of the component that may change over time. You can use stateless components inside stateful components, and vice versa.</p>
<p>在React应用中，无论组件是有状态的还是无状态的，都被视为可能随时间而改变的组件的细节。您可以在有状态组件内使用无状态组件，反之亦然。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[git problem -- 1.git&gerrit邮箱不匹配]]></title>
      <url>/2018/05/11/git/git_problem/01.git_problem/</url>
      <content type="html"><![CDATA[<h2 id="git-problem-–-git-amp-gerrit邮箱不匹配"><a href="#git-problem-–-git-amp-gerrit邮箱不匹配" class="headerlink" title="git problem – git&amp;gerrit邮箱不匹配"></a>git problem – git&amp;gerrit邮箱不匹配</h2><p>Git邮箱不匹配问题 does not match your user account</p>
<p>在活动比较多，使用分支开发的时候，从远端拉取分支，在完成fetch-&gt;rebase-&gt;修改代码以后，执行gerrit push指令时，提示用户信息不匹配。类似于下图所示：</p>
<p><img src="/images/git/01.git_account.png"></p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">remote: ERROR:  In commit <span class="number">024</span>c0bd88da87274f956a10dfa6b41e8c69ebd04</span><br><span class="line">remote: ERROR:  author email address xxxxx@xx.com</span><br><span class="line">remote: ERROR:  does not match your user account.</span><br></pre></td></tr></table></figure>
<p>此问题解决方法：（不仅仅限于分支，master分支出现类似问题也可以用此方法）</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">(1)git <span class="built_in"> config </span>user.email (email地址)</span><br><span class="line">(2)git checkout -b another_branch（如果已经被占，随便再换一个）</span><br><span class="line">(3)git branch -D pre_branch(删除出现问题的分支)</span><br><span class="line">(4)git checkout --track origin/pre_branch</span><br><span class="line">(5)git push origin/pre_branch:refs/<span class="keyword">for</span>/pre_branch  此时原先出现问题的分支就可以push成功了</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> git </category>
            
        </categories>
        
        
        <tags>
            
            <tag> git problem </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 04.Components and Props]]></title>
      <url>/2018/05/08/react/02.Quick_Start/04.Components_and_Props/</url>
      <content type="html"><![CDATA[<h2 id="Components-and-Props"><a href="#Components-and-Props" class="headerlink" title="Components and Props"></a>Components and Props</h2><p>Components let you split the UI into independent, reusable pieces, and think about each piece in isolation.</p>
<p>组件可以让您将用户界面分成独立的，可重复使用的部分，并且每一部分都相互独立。</p>
<p>Conceptually, components are like JavaScript functions. They accept arbitrary inputs (called “props”) and return React elements describing what should appear on the screen.</p>
<p>从概念上讲，组件就像JavaScript的函数一样。他可以接受任意值的输入（我们通常称之为“参数”）并返回显示在屏幕上的React元素。</p>
<h3 id="Functional-and-Class-Components-函数和类组件"><a href="#Functional-and-Class-Components-函数和类组件" class="headerlink" title="Functional and Class Components(函数和类组件)"></a>Functional and Class Components(函数和类组件)</h3><p>The simplest way to define a component is to write a JavaScript function:</p>
<p>定义一个组件最简单的方法是写一个JavaScript函数：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This function is a valid React component because it accepts a single “props” (which stands for properties) object argument with data and returns a React element. We call such components “functional” because they are literally JavaScript functions.</p>
<p>这个函数是一个有效的React组件，因为它可以接受一个带有数据的单一的“参数”（通常代表着属性）对象并返回一个React元素。我们称这样的组件是“函数化”的，因为它们都是JavaScript字面上的方法。</p>
<p>You can also use an <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a> to define a component:</p>
<p>您也可以使用<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">ES6 class</a>来定义一个组件：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="class"><span class="keyword">class</span> <span class="title">Welcome</span> <span class="keyword">extends</span> <span class="title">React</span>.<span class="title">Component</span> </span>&#123;</span><br><span class="line">  render() &#123;</span><br><span class="line">    <span class="keyword">return</span> &lt;h1&gt;<span class="type">Hello</span>, &#123;<span class="keyword">this</span>.props.name&#125;&lt;/h1&gt;;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The above two components are equivalent from React’s point of view.</p>
<p>以上两种组件对于React来说是等价的。</p>
<p>Classes have some additional features that we will discuss in the <a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">next sections</a>. Until then, we will use functional components for their conciseness.</p>
<p>类通常有一些额外的特性，我们会在<a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一章节</a>讨论这些内容。在此之前，我们将会使用更为简洁的函数组件。</p>
<h3 id="Rendering-a-Component-渲染一个组件"><a href="#Rendering-a-Component-渲染一个组件" class="headerlink" title="Rendering a Component(渲染一个组件)"></a>Rendering a Component(渲染一个组件)</h3><p>Previously, we only encountered React elements that represent DOM tags:</p>
<p>在此之前，我们仅仅遇到过使用DOM标签表示的React元素：</p>
<figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = &lt;<span class="keyword">div</span> /&gt;;</span><br></pre></td></tr></table></figure>
<p>However, elements can also represent user-defined components:</p>
<p>然而，元素也可以代表用户自定义的组件：</p>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const element</span> = &lt;Welcome name=<span class="string">"Sara"</span> /&gt;;</span><br></pre></td></tr></table></figure>
<p>When React sees an element representing a user-defined component, it passes JSX attributes to this component as a single object. We call this object “props”.</p>
<p>当React遇到一个用户自定义的组件时，他就会传递JSX属性作为单一的对象给它们的组件。我们称之为对象的“属性”。</p>
<p>For example, this code renders “Hello, Sara” on the page:</p>
<p>例如，以下代码将会把“Hello, Sara”渲染到页面上：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Welcome</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;props.name&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">Welcome</span> <span class="attr">name</span>=<span class="string">"Sara"</span> /&gt;</span>;</span></span><br><span class="line"><span class="xml">ReactDOM.render(</span></span><br><span class="line"><span class="xml">  element,</span></span><br><span class="line"><span class="xml">  document.getElementById('root')</span></span><br><span class="line"><span class="xml">);</span></span><br></pre></td></tr></table></figure>
<p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/rendering-a-component" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Let’s recap what happens in this example:</p>
<p>让我们回顾一下上述代码发生了什么：</p>
<ol>
<li>We call <code>ReactDOM.render()</code> with the <code><welcome name="Sara"></welcome></code> element.</li>
<li>React calls the <code>Welcome</code> component with <code>{name: ‘Sara’}</code> as the props.</li>
<li>Our <code>Welcome</code> component returns a <code>Hello, Sara</code> element as the result.</li>
<li>React DOM efficiently updates the DOM to match <code>Hello, Sara</code>.</li>
</ol>
<hr>
<ol>
<li>我们对<code><welcome name="Sara"></welcome></code>元素调用了<code>ReactDOM.render()</code>。</li>
<li>React调用了<code>Welcome</code>组件，并将<code>{name: ‘Sara’}</code>作为参数。</li>
<li>我们的<code>Welcome</code>返回一个<code>Hello, Sara</code>元素作为结果。</li>
<li>React DOM会很快更新DOM，并显示<code>Hello, Sara</code>。</li>
</ol>
<blockquote>
<p>Note: Always start component names with a capital letter.<br>React treats components starting with lowercase letters as DOM tags. For example, <code>div</code> represents an HTML div tag, but <code>Welcome</code> represents a component and requires Welcome to be in scope.<br>You can read more about the reasoning behind this convention <a href="https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized" target="_blank" rel="noopener">here</a>.</p>
</blockquote>
<hr>
<blockquote>
<p>注意：通常一个组件的命名是以大写字母开始的。<br>React会将以小写字母开头的组件视为DOM标签。例如，<code>div</code>表示一个HTML div标签，但<code>Welcome</code>表示一个组件，并且要求Welcome在作用域内。<br>您可以在<a href="https://reactjs.org/docs/jsx-in-depth.html#user-defined-components-must-be-capitalized" target="_blank" rel="noopener">这里</a>阅读更多关于背后的内容。</p>
</blockquote>
<h3 id="Composing-Components-构成组件"><a href="#Composing-Components-构成组件" class="headerlink" title="Composing Components(构成组件)"></a>Composing Components(构成组件)</h3><p>Components can refer to other components in their output. This lets us use the same component abstraction for any level of detail. A button, a form, a dialog, a screen: in React apps, all those are commonly expressed as components.</p>
<p>组件能在它们的输出中引用其他的组件。这让我们可以对任何有相同内容的细节抽象出相同的部分。例如一个按钮，一个表格，一个对话框，一个屏幕：在React应用程序中，所有这些都通常表示为组件。</p>
<p>For example, we can create an App component that renders Welcome many times:</p>
<p>例如，我们可以创建一个App组件来渲染很多遍Welcome：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">Welcome</span>(props) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">&lt;h1&gt;Hello,</span> &#123;props.name&#125;&lt;/h1&gt;;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">function</span> <span class="title">App</span>() &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">(</span></span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Sara"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Cahal"</span> /&gt;</span><br><span class="line">      &lt;Welcome name=<span class="string">"Edite"</span> /&gt;</span><br><span class="line">    &lt;/div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;App /&gt;,</span><br><span class="line">  document.getElementById(<span class="symbol">'root</span>')</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/composing-components" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Typically, new React apps have a single <code>App</code> component at the very top. However, if you integrate React into an existing app, you might start bottom-up with a small component like <code>Button</code> and gradually work your way to the top of the view hierarchy.</p>
<p>通常情况下，一个新的React<code>APP</code>会在顶层架构上有单一的应用组件。但是，如果您将React集成到现有的应用程序中，则可以使用<code>Button</code>之类的小组件自下而上地嵌入进去，并逐渐转向视图层次结构的顶部。</p>
<h3 id="Extracting-Components-抽象组件"><a href="#Extracting-Components-抽象组件" class="headerlink" title="Extracting Components(抽象组件)"></a>Extracting Components(抽象组件)</h3><p>Don’t be afraid to split components into smaller components.</p>
<p>永远不要担心将组件分成更小的组件。</p>
<p>For example, consider this <code>Comment</code> component:</p>
<p>观看下列例子，考虑<code>Comment</code>组件：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;img className=<span class="string">"Avatar"</span></span><br><span class="line">          src=&#123;props.author.avatarUrl&#125;</span><br><span class="line">          alt=&#123;props.author.name&#125;</span><br><span class="line">        /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">          &#123;props.author.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/extracting-components" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>It accepts author (an object), text (a string), and date (a date) as props, and describes a comment on a social media website.</p>
<p>它会接受用户(一个对象)，文本(一个字符串)，和日期(一个时间)作为参数，并且可以描述一个社交媒体平台上的一个评论。</p>
<p>This component can be tricky to change because of all the nesting, and it is also hard to reuse individual parts of it. Let’s extract a few components from it.</p>
<p>因为有大量的嵌套，这个组件可能会变得很棘手，并且它的单一部分也很难复用。让我们将它抽象成一些小的组件。</p>
<p>First, we will extract Avatar:</p>
<p>首先，我们会抽象出Avatar：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Avatar</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;img className=<span class="string">"Avatar"</span></span><br><span class="line">      src=&#123;props.user.avatarUrl&#125;</span><br><span class="line">      alt=&#123;props.user.name&#125;</span><br><span class="line">    /&gt;</span><br><span class="line"></span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>The Avatar doesn’t need to know that it is being rendered inside a Comment. This is why we have given its prop a more generic name: user rather than author.</p>
<p>Avatar不需要知道它是否被渲染在一个评论中。这也是为什么我们可以将它的参数设置为一个更符合的名字：使用user而不是author</p>
<p>We recommend naming props from the component’s own point of view rather than the context in which it is being used.</p>
<p>我们建议从组件自身的角度命名参数而不是从它使用的环境下命名。</p>
<p>We can now simplify Comment a tiny bit:</p>
<p>因此我们可以将评论简化一些：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">        &lt;Avatar user=&#123;props.author&#125; /&gt;</span><br><span class="line">        &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">          &#123;props.author.name&#125;</span><br><span class="line">        &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p>Next, we will extract a UserInfo component that renders an Avatar next to the user’s name:</p>
<p>接下来，我们将会将UserInfo组件抽象出来，该组件会将Avatar呈现给旁边的用户的姓名出来：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">UserInfo</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"UserInfo"</span>&gt;</span><br><span class="line">      &lt;Avatar user=&#123;props.user&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"UserInfo-name"</span>&gt;</span><br><span class="line">        &#123;props.user.name&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>This lets us simplify Comment even further:</p>
<p>这样Comment比之前更加简化了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">Comment</span>(<span class="params">props</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> (</span><br><span class="line">    &lt;div className=<span class="string">"Comment"</span>&gt;</span><br><span class="line">      &lt;UserInfo user=&#123;props.author&#125; /&gt;</span><br><span class="line">      &lt;div className=<span class="string">"Comment-text"</span>&gt;</span><br><span class="line">        &#123;props.text&#125;</span><br><span class="line">      &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">      &lt;div className="Comment-date"&gt;</span></span><br><span class="line"><span class="regexp">        &#123;formatDate(props.date)&#125;</span></span><br><span class="line"><span class="regexp">      &lt;/</span>div&gt;</span><br><span class="line">    &lt;<span class="regexp">/div&gt;</span></span><br><span class="line"><span class="regexp">  );</span></span><br><span class="line"><span class="regexp">&#125;</span></span><br></pre></td></tr></table></figure>
<p><a href="https://reactjs.org/redirect-to-codepen/components-and-props/extracting-components-continued" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>Extracting components might seem like grunt work at first, but having a palette of reusable components pays off in larger apps. A good rule of thumb is that if a part of your UI is used several times (Button, Panel, Avatar), or is complex enough on its own (App, FeedStory, Comment), it is a good candidate to be a reusable component.</p>
<p>首先提取组件可能看起来像重复工作，但在更大的应用程序中，我们可以提取出可重用的部分。一个好的经验法则是，如果你的用户界面的一部分被多次使用（按钮，面板，头像），或者它本身已经足够复杂，那么它会是一个好的可重用组件的选择。</p>
<h3 id="Props-are-Read-Only-属性是只读的"><a href="#Props-are-Read-Only-属性是只读的" class="headerlink" title="Props are Read-Only(属性是只读的)"></a>Props are Read-Only(属性是只读的)</h3><p>Whether you declare a component as a function or a class, it must never modify its own props. Consider this sum function:</p>
<p>不管您是否是通过函数或者类来声明组件的，它永远都不能修改属于它自己的参数。考虑下面的加法函数：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> <span class="title">sum</span>(a, b) &#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="type">a</span> + b;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>Such functions are called <a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“pure”</a> because they do not attempt to change their inputs, and always return the same result for the same inputs.</p>
<p>这样的函数是<a href="https://en.wikipedia.org/wiki/Pure_function" target="_blank" rel="noopener">“纯函数”</a>，因为它们不会试图改变它们的输入，并总会对于相同的输入返回相同的值。</p>
<p>In contrast, this function is impure because it changes its own input:</p>
<p>相反的，下面这个函数就是动机不纯的，因为它会改变它本身的输入：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">withdraw</span><span class="params">(account, amount)</span> </span>&#123;</span><br><span class="line">  account.total -= amount;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>React is pretty flexible but it has a single strict rule:</p>
<p>React十分灵活，但是它有一个特别严格的规定：</p>
<p><strong>All React components must act like pure functions with respect to their props.</strong></p>
<p><strong>所有的React组件都必须表现的想一个纯函数一样，并不会修改它们的属性。</strong></p>
<p>Of course, application UIs are dynamic and change over time. In the <a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">next section</a>, we will introduce a new concept of “state”. State allows React components to change their output over time in response to user actions, network responses, and anything else, without violating this rule.</p>
<p>当然，应用的UI是动态的，并且会随时间的改变而改变。在<a href="https://reactjs.org/docs/state-and-lifecycle.html" target="_blank" rel="noopener">下一章节</a>中，我们会介绍一个新的概念“状态”。状态允许React组件随着用户的动作，网络的反馈和任何其他事情的来随时改变它们的输出，并且不会违背这个规则。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 03.Rendering Elements]]></title>
      <url>/2018/05/04/react/02.Quick_Start/03.Rendering_Elements/</url>
      <content type="html"><![CDATA[<h2 id="Rendering-Elements"><a href="#Rendering-Elements" class="headerlink" title="Rendering Elements"></a>Rendering Elements</h2><p>Elements are the smallest building blocks of React apps.</p>
<p>元素是React 应用中最小的构建组块。</p>
<p>An element describes what you want to see on the screen:</p>
<p>以下是一个描述了您在在屏幕上想看到的元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>Unlike browser DOM elements, React elements are plain objects, and are cheap to create. React DOM takes care of updating the DOM to match the React elements.</p>
<p>不想浏览器的DOM元素，React元素是普通对象，并且很容易创建。React DOM负责更新DOM以便于匹配React元素。</p>
<blockquote>
<p>Note:<br>One might confuse elements with a more widely known concept of “components”. We will introduce components in the <a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">next section</a>. Elements are what components are “made of”, and we encourage you to read this section before jumping ahead.</p>
<p>注意：<br>人们可能会将元素与更广为人知的“组件”概念混为一谈。 我们将在<a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">下一部分</a>介绍组件。 组件是由元素“组成”的，我们鼓励您在跳过本节之前先阅读本节内容。</p>
</blockquote>
<h3 id="Rendering-an-Element-into-the-DOM-渲染一个在DOM中的元素"><a href="#Rendering-an-Element-into-the-DOM-渲染一个在DOM中的元素" class="headerlink" title="Rendering an Element into the DOM(渲染一个在DOM中的元素)"></a>Rendering an Element into the DOM(渲染一个在DOM中的元素)</h3><p>Let’s say there is a <code><div></div></code> somewhere in your HTML file:</p>
<p>以下是一个在您的HTML文件中的<code><div></div></code></p>
<figure class="highlight applescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span> <span class="built_in">id</span>=<span class="string">"root"</span>&gt;&lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p>We call this a “root” DOM node because everything inside it will be managed by React DOM.</p>
<p>我们叫它为“root”DOM节点，因为它其中的所有元素都由React DOM控制。</p>
<p>Applications built with just React usually have a single root DOM node. If you are integrating React into an existing app, you may have as many isolated root DOM nodes as you like.</p>
<p>仅使用React构建的应用程序通常只有单个根DOM节点。如果您将React集成到现有的应用程序中，您可以根据需要选择多个独立的根DOM节点。</p>
<p>To render a React element into a root DOM node, pass both to <code>ReactDOM.render()</code>:</p>
<p>为了将一个React元素渲染到一个根DOM节点，将它们全部传给<code>ReactDOM.render()</code>:</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br></pre></td></tr></table></figure>
<p><a href="https://reactjs.org/redirect-to-codepen/rendering-elements/render-an-element" target="_blank" rel="noopener">Try it on CodePen</a></p>
<p>It displays “Hello, world” on the page.</p>
<p>它将会在页面上显示“Hello, world”。</p>
<h3 id="Updating-the-Rendered-Element-更新渲染的元素"><a href="#Updating-the-Rendered-Element-更新渲染的元素" class="headerlink" title="Updating the Rendered Element(更新渲染的元素)"></a>Updating the Rendered Element(更新渲染的元素)</h3><p>React elements are <code>immutable</code>. Once you create an element, you can’t change its children or attributes. An element is like a single frame in a movie: it represents the UI at a certain point in time.</p>
<p>React元素是<code>不可变的</code>。一旦您创建了一个元素，您就不能改变它的子元素或者属性。一个元素就像电影里的一帧：它代表着一个特定时间点的UI。</p>
<p>With our knowledge so far, the only way to update the UI is to create a new element, and pass it to <code>ReactDOM.render()</code>.</p>
<p>以我们目前所有的知识，更新UI的唯一方法就是创建一个新的元素，并将它传给<code>ReactDOM.render()</code>。</p>
<p>Consider this ticking clock example:</p>
<p>考虑以下秒表的例子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">tick</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">const</span> element = (</span><br><span class="line">    &lt;div&gt;</span><br><span class="line">      &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">      &lt;h2&gt;It is &#123;<span class="keyword">new</span> <span class="built_in">Date</span>().toLocaleTimeString()&#125;.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">    &lt;/</span>div&gt;</span><br><span class="line">  );</span><br><span class="line">  ReactDOM.render(element, <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>));</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">setInterval(tick, <span class="number">1000</span>);</span><br></pre></td></tr></table></figure>
<p><a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">Try it on CodePen</a></p>
<p>It calls <code>ReactDOM.render()</code> every second from a setInterval() callback.</p>
<p>它会每秒从setInterval()函数的回调函数中调用<code>ReactDOM.render()</code>。</p>
<blockquote>
<p>Note:<br>In practice, most React apps only call <code>ReactDOM.render()</code> once. In the next sections we will learn how such code gets encapsulated into stateful components.<br>We recommend that you don’t skip topics because they build on each other.</p>
<p>注意：<br>在实际使用过程中，大多数的React应用仅仅只调用<code>ReactDOM.render()</code>一次。在接下来的部分中，我们将学习如何将这些代码封装到有状态的组件中。<br>我们建议您不要跳过这些内容，因为它们互相之间都有联系。</p>
</blockquote>
<h3 id="React-Only-Updates-What’s-Necessary-React只有在必须的时候才会更新"><a href="#React-Only-Updates-What’s-Necessary-React只有在必须的时候才会更新" class="headerlink" title="React Only Updates What’s Necessary(React只有在必须的时候才会更新)"></a>React Only Updates What’s Necessary(React只有在必须的时候才会更新)</h3><p>React DOM compares the element and its children to the previous one, and only applies the DOM updates necessary to bring the DOM to the desired state.</p>
<p>React DOM 会将元素和它的子元素与上一个状态的元素和子元素比较，并且只在DOM必须更新的时候才会让DOM变化到期待的状态。</p>
<p>You can verify by inspecting the <a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">last example</a> with the browser tools:</p>
<p>您可以通过浏览器工具监视<a href="https://reactjs.org/redirect-to-codepen/rendering-elements/update-rendered-element" target="_blank" rel="noopener">最后一个例子</a>。</p>
<p><img src="/images/react_document/02-03-ticking_click.gif"></p>
<p>Even though we create an element describing the whole UI tree on every tick, only the text node whose contents has changed gets updated by React DOM.</p>
<p>尽管我们创建了一个元素来描述在每秒钟的整个结构，但是只有内容改变的文本节点会被React DOM更新。</p>
<p>In our experience, thinking about how the UI should look at any given moment rather than how to change it over time eliminates a whole class of bugs.</p>
<p>根据我们的经验，思考如何在任何特定时刻看到UI，而不是随着时间的推移如何改变，从而消除了一整类错误。根据我们的经验，考率如何在任何特定时刻看到特定的样式，而不是随着时间的推移而变化，只有这样做才能消除了一系列相关的错误。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 02.Introducing JSX]]></title>
      <url>/2018/05/04/react/02.Quick_Start/02.Introducing_JSX/</url>
      <content type="html"><![CDATA[<h2 id="Introducing-JSX"><a href="#Introducing-JSX" class="headerlink" title="Introducing JSX"></a>Introducing JSX</h2><p>Consider this variable declaration:</p>
<p>考虑以下变量声明：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, world!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>This funny tag syntax is neither a string nor HTML.</p>
<p>It is called JSX, and it is a syntax extension to JavaScript. We recommend using it with React to describe what the UI should look like. JSX may remind you of a template language, but it comes with the full power of JavaScript.</p>
<p>它叫做JSX，并且它是基于JavaScript的语法进行扩展的。我们建议是在React中使用它来描述UI的样式。JSX也许让您想起一些模板语言，但是它具有JavaScript的全部功能。</p>
<p>JSX produces React “elements”. We will explore rendering them to the DOM in the <a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener">next section</a>. Below, you can find the basics of JSX necessary to get you started.</p>
<p>JSX生成了React“元素”。我们将在<a href="https://reactjs.org/docs/rendering-elements.html" target="_blank" rel="noopener">下一章节</a>内探索它是如果将React渲染到DOM上的。除此之外，您还可以学习到使用JSX的基本知识。</p>
<h3 id="Why-JSX-为什么使用JSX"><a href="#Why-JSX-为什么使用JSX" class="headerlink" title="Why JSX?(为什么使用JSX?)"></a>Why JSX?(为什么使用JSX?)</h3><p>React embraces the fact that rendering logic is inherently coupled with other UI logic: how events are handled, how the state changes over time, and how the data is prepared for display.</p>
<p>React认为渲染逻辑与其他UI逻辑是有耦合的：事件如何处理，状态如何随时间变化以及数据如何准备显示。</p>
<p>Instead of artificially separating technologies by putting markup and logic in separate files, React <a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">separates concerns</a> with loosely coupled units called “components” that contain both. We will come back to components in a <a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">further section</a>, but if you’re not yet comfortable putting markup in JS, <a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank" rel="noopener">this talk</a> might convince you otherwise.</p>
<p>React不再人为地通过将标记和逻辑放在单独的文件中来分离技术，React通过将问题与“组件”–一个松散耦合的单元<a href="https://en.wikipedia.org/wiki/Separation_of_concerns" target="_blank" rel="noopener">分隔开</a>。我们将在<a href="https://reactjs.org/docs/components-and-props.html" target="_blank" rel="noopener">接下来的章节内</a>回到组件中，但如果你不习惯在JS中添加标记，那么<a href="https://www.youtube.com/watch?v=x7cQ3mrcKaY" target="_blank" rel="noopener">这个话题</a>可能会让你习惯这个改变。</p>
<p>React <a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">doesn’t require</a> using JSX, but most people find it helpful as a visual aid when working with UI inside the JavaScript code. It also allows React to show more useful error and warning messages.</p>
<p>React<a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">不需要</a>使用JSX，但是大多数人认为在JavaScript代码中使用它时，有助于从视觉上更清晰地理解代码。它还允许React显示更多有用的错误和警告消息。</p>
<p>With that out of the way, let’s get started!</p>
<p>那就这样，让我们开始吧！</p>
<h3 id="Embedding-Expressions-in-JSX-在JSX中嵌入表达式"><a href="#Embedding-Expressions-in-JSX-在JSX中嵌入表达式" class="headerlink" title="Embedding Expressions in JSX(在JSX中嵌入表达式)"></a>Embedding Expressions in JSX(在JSX中嵌入表达式)</h3><p>You can embed any <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript expression</a> in JSX by wrapping it in curly braces.</p>
<p>您可以用大括号在JSX中包括任何<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Expressions_and_Operators#Expressions" target="_blank" rel="noopener">JavaScript表达式</a>。</p>
<p>For example, <code>2 + 2</code>, <code>user.firstName</code>, and <code>formatName(user)</code> are all valid expressions:</p>
<p>例如，<code>2 + 2</code>, <code>user.firstName</code>, and <code>formatName(user)</code>都是有效的表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">formatName</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">return</span> user.firstName + <span class="string">' '</span> + user.lastName;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> user = &#123;</span><br><span class="line">  firstName: <span class="string">'Harper'</span>,</span><br><span class="line">  lastName: <span class="string">'Perez'</span></span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1&gt;</span><br><span class="line">    Hello, &#123;formatName(user)&#125;!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br><span class="line"><span class="regexp"></span></span><br><span class="line"><span class="regexp">ReactDOM.render(</span></span><br><span class="line"><span class="regexp">  element,</span></span><br><span class="line"><span class="regexp">  document.getElementById('root')</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<p><a href="https://reactjs.org/redirect-to-codepen/introducing-jsx" target="_blank" rel="noopener">Try it on CodePen.</a></p>
<p>We split JSX over multiple lines for readability. While it isn’t required, when doing this, we also recommend wrapping it in parentheses to avoid the pitfalls of <a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">automatic semicolon insertion</a>.</p>
<p>为了便于阅读，我们将JSX分成多行。虽然这不是必需的，但是我们还建议将其包装在括号内以避免<a href="http://stackoverflow.com/q/2846283" target="_blank" rel="noopener">自动分号插入</a>的缺陷。</p>
<h3 id="JSX-is-an-Expression-Too-JSX也是一个表达式"><a href="#JSX-is-an-Expression-Too-JSX也是一个表达式" class="headerlink" title="JSX is an Expression Too(JSX也是一个表达式)"></a>JSX is an Expression Too(JSX也是一个表达式)</h3><p>After compilation, JSX expressions become regular JavaScript function calls and evaluate to JavaScript objects.</p>
<p>在编译完后，JSX表达式会变成常规的JavaScript方法的调用，并且会转为JavaScript对象。</p>
<p>This means that you can use JSX inside of <code>if</code> statements and <code>for</code> loops, assign it to variables, accept it as arguments, and return it from functions:</p>
<p>这意味着您可以在if语句和for循环中使用JSX，将其分配给变量，将其作为参数接受，并从函数中返回：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">getGreeting</span>(<span class="params">user</span>) </span>&#123;</span><br><span class="line">  <span class="keyword">if</span> (user) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, &#123;formatName(user)&#125;!<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>Hello, Stranger.<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<h3 id="Specifying-Attributes-with-JSX-使用JSX指定属性"><a href="#Specifying-Attributes-with-JSX-使用JSX指定属性" class="headerlink" title="Specifying Attributes with JSX(使用JSX指定属性)"></a>Specifying Attributes with JSX(使用JSX指定属性)</h3><p>You may use quotes to specify string literals as attributes:</p>
<p>您可以使用引号将字符串文字指定为属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">div</span> <span class="attr">tabIndex</span>=<span class="string">"0"</span>&gt;</span><span class="tag">&lt;/<span class="name">div</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>You may also use curly braces to embed a JavaScript expression in an attribute:</p>
<p>您也可以使用大括号包裹JavaScript表达式作为属性：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span>&gt;</span><span class="tag">&lt;/<span class="name">img</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>Don’t put quotes around curly braces when embedding a JavaScript expression in an attribute. You should either use quotes (for string values) or curly braces (for expressions), but not both in the same attribute.</p>
<p>当将JavaScript表达式作为属性时，不要在大括号外边加引号。您应该要么使用引号（对于字符串的值来说）或者大括号（对于表达式来说）,但是不能两者一起使用。</p>
<blockquote>
<p>Warning:<br>Since JSX is closer to JavaScript than to HTML, React DOM uses camelCase property naming convention instead of HTML attribute names.<br>For example, class becomes className in JSX, and tabindex becomes tabIndex.</p>
<p>警告：<br>因为JSX相对于HTML来说更接近于JavaScript，React Dom使用传统的驼峰命名方法来命名，而不是像HTML属性一样命名。<br>例如，在JSX中，class应该是className，tabindex应该是tabIndex</p>
</blockquote>
<h3 id="Specifying-Children-with-JSX-用JSX指定子元素"><a href="#Specifying-Children-with-JSX-用JSX指定子元素" class="headerlink" title="Specifying Children with JSX(用JSX指定子元素)"></a>Specifying Children with JSX(用JSX指定子元素)</h3><p>If a tag is empty, you may close it immediately with <code>/&gt;</code>, like XML:</p>
<p>如果一个标签是空的，您应该立即使用<code>/&gt;</code>的方式关闭它，像XML一样：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">img</span> <span class="attr">src</span>=<span class="string">&#123;user.avatarUrl&#125;</span> /&gt;</span>;</span></span><br></pre></td></tr></table></figure>
<p>JSX tags may contain children:</p>
<p>JSX标签可以包含子元素：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;div&gt;</span><br><span class="line">    &lt;h1&gt;Hello!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span></span><br><span class="line">    &lt;h2&gt;Good to see you here.&lt;<span class="regexp">/h2&gt;</span></span><br><span class="line"><span class="regexp">  &lt;/</span>div&gt;</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<h3 id="JSX-Prevents-Injection-Attacks-JSX可以防止注入攻击"><a href="#JSX-Prevents-Injection-Attacks-JSX可以防止注入攻击" class="headerlink" title="JSX Prevents Injection Attacks(JSX可以防止注入攻击)"></a>JSX Prevents Injection Attacks(JSX可以防止注入攻击)</h3><p>It is safe to embed user input in JSX:</p>
<p>将用户输入置于JSX中是安全的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> title = response.potentiallyMaliciousInput;</span><br><span class="line"><span class="comment">// This is safe:</span></span><br><span class="line"><span class="keyword">const</span> element = <span class="xml"><span class="tag">&lt;<span class="name">h1</span>&gt;</span>&#123;title&#125;<span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>;</span><br></pre></td></tr></table></figure>
<p>By default, React DOM <a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">escapes</a> any values embedded in JSX before rendering them. Thus it ensures that you can never inject anything that’s not explicitly written in your application. Everything is converted to a string before being rendered. This helps prevent <a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS (cross-site-scripting)</a> attacks.</p>
<p>默认情况下，React DOM在渲染之前会<a href="http://stackoverflow.com/questions/7381974/which-characters-need-to-be-escaped-on-html" target="_blank" rel="noopener">转义</a>嵌入在JSX中的任何值。因此它确保您永远不会注入任何未明确的写入应用程序中的内容。在呈现之前，所有内容都会转换为字符串。这有助于防止<a href="https://en.wikipedia.org/wiki/Cross-site_scripting" target="_blank" rel="noopener">XSS(跨站点脚本)</a>攻击。</p>
<h3 id="JSX-Represents-Objects-JSX表示对象"><a href="#JSX-Represents-Objects-JSX表示对象" class="headerlink" title="JSX Represents Objects(JSX表示对象)"></a>JSX Represents Objects(JSX表示对象)</h3><p>Babel compiles JSX down to <code>React.createElement()</code> calls.</p>
<p>Babel会将JSX编译成<code>React.createElement()</code>的调用。</p>
<p>These two examples are identical:</p>
<p>以下两个例子是一样的：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">const</span> element = (</span><br><span class="line">  &lt;h1 className=<span class="string">"greeting"</span>&gt;</span><br><span class="line">    Hello, world!</span><br><span class="line">  &lt;<span class="regexp">/h1&gt;</span></span><br><span class="line"><span class="regexp">);</span></span><br></pre></td></tr></table></figure>
<figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">const element</span> = React.createElement(</span><br><span class="line">  <span class="string">'h1'</span>,</span><br><span class="line">  &#123;className: <span class="string">'greeting'</span>&#125;,</span><br><span class="line">  <span class="string">'Hello, world!'</span></span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p><code>React.createElement()</code> performs a few checks to help you write bug-free code but essentially it creates an object like this:</p>
<p><code>React.createElement()</code>会执行一些检查来帮助您编写无错代码，但本质上它会创建一个如下所示的对象：</p>
<figure class="highlight go"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// Note: this structure is simplified</span></span><br><span class="line"><span class="keyword">const</span> element = &#123;</span><br><span class="line">  <span class="keyword">type</span>: <span class="string">'h1'</span>,</span><br><span class="line">  props: &#123;</span><br><span class="line">    className: <span class="string">'greeting'</span>,</span><br><span class="line">    children: <span class="string">'Hello, world!'</span></span><br><span class="line">  &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>These objects are called “React elements”. You can think of them as descriptions of what you want to see on the screen. React reads these objects and uses them to construct the DOM and keep it up to date.</p>
<p>这些对象被称为“React元素”。你可以把它们想象成你想要在屏幕上看到的东西。React会读取这些对象并使用它们来构建DOM并使其保持最新状态。</p>
<p>We will explore rendering React elements to the DOM in the next section.</p>
<p>我们将会在下一章里探索如何在DOM中渲染React元素。</p>
<blockquote>
<p>Tip:<br>We recommend using the <a href="http://babeljs.io/docs/editors" target="_blank" rel="noopener">“Babel” language definition</a> for your editor of choice so that both ES6 and JSX code is properly highlighted. This website uses the <a href="https://labs.voronianski.com/oceanic-next-color-scheme/" target="_blank" rel="noopener">Oceanic Next</a> color scheme which is compatible with it.<br>提示：<br>我们将以使用<a href="http://babeljs.io/docs/editors" target="_blank" rel="noopener">“Babel”语言定义</a>作为您的编译器，以便正确突出显示ES6和JSX代码。本网站采用与其兼容的Oceanic Next色彩方案。</p>
</blockquote>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[02.Quick Start -- 01.Hello World]]></title>
      <url>/2018/05/04/react/02.Quick_Start/01.Hello_World/</url>
      <content type="html"><![CDATA[<h2 id="Hello-World"><a href="#Hello-World" class="headerlink" title="Hello World"></a>Hello World</h2><h4>The easiest way to get started with React is to use <a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">this Hello World example code on CodePen</a>. You don’t need to install anything; you can just open it in another tab and follow along as we go through examples. If you’d rather use a local development environment, check out the <a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">Installation</a> section.</h4>

<h4>开始学习React最简单的方式是使用<a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">Codepen上的Hello World的例子</a>。您不必安装任何东西；您只需要在另一个窗口打开就能查看我们写下的例子。如果您想在本地搭建环境，请查看<a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">安装</a>章节。</h4>

<hr>
<p>The smallest React example looks like this:</p>
<p>最小的React例子像这个样子：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>It renders a heading saying “Hello, world!” on the page.</p>
<p>它将会在页面上渲染一个写着“Hello World”的标题。</p>
<p>The next few sections will gradually introduce you to using React. We will examine the building blocks of React apps: elements and components. Once you master them, you can create complex apps from small reusable pieces.</p>
<p>接下来的章节将会逐渐向您介绍如何使用React。我们将检查React应用程序的构建部分：元素和组件。一旦您掌握了它们，您就可以通过小型可重复使用的部分创建复杂的应用程序。</p>
<h3 id="A-Note-on-JavaScript-一个关于JavaScript的注意点"><a href="#A-Note-on-JavaScript-一个关于JavaScript的注意点" class="headerlink" title="A Note on JavaScript(一个关于JavaScript的注意点)"></a>A Note on JavaScript(一个关于JavaScript的注意点)</h3><p>React is a JavaScript library, and so we’ll assume you have a basic understanding of the JavaScript language. If you don’t feel very confident, we recommend <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">refreshing your JavaScript knowledge</a> so you can follow along more easily.</p>
<p>React是一个JavaScript库，因此我们假设您对于JavaScript语言有一个基本的了解。如果您不是很自信，我们建议您<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/A_re-introduction_to_JavaScript" target="_blank" rel="noopener">重新回顾JavaScript的相关知识</a>，以便能让您在接下来的内容上更容易。</p>
<p>We also use some of the ES6 syntax in the examples. We try to use it sparingly because it’s still relatively new, but we encourage you to get familiar with <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">arrow functions</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">classes</a>, <a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">template literals</a>, <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">let</a>, and <a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener">const</a> statements. You can use the <a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA" target="_blank" rel="noopener">Babel REPL</a> to check what ES6 code compiles to.</p>
<p>我们在案例中也使用了一些ES6的语法。我们尽量少的使用它们，因为它们还相对较新，但是我们还是建议您熟悉<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Arrow_functions" target="_blank" rel="noopener">箭头函数</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="noopener">类</a>，<a href="https://developer.mozilla.org/en/docs/Web/JavaScript/Reference/Template_literals" target="_blank" rel="noopener">模板字面量</a>，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/let" target="_blank" rel="noopener">let</a>和<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/const" target="_blank" rel="noopener">const</a>等概念。您可以使用<a href="https://babeljs.io/repl/#?presets=react&amp;code_lz=MYewdgzgLgBApgGzgWzmWBeGAeAFgRgD4AJRBEAGhgHcQAnBAEwEJsB6AwgbgChRJY_KAEMAlmDh0YWRiGABXVOgB0AczhQAokiVQAQgE8AkowAUAcjogQUcwEpeAJTjDgUACIB5ALLK6aRklTRBQ0KCohMQk6Bx4gA" target="_blank" rel="noopener">Babel REPL</a>来查看ES6代码编译过后的结果。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 04.CDN Links]]></title>
      <url>/2018/05/03/react/01.Try_React/04.CDN_Links/</url>
      <content type="html"><![CDATA[<h2 id="CDN-Links-CDN链接"><a href="#CDN-Links-CDN链接" class="headerlink" title="CDN Links(CDN链接)"></a>CDN Links(CDN链接)</h2><p>The UMD builds of React and ReactDOM are available over a CDN.</p>
<p>React和ReactDOM的UMD版本可通过CDN获得。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;script crossorigin src=<span class="string">"https://unpkg.com/react@16/umd/react.development.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br><span class="line">&lt;script crossorigin src=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.development.js"</span>&gt;<span class="xml"><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span></span><br></pre></td></tr></table></figure>
<p>The versions above are only meant for development, and are not suitable for production. </p>
<p>以上版本仅用于开发，不适合生产。</p>
<p>Minified and optimized production versions of React are available at:</p>
<p>缩小和优化的React生产版本可以用以下方式获得：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react@16/umd/react.production.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"https://unpkg.com/react-dom@16/umd/react-dom.production.min.js"</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>To load a specific version of <code>react</code> and <code>react-dom</code>, replace <code>16</code> with the version number.</p>
<p>如果要加载特定版本的<code>react</code>和<code>react-dom</code>，请将<code>16</code>替换为对应的版本号。</p>
<h3 id="Why-the-crossorigin-Attribute-为什么要设置crossorigin属性"><a href="#Why-the-crossorigin-Attribute-为什么要设置crossorigin属性" class="headerlink" title="Why the crossorigin Attribute?(为什么要设置crossorigin属性?)"></a>Why the crossorigin Attribute?(为什么要设置crossorigin属性?)</h3><p>If you serve React from a CDN, we recommend to keep the crossorigin <code>attribute set</code>:</p>
<p>如果您使用基于CDN的React，我们建议保留crossorigin<code>属性集</code>：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">crossorigin</span> <span class="attr">src</span>=<span class="string">"..."</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>We also recommend to verify that the CDN you are using sets the <code>Access-Control-Allow-Origin: *</code> HTTP header:</p>
<p>我们还建议验证您使用的CDN是否设置了<code>Access-Control-Allow-Origin：* </code>HTTP标头：</p>
<p><img src="/images/react_document/01-04-access_control_allow_origin.png" alt="Access-Control-Allow-Origin:*HTTP header"></p>
<p>This enables a better <a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">error handling experience</a> in React 16 and later.</p>
<p>这可以保证在React16或更高的版本上有一个更好的<a href="https://reactjs.org/blog/2017/07/26/error-handling-in-react-16.html" target="_blank" rel="noopener">错误处理方法</a>。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 03.Add React to an Existing Application]]></title>
      <url>/2018/05/03/react/01.Try_React/03.Add_React_to_an_Existing_Application/</url>
      <content type="html"><![CDATA[<h2 id="Add-React-to-an-Existing-Application-在一个已存的项目中添加React"><a href="#Add-React-to-an-Existing-Application-在一个已存的项目中添加React" class="headerlink" title="Add React to an Existing Application(在一个已存的项目中添加React)"></a>Add React to an Existing Application(在一个已存的项目中添加React)</h2><p>You don’t need to rewrite your app to start using React.</p>
<p>您不必重写您的应用程序来开始使用React</p>
<p>We recommend adding React to a small part of your application, such as an individual widget, so you can see if it works well for your use case.</p>
<p>我们建议将React添加到应用程序中的一小部分中，例如单个小部件，以便您可以查看它是否适合您的用例。</p>
<p>While React <a href="https://reactjs.org/docs/react-without-es6.html" target="_blank" rel="noopener">can be used</a> without a build pipeline, we recommend setting it up so you can be more productive. A modern build pipeline typically consists of:</p>
<p>虽然<a href="https://reactjs.org/docs/react-without-es6.html" target="_blank" rel="noopener">可以</a>在没有构建通道的情况下使用React，但我们建议设置通道，以此来提高生产力。现代构建通道通常由以下部分组成：</p>
<ul>
<li>A <strong>package manager</strong>, such as <a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a> or <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>. It lets you take advantage of a vast ecosystem of third-party packages, and easily install or update them.</li>
<li>A <strong>bundler</strong>, such as <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> or <a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>. It lets you write modular code and bundle it together into small packages to optimize load time.</li>
<li>A compiler such as <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>. It lets you write modern JavaScript code that still works in older browsers.</li>
</ul>
<hr>
<ul>
<li>一个<strong>包管理器</strong>，如<a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a>或<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>。它可让您充分利用第三方软件包的完整的生态系统，并轻松安装或更新它们。</li>
<li>一个<strong>捆绑器</strong>，如<a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a>或<a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>。它允许您编写模块化代码，并将它们组合在一起成为小包，以优化加载时间。</li>
<li>一个<strong>编辑器</strong>,如<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>。它可以让你在旧版浏览器中仍然可以使用的现代JavaScript代码。</li>
</ul>
<h3 id="Installing-React-安装React"><a href="#Installing-React-安装React" class="headerlink" title="Installing React(安装React)"></a>Installing React(安装React)</h3><blockquote>
<p>Note:  </p>
<h2 id="Once-installed-we-strongly-recommend-setting-up-a-production-build-process-to-ensure-you’re-using-the-fast-version-of-React-in-production"><a href="#Once-installed-we-strongly-recommend-setting-up-a-production-build-process-to-ensure-you’re-using-the-fast-version-of-React-in-production" class="headerlink" title="Once installed, we strongly recommend setting up a production build process to ensure you’re using the fast version of React in production."></a><p style="margin:0px">Once installed, we strongly recommend setting up a production build process to ensure you’re using the fast version of React in production.</p></h2><p>注意:<br>一旦完成安装，我们强烈建议您设置生成的构建流程，以此确保您可以在开发环境中使用更快版本的React。</p>
</blockquote>
<p>We recommend using <a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a> or <a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a> for managing front-end dependencies. If you’re new to package managers, the <a href="https://yarnpkg.com/en/docs/getting-started" target="_blank" rel="noopener">Yarn documentation</a> is a good place to get started.</p>
<p>我们建议使用<a href="https://yarnpkg.com/" target="_blank" rel="noopener">Yarn</a>或者<a href="https://www.npmjs.com/" target="_blank" rel="noopener">npm</a>来管理前端依赖。如果您是新接触包管理器的开发者，<a href="https://yarnpkg.com/en/docs/getting-started" target="_blank" rel="noopener">Yarn的文档</a>是一个开始学习的不错的地方。</p>
<p>To install React with Yarn, run:</p>
<p>使用Yarn安装React，请运行：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">yarn init</span><br><span class="line">yarn add react react-dom</span><br></pre></td></tr></table></figure>
<p>如果使用npm安装React，请运行：<br><figure class="highlight coffeescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">npm</span> init</span><br><span class="line"><span class="built_in">npm</span> install --save react react-dom</span><br></pre></td></tr></table></figure></p>
<p>Both Yarn and npm download packages from the <a href="http://npmjs.com/" target="_blank" rel="noopener">npm registry</a>.</p>
<p>Yarn和npm都从<a href="http://npmjs.com/" target="_blank" rel="noopener">npm注册表</a>中下载软件包。</p>
<blockquote>
<p>Note:<br>To prevent potential incompatibilities, all react packages should use the same version. (This includes <code>react</code>, <code>react-dom</code>, <code>react-test-renderer</code>, etc.)</p>
</blockquote>
<hr>
<blockquote>
<p>注意：<br>为了避免潜在的不兼容性，所有的react包都应该使用相同的版本。（这包括<code>react</code>, <code>react-dom</code>, <code>react-test-renderer</code>等等。）</p>
</blockquote>
<h3 id="Enabling-ES6-and-JSX-启用ES6和JSX"><a href="#Enabling-ES6-and-JSX-启用ES6和JSX" class="headerlink" title="Enabling ES6 and JSX(启用ES6和JSX)"></a>Enabling ES6 and JSX(启用ES6和JSX)</h3><p>We recommend using React with <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a> to let you use ES6 and JSX in your JavaScript code. ES6 is a set of modern JavaScript features that make development easier, and JSX is an extension to the JavaScript language that works nicely with React.</p>
<p>我们建议在React上使用<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>以便让您在您的JavaScript代码中使用ES6和JSX。ES6包括一系列的现代化JavaScript特性，以便让开发更容易，并且JSX是一个JavaScript语言的扩展，以便让React工作更方便。</p>
<p>The <a href="https://babeljs.io/docs/setup/" target="_blank" rel="noopener">Babel setup instructions</a> explain how to configure Babel in many different build environments. Make sure you install <a href="http://babeljs.io/docs/plugins/preset-react/#basic-setup-with-the-cli-" target="_blank" rel="noopener">babel-preset-react</a> and <a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="noopener">babel-preset-env</a> and enable them in your <a href="http://babeljs.io/docs/usage/babelrc/" target="_blank" rel="noopener">.babelrc configuration</a>, and you’re good to go.</p>
<p><a href="https://babeljs.io/docs/setup/" target="_blank" rel="noopener">Babel设置介绍</a>解释了如何在许多不同的构建环境中配置Babel。以此可以确保您安装了<a href="http://babeljs.io/docs/plugins/preset-react/#basic-setup-with-the-cli-" target="_blank" rel="noopener">babel-preset-react</a>和<a href="http://babeljs.io/docs/plugins/preset-env/" target="_blank" rel="noopener">babel-preset-env</a>，并在你的<a href="http://babeljs.io/docs/usage/babelrc/" target="_blank" rel="noopener">.babelrc configuration</a>中启用它们，并且可以方便访问。</p>
<h3 id="Hello-World-with-ES6-and-JSX-使用ES6和JSX编写Hello-World"><a href="#Hello-World-with-ES6-and-JSX-使用ES6和JSX编写Hello-World" class="headerlink" title="Hello World with ES6 and JSX(使用ES6和JSX编写Hello World)"></a>Hello World with ES6 and JSX(使用ES6和JSX编写Hello World)</h3><p>We recommend using a bundler like <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> or <a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>, so you can write modular code and bundle it together into small packages to optimize load time.</p>
<p>我们建议使用像<a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a>或者<a href="http://browserify.org/" target="_blank" rel="noopener">Browserify</a>这样的捆绑器，这样您就可以编写现代化代码并将他们绑定在小的包上以优化加载时间。</p>
<p>The smallest React example looks like this：</p>
<p>最小的React案例如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> React <span class="keyword">from</span> <span class="string">'react'</span>;</span><br><span class="line"><span class="keyword">import</span> ReactDOM <span class="keyword">from</span> <span class="string">'react-dom'</span>;</span><br><span class="line"></span><br><span class="line">ReactDOM.render(</span><br><span class="line">  &lt;h1&gt;Hello, world!<span class="xml"><span class="tag">&lt;/<span class="name">h1</span>&gt;</span></span>,</span><br><span class="line">  <span class="built_in">document</span>.getElementById(<span class="string">'root'</span>)</span><br><span class="line">);</span><br></pre></td></tr></table></figure>
<p>This code renders into a DOM element with the id of <code>root</code>, so you need <code><div id="root"></div> </code>somewhere in your HTML file.</p>
<p>这些代码会在一个id为<code>root</code>的DOM元素上渲染，所以您需要在您的HTML文件上有<code><div id="root"></div></code>。</p>
<p>Similarly, you can render a React component inside a DOM element somewhere inside your existing app written with any other JavaScript UI library.</p>
<p>相似的，您可以在现有的，由其他任何JavaScript UI库编写的应用程序内的某个DOM元素内部渲染一个React组件。</p>
<p><a href="https://reactjs.org/docs/integrating-with-other-libraries.html#integrating-with-other-view-libraries" target="_blank" rel="noopener">Learn more about integrating React with existing code.</a></p>
<p><a href="https://reactjs.org/docs/integrating-with-other-libraries.html#integrating-with-other-view-libraries" target="_blank" rel="noopener">了解有关将React与现有代码集成的更多信息。</a></p>
<h3 id="A-Complete-Example-一个完整的例子"><a href="#A-Complete-Example-一个完整的例子" class="headerlink" title="A Complete Example(一个完整的例子)"></a>A Complete Example(一个完整的例子)</h3><p>You can find step-by-step instructions detailing a basic implementation from scratch, including Babel and Webpack setup <a href="https://medium.com/@JedaiSaboteur/creating-a-react-app-from-scratch-f3c693b84658" target="_blank" rel="noopener">here</a>.</p>
<p>您可以从零开始找到详细的说明,<a href="https://medium.com/@JedaiSaboteur/creating-a-react-app-from-scratch-f3c693b84658" target="_blank" rel="noopener">这</a>也包括如何设置Babel和Webpack。</p>
<h3 id="Development-and-Production-Versions-开发和生成环境的版本"><a href="#Development-and-Production-Versions-开发和生成环境的版本" class="headerlink" title="Development and Production Versions(开发和生成环境的版本)"></a>Development and Production Versions(开发和生成环境的版本)</h3><p>By default, React includes many helpful warnings. These warnings are very useful in development.</p>
<p>通常情况下，React包括许多有用的警告。这些警告对于开发非常有用。</p>
<p><strong>However, they make the development version of React larger and slower so you should use the production version when you deploy the app.</strong></p>
<p><strong>但是，它们会使React的开发版本变得更大并且更慢，所以当您部署应用程序时，请使用生产版本</strong></p>
<p>Learn <a href="https://reactjs.org/docs/optimizing-performance.html#use-the-production-build" target="_blank" rel="noopener">how to tell if your website is serving the right version of React</a>, and how to configure the production build process most efficiently:</p>
<p>了解<a href="https://reactjs.org/docs/optimizing-performance.html#use-the-production-build" target="_blank" rel="noopener">如何判断您的网站是否提供正确版本的React</a>，以及如何最有效地配置生产构建过程：</p>
<ul>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#create-react-app" target="_blank" rel="noopener">Creating a Production Build with Create React App</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#single-file-builds" target="_blank" rel="noopener">Creating a Production Build with Single-File Builds</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#brunch" target="_blank" rel="noopener">Creating a Production Build with Brunch</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#browserify" target="_blank" rel="noopener">Creating a Production Build with Browserify</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#rollup" target="_blank" rel="noopener">Creating a Production Build with Rollup</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#webpack" target="_blank" rel="noopener">Creating a Production Build with webpack</a></li>
</ul>
<hr>
<ul>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#create-react-app" target="_blank" rel="noopener">使用Create React App来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#single-file-builds" target="_blank" rel="noopener">使用单个文件构建来实现生产环境构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#brunch" target="_blank" rel="noopener">使用Brunch来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#browserify" target="_blank" rel="noopener">使用Browserify来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#rollup" target="_blank" rel="noopener">使用Rollup来实现生产环境的构建</a></li>
<li><a href="https://reactjs.org/docs/optimizing-performance.html#webpack" target="_blank" rel="noopener">使用webpack来实现生产环境的构建</a></li>
</ul>
<h3 id="Using-a-CDN-使用CDN"><a href="#Using-a-CDN-使用CDN" class="headerlink" title="Using a CDN(使用CDN)"></a>Using a CDN(使用CDN)</h3><p>If you don’t want to use npm to manage client packages, the <code>react</code> and <code>react-dom</code> npm packages also provide single-file distributions in <code>umd</code> folders. See the <a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">CDN</a> page for links.</p>
<p>如果您不想用npm来管理客户端的包，<code>react</code>和<code>react-dom</code>的npm的包也提供在<code>umd</code>单个文件的发布。请<a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">CDN</a>查看相关链接。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 02.Add React to a New Application]]></title>
      <url>/2018/05/03/react/01.Try_React/02.Add_React_to_a_New_Application/</url>
      <content type="html"><![CDATA[<h2 id="Add-React-to-a-New-Application-在一个新的应用上添加React"><a href="#Add-React-to-a-New-Application-在一个新的应用上添加React" class="headerlink" title="Add React to a New Application(在一个新的应用上添加React)"></a>Add React to a New Application(在一个新的应用上添加React)</h2><p>The easiest way to get started on a new React project is by using a starter kit.</p>
<p>最简单的开始一个新的React项目的方式是使用一个入门套件。</p>
<blockquote>
<p>Note:<br>This page describes setting up a single-page application with everything you need for a comfortable development workflow, including linting, testing, production optimizations, and more. Full-featured tools like these require some time and disk space to install.<br>If you are looking for a lightweight environment to experiment with React, check out the <a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">Try React</a> page instead. <strong>A <a href="https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html" target="_blank" rel="noopener">single HTML file</a> is enough to get you started!</strong><br>Finally, if you’re not building a single-page application, you can either <a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">add React to your existing build pipeline</a> or <a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">use it from CDN</a> and <a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">without a build step</a>.</p>
</blockquote>
<hr>
<blockquote>
<p>注意:<br>本页面介绍如何设置一个单页面应用程序，其中包含您需要的所有功能以实现完整的开发工作流程，包括linting，测试，生产优化等。像这些包括全功能的工具需要一些时间和磁盘空间来安装。<br>如果您在寻找一个轻量级的环境来使用React，请查看<a href="https://reactjs.org/docs/try-react.html" target="_blank" rel="noopener">尝试React</a>页面。<strong><a href="https://raw.githubusercontent.com/reactjs/reactjs.org/master/static/html/single-file-example.html" target="_blank" rel="noopener">一个简单的HTML文件</a>足以让您开始入门！</strong><br>最后，如果您不是在搭建一个单页面的应用，您可以查看<a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">将React添加到您现存的环境上</a> or <a href="https://reactjs.org/docs/cdn-links.html" target="_blank" rel="noopener">从CDN使用React</a> and <a href="https://reactjs.org/docs/react-without-jsx.html" target="_blank" rel="noopener">不适用搭建步骤</a>.</p>
</blockquote>
<h3 id="Create-React-App-创建React应用"><a href="#Create-React-App-创建React应用" class="headerlink" title="Create React App(创建React应用)"></a>Create React App(创建React应用)</h3><p><a href="http://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">Create React App</a> is the best way to start building a new React single page application. It sets up your development environment so that you can use the latest JavaScript features, provides a nice developer experience, and optimizes your app for production. You’ll need to have Node &gt;= 6 on your machine.</p>
<p><a href="http://github.com/facebookincubator/create-react-app" target="_blank" rel="noopener">创建React应用</a>是开始构建新的React单页应用程序的最佳方式。 它为您设置好了开发环境，以便您可以使用最新的JavaScript功能，为开发者提供了良好的体验并从生产环境上优化了您的应用程序。注意您需要保证您的开发机上的node版本大于等于6。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">npm install -g create-react-app</span><br><span class="line">create-react-app my-app</span><br><span class="line"></span><br><span class="line">cd my-app</span><br><span class="line">npm start</span><br></pre></td></tr></table></figure>
<p>If you have npm 5.2.0+ installed, you may use <a href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener">npx</a> instead.</p>
<p>如果您安装的npm版本号为5.2.0+，您也可以使用<a href="https://www.npmjs.com/package/npx" target="_blank" rel="noopener">npx</a>。</p>
<figure class="highlight dsconfig"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">npx </span><span class="built_in">create-react-app</span> <span class="string">my-app</span></span><br><span class="line"><span class="string"></span></span><br><span class="line"><span class="string">cd </span><span class="string">my-app</span></span><br><span class="line"><span class="string">npm </span><span class="string">start</span></span><br></pre></td></tr></table></figure>
<p>Create React App doesn’t handle backend logic or databases; it just creates a frontend build pipeline, so you can use it with any backend you want. It uses build tools like <a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a> and <a href="https://webpack.js.org/" target="_blank" rel="noopener">webpack</a> under the hood, but works with zero configuration.</p>
<p>创建React应用不会处理后端逻辑或者数据库；它只是创建了一个前端构建通道，所以您可以使用任何您相适应的后端语言。它基于钩子上使用像<a href="http://babeljs.io/" target="_blank" rel="noopener">Babel</a>和<a href="https://webpack.js.org/" target="_blank" rel="noopener">Webpack</a>这样的构建工具，但是在使用是时为不需要配置。</p>
<p>When you’re ready to deploy to production, running npm run build will create an optimized build of your app in the build folder. You can learn more about Create React App from its <a href="https://github.com/facebookincubator/create-react-app#create-react-app-" target="_blank" rel="noopener">README</a> and the <a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents" target="_blank" rel="noopener">User Guide</a>.</p>
<p>当您准备部署到生产环境时，您可以运行<code>npm run build</code>，在<code>build</code>文件夹中创建一个优化的应用程序版本。您可以从<a href="https://github.com/facebookincubator/create-react-app#create-react-app-" target="_blank" rel="noopener">README</a>和<a href="https://github.com/facebookincubator/create-react-app/blob/master/packages/react-scripts/template/README.md#table-of-contents" target="_blank" rel="noopener">用户指南</a>中了解有关创建React应用程序的更多信息。</p>
<h3 id="Other-Starter-Kits-其他的入门套件"><a href="#Other-Starter-Kits-其他的入门套件" class="headerlink" title="Other Starter Kits(其他的入门套件)"></a>Other Starter Kits(其他的入门套件)</h3><p>We have created <a href="https://reactjs.org/community/starter-kits.html" target="_blank" rel="noopener">a curated list of third-party starter kits that we officially recommend</a>.</p>
<p>我们已经创建了<a href="https://reactjs.org/community/starter-kits.html" target="_blank" rel="noopener">我们正式推荐的第三方入门套件的策划清单</a>。</p>
<p>They slightly differ in their focus but are all production-ready, well-maintained, and don’t require configuration to get started.</p>
<p>他们的重点略有不同，但在生成环境上准备就绪，并且维护良好的，不需要配置即可开始使用。</p>
<p>You can also check out a list of <a href="https://reactjs.org/community/starter-kits.html#other-starter-kits" target="_blank" rel="noopener">other kits</a> contributed by the community.</p>
<p>您还可以查看社区贡献的<a href="https://reactjs.org/community/starter-kits.html#other-starter-kits" target="_blank" rel="noopener">其他工具包列表</a>。</p>
<h3 id="Advanced-高级"><a href="#Advanced-高级" class="headerlink" title="Advanced(高级)"></a>Advanced(高级)</h3><p>If you prefer to configure a project manually, see <a href="https://reactjs.org/docs/add-react-to-an-existing-app.html#installing-react" target="_blank" rel="noopener">Installing React</a> in the next section.</p>
<p>如果您想人工配置一个项目，请在下一章节中查看<a href="https://reactjs.org/docs/add-react-to-an-existing-app.html#installing-react" target="_blank" rel="noopener">安装React</a>。</p>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[01.Try React -- 01.Add React To A New App]]></title>
      <url>/2018/05/03/react/01.Try_React/01.Add_React_To_A_New_App/</url>
      <content type="html"><![CDATA[<h2 id="Try-React-尝试使用React"><a href="#Try-React-尝试使用React" class="headerlink" title="Try React(尝试使用React)"></a>Try React(尝试使用React)</h2><p>Try React online or set up your local development environment.</p>
<p>设置在线的react或您本地的react环境。</p>
<h3 id="Online-在线"><a href="#Online-在线" class="headerlink" title="Online(在线)"></a>Online(在线)</h3><p>If you’re just interested in playing around with React, you can use an online code playground. Try a Hello World template on <a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">CodePen</a> or <a href="https://codesandbox.io/s/new" target="_blank" rel="noopener">CodeSandbox</a>.</p>
<p>如果您只是对如何使用React有兴趣，您可以使用在线的编码器。您可以在<a href="https://reactjs.org/redirect-to-codepen/hello-world" target="_blank" rel="noopener">CodePen</a>或者 <a href="https://codesandbox.io/s/new" target="_blank" rel="noopener">CodeSandbox</a>上尝试Hello World模板。</p>
<h3 id="Minimal-HTML-Template-最小的HTML模板"><a href="#Minimal-HTML-Template-最小的HTML模板" class="headerlink" title="Minimal HTML Template(最小的HTML模板)"></a>Minimal HTML Template(最小的HTML模板)</h3><p>If you prefer to use your own text editor, you can also download this HTML file, edit it, and open it from the local filesystem in your browser. It does a slow runtime code transformation, so don’t use it in production.</p>
<p>如果您倾向于使用您自己的文本编辑器，您可以下载该HTML文件，编辑它并用浏览器在您本地文件系统上打开它。它会花费比较长的时间用来进行代码转换，所以不要在应用产品层上使用它。</p>
<h3 id="Next-Steps-下一步"><a href="#Next-Steps-下一步" class="headerlink" title="Next Steps(下一步)"></a>Next Steps(下一步)</h3><h4 id="Quick-Start"><a href="#Quick-Start" class="headerlink" title="Quick Start"></a>Quick Start</h4><ul>
<li>Head over to the <a href="https://reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">Quick Start</a> section for a step-by-step introduction to React concepts.</li>
<li><p>Try the <a href="https://reactjs.org/tutorial/tutorial.html" target="_blank" rel="noopener">Tutorial</a> for a hands-on practical example.</p>
</li>
<li><p>从<a href="https://reactjs.org/docs/hello-world.html" target="_blank" rel="noopener">快速开始</a>部分，开始一步一步地熟悉React的内容。</p>
</li>
<li>尝试<a href="https://reactjs.org/tutorial/tutorial.html" target="_blank" rel="noopener">教程</a>部分，开始上手的练习。</li>
</ul>
<h4 id="Complete-Development-Environment-完成开发环境"><a href="#Complete-Development-Environment-完成开发环境" class="headerlink" title="Complete Development Environment(完成开发环境)"></a>Complete Development Environment(完成开发环境)</h4><p>The lightweight solutions above are the best fit if you are new to React or just experimenting.</p>
<p>如果您是新接触React，或者只是想尝试一下React的话，这种轻量级解决方案是最适合的。</p>
<p>When you are ready to build your first application with React, check out the install guides below. These setups are designed to get you up and running with a great developer experience and are ready for production. They include linting, testing, and optimizations built-in; however, they require more time and disk space to set up and install.</p>
<p>当您开始准备使用React搭建您第一个应用时，请先阅读下面的安装指南。这些步骤的目的是在让您在开发过程中获得丰富的开发体验，并且可以随时投入生产环境中使用。它们包括linting，测试和内置优化; 但是，它们需要更多时间和磁盘空间来设置和安装。</p>
<ul>
<li><a href="https://reactjs.org/docs/add-react-to-a-new-app.html" target="_blank" rel="noopener">Add React to a New App</a>: Create a new app with a fully-featured starter kit.</li>
<li><p><a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">Add React to an Existing App</a>: Add React to a build system or a larger app.</p>
</li>
<li><p><a href="https://reactjs.org/docs/add-react-to-a-new-app.html" target="_blank" rel="noopener">Add React to a New App</a>:使用包括全套功能的入门套件来创建新应用程序。</p>
</li>
<li><a href="https://reactjs.org/docs/add-react-to-an-existing-app.html" target="_blank" rel="noopener">Add React to an Existing App</a>:构建系统或更大的应用程序上添加使用React。</li>
</ul>
]]></content>
      
        <categories>
            
            <category> react document </category>
            
        </categories>
        
        
        <tags>
            
            <tag> react document </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript对象与继承---单一继承.md]]></title>
      <url>/2018/03/16/blog/problem/Javascript_Objects_and_Inheritance/</url>
      <content type="html"><![CDATA[<h2 id="JavaScript对象与继承–单一对象"><a href="#JavaScript对象与继承–单一对象" class="headerlink" title="JavaScript对象与继承–单一对象"></a>JavaScript对象与继承–单一对象</h2><p>说真的，这次的博客我写了三个小时硬是一点都没写出来，洋洋洒洒把自己最近的心情写了1000多字，但是感觉自己太幼稚，又删了;然后打算写大三时候给前女友写的主界面和音乐播放器，想了想，算了吧，往事随风，又删了，现在两手空空，然后纠结了半个小时，只能是写写无关痛痒的问题。</p>
<p>哈哈哈在一小时后我终于找到了这个比较符合我的情况的内容哈哈哈</p>
<p>原文在<a href="http://speakingjs.com/es5/ch17.html#single_objects" target="_blank" rel="noopener">Objects and Inheritance</a>中,不容易呀。</p>
<p>概括的讲所有的js对象都是从字符串到值的映射，一个对象中的某一项（键，值对）称作对象的属性。属性的key始终是一个字符串而值可以是任何js值，包括函数。方法是指值为函数的属性。</p>
<h3 id="属性的种类"><a href="#属性的种类" class="headerlink" title="属性的种类"></a>属性的种类</h3><p>三种属性:</p>
<ol>
<li>属性（Properties，或称为数据属性） 普通属性，在一个对象里面的一个键值对包括方法，最常用属性。</li>
<li>访问器(Accessors，或者叫访问属性) 类似于读写属性的特殊方法。属性值存在普通属性中，而访问属性可以计算他们的值。你可以把他们看作是虚拟的属性，比如（getter 和 setter）.</li>
<li>内置属性(Internal property) 只存在于ECMAscript规范当中，他们不能被js直接访问，但可以间接的方式访问到。规范里规定将这种属性放在[[]]当中，比如[[Property]]吃有一个对象的原型，它可以通过Object.getPrototypeOf() 访问到。</li>
</ol>
<h3 id="对象字面量"><a href="#对象字面量" class="headerlink" title="对象字面量"></a>对象字面量</h3><p>JavaScript对象字面量允许你直接的创建简单的对象（Object直接实例）。</p>
<p>EX:<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jane = &#123;</span><br><span class="line">    name: <span class="string">'Jane'</span>,</span><br><span class="line">    describe: <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Person named '</span>+<span class="keyword">this</span>.name;  <span class="comment">// (1)</span></span><br><span class="line">    &#125;,  <span class="comment">// (2)</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>你可能有这样的印象，对象仅仅是字符串到值的映射。事实上远不止这些，有一些真正意义上的通用对象。</p>
<p>比如你可以做对象的继承，还可以保护对象不被修改。直接创建对象的功能是标准的js特性之一：你可以在没有类的前提下创建一个正确的对象，然后再对他进行抽象。</p>
<p>例如：构造函数（constructors）大体和其他语言的类相似，我们在后面会讲到。</p>
<h3 id="点运算符-通过固定值来访问属性"><a href="#点运算符-通过固定值来访问属性" class="headerlink" title="点运算符 (.): 通过固定值来访问属性"></a>点运算符 (.): 通过固定值来访问属性</h3><p>点运算符提供了一种简洁的语法来访问属性,属性的名称必须是合法标识符. 你可以用中括号来读写任意名称的属性.</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> jane = &#123;</span><br><span class="line">    name: <span class="string">'Jane'</span>,</span><br><span class="line"></span><br><span class="line">    describe: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="string">'Person named '</span>+<span class="keyword">this</span>.name;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<h3 id="获取属性"><a href="#获取属性" class="headerlink" title="获取属性"></a>获取属性</h3><p>点操作符获取属性 (读值).例如:</p>
<figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; jane<span class="selector-class">.name</span>  <span class="comment">// get property `name`</span></span><br><span class="line"><span class="string">'Jane'</span></span><br><span class="line">&gt; jane<span class="selector-class">.describe</span>  <span class="comment">// get property `describe`</span></span><br><span class="line">[Function]</span><br></pre></td></tr></table></figure>
<p>如果属性不存在则返回 undefined:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> jane.unknownProperty</span></span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>
<h3 id="调用方法"><a href="#调用方法" class="headerlink" title="调用方法"></a>调用方法</h3><p>也可以调用方法:</p>
<figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; jane.<span class="built_in">describe</span>()  // call <span class="built_in">method</span> `<span class="built_in">describe</span>`</span><br><span class="line">'Person named Jane'</span><br></pre></td></tr></table></figure>
<h3 id="设置属性"><a href="#设置属性" class="headerlink" title="设置属性"></a>设置属性</h3><p>可以用赋值符=来给.指向的属性赋值:</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> jane.name = <span class="string">'John'</span>;  // <span class="built_in">set</span> property `name`</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> jane.describe()</span></span><br><span class="line">'Person named John'</span><br></pre></td></tr></table></figure>
<p>如果设置的属性不存在在赋值的时候就自动创建一个属性.如果存在就修改该属性。</p>
<h3 id="删除属性"><a href="#删除属性" class="headerlink" title="删除属性"></a>删除属性</h3><p>delete操作符可以完全的从对象里面删除一个属性（键值对）：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> var obj = &#123; hello: <span class="string">'world'</span> &#125;;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> delete obj.hello</span></span><br><span class="line">true</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj.hello</span></span><br><span class="line">undefined</span><br></pre></td></tr></table></figure>
<p>如果你仅仅给一个属性设置为undefined，这个属性会仍然存在，而且这个对象包含这个键：</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> var obj = &#123; foo: <span class="string">'a'</span>, bar: <span class="string">'b'</span> &#125;;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj.foo = undefined;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Object.keys(obj)</span></span><br><span class="line">[ 'foo', 'bar' ]</span><br></pre></td></tr></table></figure>
<p>但是如果你将属性删除那么他的键就不存在了</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">delete</span> obj.foo</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">[ <span class="string">'bar'</span> ]</span><br></pre></td></tr></table></figure>
<p>delete只影响一个对象的直接属性（非继承的，自有属性）。并不会删除对象的原型。</p>
<p>Tip:慎用delete操作符，大多数现代化js引擎都会针对构造函数的创建实例进行优化，前提是这些实例不会发生形态改变（就是说没有删除或者添加属性的），但是删除属性会破坏这种优化。</p>
<h3 id="delete的返回值"><a href="#delete的返回值" class="headerlink" title="delete的返回值"></a>delete的返回值</h3><p>如果属性是一个自有属性且不能删除，那么delete会反回false，其他情况返回true。<br>例子：<br>作为准备，我们用Object.defineProperty创建一个不被删除自有属性</p>
<figure class="highlight yaml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">var</span> <span class="string">obj</span> <span class="string">=</span> <span class="string">&#123;&#125;;</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,</span> <span class="string">'canBeDeleted'</span><span class="string">,</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    value:</span> <span class="number">123</span><span class="string">,</span></span><br><span class="line"><span class="attr">    configurable:</span> <span class="literal">true</span></span><br><span class="line"><span class="string">&#125;);</span></span><br><span class="line"><span class="string">Object.defineProperty(obj,</span> <span class="string">'cannotBeDeleted'</span><span class="string">,</span> <span class="string">&#123;</span></span><br><span class="line"><span class="attr">    value:</span> <span class="number">456</span><span class="string">,</span></span><br><span class="line"><span class="attr">    configurable:</span> <span class="literal">false</span></span><br><span class="line"><span class="string">&#125;);</span></span><br></pre></td></tr></table></figure>
<p>delete cannotBeDeleted 时候返回 false :</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">delete</span> obj.cannotBeDeleted</span><br><span class="line"><span class="literal">false</span></span><br></pre></td></tr></table></figure>
<p>其他情况下delete 返回 true:</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">delete</span> obj.doesNotExist</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="keyword">delete</span> obj.canBeDeleted</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<p>即使delete没有起作用也会返回true (继承的属性是不会被移除的):</p>
<figure class="highlight n1ql"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">delete</span> obj.<span class="built_in">toString</span></span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; obj.<span class="built_in">toString</span> // still there</span><br><span class="line">[<span class="keyword">Function</span>: <span class="built_in">toString</span>]</span><br></pre></td></tr></table></figure>
<h3 id="特殊属性键"><a href="#特殊属性键" class="headerlink" title="特殊属性键"></a>特殊属性键</h3><p>虽然你不能使用保留字作为变量名，但是你可以把他们作为属性键。</p>
<figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> var obj = &#123; var: <span class="string">'a'</span>, <span class="keyword">function</span>: <span class="string">'b'</span> &#125;;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj.var</span></span><br><span class="line">'a'</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj.function</span></span><br><span class="line">'b'</span><br></pre></td></tr></table></figure>
<h3 id="数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用-来访问："><a href="#数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用-来访问：" class="headerlink" title="数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用[]来访问："></a>数字也可以作为属性键，但会被解析成字符串。点操作符不能访问他们（只能访问键为标识符的属性）所以要用[]来访问：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> var obj = &#123; 0.7: <span class="string">'abc'</span> &#125;;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Object.keys(obj)</span></span><br><span class="line">[ '0.7' ]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj[<span class="string">'0.7'</span>]</span></span><br><span class="line">'abc'</span><br></pre></td></tr></table></figure>
<h3 id="对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用-来访问。"><a href="#对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用-来访问。" class="headerlink" title="对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用[]来访问。"></a>对象字面量，同样允许你使用其他任意字符串来做为键，但是你必须用上单引号，且需要用[]来访问。</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> var obj = &#123; <span class="string">'not an identifier'</span>: 123 &#125;;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> Object.keys(obj)</span></span><br><span class="line">[ 'not an identifier' ]</span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj[<span class="string">'not an identifier'</span>]</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<p>中括号 ([]): 通过计算出来的键访问属性<br>中括号可以通过表达式引用一个属性。</p>
<h3 id="用中括号获取属性："><a href="#用中括号获取属性：" class="headerlink" title="用中括号获取属性："></a>用中括号获取属性：</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> var obj = &#123; someProperty: <span class="string">'abc'</span> &#125;;</span></span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj[<span class="string">'some'</span> + <span class="string">'Property'</span>]</span></span><br><span class="line">'abc'</span><br><span class="line"></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> var propKey = <span class="string">'someProperty'</span>;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj[propKey]</span></span><br><span class="line">'abc'</span><br></pre></td></tr></table></figure>
<h3 id="非标识符"><a href="#非标识符" class="headerlink" title="非标识符:"></a>非标识符:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> var obj = &#123; <span class="string">'not an identifier'</span>: 123 &#125;;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj[<span class="string">'not an identifier'</span>]</span></span><br><span class="line">123</span><br></pre></td></tr></table></figure>
<h3 id="表达式，转换成字符串"><a href="#表达式，转换成字符串" class="headerlink" title="表达式，转换成字符串:"></a>表达式，转换成字符串:</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> var obj = &#123; <span class="string">'6'</span>: <span class="string">'bar'</span> &#125;;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj[3+3]  // key: the string <span class="string">'6'</span></span></span><br><span class="line">'bar'</span><br></pre></td></tr></table></figure>
<h3 id="用中括号调用方法"><a href="#用中括号调用方法" class="headerlink" title="用中括号调用方法"></a>用中括号调用方法</h3><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> obj = &#123; myMethod: <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123; <span class="keyword">return</span> <span class="literal">true</span> &#125; &#125;;</span><br><span class="line">&gt; obj[<span class="string">'myMethod'</span>]()</span><br><span class="line"><span class="literal">true</span></span><br></pre></td></tr></table></figure>
<h3 id="用中括号设置属性"><a href="#用中括号设置属性" class="headerlink" title="用中括号设置属性"></a>用中括号设置属性</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">&gt;</span><span class="bash"> var obj = &#123;&#125;;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj[<span class="string">'anotherProperty'</span>] = <span class="string">'def'</span>;</span></span><br><span class="line"><span class="meta">&gt;</span><span class="bash"> obj.anotherProperty</span></span><br><span class="line">'def'</span><br></pre></td></tr></table></figure>
<h3 id="用中括号删除属性"><a href="#用中括号删除属性" class="headerlink" title="用中括号删除属性"></a>用中括号删除属性</h3><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&gt; <span class="keyword">var</span> obj = &#123; <span class="string">'not an identifier'</span>: <span class="number">1</span>, <span class="attr">prop</span>: <span class="number">2</span> &#125;;</span><br><span class="line">&gt; <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">[ <span class="string">'not an identifier'</span>, <span class="string">'prop'</span> ]</span><br><span class="line">&gt; <span class="keyword">delete</span> obj[<span class="string">'not an identifier'</span>]</span><br><span class="line"><span class="literal">true</span></span><br><span class="line">&gt; <span class="built_in">Object</span>.keys(obj)</span><br><span class="line">[ <span class="string">'prop'</span> ]</span><br></pre></td></tr></table></figure>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Javascript闭包及相关问题]]></title>
      <url>/2018/03/09/blog/problem/Javascript%E9%97%AD%E5%8C%85/</url>
      <content type="html"><![CDATA[<h2 id="Javascript闭包及相关问题"><a href="#Javascript闭包及相关问题" class="headerlink" title="Javascript闭包及相关问题"></a>Javascript闭包及相关问题</h2><p>基本概念：闭包是指有权访问另一个函数作用域中的变量的函数。</p>
<p>当某个函数第一次被调用时，会创建一个执行环境及相应的作用域链，并把作用域链赋值给一个特殊的内部属性[[scope]]。然后使用this，arguments和其他的值初始化函数的活动对象。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">compare</span>(<span class="params">value1, value2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(value1 &lt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> <span class="keyword">if</span>(value1 &gt; value2) &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">var</span> result = compare(<span class="number">5</span>,<span class="number">10</span>);</span><br></pre></td></tr></table></figure>
<p>在全局作用域中调用了compare函数，会创建一个compare的活动对象，其中会包含this，arguments，value1，value2，而在全局执行环境中，会有this，result，arguments，位于作用域链的第二层。</p>
<p>后台在每个执行环境中都有一个表示变量的对象–变量对象。全局环境的变量对象始终存在，而局部环境的变量对象在函数执行时存在。</p>
<p>在创建compare函数时，会创建一个包含全局变量对象的活动对象，此时活动对象指向作用域链，而作用域链指向[[scope]]属性。当调用compare函数时，会创建一个compare的执行环境，<b>这个执行环境会复制函数的[[scope]]属性中的作用域链</b>，之后这个局部作用域链会被推入执行环境作用域链的前端，所以，对于compare函数而言，其作用域链包含本地活动对象和全局变量对象。因此，<b>作用域链的本质是一个指向变量对象的指针列表，只引用，但不包含变量对象。</b></p>
<p>正常情况下，在函数中访问变量，会沿着作用域链搜索对应名字的变量。一般在函数执行完后，局部活动对象就会被销毁，内存中只有全局作用域。</p>
<p>闭包：在另一个函数内部定义的函数会将包括它的函数的活动对象添加到它的作用域上。</p>
<figure class="highlight ceylon"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">function</span> createComparisonFunction(propertyName) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="keyword">function</span>(<span class="keyword">object</span><span class="number">1</span>, <span class="keyword">object</span><span class="number">2</span>) &#123;</span><br><span class="line">        var <span class="keyword">value</span><span class="number">1</span> = <span class="keyword">object</span><span class="number">1</span>[propertyName];</span><br><span class="line">        var <span class="keyword">value</span><span class="number">2</span> = <span class="keyword">object</span><span class="number">2</span>[propertyName];</span><br><span class="line">        <span class="keyword">if</span>(<span class="keyword">value</span><span class="number">1</span> &lt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> -<span class="number">1</span>; </span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span>(<span class="keyword">value</span><span class="number">1</span> &gt; <span class="keyword">value</span><span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>注意，在return一个匿名函数后，要添加上’;’</p>
<p>当执行以下两部操作时：<br><figure class="highlight ebnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="attribute">var compareName</span> = createComparisonFunction(<span class="string">'name'</span>);</span><br><span class="line"><span class="attribute">var result</span> = compare(&#123;name:<span class="string">'lpld'</span>&#125;, &#123;name:<span class="string">'plws'</span>&#125;);</span><br></pre></td></tr></table></figure></p>
<p>在compare()时，向上面一样，会有全局活动对象和局部活动对象两个作用域链，而根据上面说的闭包的内容：在另一个函数内部定义的函数会将包括它的函数的活动对象添加到它的作用域上。对于result而言，是createComparisonFunction的返回函数，所以也包括了compare的活动对象。所以，当createComparisonFunction返回后，<b>其执行环境的作用域链会被销毁，但是其活动对象会留在内存中。因为在匿名函数中会把其活动对象添加到匿名函数的作用域链上</b>。</p>
<p>因此，在执行compareName = null;相当于解除匿名函数的作用域链，至此该匿名函数作用域链上的活动对象（也包括外部函数内的活动对象）也都会释放。</p>
<p>闭包缺点：闭包会携带包含它的函数的作用域，换句话说，是会保留包括它的函数的活动对象。因此会占用更多的内存。（在外部函数没有被释放时，也会在内部函数的作用域链上生成新的外部函数的活动对象，会产生新的内存）。</p>
<p>this对象：</p>
<p>this永远指向调用它的函数</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><span class="line"><span class="number">1.</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'The Window'</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">'My Object'</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="keyword">this</span>.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());<span class="comment">//The Window</span></span><br><span class="line"></span><br><span class="line"><span class="number">2.</span></span><br><span class="line"><span class="keyword">var</span> name = <span class="string">'The Window'</span>;</span><br><span class="line"><span class="keyword">var</span> object = &#123;</span><br><span class="line">    name : <span class="string">'My Object'</span>,</span><br><span class="line">    getNameFunc : <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">        <span class="keyword">var</span> that = <span class="keyword">this</span>;</span><br><span class="line">        <span class="keyword">return</span> <span class="function"><span class="keyword">function</span><span class="params">()</span></span>&#123;</span><br><span class="line">            <span class="keyword">return</span> that.name;</span><br><span class="line">        &#125;;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br><span class="line">alert(object.getNameFunc()());<span class="comment">//My Object</span></span><br></pre></td></tr></table></figure>
<p>根据书中的内容，匿名函数的执行环境具有全局性，所以第一个返回的是window，第二个是object，在执行函数时，当执行到object.getNameFunc()时，此时的name对应的是object，这时执行匿名函数，相当于返回全局中的name，即是window。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[JavaScript学习笔记（1）]]></title>
      <url>/2018/03/02/blog/problem/JavaScript%E5%9F%BA%E6%9C%AC1/</url>
      <content type="html"><![CDATA[<h2 id="JavaScrip学习笔记（1）"><a href="#JavaScrip学习笔记（1）" class="headerlink" title="JavaScrip学习笔记（1）"></a>JavaScrip学习笔记（1）</h2><h3 id="JavaScript函数表达式和函数声明"><a href="#JavaScript函数表达式和函数声明" class="headerlink" title="JavaScript函数表达式和函数声明"></a>JavaScript函数表达式和函数声明</h3><p>首先，来了解一下函数表达式和函数声明：</p>
<p>在ECMAScript中，创建函数的最常用的两个方法是函数表达式和函数声明，两者还是有一定的区别，在ECMA规范中提到：函数声明必须带有标示符（Identifier）（就是大家常说的函数名称），而函数表达式则可以省略这个标示符，即：</p>
<p>函数声明:</p>
<p>function 函数名称 (参数：可选){ 函数体 }</p>
<p>函数表达式：</p>
<p>function 函数名称（可选）(参数：可选){ 函数体 }</p>
<p>所以，可以看出，如果不声明函数名称，它肯定是表达式，可如果声明了函数名称，ECMAScript是通过上下文来区分的，如果function foo(){}是作为赋值表达式的一部分的话，那它就是一个函数表达式，如果function foo(){}被包含在一个函数体内，或者位于程序的最顶部的话，那它就是一个函数声明。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 声明，因为它是程序的一部分</span></span><br><span class="line"><span class="keyword">var</span> bar = <span class="function"><span class="keyword">function</span> <span class="title">foo</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 表达式，因为它是赋值表达式的一部分</span></span><br><span class="line"><span class="keyword">new</span> <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125;; <span class="comment">// 表达式，因为它是new表达式</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">bar</span>(<span class="params"></span>)</span>&#123;&#125; <span class="comment">// 声明，因为它是函数体的一部分</span></span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>还有一种函数表达式不太常见，就是被括号括住的(function foo(){})，他是表达式的原因是因为括号 ()是一个分组操作符，它的内部只能包含表达式，我们来看几个例子：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125; <span class="comment">// 函数声明</span></span><br><span class="line">(<span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;&#125;); <span class="comment">// 函数表达式：包含在分组操作符内</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">  (<span class="keyword">var</span> x = <span class="number">5</span>); <span class="comment">// 分组操作符，只能包含表达式而不能包含语句，这里的var就是语句</span></span><br><span class="line">&#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line"><span class="comment">// SyntaxError</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>在使用eval对JSON进行执行的时候，JSON字符串通常被包含在一个圆括号里：eval(‘(‘ + json + ‘)’)，这样做的原因就是因为分组操作符，也就是这对括号，会让解析器强制将JSON的花括号解析成表达式而不是代码块。</p>
<figure class="highlight xquery"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">try</span> &#123;</span><br><span class="line">   &#123; <span class="string">"x"</span>: <span class="number">5</span> &#125;; // <span class="string">"&#123;"</span> 和 <span class="string">"&#125;"</span> 做解析成代码块</span><br><span class="line"> &#125; <span class="keyword">catch</span>(err) &#123;</span><br><span class="line">   // SyntaxError</span><br><span class="line"> &#125;</span><br><span class="line"></span><br><span class="line"> (&#123; <span class="string">"x"</span>: <span class="number">5</span> &#125;); // 分组操作符强制将<span class="string">"&#123;"</span> 和 <span class="string">"&#125;"</span>作为对象字面量来解析</span><br></pre></td></tr></table></figure>
<p>表达式和声明存在着十分微妙的区别，函数声明会在任何表达式被解析和求值之前先被解析和求值，即使你的声明在代码的最后一行，它也会在同作用域内第一个表达式之前被解析/求值，也就是所谓的函数提升。参考如下例子，函数fn是在alert之后声明的，但是在alert执行的时候，fn已经有定义了：</p>
<figure class="highlight rust"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">alert(<span class="function"><span class="keyword">fn</span></span>());</span><br><span class="line">function <span class="function"><span class="keyword">fn</span></span>() &#123;  </span><br><span class="line">  <span class="keyword">return</span> <span class="symbol">'Hello</span> world!';</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>还有一点，函数声明在条件语句内虽然可以用，但是没有被标准化，也就是说不同的环境可能有不同的执行结果，所以这样情况下，最好使用函数表达式：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">// 千万别这样做！</span></span><br><span class="line"><span class="comment">// 因为有的浏览器会返回first的这个function，而有的浏览器返回的却是第二个</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'first'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'second'</span>;</span><br><span class="line">  &#125;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br><span class="line"></span><br><span class="line"><span class="comment">// 相反，这样情况，我们要用函数表达式</span></span><br><span class="line"><span class="keyword">var</span> foo;</span><br><span class="line"><span class="keyword">if</span> (<span class="literal">true</span>) &#123;</span><br><span class="line">  foo = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'first'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line"><span class="keyword">else</span> &#123;</span><br><span class="line">  foo = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="string">'second'</span>;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;</span><br><span class="line">foo();</span><br></pre></td></tr></table></figure>
<p>函数声明的实际规则如下：</p>
<p><b>函数声明只能出现在程序或函数体内。从句法上讲，它们 不能出现在Block（块）（{ … }）中，例如不能出现在 if、while 或 for 语句中。因为 Block（块） 中只能包含Statement语句， 而不能包含函数声明这样的源元素。另一方面，仔细看一看规则也会发现，唯一可能让表达式出现在Block（块）中情形，就是让它作为表达式语句的一部分。但是，规范明确规定了表达式语句不能以关键字function开头。而这实际上就是说，函数表达式同样也不能出现在Statement语句或Block（块）中（因为Block（块）就是由Statement语句构成的）。 </b></p>
<h3 id="函数表达式的命名"><a href="#函数表达式的命名" class="headerlink" title="函数表达式的命名"></a>函数表达式的命名</h3><p>函数表达式在实际应用中还是很常见的，但由于这种方式都是在同一作用域内，所以基本上一定要用函数表达式：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line">  <span class="keyword">var</span> contains = (<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</span><br><span class="line">  <span class="keyword">var</span> docEl = <span class="built_in">document</span>.documentElement;</span><br><span class="line"></span><br><span class="line">  <span class="keyword">if</span> (<span class="keyword">typeof</span> docEl.compareDocumentPosition != <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> (el.compareDocumentPosition(b) &amp; <span class="number">16</span>) !== <span class="number">0</span>;</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">else</span> <span class="keyword">if</span> (<span class="keyword">typeof</span> docEl.contains != <span class="string">'undefined'</span>) &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, b</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> el !== b &amp;&amp; el.contains(b);</span><br><span class="line">    &#125;;</span><br><span class="line">  &#125;</span><br><span class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span>(<span class="params">el, b</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span> (el === b) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">while</span> (el != b &amp;&amp; (b = b.parentNode) != <span class="literal">null</span>);</span><br><span class="line">    <span class="keyword">return</span> el === b;</span><br><span class="line">  &#125;;</span><br><span class="line">&#125;)();</span><br></pre></td></tr></table></figure>
<p>提到命名函数表达式，理所当然，就是它得有名字，前面的例子var bar = function foo(){};就是一个有效的命名函数表达式，但有一点需要记住：这个名字只在新定义的函数作用域内有效，因为规范规定了标示符不能在外围的作用域内有效：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> f = <span class="function"><span class="keyword">function</span> <span class="title">foo</span><span class="params">()</span></span>&#123;</span><br><span class="line">  <span class="keyword">return</span> <span class="keyword">typeof</span> foo; <span class="comment">// foo是在内部作用域内有效</span></span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">// foo在外部用于是不可见的</span></span><br><span class="line"><span class="keyword">typeof</span> foo; <span class="comment">// "undefined"</span></span><br><span class="line">f(); <span class="comment">// "function"</span></span><br></pre></td></tr></table></figure>
<h3 id="原型和原型链"><a href="#原型和原型链" class="headerlink" title="原型和原型链"></a>原型和原型链</h3><p>首先，我们可以从这几个方面理解：</p>
<p>1.原型使用方式1：</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Calculator = <span class="function"><span class="keyword">function</span> <span class="params">(decimalDigits, tax)</span> </span>&#123;</span><br><span class="line">   <span class="keyword">this</span>.decimalDigits = decimalDigits;</span><br><span class="line">   <span class="keyword">this</span>.tax = tax;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="comment">//然后，通过给Calculator对象的prototype属性赋值对象字面量来设定Calculator对象的原型。</span></span><br><span class="line">Calculator.prototype = &#123;</span><br><span class="line">   add: <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;,</span><br><span class="line">   subtract: <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">      <span class="keyword">return</span> x - y;</span><br><span class="line">   &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>这样，就可以new Calculator对象以后，就可以调用add方法来计算结果了。</p>
<p>2.原型使用方式2：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">Calculator.prototype = <span class="keyword">function</span> <span class="title"></span>() &#123;</span><br><span class="line">   add = <span class="keyword">function</span> <span class="title"></span>(x, y) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">x</span> + y;</span><br><span class="line">   &#125;,</span><br><span class="line">   subtract = <span class="keyword">function</span> <span class="title"></span>(x, y) &#123;</span><br><span class="line">      <span class="keyword">return</span> <span class="type">x</span> - y;</span><br><span class="line">   &#125;</span><br><span class="line">   <span class="keyword">return</span> &#123;</span><br><span class="line">      add: add,</span><br><span class="line">      subtract: subtract</span><br><span class="line">   &#125;</span><br><span class="line">&#125; ();</span><br></pre></td></tr></table></figure>
<p>这样我们可以new Calculator对象以后调用add方法来计算结果了。</p>
<p>以上有一个限制就是一次性设置了原型对象，我们再来说一下如何分开设置原型的每个属性吧。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BaseCalculator = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为每个实例都声明一个小数位数</span></span><br><span class="line">    <span class="keyword">this</span>.decimalDigits = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="comment">//使用原型给BaseCalculator扩展2个对象方法</span></span><br><span class="line">BaseCalculator.prototype.add = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x + y;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BaseCalculator.prototype.subtract = <span class="function"><span class="keyword">function</span> <span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">    <span class="keyword">return</span> x - y;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>首先，声明了一个BaseCalculator对象，构造函数里会初始化一个小数位数的属性decimalDigits，然后通过原型属性设置2个function，分别是add(x,y)和subtract(x,y)，当然你也可以使用前面提到的2种方式的任何一种，我们的主要目的是看如何将BaseCalculator对象设置到真正的Calculator的原型上。</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> BaseCalculator = <span class="function"><span class="keyword">function</span><span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.decimalDigits = <span class="number">2</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">BaseCalculator.prototype = &#123;</span><br><span class="line">    add: <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;,</span><br><span class="line">    subtract: <span class="function"><span class="keyword">function</span><span class="params">(x, y)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x - y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>创建完上述代码以后<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Calculator = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="comment">//为每个实例都声明一个税收数字</span></span><br><span class="line">    <span class="keyword">this</span>.tax = <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Calculator.prototype = <span class="keyword">new</span> BaseCalculator();</span><br></pre></td></tr></table></figure></p>
<p>我们可以看到Calculator的原型是指向到BaseCalculator的一个实例上，目的是让Calculator集成它的add(x,y)和subtract(x,y)这2个function，还有一点要说的是，由于它的原型是BaseCalculator的一个实例，所以不管你创建多少个Calculator对象实例，他们的原型指向的都是同一个实例。</p>
<figure class="highlight pony"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> calc = <span class="function"><span class="keyword">new</span> <span class="title">Calculator</span>();</span></span><br><span class="line"><span class="function"><span class="title">alert</span>(calc.add(<span class="number">1</span>, <span class="number">1</span>));</span></span><br><span class="line"><span class="function"><span class="comment">//BaseCalculator 里声明的decimalDigits属性，在 Calculator里是可以访问到的</span></span></span><br><span class="line"><span class="function"><span class="title">alert</span>(calc.decimalDigits);</span></span><br></pre></td></tr></table></figure>
<p>上面的代码，运行以后，我们可以看到因为Calculator的原型是指向BaseCalculator的实例上的，所以可以访问他的decimalDigits属性值，如果我不想让Calculator访问BaseCalculator的构造函数里声明:</p>
<figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> Calculator = <span class="function"><span class="keyword">function</span> <span class="params">()</span> </span>&#123;</span><br><span class="line">    <span class="keyword">this</span>.tax= <span class="number">5</span>;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line">Calculator.prototype = BaseCalculator.prototype;</span><br></pre></td></tr></table></figure>
<p>通过将BaseCalculator的原型赋给Calculator的原型，这样你在Calculator的实例上就访问不到那个decimalDigits值了，如果你访问如下代码，那将会提升出错。</p>
<figure class="highlight lisp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">var calc = new Calculator()<span class="comment">;</span></span><br><span class="line">alert(<span class="name">calc</span>.add(<span class="number">1</span>, <span class="number">1</span>))<span class="comment">;</span></span><br><span class="line">alert(<span class="name">calc</span>.decimalDigits)<span class="comment">;</span></span><br></pre></td></tr></table></figure>
<p>先是这部分内容，看的有些部分没有懂还没有写完，等第二版到了读第二版吧。。。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[2.5~2.9所遇问题]]></title>
      <url>/2018/02/09/blog/problem/2.5~2.9_questions/</url>
      <content type="html"><![CDATA[<h2 id="2-5-2-9所遇问题"><a href="#2-5-2-9所遇问题" class="headerlink" title="2.5~2.9所遇问题"></a>2.5~2.9所遇问题</h2><h3 id="一-开发所遇问题"><a href="#一-开发所遇问题" class="headerlink" title="一.开发所遇问题"></a>一.开发所遇问题</h3><p>在这次开发过程中，是真正自己做的第一个迭代版本，在开发中主要遇到的问题有：从理清思路到代码的实现；代码的格式规范与模块化；如何与后台人员沟通好。</p>
<p>1.从理清思路到代码的实现</p>
<p>这部分内容主要是因为自己以前写的代码只考虑到最后呈现的效果，没有具体深入探讨如何高效的写代码，拿生庆哥的话讲就是：没有真正明白要做什么。这个做什么不仅仅是你要实现的效果是什么，还包括你对整体项目的思路。之前我写代码都是只想到大概有哪些代码块，但是几个代码块传参是什么，怎么传，情况考虑全不全，整体的逻辑也是只有个大概的印象就开始动手，造成的结果就是每个代码块之间都有一定的耦合，没有全部拆分开，这造成的结果就是会有很多重复的代码，本来能拆分成函数的内容都没有抽象出来，每个函数功能目的不明确，有很多“胶水代码”，归根结底是因为一开始太着急动手，写代码时又没有细究逻辑，功能是完成了，但过不了组内review的关卡，所以总结一句话：解决问题从源头开始，这次实现代码后发现，原本想象的多复杂多复杂的代码，其实并没有想象中那么难，只要逻辑正确，思路正确其实还是很好解决的。</p>
<p>2.代码的格式规范与模块化</p>
<p>这次写代码的过程真真切切的明白了一个道理：良好的命名的重要性，因为一开始想的功能不全，所以在中途添加了不少变量，这就造成了不断添加变量，但是因为函数的功能性不清晰，所以在定义变量的时候又会有代码名称比较接近的结果，一开始还没觉得什么，但是写的稍微多一点就会发现，自己不知道当时为什么要用这个变量名定义了，虽然名称有一定的含义，但是有一个变量名跟预期的函数功能还是有偏差，还得重新看一遍代码的过程，也是一个不好的习惯。</p>
<p>3.如何与后台人员沟通</p>
<p>因为这次的后台是千仪哥提供的，自己刚刚来，总是觉得千仪哥做的肯定没问题，所以在看接口的时候当不满足自己这边的需求时，在检查完对应的接口功能发现有问题时，先自己偷偷的看能不能自己生产这样的过程。在中间造成了不小的麻烦，经过这件事懂得了：尊重规范，按规范办事，这样才是解决问题最有效也是最便捷的方法。</p>
<h3 id="二-如何生成一个比1px更短的边框"><a href="#二-如何生成一个比1px更短的边框" class="headerlink" title="二.如何生成一个比1px更短的边框"></a>二.如何生成一个比1px更短的边框</h3><p>因为css提供最短的就是1px的长度，这也是屏幕的最短像素，所以要生成1px的边框长度也是有一定的技巧的；</p>
<p>1.使用rgba，通过添加透明度来在视觉上减少边框的长度。</p>
<p>这个是没什么好说的，效果虽然有，但是不是一个好的解决方法。</p>
<p>2.利用box-shadow实现窄边框<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">box-shadow:<span class="number">0</span> <span class="number">0</span> <span class="number">1</span>px <span class="number">0</span> red</span><br></pre></td></tr></table></figure></p>
<p>利用了盒子阴影绘制。可以用于各种场景。但是最后的颜色会变暗，而且box-shadow不占位置，语义化不符合标准。不是实际意义的边框。</p>
<p>3.多背景渐变实现</p>
<figure class="highlight coq"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">background:</span><br><span class="line">linear-gradient(<span class="number">180</span>deg, <span class="built_in">red</span>, <span class="built_in">red</span> <span class="number">50</span>%, transparent <span class="number">50</span>%) <span class="built_in">top</span> <span class="built_in">left</span> / <span class="number">100</span>% <span class="number">1</span>px no-<span class="built_in">repeat</span>, </span><br><span class="line">linear-gradient(<span class="number">90</span>deg, <span class="built_in">red</span>, <span class="built_in">red</span> <span class="number">50</span>%, transparent <span class="number">50</span>%) <span class="built_in">top</span> <span class="built_in">right</span> / <span class="number">1</span>px <span class="number">100</span>% no-<span class="built_in">repeat</span>, </span><br><span class="line">linear-gradient(<span class="number">0</span>deg, <span class="built_in">red</span>, <span class="built_in">red</span> <span class="number">50</span>%, transparent <span class="number">50</span>%) <span class="built_in">bottom</span> <span class="built_in">right</span> / <span class="number">100</span>% <span class="number">1</span>px no-<span class="built_in">repeat</span>, </span><br><span class="line">linear-gradient(<span class="number">-270</span>deg, <span class="built_in">red</span>, <span class="built_in">red</span> <span class="number">50</span>%, transparent <span class="number">50</span>%) <span class="built_in">bottom</span> <span class="built_in">left</span> / <span class="number">1</span>px <span class="number">100</span>% no-<span class="built_in">repeat</span>;</span><br></pre></td></tr></table></figure>
<p>可以通过不同的四种角度的渐变，实现边框，颜色可以自定义。缺点是代码比较多，而且不能实现圆角。</p>
<p>4.伪类 + transform 实现</p>
<figure class="highlight css"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="selector-pseudo">:after</span>&#123;</span><br><span class="line">    <span class="attribute">content</span>: <span class="string">''</span>; </span><br><span class="line">    <span class="attribute">position</span>: absolute; </span><br><span class="line">    <span class="attribute">top</span>: <span class="number">0</span>; <span class="attribute">left</span>: <span class="number">0</span>; </span><br><span class="line">    <span class="attribute">border</span>: <span class="number">1px</span> solid red; </span><br><span class="line">    <span class="attribute">-webkit-box-sizing</span>: border-box; </span><br><span class="line">    <span class="attribute">box-sizing</span>: border-box; </span><br><span class="line">    <span class="attribute">width</span>: <span class="number">200%</span>; </span><br><span class="line">    <span class="attribute">height</span>: <span class="number">200%</span>; </span><br><span class="line">    <span class="attribute">-webkit-transform</span>: <span class="built_in">scale</span>(0.5); </span><br><span class="line">    <span class="attribute">transform</span>: <span class="built_in">scale</span>(0.5); </span><br><span class="line">    <span class="attribute">-webkit-transform-origin</span>: left top; </span><br><span class="line">    <span class="attribute">transform-origin</span>: left top; </span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>利用 :before 或者 :after 重做 border ，并 transform 的 scale 缩小一半， 然后进行绝对定位，这种方法现在没有发现问题。</p>
<h3 id="三-图的遍历"><a href="#三-图的遍历" class="headerlink" title="三.图的遍历"></a>三.图的遍历</h3><p>这部分是上次分享没有添加的内容：</p>
<p>广度优先 搜索(Breadth-First Search，BFS)和深度优先搜索(Depth-First Search，DFS)。图遍历可以用来寻找特定的顶点或寻找两个顶点之间的路径，检查图是否连通等。</p>
<p>图遍历算法的思想是必须追踪每个第一次访问的节点，并且追踪有哪些节点还没有被完全探索。对于两种图遍历算法，都需要明确指出第一个被访问的顶点。完全探索一个顶点要求我们查看该顶点的每一条边。对于每一条边所连接的没有被访问过的顶点，将其标注为被发现的，并将其加进待访问顶点列表中。</p>
<h4 id="广度优先搜索"><a href="#广度优先搜索" class="headerlink" title="广度优先搜索"></a>广度优先搜索</h4><p>广度优先搜索算法会从指定的第一个顶点开始遍历图，先访问其所有的相邻点，就像一次访问图的一层。换句话说，就是先宽后深地访问顶点。</p>
<p>以下是从顶点v开始的广度优先搜索算法所遵循的步骤。<br>(1) 创建一个队列Q。<br>(2) 将v标注为被发现的(灰色)，并将v入队列Q。<br>(3) 如果Q非空，则运行以下步骤:<br>    (a) 将u从Q中出队列;<br>    (b) 将标注u为被发现的(灰色);<br>    (c) 将u所有未被访问过的邻点(白色)入队列;<br>    (d) 将u标注为已被探索的(黑色)。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> initializeColor = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123; </span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">color</span> = [];</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;vertices.length; i++)&#123;</span><br><span class="line">         <span class="built_in">color</span>[vertices[i]] = <span class="string">'white'</span>; </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">color</span>; </span><br><span class="line">&#125;;</span><br><span class="line">    <span class="keyword">this</span>.bfs = <span class="function"><span class="keyword">function</span>(<span class="params">v, callback</span>)</span>&#123;</span><br><span class="line">        <span class="keyword">var</span> <span class="built_in">color</span> = initializeColor(),  </span><br><span class="line">        queue = <span class="keyword">new</span> Queue();</span><br><span class="line">        queue.enqueue(v);</span><br><span class="line">        <span class="keyword">while</span> (!queue.isEmpty())&#123;</span><br><span class="line">            <span class="keyword">var</span> u = queue.dequeue(), neighbors = adjList.get(u); </span><br><span class="line">            <span class="built_in">color</span>[u] = <span class="string">'grey'</span>;                    </span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;neighbors.length; i++)&#123; </span><br><span class="line">            <span class="keyword">var</span> w = neighbors[i];</span><br><span class="line">            <span class="keyword">if</span> (<span class="built_in">color</span>[w] === <span class="string">'white'</span>)&#123;</span><br><span class="line">                <span class="built_in">color</span>[w] = <span class="string">'grey'</span>;</span><br><span class="line">                queue.enqueue(w);</span><br><span class="line">            &#125; &#125;</span><br><span class="line">            <span class="built_in">color</span>[u] = <span class="string">'black'</span>; </span><br><span class="line">            <span class="keyword">if</span> (callback) &#123;    </span><br><span class="line">                callback(u);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125;;</span><br></pre></td></tr></table></figure>
<h4 id="深度优先搜索"><a href="#深度优先搜索" class="headerlink" title="深度优先搜索"></a>深度优先搜索</h4><p>深度优先搜索算法将会从第一个指定的顶点开始遍历图，沿着路径直到这条路径最后一个顶点被访问了，接着原路回退并探索下一条路径。换句话说，它是先深度后广度地访问顶点。</p>
<figure class="highlight qml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">this</span>.dfs = <span class="function"><span class="keyword">function</span>(<span class="params">callback</span>)</span>&#123;</span><br><span class="line">    <span class="keyword">var</span> <span class="built_in">color</span> = initializeColor(); </span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;vertices.length; i++)&#123; </span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">color</span>[vertices[i]] === <span class="string">'white'</span>)&#123; </span><br><span class="line">            dfsVisit(vertices[i], <span class="built_in">color</span>, callback); </span><br><span class="line">        &#125;</span><br><span class="line">    &#125; </span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> dfsVisit = <span class="function"><span class="keyword">function</span>(<span class="params">u, color, callback</span>)</span>&#123;</span><br><span class="line">    <span class="built_in">color</span>[u] = <span class="string">'grey'</span>; </span><br><span class="line">    <span class="keyword">if</span> (callback) &#123;    &#125;</span><br><span class="line">        callback(u);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> neighbors = adjList.get(u);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i=<span class="number">0</span>; i&lt;neighbors.length; i++)&#123; </span><br><span class="line">        <span class="keyword">var</span> w = neighbors[i];</span><br><span class="line">        <span class="keyword">if</span> (<span class="built_in">color</span>[w] === <span class="string">'white'</span>)&#123;</span><br><span class="line">            dfsVisit(w, <span class="built_in">color</span>, callback);</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">color</span>[u] = <span class="string">'black'</span>; </span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>以上是两个基本的图的遍历方法。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 23.Missing Number]]></title>
      <url>/2018/02/02/leetCode/array/23.Missing_Number/</url>
      <content type="html"><![CDATA[<h2 id="Problem-23-Missing-Number"><a href="#Problem-23-Missing-Number" class="headerlink" title="Problem 23.Missing Number"></a>Problem 23.Missing Number</h2><p>Given an array containing n distinct numbers taken from 0, 1, 2, …, n, find the one that is missing from the array.</p>
<p><strong>Example 1</strong></p>
<blockquote>
<p><strong>Input:</strong> [3,0,1]<br><strong>Output:</strong> 2</p>
</blockquote>
<p><strong>Example 2</strong><br><strong>Input:</strong> [9,6,4,2,3,5,7,0,1]<br><strong>Output:</strong> 8</p>
<p><strong>Note:</strong><br>Your algorithm should run in linear runtime complexity. Could you implement it using only constant extra space complexity?</p>
<p><strong>Credits:</strong><br>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p>
<p><strong>solution</strong></p>
<p>1.这道题也是比较简单，只要先对数组排好序，然后跟序数进行对比，返回不相等的下标即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> missingNumber = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b;&#125;);</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] != i) &#123;</span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 22.Maximum Product of Three Numbers]]></title>
      <url>/2018/02/02/leetCode/array/22.Maximum_Product_of_Three_Numbers/</url>
      <content type="html"><![CDATA[<h2 id="Problem-22-Maximum-Product-of-Three-Numbers"><a href="#Problem-22-Maximum-Product-of-Three-Numbers" class="headerlink" title="Problem 22.Maximum Product of Three Numbers"></a>Problem 22.Maximum Product of Three Numbers</h2><p>Given an integer array, find three numbers whose product is maximum and output the maximum product.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,3]<br><strong>Output:</strong> 6</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,3,4]<br><strong>Output:</strong> 24</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The length of the given array will be in range [3,10<sup>4</sup>] and all elements are in the range [-1000, 1000].</li>
<li>Multiplication of any three numbers in the input won’t exceed the range of 32-bit signed integer.</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.因为最短数组长度为3，所以不要考虑数组长度小于3的情况。本题的元素大小可能为负数，若都为正数或都为负数，则取前三个元素，若有正数有负数，通过查资料可以得到，此时3个数之积的最大值为max(第一大数<em>第二大数</em>第三大数， 第一大数<em>最小数</em>倒数第二小数)。这个方法可以记住。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maximumProduct = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> b-a;&#125;);</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.max(nums[nums.length - <span class="number">1</span>] * nums[nums.length - <span class="number">2</span>] * nums[<span class="number">0</span>], nums[<span class="number">0</span>] * nums[<span class="number">1</span>] * nums[<span class="number">2</span>]);</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 21. Image Smoother]]></title>
      <url>/2018/02/02/leetCode/array/21.Image_Smoother/</url>
      <content type="html"><![CDATA[<h2 id="Problem-21-Image-Smoother"><a href="#Problem-21-Image-Smoother" class="headerlink" title="Problem 21. Image Smoother"></a>Problem 21. Image Smoother</h2><p>Given a 2D integer matrix M representing the gray scale of an image, you need to design a smoother to make the gray scale of each cell becomes the average gray scale (rounding down) of all the 8 surrounding cells and itself. If a cell has less than 8 surrounding cells, then use as many as you can.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>[[1,1,1],<br> [1,0,1],<br> [1,1,1]]<br><strong>Output:</strong><br>[[0, 0, 0],<br> [0, 0, 0],<br> [0, 0, 0]]<br><strong>Explanation:</strong><br>For the point (0,0), (0,2), (2,0), (2,2): floor(3/4) = floor(0.75) = 0<br>For the point (0,1), (1,0), (1,2), (2,1): floor(5/6) = floor(0.83333333) = 0<br>For the point (1,1): floor(8/9) = floor(0.88888889) = 0</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>The value in the given matrix is in the range of [0, 255].</li>
<li>The length and width of the given matrix are in the range of [1, 150].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.这道题想了半天没想出什么好点的方法，就用最笨的方法写了，判断周围八个位置是否正常，如果正常，就计算到总额里并得到平均值。注意，js里不满1会向上取整，所以应该用Math.floor()。代码如下：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> imageSmoother = <span class="function"><span class="keyword">function</span>(<span class="params">M</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nx = M.length;</span><br><span class="line">        <span class="keyword">var</span> ny = M[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="keyword">new</span> <span class="built_in">Array</span>(nx);</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; nx; n++)&#123;</span><br><span class="line">            res[n] = <span class="keyword">new</span> <span class="built_in">Array</span>(ny);</span><br><span class="line">        &#125; ;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nx; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; ny; j++) &#123;</span><br><span class="line">                res[i][j] = smooth(M, i, j);</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">var</span> smooth = <span class="function"><span class="keyword">function</span>(<span class="params">M, x, y</span>) </span>&#123;</span><br><span class="line">        <span class="keyword">var</span> nx = M.length;</span><br><span class="line">        <span class="keyword">var</span> ny = M[<span class="number">0</span>].length;</span><br><span class="line">        <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> count = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">-1</span>; i &lt;= <span class="number">1</span>; i++) &#123;</span><br><span class="line">           <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">-1</span>; j &lt;= <span class="number">1</span>; j++) &#123;</span><br><span class="line">             <span class="keyword">if</span> (x + i &lt; <span class="number">0</span> || x + i &gt;= nx || y + j &lt; <span class="number">0</span> || y + j &gt;= ny) &#123;</span><br><span class="line">                 <span class="keyword">continue</span>;</span><br><span class="line">             &#125;</span><br><span class="line">             count++;</span><br><span class="line">             sum += M[x + i][y + j];</span><br><span class="line">           &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> <span class="built_in">Math</span>.floor(sum / count);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br> Time Complexity：O(r X c),r为M.length,c为M[0].length.</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 20.Contains Duplicate]]></title>
      <url>/2018/01/31/leetCode/array/20.Contains_Duplicate/</url>
      <content type="html"><![CDATA[<h2 id="Problem-20-Contains-Duplicate"><a href="#Problem-20-Contains-Duplicate" class="headerlink" title="Problem 20:Contains Duplicate"></a>Problem 20:Contains Duplicate</h2><p>Given an array of integers, find if the array contains any duplicates. Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.</p>
<p><strong>solution:</strong></p>
<p>1.先对数组进行sort，然后除去特殊情况下判断只要元素周围两侧元素有一个相同，就返回true，否则为false。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> containsDuplicate = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b&#125;);</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>) <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">2</span> &amp;&amp; nums[<span class="number">0</span>] ==nums[<span class="number">1</span>]) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; nums.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == nums[i<span class="number">-1</span>] || nums[i] == nums[i+<span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 19.Degree of an Array]]></title>
      <url>/2018/01/31/leetCode/array/19.Degree_of_an_Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-19-Degree-of-an-Array"><a href="#Problem-19-Degree-of-an-Array" class="headerlink" title="Problem 19: Degree of an Array"></a>Problem 19: Degree of an Array</h2><p>Given a non-empty array of non-negative integers nums, the <strong>degree</strong> of this array is defined as the maximum frequency of any one of its elements.</p>
<p>Your task is to find the smallest possible length of a (contiguous) subarray of nums, that has the same degree as nums.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1, 2, 2, 3, 1]<br><strong>Output:</strong> 2<br><strong>Explanation:</strong><br>The input array has a degree of 2 because both elements 1 and 2 appear twice.<br>Of the subarrays that have the same degree:<br>[1, 2, 2, 3, 1], [1, 2, 2, 3], [2, 2, 3, 1], [1, 2, 2], [2, 2, 3], [2, 2]<br>The shortest length is 2. So return 2.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,2,2,3,1,4,2]<br><strong>Output:</strong> 6</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>nums.length will be between 1 and 50,000.</li>
<li>nums[i] will be an integer between 0 and 49,999.</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.本题本来想用数组的方式解决，但感觉比较麻烦，所以选择map来解决</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findShortestSubArray = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> m = <span class="keyword">new</span> <span class="built_in">Map</span>(),</span><br><span class="line">    degree = <span class="number">1</span>,</span><br><span class="line">    whichDegree = nums[<span class="number">0</span>]</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (m.has(nums[i])) &#123;</span><br><span class="line">        <span class="keyword">var</span> pos = m.get(nums[i])</span><br><span class="line">        pos.push(i)</span><br><span class="line">        <span class="keyword">if</span> (pos.length &gt; degree) &#123;</span><br><span class="line">            degree = pos.length</span><br><span class="line">            whichDegree = nums[i]</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (pos.length == degree &amp;&amp; pos[pos.length - <span class="number">1</span>] - pos[<span class="number">0</span>] &lt; m.get(whichDegree)[m.get(whichDegree).length - <span class="number">1</span>] - m.get(whichDegree)[<span class="number">0</span>]) &#123;</span><br><span class="line">        degree = pos.length</span><br><span class="line">        whichDegree = nums[i]</span><br><span class="line">        &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span> </span><br><span class="line">            m.set(nums[i], [i])</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> m.get(whichDegree)[m.get(whichDegree).length - <span class="number">1</span>] - m.get(whichDegree)[<span class="number">0</span>] + <span class="number">1</span></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 18.Two Sum II - Input array is sorted]]></title>
      <url>/2018/01/31/leetCode/array/18.Two_Sum_II_Input_array_is_sorted/</url>
      <content type="html"><![CDATA[<h2 id="Problem-18-Two-Sum-II-Input-array-is-sorted"><a href="#Problem-18-Two-Sum-II-Input-array-is-sorted" class="headerlink" title="Problem 18: Two Sum II - Input array is sorted"></a>Problem 18: Two Sum II - Input array is sorted</h2><p>Given an array of integers that is already <em>sorted in ascending order</em>, find two numbers such that they add up to a specific target number.</p>
<p>The function twoSum should return indices of the two numbers such that they add up to the target, where index1 must be less than index2. Please note that your returned answers (both index1 and index2) are not zero-based.</p>
<p>You may assume that each input would have exactly one solution and you may not use the same element twice.</p>
<p><strong>Input:</strong> numbers={2, 7, 11, 15}, target=9<br><strong>Output:</strong> index1=1, index2=2</p>
<p><strong>solution:</strong></p>
<p>1.因为已经是升序的，所以只要从数组头尾往中间收拢，就必然会找到对应的两个数。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> twoSum = <span class="function"><span class="keyword">function</span>(<span class="params">numbers, target</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> left = <span class="number">0</span>, right= numbers.length - <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">while</span> (left &lt; right) &#123;</span><br><span class="line">        sum = numbers[left] + numbers[right];</span><br><span class="line">        <span class="keyword">if</span> (sum == target)&#123;<span class="keyword">return</span> [left + <span class="number">1</span>, right + <span class="number">1</span>];&#125;</span><br><span class="line">        <span class="keyword">else</span> <span class="keyword">if</span>(sum &lt; target) left++;</span><br><span class="line">        <span class="keyword">else</span> right--;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> [];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 17.Majority Element]]></title>
      <url>/2018/01/30/leetCode/array/17.Majority_Element/</url>
      <content type="html"><![CDATA[<h2 id="Problem-17-Majority-Element"><a href="#Problem-17-Majority-Element" class="headerlink" title="Problem 17: Majority Element"></a>Problem 17: Majority Element</h2><p>Given an array of size n, find the majority element. The majority element is the element that appears <strong>more than</strong> ⌊ n/2 ⌋ times.</p>
<p>You may assume that the array is non-empty and the majority element always exist in the array.</p>
<p><strong>Credits:</strong><br>Special thanks to @ts for adding this problem and creating all test cases.</p>
<p><strong>solution:</strong></p>
<p>1.这里比较取巧，因为内容全部为数字，所以sort按序排序然后选择中位数即可。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> majorityElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a,b</span>)</span>&#123;<span class="keyword">return</span> a-b;&#125;);</span><br><span class="line">    <span class="keyword">return</span> nums[<span class="built_in">Math</span>.floor(nums.length/<span class="number">2</span>)];</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 16.Best Time to Buy and Sell Stock II]]></title>
      <url>/2018/01/30/leetCode/array/16.Best_Time_to_Buy_and_Sell_Stock_II/</url>
      <content type="html"><![CDATA[<h2 id="Problem-16-Best-Time-to-Buy-and-Sell-Stock-II"><a href="#Problem-16-Best-Time-to-Buy-and-Sell-Stock-II" class="headerlink" title="Problem 16: Best Time to Buy and Sell Stock II"></a>Problem 16: Best Time to Buy and Sell Stock II</h2><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>Design an algorithm to find the maximum profit. You may complete as many transactions as you like (ie, buy one and sell one share of the stock multiple times). However, you may not engage in multiple transactions at the same time (ie, you must sell the stock before you buy again).</p>
<p><strong>solution:</strong></p>
<p>1.题目信息请见之前的题目地址，这道题的思路比较奇特，因为可以选择多次，所以只要后一次大于前一次，即可以在总额上加上差值，因为若后面的数继续大于前面的数，累加的差值等于之后的差值。若后面的小，则可以跳过，因为前面的内容已经得到最多的利润。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (prices[i] &gt; prices[i - <span class="number">1</span>])</span><br><span class="line">            maxprofit += prices[i] - prices[i - <span class="number">1</span>];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxprofit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 15.1-bit and 2-bit Characters]]></title>
      <url>/2018/01/30/leetCode/array/15.1_bit_and_2_bit_Characters/</url>
      <content type="html"><![CDATA[<h2 id="Problem-15-1-bit-and-2-bit-Characters"><a href="#Problem-15-1-bit-and-2-bit-Characters" class="headerlink" title="Problem 15: 1-bit and 2-bit Characters"></a>Problem 15: 1-bit and 2-bit Characters</h2><p>We have two special characters. The first character can be represented by one bit 0. The second character can be represented by two bits (10 or 11).</p>
<p>Now given a string represented by several bits. Return whether the last character must be a one-bit character or not. The given string will always end with a zero.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>bits = [1, 0, 0]<br><strong>Output:</strong> True<br><strong>Explanation:</strong><br>The only way to decode it is two-bit character and one-bit character. So the last character is one-bit character.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>bits = [1, 1, 1, 0]<br><strong>Output:</strong> False<br><strong>Explanation:</strong><br>The only way to decode it is two-bit character and two-bit character. So the last character is NOT one-bit character.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>1 &lt;= len(bits) &lt;= 1000.</li>
<li>bits[i] is always 0 or 1.</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.近期因为时间比较紧，所以只用一种方法解决。本题选择递归，当前元素若为1，则删掉前两个，当前元素为0，则删除一个，直到最后长度为0或时，返回false或true。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isOneBitCharacter = <span class="function"><span class="keyword">function</span>(<span class="params">bits</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(bits.length==<span class="number">0</span>) <span class="keyword">return</span> <span class="literal">false</span>; </span><br><span class="line">    <span class="keyword">else</span> <span class="keyword">if</span>(bits.length==<span class="number">1</span>) <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">    <span class="keyword">if</span>(bits[<span class="number">0</span>]==<span class="number">0</span>)bits.splice(<span class="number">0</span>,<span class="number">1</span>); </span><br><span class="line">    <span class="keyword">else</span> bits.splice(<span class="number">0</span>,<span class="number">2</span>);</span><br><span class="line">    <span class="keyword">return</span> isOneBitCharacter(bits)</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 14.Move Zeroes]]></title>
      <url>/2018/01/27/leetCode/array/14.Move_Zeroes/</url>
      <content type="html"><![CDATA[<h2 id="Problem-14-Move-Zeroes"><a href="#Problem-14-Move-Zeroes" class="headerlink" title="Problem 14: Move Zeroes"></a>Problem 14: Move Zeroes</h2><p>Given an array nums, write a function to move all 0’s to the end of it while maintaining the relative order of the non-zero elements.</p>
<p>For example, given nums = [0, 1, 0, 3, 12], after calling your function, nums should be [1, 3, 12, 0, 0].</p>
<p><strong>Note:</strong></p>
<ol>
<li>You must do this <strong>in-place</strong> without making a copy of the array.</li>
<li>Minimize the total number of operations.</li>
</ol>
<p><strong>Credits:</strong></p>
<p>Special thanks to @jianchao.li.fighter for adding this problem and creating all test cases.</p>
<p><strong>solution:</strong></p>
<ol>
<li>这跟之前做的题很类似，只要注意在splice之后要对i减一即可。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> moveZeroes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sumZero = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == <span class="number">0</span>) &#123;</span><br><span class="line">            nums.splice(i, <span class="number">1</span>);</span><br><span class="line">            i--;</span><br><span class="line">            sumZero++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; sumZero; n++) &#123;</span><br><span class="line">        nums.push(<span class="number">0</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 13.Find All Numbers Disappeared in an Array]]></title>
      <url>/2018/01/27/leetCode/array/13.Find_All_Numbers_Disappeared_in_an_Array/</url>
      <content type="html"><![CDATA[<h2 id="Problem-13-Find-All-Numbers-Disappeared-in-an-Array"><a href="#Problem-13-Find-All-Numbers-Disappeared-in-an-Array" class="headerlink" title="Problem 13: Find All Numbers Disappeared in an Array"></a>Problem 13: Find All Numbers Disappeared in an Array</h2><p>Given an array of integers where 1 ≤ a[i] ≤ n (n = size of array), some elements appear twice and others appear once.</p>
<p>Find all the elements of [1, n] inclusive that do not appear in this array.</p>
<p>Could you do it without extra space and in O(n) runtime? You may assume the returned list does not count as extra space.</p>
<p><strong>Example:</strong></p>
<p><strong>Input:</strong><br>[4,3,2,7,8,2,3,1]</p>
<p><strong>Output:</strong><br>[5,6]</p>
<p><strong>solution:</strong></p>
<p>1.本来想最简单的方法就是先筛选出1 ≤ a[i] ≤ n 中哪个元素不再数组里，然后push到最后一位在splice之前的内容，但是要求<code>without extra space and in O(n) runtime</code>，所以选择其他的方法。这里选择先将数组排序，然后判断哪个元素不是对应位置上的数字，最后push到数组中。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findDisappearedNumbers = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> res = [];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] != nums[nums[i] - <span class="number">1</span>]) &#123;</span><br><span class="line">            <span class="keyword">var</span> inchange = nums[nums[i] - <span class="number">1</span>];</span><br><span class="line">            nums[nums[i] - <span class="number">1</span>] = nums[i];</span><br><span class="line">            nums[i] = inchange;</span><br><span class="line">            i--;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; nums.length; j++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[j] != j + <span class="number">1</span>)</span><br><span class="line">            res.push(j + <span class="number">1</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为数组长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 12.Max Area of Island]]></title>
      <url>/2018/01/27/leetCode/array/12.Max_Area_of_Island/</url>
      <content type="html"><![CDATA[<h2 id="Problem-12-Max-Area-of-Island"><a href="#Problem-12-Max-Area-of-Island" class="headerlink" title="Problem 12: Max Area of Island"></a>Problem 12: Max Area of Island</h2><p>Given a non-empty 2D array <code>grid</code> of 0’s and 1’s, an island is a group of 1’s (representing land) connected 4-directionally (horizontal or vertical.) You may assume all four edges of the grid are surrounded by water.</p>
<p>Find the maximum area of an island in the given 2D array. (If there is no island, the maximum area is 0.)</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p>[[0,0,1,0,0,0,0,1,0,0,0,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,1,1,0,1,0,0,0,0,0,0,0,0],<br> [0,1,0,0,1,1,0,0,1,0,1,0,0],<br> [0,1,0,0,1,1,0,0,1,1,1,0,0],<br> [0,0,0,0,0,0,0,0,0,0,1,0,0],<br> [0,0,0,0,0,0,0,1,1,1,0,0,0],<br> [0,0,0,0,0,0,0,1,1,0,0,0,0]]</p>
</blockquote>
<p>Given the above grid, return 6. Note the answer is not 11, because the island must be connected 4-directionally.</p>
<p><strong>Example 2:</strong></p>
<blockquote>
<p>[[0,0,0,0,0,0,0,0]]</p>
</blockquote>
<p>Given the above grid, return 0.</p>
<p><strong>Note:</strong> The length of each dimension in the given grid does not exceed 50.</p>
<p><strong>solution:</strong></p>
<ol>
<li>因为选取最多的相邻的1，本来打算遍历一遍，如果当前元素右边和下边为1，则对右下方元素加对应的值，但是边界条件判断比较复杂。所以，选择递归实现，虽然实现很简单，但是时间复杂度相对较高，做了比较多重复的操作。以下为对应代码：</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxAreaOfIsland = <span class="function"><span class="keyword">function</span>(<span class="params">grid</span>) </span>&#123;</span><br><span class="line">      <span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line">      <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; grid.length; i++)&#123;</span><br><span class="line">         <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; grid[<span class="number">0</span>].length; j++)&#123;</span><br><span class="line">                <span class="keyword">if</span>(grid[i][j] == <span class="number">1</span>) res = <span class="built_in">Math</span>.max(res, helper(grid, i, j));</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br><span class="line"></span><br><span class="line"><span class="keyword">var</span> helper = <span class="function"><span class="keyword">function</span>(<span class="params">grid, r, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">if</span>(r &lt; <span class="number">0</span> || r &gt;= grid.length || c &lt; <span class="number">0</span> || c &gt;= grid[<span class="number">0</span>].length) <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">if</span>(grid[r][c] == <span class="number">1</span>)&#123;</span><br><span class="line">            grid[r][c] = <span class="number">0</span>;</span><br><span class="line">            res = <span class="number">1</span> + helper(grid, r<span class="number">-1</span>, c) + helper(grid, r+<span class="number">1</span>, c) + helper(grid, r, c<span class="number">-1</span>) + helper(grid, r, c+<span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> res;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(r X c), r为行的个数，c为列的个数。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 11.Shortest Word Distance]]></title>
      <url>/2018/01/27/leetCode/array/11.Shortest_Word_Distance/</url>
      <content type="html"><![CDATA[<h2 id="Problem-11-Shortest-Word-Distance"><a href="#Problem-11-Shortest-Word-Distance" class="headerlink" title="Problem 11: Shortest Word Distance"></a>Problem 11: Shortest Word Distance</h2><p>Given a list of words and two words word1 and word2, return the shortest distance between these two words in the list.</p>
<p>For example,<br>Assume that words = <code>[&quot;practice&quot;, &quot;makes&quot;, &quot;perfect&quot;, &quot;coding&quot;, &quot;makes&quot;]</code>.</p>
<p>Given word1 = <code>&quot;coding&quot;</code>, word2 = <code>&quot;practice&quot;</code>, return 3.<br>Given word1 = <code>&quot;makes&quot;</code>, word2 = <code>&quot;coding&quot;</code>, return 1.</p>
<p><strong>Note:</strong></p>
<p>You may assume that word1 <strong>does not equal to</strong> word2, and word1 and word2 are both in the list.</p>
<p><strong>solution:</strong></p>
<ol>
<li>根据题意，选出最近的两个对应的单词的间距，因为所选单词最短的间距即相邻间距，所以最小的匹配值间距的绝对值即是所求答案。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> shortestDistance = <span class="function"><span class="keyword">function</span>(<span class="params">words, word1, word2</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> index1 = <span class="number">-1</span>, index2 = <span class="number">-1</span>;</span><br><span class="line">    <span class="keyword">var</span> minDistance = words.length;</span><br><span class="line">    <span class="keyword">var</span> currentDistance;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; words.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (words[i] == word1) &#123;</span><br><span class="line">            index1 = i;</span><br><span class="line">        &#125; <span class="keyword">else</span> <span class="keyword">if</span> (words[i] == word2) &#123;</span><br><span class="line">            index2 = i;</span><br><span class="line">        &#125;</span><br><span class="line"></span><br><span class="line">        <span class="keyword">if</span> (index1 != <span class="number">-1</span> &amp;&amp; index2 != <span class="number">-1</span>) &#123;</span><br><span class="line">            minDistance = <span class="built_in">Math</span>.min(minDistance, <span class="built_in">Math</span>.abs(index1 - index2));</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> minDistance;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为数组的长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 10.Max Consecutive Ones]]></title>
      <url>/2018/01/26/leetCode/array/10.Max_Consecutive_Ones/</url>
      <content type="html"><![CDATA[<h2 id="Problem-10-Max-Consecutive-Ones"><a href="#Problem-10-Max-Consecutive-Ones" class="headerlink" title="Problem 10: Max Consecutive Ones"></a>Problem 10: Max Consecutive Ones</h2><p>Given a binary array, find the maximum number of consecutive 1s in this array.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,1,0,1,1,1]<br><strong>Output:</strong> 3<br><strong>Explanation:</strong> The first two digits or the last three digits are consecutive 1s.<br>    The maximum number of consecutive 1s is 3.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The input array will only contain 0 and 1.</li>
<li>The length of input array is a positive integer and will not exceed 10,000</li>
</ul>
<p><strong>solution:</strong></p>
<p>1.这道题算是福利题了，只要确定最长的1的长度就行了，所以直接判断即可：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaxConsecutiveOnes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">        cnt = (nums[i] == <span class="number">0</span>) ? <span class="number">0</span> : cnt + <span class="number">1</span>;</span><br><span class="line">        res = <span class="built_in">Math</span>.max(res, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n),n为nums的长度；</p>
<p>2.除此之外还看到一个人的另一种比较有趣的方法，因为是01串，那么连续1的和跟个数相等，所以我们可以计算和，通过加上num，再乘以num来计算，如果当前数字是0，那么sum就被重置为0，还是要更新结果res。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findMaxConsecutiveOnes = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> res = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> cnt = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">        cnt = (cnt + nums[i]) * nums[i];</span><br><span class="line">        res = <span class="built_in">Math</span>.max(res, cnt);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> res;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n),n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 9.Reshape the Matrix]]></title>
      <url>/2018/01/26/leetCode/array/09.Reshape_the_Matrix/</url>
      <content type="html"><![CDATA[<h2 id="Problem-9-Reshape-the-Matrix"><a href="#Problem-9-Reshape-the-Matrix" class="headerlink" title="Problem 9:Reshape the Matrix"></a>Problem 9:Reshape the Matrix</h2><p>In MATLAB, there is a very useful function called ‘reshape’, which can reshape a matrix into a new one with different size but keep its original data.</p>
<p>You’re given a matrix represented by a two-dimensional array, and two <strong>positive</strong> integers <strong>r</strong> and <strong>c</strong> representing the <strong>row</strong> number and column number of the wanted reshaped matrix, respectively.</p>
<p>The reshaped matrix need to be filled with all the elements of the original matrix in the same <strong>row-traversing</strong> order as they were.</p>
<p>If the ‘reshape’ operation with given parameters is possible and legal, output the new reshaped matrix; Otherwise, output the original matrix.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>nums =<br>[[1,2],<br> [3,4]]<br>r = 1, c = 4<br><strong>Output:</strong><br>[[1,2,3,4]]<br><strong>Explanation:</strong><br>The <strong>row-traversing</strong> of nums is [1,2,3,4]. The new reshaped matrix is a 1 * 4 matrix, fill it row by row by using the previous list.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong><br>nums =<br>[[1,2],<br> [3,4]]<br>r = 2, c = 4<br><strong>Output:</strong><br>[[1,2],<br> [3,4]]<br><strong>Explanation:</strong><br>There is no way to reshape a 2 X 2 matrix to a 2 X 4 matrix. So output the original matrix.</p>
</blockquote>
<p><strong>Note:</strong><br>The height and width of the given matrix is in range [1, 100].<br>The given r and c are all positive.</p>
<p><strong>solution:</strong></p>
<ol>
<li>做这道题时主要的问题在于如何创建一个二维数组，因为js创建二维数组时出现问题，所以选择设两个一维数组，先判断是否符合要求，不符合返回原数组，然后将元素通过concat添加到一个一维数组中，然后根据所给的r,c一一赋值即可。这道题主要纠结在如何设置一个空的二维数组以及如何对二维数组进行赋值。最后回避了这个问题。</li>
</ol>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> matrixReshape = <span class="function"><span class="keyword">function</span>(<span class="params">nums, r, c</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> result_storage = [];</span><br><span class="line">    <span class="keyword">var</span> result = []; </span><br><span class="line">    <span class="keyword">if</span>(nums.length * nums[<span class="number">0</span>].length != r * c) &#123;</span><br><span class="line">        <span class="keyword">return</span> nums;</span><br><span class="line">    &#125;    </span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">0</span>; i &lt; nums.length; i++) &#123;  </span><br><span class="line">            result_storage = result_storage.concat(nums[i]);  </span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; r; i++) &#123;  </span><br><span class="line">        result.push([]);  </span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> j = <span class="number">0</span>; j &lt; c ; j++)&#123;  </span><br><span class="line">                result[i][j] = result_storage[i * c + j];  </span><br><span class="line">            &#125;  </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(r X c), r为矩阵的横向长度，c为矩阵的纵向长度。</p>
<p>2.经过查询过后，发现二维数组不是通过创建`var result = new Array[][]这样的形式创建，而是通过先创建一个一维数组，再对其中的元素设置为数组的形式创建多维数组。接下来就对数组中的内容进行判断，若没有到下一行，则继续对下一位内容赋值，若倒下一行，则换行输入。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> matrixReshape = function(nums, r, c) &#123;</span><br><span class="line">    <span class="built_in">var</span> result =  <span class="built_in">new</span> Array(r);  </span><br><span class="line">    <span class="keyword">for</span>(<span class="built_in">var</span> n = <span class="number">0</span>; n &lt; result.<span class="built_in">length</span>; n++)&#123;  </span><br><span class="line">        result[n] = <span class="built_in">new</span> Array(c);   </span><br><span class="line">    &#125;  </span><br><span class="line">    <span class="built_in">var</span> rows = <span class="number">0</span>; </span><br><span class="line">    <span class="built_in">var</span> cols = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">var</span> count = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.<span class="built_in">length</span> == <span class="number">0</span> || nums.<span class="built_in">length</span> * nums[<span class="number">0</span>].<span class="built_in">length</span> != r * c) </span><br><span class="line">        <span class="built_in">return</span> nums;   </span><br><span class="line">    <span class="keyword">for</span> (<span class="built_in">var</span> i = <span class="number">0</span>; i &lt; nums.<span class="built_in">length</span>; i ++) &#123;</span><br><span class="line">        <span class="keyword">for</span> (<span class="built_in">var</span> j = <span class="number">0</span>; j &lt; nums[<span class="number">0</span>].<span class="built_in">length</span>; j++) &#123;</span><br><span class="line">            result[rows][cols] = nums[i][j];</span><br><span class="line">            cols++;</span><br><span class="line">            <span class="keyword">if</span> (cols == c) &#123;</span><br><span class="line">                rows++;</span><br><span class="line">                cols = <span class="number">0</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> result;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：<br>Time Complexity：O(num.length X num[0].length), 与上述方法的复杂度类似，不过更直观一些。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 8.Toeplitz Matrix]]></title>
      <url>/2018/01/26/leetCode/array/08.Toeplitz_Matrix/</url>
      <content type="html"><![CDATA[<h2 id="Problem-8-Toeplitz-Matrix"><a href="#Problem-8-Toeplitz-Matrix" class="headerlink" title="Problem 8: Toeplitz Matrix"></a>Problem 8: Toeplitz Matrix</h2><p>A matrix is Toeplitz if every diagonal from top-left to bottom-right has the same element.</p>
<p>Now given an <code>M x N</code> matrix, return <code>True</code> if and only if the matrix is Toeplitz.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> matrix = [[1,2,3,4],[5,1,2,3],[9,5,1,2]]<br><strong>Output:</strong> True<br><strong>Explanation:</strong><br>1234<br>5123<br>9512</p>
</blockquote>
<p>In the above grid, the diagonals are “[9]”, “[5, 5]”, “[1, 1, 1]”, “[2, 2, 2]”, “[3, 3]”, “[4]”, and in each diagonal all elements are the same, so the answer is True.</p>
<p><strong>Example 2:</strong></p>
<p><strong>Input:</strong> matrix = [[1,2],[2,2]]<br><strong>Output:</strong> False<br><strong>Explanation:</strong><br>The diagonal “[1, 2]” has different elements.</p>
<p><strong>Note:</strong></p>
<ol>
<li>matrix will be a 2D array of integers.</li>
<li>matrix will have a number of rows and columns in range [1, 20].</li>
<li>matrix[i][j] will be integers in range [0, 99].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.通过画图可得，从左上角的元素开始，如果每行（最后一行除外）元素可以与右下方（每行最后一个元素除外）的元素相等，既符合要求，所以可以选择遍历得到答案。</p>
<p>目前就只有这一种比较好的解法，所以就先写一个算法了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> isToeplitzMatrix = <span class="function"><span class="keyword">function</span>(<span class="params">matrix</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> r = <span class="number">0</span>; r &lt; matrix.length - <span class="number">1</span>; r++) &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> c = <span class="number">0</span>; c &lt; matrix[<span class="number">0</span>].length - <span class="number">1</span>; c++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(matrix[r][c] != matrix[r+<span class="number">1</span>][c+<span class="number">1</span>]) &#123;</span><br><span class="line">                <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">true</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity: O(m X n), m为矩阵的横向长度，n为矩阵的纵向长度。</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 7.Array Partition I]]></title>
      <url>/2018/01/26/leetCode/array/07.array_partition_I/</url>
      <content type="html"><![CDATA[<h2 id="Problem-7-Array-Partition-I"><a href="#Problem-7-Array-Partition-I" class="headerlink" title="Problem 7:Array Partition I"></a>Problem 7:Array Partition I</h2><p>Given an array of <strong>2n</strong> integers, your task is to group these integers into <strong>n</strong> pairs of integer, say (a1, b1), (a2, b2), …, (an, bn) which makes sum of min(ai, bi) for all i from 1 to n as large as possible.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,4,3,2]<br><strong>Output:</strong> 4<br><strong>Explanation:</strong> n is 2, and the maximum sum of pairs is 4 = min(1, 2) + min(3, 4).</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li><strong>n</strong> is a positive integer, which is in the range of [1, 10000].</li>
<li>All the integers in the array will be in the range of [-10000, 10000].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.这道题比较简单的做法是对数组排序，然后隔一个数字取一个，就可以保证数组中所有的每两个数字的最小值的总和是最小值。</p>
<p>目前也没有找到比这个更简单的算法，所以就先写一个算法了。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> arrayPairSum = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> i = <span class="number">0</span>;</span><br><span class="line">    nums.sort(<span class="function"><span class="keyword">function</span>(<span class="params">a, b</span>)</span>&#123;<span class="keyword">return</span> a-b;&#125;);</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; nums.length; i+=<span class="number">2</span>) &#123;</span><br><span class="line">        sum+=nums[i];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> sum;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[1.22~1.26所遇问题]]></title>
      <url>/2018/01/25/blog/problem/1.22~1.16_questions/</url>
      <content type="html"><![CDATA[<h2 id="1-22-1-26所遇问题"><a href="#1-22-1-26所遇问题" class="headerlink" title="1.22~1.26所遇问题"></a>1.22~1.26所遇问题</h2><h3 id="1-导入css文件时，import和link的区别"><a href="#1-导入css文件时，import和link的区别" class="headerlink" title="1.导入css文件时，import和link的区别"></a>1.导入css文件时，import和link的区别</h3><ol>
<li><code>&lt;link&gt;</code>标签是html标签，除了可以引入CSS之外还可以定义RSS，定义rel属性等，而@import只能引入CSS样式；</li>
<li><code>&lt;link&gt;</code>标签引用的CSS文件会在页面加载时与html同时加载，而@import引入的CSS文件会等页面全部加载完以后再加载；</li>
<li>@import标签必须放在页面样式表的顶部，而<code>&lt;link&gt;</code>不必；</li>
</ol>
<p>那为什么会有很多人建议使用link标签，而非import呢？在Steve Souders（编写过《高性能网站建设指南》等书）的博客中通过一些实例来说明<strong>don’t use @import</strong>。<br>以下节选部分内容并进行翻译：</p>
<p>原文链接<a href="http://www.stevesouders.com/blog/2009/04/09/dont-use-import/" target="_blank" rel="noopener">http://www.stevesouders.com/blog/2009/04/09/dont-use-import/</a><br>——————————————————————————————————————<br><strong>LINK vs. @import</strong></p>
<p>There are two ways to include a stylesheet in your web page. You can use the LINK tag:</p>
<p>以下有两种将样式表引入到您的网页中的方式。您可以使用LINK标签：</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">&lt;link rel=<span class="string">'stylesheet'</span> href=<span class="string">'a.css'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>Or you can use the @import rule:</p>
<p>或者您可以使用@import规则：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'a.css'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>I prefer using LINK for simplicity—you have to remember to put @import at the top of the style block or else it won’t work. It turns out that avoiding @import is better for performance, too.</p>
<p>为了简单起见，我更倾向于使用LINK。如果您使用@import的话，您必须将它放在样式内容的顶部，否则它将无法显示。事实证明，处于性能来说，避免使用@import也是一个更好的选择。</p>
<p><strong>@import @import</strong></p>
<p>I’m going to walk through the different ways LINK and @import can be used. In these examples, there are two stylesheets: a.css and b.css. Each stylesheet is configured to take two seconds to download to make it easier to see the performance impact. The first example uses @import to pull in these two stylesheets. In this example, called @import @import, the HTML document contains the following style block:</p>
<p>我将在不同的情况下使用LINK和@import。在这些例子中，有两个样式表：a.css和b.css。每个样式表都需要花费两秒钟的时间下载，以便更容易地观测性能。第一个示例中，我们使用@import来下载这两个样式表。我们叫这个例子为<code>@import @import</code>在这个示例中，HTML文档包含以下样式块：<br><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'a.css'</span>);</span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'b.css'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure></p>
<p>If you always use @import in this way, there are no performance problems, although we’ll see below it could result in JavaScript errors due to race conditions. The two stylesheets are downloaded in parallel, as shown in Figure 1. (The first tiny request is the HTML document.) The problems arise when @import is embedded in other stylesheets or is used in combination with LINK.</p>
<p>如果您总是使用@import的方式，不会有什么性能方面的问题，尽管可能由于竞争的原因导致JavaScript报错。如图1所示，这两个样式表是并行下载的。（第一个请求时HTML文档），但是，当@import与LINK结合使用引入其他样式表时，问题就出现了。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/import-import.gif" alt="只使用@import"><br>    <figcaption><br>        只使用@import<br>    </figcaption><br></figure>

<p>由此可见，只使用@import是没有问题的。</p>
<p><strong>LINK @import</strong></p>
<p>The LINK @import example uses LINK for a.css, and @import for b.css:</p>
<p>LINK @import示例中使用LINK标签引入a.css，使用@import引入b.css：</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">link</span> <span class="attr">rel</span>=<span class="string">'stylesheet'</span> <span class="attr">type</span>=<span class="string">'text/css'</span> <span class="attr">href</span>=<span class="string">'a.css'</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'b.css'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>In IE (tested on 6, 7, and 8), this causes the stylesheets to be downloaded sequentially, as shown in Figure 2. Downloading resources in parallel is key to a faster page. As shown here, this behavior in IE causes the page to take a longer time to finish.</p>
<p>在IE（在IE6， 7， 8下测试）中，如下图所示，这将导致样式表按顺序下载，而并行下载资源是让页面加载更快的关键。如图所示，在IE中的这会导致页面花费较长的时间完成渲染。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-import.gif" alt="混合使用@import和link标签"><br>    <figcaption><br>        混合使用@import和link标签<br>    </figcaption><br></figure>

<p><strong>LINK with @import</strong></p>
<p>In the LINK with @import example, a.css is inserted using LINK, and a.css has an @import rule to pull in b.css:</p>
<p>在使用LINK中使用@import的示例中，a.css使用LINK嵌入在DOM中，而a.css中则通过@import导入b.css：<br><figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> the <span class="type">HTML</span> document:</span><br><span class="line">&lt;link rel=<span class="symbol">'stylesheet'</span> <span class="keyword">type</span>=<span class="symbol">'text</span>/css' href=<span class="symbol">'a</span>.css'&gt;</span><br><span class="line"><span class="keyword">in</span> a.css:</span><br><span class="line">@import url(<span class="symbol">'b</span>.css');</span><br></pre></td></tr></table></figure></p>
<p>This pattern also prevents the stylesheets from loading in parallel, but this time it happens on all browsers. When we stop and think about it, we shouldn’t be too surprised. The browser has to download a.css and parse it. At that point, the browser sees the @import rule and starts to fetch b.css.</p>
<p>这种方式也可以防止样式表的并行加载，但是这次它发生在所有的浏览器上。其实仔细想一想，我们都不应该感到惊讶。浏览器必须先下载a.css并解析它，只有解析它后，浏览器才会看到@import规则并开始加载b.css。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-with-import.gif" alt="在link标签引入@import"><br>    <figcaption><br>       在link标签引入@import<br>    </figcaption><br></figure>

<p><strong>LINK blocks @import</strong></p>
<p>A slight variation on the previous example with surprising results in IE: LINK is used for a.css and for a new stylesheet called proxy.css. proxy.css is configured to return immediately; it contains an @import rule for b.css.</p>
<p>在IE中与上述结果有些许不同：对a.css和名为proxy.css的样式表使用LINK引入。而proxy.css会立即执行并渲染; 注意，它包含一个b.css的@import规则</p>
<figure class="highlight sml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">in</span> the <span class="type">HTML</span> document:</span><br><span class="line">&lt;link rel=<span class="symbol">'stylesheet'</span> <span class="keyword">type</span>=<span class="symbol">'text</span>/css' href=<span class="symbol">'a</span>.css'&gt;</span><br><span class="line">&lt;link rel=<span class="symbol">'stylesheet'</span> <span class="keyword">type</span>=<span class="symbol">'text</span>/css' href=<span class="symbol">'proxy</span>.css'&gt;</span><br><span class="line"><span class="keyword">in</span> proxy.css:</span><br><span class="line">@import url(<span class="symbol">'b</span>.css');</span><br></pre></td></tr></table></figure>
<p>The results of this example in IE, LINK blocks @import, are shown in Figure 4. The first request is the HTML document. The second request is a.css (two seconds). The third (tiny) request is proxy.css. The fourth request is b.css (two seconds). Surprisingly, IE won’t start downloading b.css until a.css finishes. In all other browsers, this blocking issue doesn’t occur, resulting in a faster page as shown in Figure 5.</p>
<p>在IE中的LINK bock @import例子里，第一个请求时HTML文件，第二个请求是a.css（花费了两秒），第三个请求（很短）是proxy.css。第四个请求时b.css（花费了两秒）。令人惊奇的是，IE不会等到a.css结束后再开始下载b.css。在所有其他的浏览器里，这种加速渲染页面的情况不会发生。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-blocks-import.gif" alt="LINK blocks @import embedded in other stylesheets in IE"><br>     <figcaption><br>        LINK blocks @import embedded in other stylesheets in IE<br>     </figcaption><br></figure>

<figure><br>    <img src="http://stevesouders.com/tests/atimport/link-blocks-import-not-ie.gif" alt=" LINK doesn't block @import embedded stylesheets in browsers other than IE"><br>     <figcaption><br>         LINK doesn’t block @import embedded stylesheets in browsers other than IE<br>     </figcaption><br></figure>

<p><strong>many @imports</strong></p>
<p>The many @imports example shows that using @import in IE causes resources to be downloaded in a different order than specified. This example has six stylesheets (each takes two seconds to download) followed by a script (a four second download).</p>
<p>在many @imports例子中显示了在IE中使用@import会导致不同于指定的顺序下载资源。这个例子有六个样式表（每个需要两秒钟下载），后面是一个脚本（四秒钟的下载）</p>
<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">style</span>&gt;</span><span class="undefined"></span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'a.css'</span>);</span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'b.css'</span>);</span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'c.css'</span>);</span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'d.css'</span>);</span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'e.css'</span>);</span></span><br><span class="line"><span class="css">@<span class="keyword">import</span> url(<span class="string">'f.css'</span>);</span></span><br><span class="line"><span class="undefined"></span><span class="tag">&lt;/<span class="name">style</span>&gt;</span></span><br><span class="line"><span class="tag">&lt;<span class="name">script</span> <span class="attr">src</span>=<span class="string">'one.js'</span> <span class="attr">type</span>=<span class="string">'text/javascript'</span>&gt;</span><span class="undefined"></span><span class="tag">&lt;/<span class="name">script</span>&gt;</span></span><br></pre></td></tr></table></figure>
<p>Looking at Figure 6, the longest bar is the four second script. Even though it was listed last, it gets downloaded first in IE. If the script contains code that depends on the styles applied from the stylesheets (a la getElementsByClassName, etc.), then unexpected results may occur because the script is loaded before the stylesheets, despite the developer listing it last.</p>
<p>看下图，最长的一条是一个四秒的脚本。尽管它位于最后，但是它在IE中是最早下载下来的。如果脚本包括依赖于样式表中的样式，会有未知的结果发生，因为脚本不是按照预期的顺序在样式之后加载的。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/many-imports.gif" alt="多个import"><br>     <figcaption><br>        多个import<br>     </figcaption><br></figure>

<p><strong>LINK LINK</strong></p>
<p>It’s simpler and safer to use LINK to pull in stylesheets:</p>
<p>使用LINK加载样式更快捷也更安全：</p>
<figure class="highlight routeros"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">'stylesheet'</span> <span class="attribute">type</span>=<span class="string">'text/css'</span> <span class="attribute">href</span>=<span class="string">'a.css'</span>&gt;</span><br><span class="line">&lt;link <span class="attribute">rel</span>=<span class="string">'stylesheet'</span> <span class="attribute">type</span>=<span class="string">'text/css'</span> <span class="attribute">href</span>=<span class="string">'b.css'</span>&gt;</span><br></pre></td></tr></table></figure>
<p>Using LINK ensures that stylesheets will be downloaded in parallel across all browsers. The LINK LINK example demonstrates this, as shown in Figure 7. Using LINK also guarantees resources are downloaded in the order specified by the developer.</p>
<p>使用LINK会确保样式表会在所有的浏览器中都并行下载。这个LINK LINK的例子证明了这点，使用LINk也保证资源会按开发者的顺序加载。</p>
<figure><br>    <img src="http://stevesouders.com/tests/atimport/import-import.gif" alt="使用link加载样式表"><br>     <figcaption><br>        使用link加载样式表<br>     </figcaption><br></figure>

<p>These issues need to be addressed in IE. It’s especially bad that resources can end up getting downloaded in a different order. All browsers should implement a small lookahead when downloading stylesheets to extract any @import rules and start those downloads immediately. Until browsers make these changes, I recommend avoiding @import and instead using LINK for inserting stylesheets.</p>
<p>这些问题在IE中都需要解决。尤其是资源会以不同的顺序下载的问题尤为糟糕。所有的浏览器都应该在下载样式表的时候就提取任何@import规则并立即开始下载。在浏览器进行这些更改之前，我建议避免使用@import，而应使用LINK来引入样式表。</p>
<p>The load times of these resources are exaggerated to make it easy to see what’s happening. But for people with slow connections, especially those in some of the world’s emerging markets, these response times may not be that far from reality. The takeaways are:</p>
<ol>
<li>Using @import within a stylesheet adds one more roundtrip to the overall download time of the page.</li>
<li>Using @import in IE causes the download order to be altered. This may cause stylesheets to take longer to download, which hinders progress rendering making the page feel slower.</li>
</ol>
<p>因为这些资源的加载时间被夸大，所有我们很容易看到发生了什么事情。但是对于那些网速慢的人来说，网络的响应时间也许并不那么块。 原因是：</p>
<ol>
<li>在样式表中使用@import会使得页面的整体下载时间再增加一倍。</li>
<li>在IE中使用@import会导致资源的下载顺序发生改变。这可能会导致样式表花费更长的时间来下载，因此会阻碍渲染，使页面加载的更慢。</li>
</ol>
<h3 id="2-微格式"><a href="#2-微格式" class="headerlink" title="2.微格式"></a>2.微格式</h3><p>对应官网为：<a href="http://microformats.org/" target="_blank" rel="noopener">http://microformats.org/</a></p>
<h4 id="微格式产生背景："><a href="#微格式产生背景：" class="headerlink" title="微格式产生背景："></a>微格式产生背景：</h4><p>由于早期HTML中缺少相应的元素，很难突出显示人、地点或日期等类型的信息。为了解决这个问题，有一组开发人员决定开发一套标准的命名约定盒标记模式来表示这些数据。这些命名约定基于vCard（电子名片）和iCalendar（日历数据交换）等现有的数据格式，现在称为微格式（microformat)。</p>
<h4 id="微格式定义："><a href="#微格式定义：" class="headerlink" title="微格式定义："></a>微格式定义：</h4><p>建立在已有的、被广泛采用的标准基础之上的一组简单的、开放的数据格式（microformats.org官方定义）。是把语义嵌入到HTML以便有助于分离式开发而制定的一些简单约定，是兼顾人机可读性设计的数据表达方式，对Web网页进行语义注解的方法。</p>
<h4 id="微格式意义："><a href="#微格式意义：" class="headerlink" title="微格式意义："></a>微格式意义：</h4><p>微格式按照某种已有的被广泛应用的标准，通过对内容块的语义标记，可以让外部应用程序、聚合程序和搜索引擎能够做以下事情：</p>
<ol>
<li>在捉取Web内容时，能够更为准确地识别内容块的语义；</li>
<li>对内容进行操作，包括提供访问、校对，还可以将其转化成其他的相关格式，提供给外部程序和Web服务使用。</li>
</ol>
<p>因此，微格式实际上就是为现有的HTML元素添加元数据和其他属性以增强语义化。</p>
<p>常见的微格式是hCard</p>
<p>hCard是一种微格式，用来发布个人，公司，组织，地点等详细的联系信息。它可以包含在(X)HTML，Atom，RSS等可扩展置标语言中。hCard使用vCard（RFC 2426）的属性和值来实现这些功能。</p>
<p>它可以使分析器（比如其他网站，Firefox的Operator插件）获得详细的信息，并通过别的网站或者地图工具进行显示，或者载入到地址簿等其他程序。</p>
<p>example：</p>
<figure class="highlight livecodeserver"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;<span class="keyword">div</span>&gt;</span><br><span class="line">     &lt;<span class="keyword">div</span>&gt;Joe Doe&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">     &lt;<span class="keyword">div</span>&gt;The Example Company&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">     &lt;<span class="keyword">div</span>&gt;<span class="number">604</span><span class="number">-555</span><span class="number">-1234</span>&lt;/<span class="keyword">div</span>&gt;</span><br><span class="line">     &lt;<span class="keyword">a</span> href=<span class="string">"http://example.com/"</span>&gt;<span class="keyword">http</span>://example.com/&lt;/<span class="keyword">a</span>&gt;</span><br><span class="line"> &lt;/<span class="keyword">div</span>&gt;</span><br></pre></td></tr></table></figure>
<p> 如下代码添加了微格式后，成为:<br> <figure class="highlight cs"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;div <span class="keyword">class</span>=<span class="string">"vcard"</span>&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">"fn"</span>&gt;Joe Doe&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">"org"</span>&gt;The Example Company&lt;/div&gt;</span><br><span class="line">    &lt;div <span class="keyword">class</span>=<span class="string">"tel"</span>&gt;<span class="number">604</span><span class="number">-555</span><span class="number">-1234</span>&lt;/div&gt;</span><br><span class="line">    &lt;a <span class="keyword">class</span>=<span class="string">"url"</span> href=<span class="string">"http://example.com/"</span>&gt;http:<span class="comment">//example.com/&lt;/a&gt;</span></span><br><span class="line">&lt;/div&gt;</span><br></pre></td></tr></table></figure></p>
<p> 这里，正式名称（class=”fn”），组织（class=”org”），电话号码（class=”tel”）和url（class=”url”）分别用相应的class标示；同时，所有内容都包含在class=”vcard”里。</p>
<p> 以上就是微格式的大体内容。</p>
<h3 id="外边距叠加"><a href="#外边距叠加" class="headerlink" title="外边距叠加"></a>外边距叠加</h3><p>首先，先说明是什么导致的外边距叠加。</p>
<p>首先，外边距叠加是因为<strong>外边距塌陷(margin collapse)</strong>导致的。实际它也是由于一个缺省值的设定而导致的。在Chrome浏览器里，这个缺省值就是由-webkit-margin-collapse规定的。-webkit-margin-collapse的缺省值就是collapse，所以导致塌陷。这个属性还有另外2个取值：一个是discard，一个是separate。下面我们来具体看一下它们的不同表现形式。</p>
<h4 id="webkit-margin-collapse-collapse"><a href="#webkit-margin-collapse-collapse" class="headerlink" title="-webkit-margin-collapse: collapse"></a>-webkit-margin-collapse: collapse</h4><p>我们先从简单的看起。假定我们有这样一个<code>&lt;div&gt;</code>，这个<code>&lt;div&gt;</code>里面有3个<code>&lt;p&gt;</code>，如果我们什么也不设，它就是这个样子：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/157/537/1575372319-5a5eabae0c326_articlex" alt="未设置-webkit-margin-collapse"></p>
<p>会看到每一个<code>&lt;p&gt;</code>下面都有一个下边距。现在我们加上<code>margin: 20px 0;</code>表示为每一个<code>&lt;p&gt;</code>增加一个20px的上边距和一个20px的下边距，现在再看一下效果：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/537/919/537919608-5a5eac73b8e6c_articlex" alt="-webkit-margin-collapse: collapse"></p>
<p>这时我们看到虽然第一个<code>&lt;p&gt;</code>有20px的上边距，但第2个<code>&lt;p&gt;</code>的20px上边距已经被第一个<code>&lt;p&gt;</code>的下边距『吃掉』了，这就是我们大家所熟知的外边距塌陷。</p>
<h4 id="webkit-margin-collapse-separate"><a href="#webkit-margin-collapse-separate" class="headerlink" title="-webkit-margin-collapse: separate"></a>-webkit-margin-collapse: separate</h4><p>现在我们来看一下第2种情况，如果我们设定<code>-webkit-margin-collapse: separate</code>之后会怎么样：</p>
<p><img src="https://sfault-image.b0.upaiyun.com/164/511/1645114860-5a5eb3d394158_articlex" alt="-webkit-margin-collapse: separate"></p>
<p>现在我们看到塌陷的外边距回来了。</p>
<h4 id="webkit-margin-collapse-discard"><a href="#webkit-margin-collapse-discard" class="headerlink" title="-webkit-margin-collapse: discard"></a>-webkit-margin-collapse: discard</h4><p>那么第3种取值<code>discard</code>是什么作用呢？</p>
<p><img src="https://sfault-image.b0.upaiyun.com/318/356/3183561786-5a5eb42f8c31d_articlex" alt="-webkit-margin-collapse: discard"></p>
<p>外边距完全没有了。</p>
<p>所以，如果我们想强制所有元素边距都不塌陷，那么该怎么办呢？</p>
<p>我们不能再简单地同时设置上下边距为<code>margin: 20px 0;</code>而应该更精确控制，给<code>&lt;p&gt;</code>只设置下边距为20px就可以了，这样我们就实现了在强制不塌陷的情况下依然保持了行与行之间的距离。</p>
<p>Tips:<br>『外边距塌陷』其实是W3C早期标准为了一时方便而引入的一个过度设计，它的设计初衷是为了简化，但结果在CSS高度发展的情况下反倒造成了更大的混乱，使得前端工程师无法一目了然地知道自己的代码结果，不明白自己明明已经设置好的<code>margin-top: 20px;</code>怎么就会没有了？结果被人告知还要学习外边距塌陷这样的知识。这样的错误责任不在于工程师没有好好学习，而根本原因在于CSS本身设计的缺陷，才导致了工程师学习成本的增加，并且还增加了浏览器开发者的工作量，需要特意为外边距塌陷开发额外的代码。无论如何，这是一件各方成本都增加的双输设计。</p>
<p>至于水平方向上为什么没有外边距叠加，我也不知道呀，也许当时就是为了解决垂直方向上外边距累加的问题吧，定义上就是这么定义的。</p>
<p>最后总结一下W3C中外边距叠加的内容</p>
<blockquote>
<p>In CSS, the adjoining margins of two or more boxes (which might or might not be siblings) can combine to form a single margin. Margins that combine this way are said to collapse, and the resulting combined margin is called a collapsed margin.</p>
</blockquote>
<p>在CSS中，两个或多个毗邻的普通流中的盒子（可能是父子元素，也可能是兄弟元素）在垂直方向上的外边距会发生叠加，这种形成的外边距称之为外边距叠加。</p>
<p>我们可以注意定义中的几个关键字：毗邻、两个或多个、垂直方向和普通流。</p>
<h4 id="毗邻"><a href="#毗邻" class="headerlink" title="毗邻"></a>毗邻</h4><p>毗邻说明了他们的位置关系，没有被 padding、border、clear 和 line box 分隔开。</p>
<h4 id="两个或多个"><a href="#两个或多个" class="headerlink" title="两个或多个"></a>两个或多个</h4><p>两个或多个盒子是指元素之间的相互影响，单个元素不会存在外边距叠加的情况。</p>
<h4 id="垂直方向"><a href="#垂直方向" class="headerlink" title="垂直方向"></a>垂直方向</h4><blockquote>
<p>Horizontal margins never collapse.</p>
</blockquote>
<p>只有垂直方向的外边距会发生外边距叠加。水平方向的外边距不存在叠加的情况。</p>
<h4 id="普通流-in-flow"><a href="#普通流-in-flow" class="headerlink" title="普通流(in flow)"></a>普通流(in flow)</h4><p>什么是普通流？W3C 只对 out of flow 作了定义：</p>
<blockquote>
<p>An element is called out of flow if it is floated, absolutely positioned, or is the root element.An element is called in-flow if it is not out-of-flow.</p>
</blockquote>
<p>从定义中我们可以知道只要不是 float、absolutely positioned 和 root element 时就是 in flow。</p>
<h4 id="什么时候会发生外边距叠加"><a href="#什么时候会发生外边距叠加" class="headerlink" title="什么时候会发生外边距叠加"></a>什么时候会发生外边距叠加</h4><p>外边距叠加存在两种情况：一是父子外边距叠加；二是兄弟外边距叠加。</p>
<p>W3C 对于什么是毗邻的外边距也有定义：</p>
<blockquote>
<p>Two margins are adjoining if and only if: - both belong to in-flow block-level boxes that participate in the same block formatting context - no line boxes, no clearance, no padding and no border separate them - both belong to vertically-adjacent box edges, i.e. form one of the following pairs:</p>
<ul>
<li>top margin of a box and top margin of its first in-flow child</li>
<li>bottom margin of box and top margin of its next in-flow following sibling</li>
<li>bottom margin of a last in-flow child and bottom margin of its parent if the &gt; parent has “auto” computed height</li>
<li>top and bottom margins of a box that does not establish a new block formatting context and that has zero computed “min-height”, zero or “auto” computed “height”, and no in-flow children</li>
</ul>
</blockquote>
<p>从定义中我们可以很清楚的知道要符合哪些情况才会发生外边距折叠：</p>
<ul>
<li>都属于普通流的块级盒子且参与到相同的块级格式上下文中</li>
<li>没有被padding、border、clear和line box分隔开</li>
<li>都属于垂直毗邻盒子边缘：<ul>
<li>盒子的top margin和它第一个普通流子元素的top margin</li>
<li>盒子的bottom margin和它下一个普通流兄弟的top margin</li>
<li>盒子的bottom margin和它父元素的bottom margin</li>
<li>盒子的top margin和bottom margin，且没有创建一个新的块级格式上下文，且有被计算为0的min-height，被计算为0或auto的height，且没有普通流子元素</li>
</ul>
</li>
</ul>
<h4 id="如何避免外边距叠加"><a href="#如何避免外边距叠加" class="headerlink" title="如何避免外边距叠加"></a>如何避免外边距叠加</h4><p>上面讲了外边距的叠加，那如何避免呢，其实只要破坏上面讲到的四个条件中的任何一个即可：毗邻、两个或多个、普通流和垂直方向。</p>
<p>W3C也对此做了总结：</p>
<blockquote>
<ul>
<li>Margins between a floated box and any other box do not collapse (not even between a float and its in-flow children).</li>
<li>Margins of elements that establish new block formatting contexts (such as floats and elements with “overflow” other than “visible”) do not collapse with their in-flow children.</li>
<li>Margins of absolutely positioned boxes do not collapse (not even with their in-flow children).</li>
<li>Margins of inline-block boxes do not collapse (not even with their in-flow children).</li>
<li>The bottom margin of an in-flow block-level element always collapses with the top margin of its next in-flow block-level sibling, unless that sibling has clearance.</li>
<li>The top margin of an in-flow block element collapses with its first in-flow block-level child”s top margin if the element has no top border, no top padding, and the child has no clearance.</li>
<li>The bottom margin of an in-flow block box with a “height” of “auto” and a “min-height” of zero collapses with its last in-flow block-level child”s bottom margin if the box has no bottom padding and no bottom border and the child”s bottom margin does not collapse with a top margin that has clearance.</li>
<li>A box”s own margins collapse if the “min-height” property is zero, and it has neither top or bottom borders nor top or bottom padding, and it has a “height” of either 0 or “auto”, and it does not contain a line box, and all of its in-flow children”s margins (if any) collapse.</li>
</ul>
</blockquote>
<ul>
<li>浮动元素不会与任何元素发生叠加，也包括它的子元素</li>
<li>创建了 BFC 的元素不会和它的子元素发生外边距叠加</li>
<li>绝对定位元素和其他任何元素之间不发生外边距叠加，也包括它的子元素</li>
<li>inline-block 元素和其他任何元素之间不发生外边距叠加，也包括它的子元素</li>
<li>普通流中的块级元素的 margin-bottom 永远和它相邻的下一个块级元素的 margin-top 叠加，除非相邻的兄弟元素 clear</li>
<li>普通流中的块级元素（没有 border-top、没有 padding-top）的 margin-top 和它的第一个普通流中的子元素（没有clear）发生 margin-top 叠加</li>
<li>普通流中的块级元素（height为 auto、min-height为0、没有 border-bottom、没有 padding-bottom）和它的最后一个普通流中的子元素（没有自身发生margin叠加或clear）发生 margin-bottom叠加</li>
<li>如果一个元素的 min-height 为0、没有 border、没有padding、高度为0或者auto、不包含子元素，那么它自身的外边距会发生叠加</li>
</ul>
<p>以上就是外边距叠加的主要内容。</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array --6.Min Cost Climbing Stairs]]></title>
      <url>/2018/01/25/leetCode/array/06.Min_Cost_Climbing_Stairs/</url>
      <content type="html"><![CDATA[<h2 id="Problem-six-Min-Cost-Climbing-Stairs"><a href="#Problem-six-Min-Cost-Climbing-Stairs" class="headerlink" title="Problem six: Min Cost Climbing Stairs"></a>Problem six: Min Cost Climbing Stairs</h2><p>On a staircase, the i-th step has some non-negative cost cost[i] assigned (0 indexed).</p>
<p>Once you pay the cost, you can either climb one or two steps. You need to find minimum cost to reach the top of the floor, and you can either start from the step with index 0, or the step with index 1.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> cost = [10, 15, 20]<br>  <strong>Output:</strong> 15<br>  <strong>Explanation:</strong> Cheapest is start on cost[1], pay that cost and go to the top.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> cost = [1, 100, 1, 1, 1, 100, 1, 1, 100, 1]<br>  <strong>Output:</strong> 6<br>  <strong>Explanation:</strong> Cheapest is start on cost[0], and only step on 1s, skipping cost[3].</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>cost will have a length in the range [2, 1000].</li>
<li>Every cost[i] will be an integer in the range [0, 999].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.第一眼看这道题，显然是一道递归题，照着这个思路做很容易就做出来了。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i&lt;=cost.length<span class="number">-1</span>;i++)&#123;</span><br><span class="line">        cost[i]=cost[i]+<span class="built_in">Math</span>.min(cost[i<span class="number">-1</span>],cost[i<span class="number">-2</span>]);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">Math</span>.min(cost[cost.length<span class="number">-1</span>],cost[cost.length<span class="number">-2</span>]);</span><br><span class="line"></span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<ol>
<li>同理，也有一种类似的解法，三个元素三个元素的比较，最后一个元素的最小值就是前两个元素的最小值加上对应的值。<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> minCostClimbingStairs = <span class="function"><span class="keyword">function</span>(<span class="params">cost</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> firstElement = <span class="number">0</span>, secondElement = <span class="number">0</span>, thirdElement = <span class="number">0</span>;</span><br><span class="line">     <span class="keyword">for</span>(<span class="keyword">var</span> i=<span class="number">2</span>;i &lt;= cost.length;i++)&#123;</span><br><span class="line">         thirdElement = <span class="built_in">Math</span>.min(secondElement + cost[i<span class="number">-1</span>], firstElement + cost[i<span class="number">-2</span>]);</span><br><span class="line">         firstElement = secondElement;</span><br><span class="line">         secondElement = thirdElement;</span><br><span class="line">     &#125;</span><br><span class="line">     <span class="keyword">return</span> thirdElement;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 5.Largest Number At Least Twice of Others]]></title>
      <url>/2018/01/25/leetCode/array/05.Largest_Number_At_Least_Twice_of_Others/</url>
      <content type="html"><![CDATA[<h2 id="Problem-five-Largest-Number-At-Least-Twice-of-Others"><a href="#Problem-five-Largest-Number-At-Least-Twice-of-Others" class="headerlink" title="Problem five: Largest Number At Least Twice of Others"></a>Problem five: Largest Number At Least Twice of Others</h2><p>In a given integer array nums, there is always exactly one largest element.</p>
<p>Find whether the largest element in the array is at least twice as much as every other number in the array.</p>
<p>If it is, return the index of the largest element, otherwise return -1.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [3, 6, 1, 0]<br>  <strong>Output:</strong> 1<br>  <strong>Explanation:</strong> 6 is the largest integer, and for every other number in the array x,<br>    6 is more than twice as big as x.  The index of value 6 is 1, so we return 1.</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> nums = [1, 2, 3, 4]<br>  <strong>Output:</strong> -1<br>  <strong>Explanation:</strong> 4 isn’t at least as big as twice the value of 3, so we return -1.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ol>
<li>nums will have a length in the range [1, 50].</li>
<li>Every nums[i] will be an integer in the range [0, 99].</li>
</ol>
<p><strong>solution:</strong></p>
<p>1.最开始想到的是用sort()函数来解决这个问题，但是需要注意两点：在sort函数中添加判断数字大小的函数，否则会将数字视为字符串，用最开始的数字进行排序；再一个就是在复制数组时，不能直接使用‘=’进行复制操作，因为这样其实传递的是数组地址，如果这样赋值，在对原先数组进行操作时，其实会对新建的数组进行修改。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">function</span> <span class="title">sequence</span>(<span class="params">a,b</span>)</span>&#123;</span><br><span class="line">         <span class="keyword">if</span> (a&gt;b) &#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">1</span>;</span><br><span class="line">         &#125;<span class="keyword">else</span> <span class="keyword">if</span>(a&lt;b)&#123;</span><br><span class="line">              <span class="keyword">return</span> <span class="number">-1</span></span><br><span class="line">         &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">             <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">        &#125;</span><br><span class="line">&#125;;</span><br><span class="line"><span class="keyword">var</span> dominantIndex = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> nums_copy;</span><br><span class="line">    nums_copy = [];</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> m = <span class="number">0</span>; m &lt; nums.length; m++) &#123;</span><br><span class="line">        nums_copy[m] = nums[m];</span><br><span class="line">    &#125;</span><br><span class="line">    nums.sort(sequence);</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">1</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums[nums.length - <span class="number">2</span>] &gt; <span class="number">0</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[nums.length - <span class="number">1</span>]/nums[nums.length - <span class="number">2</span>] &gt;= <span class="number">2</span>) &#123;</span><br><span class="line">            <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums_copy.length; i++) &#123;</span><br><span class="line">                <span class="keyword">if</span>(nums_copy[i] == nums[nums.length <span class="number">-1</span>])</span><br><span class="line">                    <span class="keyword">return</span> i;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125; <span class="keyword">else</span></span><br><span class="line">            <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; nums_copy.length; n++) &#123;</span><br><span class="line">            <span class="keyword">if</span>(nums_copy[n] == nums[nums.length <span class="number">-1</span>])</span><br><span class="line">                <span class="keyword">return</span> n;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度；</p>
<p>2.一开始以为上述方法比较简单，但实际写下来还有需要细节要注意，因此，先选出数组中的最大值，在与数组中的所有元素进行对比，当有元素大于nums[maxIndex]的1/2时，返回-1，否则返回该最大值下标。<br><figure class="highlight matlab"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">var dominantIndex = <span class="function"><span class="keyword">function</span><span class="params">(nums)</span> &#123;</span></span><br><span class="line">    var maxIndex = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; nums.<span class="built_in">length</span>; ++<span class="built_in">i</span>) &#123;</span><br><span class="line">            if (nums[i] &gt; nums[maxIndex])</span><br><span class="line">                maxIndex = i;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span> (var <span class="built_in">i</span> = <span class="number">0</span>; <span class="built_in">i</span> &lt; nums.<span class="built_in">length</span>; ++<span class="built_in">i</span>) &#123;</span><br><span class="line">            if (maxIndex != i &amp;&amp; nums[maxIndex] &lt; <span class="number">2</span> * nums[i])</span><br><span class="line">                return <span class="number">-1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxIndex;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度;</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 4.longest continuous increasing subsequence]]></title>
      <url>/2018/01/25/leetCode/array/04.longest_continuous_increasing_subsequence/</url>
      <content type="html"><![CDATA[<h2 id="Problem-four-longest-continuous-increasing-subsequence"><a href="#Problem-four-longest-continuous-increasing-subsequence" class="headerlink" title="Problem four: longest continuous increasing subsequence"></a>Problem four: longest continuous increasing subsequence</h2><p>Given an unsorted array of integers, find the length of longest continuous increasing subsequence (subarray).</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [1,3,5,4,7]<br>  <strong>Output:</strong> 3<br>  <strong>Explanation:</strong> The longest continuous increasing subsequence is [1,3,5], its length is 3.<br>  Even though [1,3,5,7] is also an increasing subsequence, it’s not a continuous one where 5 and 7 are separated by 4. </p>
</blockquote>
<p>  <strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [2,2,2,2,2]<br>  <strong>Output:</strong> 1<br>  <strong>Explanation:</strong> The longest continuous increasing subsequence is [2], its length is 1.</p>
</blockquote>
<p><strong>Note:</strong> Length of the array will not exceed 10,000.</p>
<p><strong>solution:</strong></p>
<p>1.直观的想法是遍历数组时，当数字持续增加时用一个数字存储累加的总和，在减少时与另一个初始为0的数字对比，如果大于这个存放之前的最长长度的数字，则替换该值，并重置计数的大小。最后，比较最后一次累加数值的大小，返回最大值。<br><figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> findLengthOfLCIS = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> num = <span class="number">1</span>;</span><br><span class="line">    <span class="keyword">var</span> maxLength = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">if</span>(nums.length == <span class="number">0</span>)</span><br><span class="line">        <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; nums.length;  i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] &gt; nums[i<span class="number">-1</span>]) &#123;</span><br><span class="line">            num++;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>(num &gt; maxLength) &#123;</span><br><span class="line">                maxLength = num;</span><br><span class="line">            &#125;</span><br><span class="line">            num = <span class="number">1</span>;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(num &gt; maxLength) </span><br><span class="line">        <span class="keyword">return</span> num;</span><br><span class="line">    <span class="keyword">else</span></span><br><span class="line">        <span class="keyword">return</span> maxLength;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.因为累加的子串是在nums[i-1] &gt;= nums[i]时发生变化的，也就是说我们将变化的元素下标记录下来，当前一个元素大于后一个元素时，将当前元素下标赋值给anchor，在累加的过程中，ans会用之前的最长串与现在的累加的串的长度作对比，保留最长串。<br><figure class="highlight pf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line">var findLengthOfLCIS = function(nums) &#123;</span><br><span class="line">    var ans = <span class="number">0</span>;</span><br><span class="line">    var <span class="built_in">anchor</span> = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (var i = <span class="number">0</span>; i <span class="variable">&lt; nums.length; ++i) &#123;</span></span><br><span class="line"><span class="variable">            if (i &gt;</span> <span class="number">0</span> &amp;&amp; nums[i-<span class="number">1</span>] &gt;= nums[i])</span><br><span class="line">                <span class="built_in">anchor</span> = i;</span><br><span class="line">            ans = Math.<span class="keyword">max</span>(ans, i - <span class="built_in">anchor</span> + <span class="number">1</span>);</span><br><span class="line">        &#125;</span><br><span class="line">        return ans;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Array -- 3.Best Time to Buy and Sell Stock]]></title>
      <url>/2018/01/23/leetCode/array/03.Best_Time_to_Buy_and_sell_stock/</url>
      <content type="html"><![CDATA[<h2 id="Problem-three-Best-Time-to-Buy-and-Sell-Stock"><a href="#Problem-three-Best-Time-to-Buy-and-Sell-Stock" class="headerlink" title="Problem three: Best Time to Buy and Sell Stock"></a>Problem three: Best Time to Buy and Sell Stock</h2><p>Say you have an array for which the i<sup>th</sup> element is the price of a given stock on day i.</p>
<p>If you were only permitted to complete at most one transaction (ie, buy one and sell one share of the stock), design an algorithm to find the maximum profit.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong> [7, 1, 5, 3, 6, 4]<br><strong>Output:</strong> 5<br>max. difference = 6-1 = 5 (not 7-1 = 6, as selling price needs to be larger than buying price)</p>
</blockquote>
<p><strong>Example 2:</strong></p>
<blockquote>
<p><strong>Input:</strong> [7, 6, 4, 3, 1]<br><strong>Output:</strong> 0<br>In this case, no transaction is done, i.e. max profit = 0.</p>
</blockquote>
<p><strong>solution:</strong></p>
<p>1.这道题主要考察的是边界条件的判断，首先，将第二个元素与第一个元素进行对比，如果第二个元素大，则设置maxProfit，minPrice和maxPrice，如果第一个元素大，设置maxPrice，minPrice。若不为前两个元素，需要考虑下一个元素与之前最小的元素比较是否会大于之前的maxProfit，若大于，则设置maxProfit和maxPrice，否则设置minPrice。以此类推，最后返回maxProfit。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span>(<span class="params">prices</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> maxProfit = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> maxPrice = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> minPrice = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">1</span>) &#123;</span><br><span class="line">            <span class="keyword">if</span>((prices[i] - prices[i<span class="number">-1</span>]) &gt; maxProfit) &#123;</span><br><span class="line">                maxProfit = prices[i] - prices[i<span class="number">-1</span>];</span><br><span class="line">                minPrice = prices[i - <span class="number">1</span>];</span><br><span class="line">                maxPrice = prices[i];</span><br><span class="line">            &#125; </span><br><span class="line">            <span class="keyword">else</span> &#123;</span><br><span class="line">                minPrice = prices[i];</span><br><span class="line">                maxPrice = prices[i<span class="number">-1</span>];</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;<span class="keyword">else</span> &#123;</span><br><span class="line">            <span class="keyword">if</span>((prices[i] - minPrice) &gt; maxProfit) &#123;</span><br><span class="line">                maxProfit = prices[i] - minPrice;</span><br><span class="line">                maxPrice = prices[i];</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="keyword">else</span>&#123;</span><br><span class="line">                <span class="keyword">if</span>(minPrice &gt; prices[i]) &#123;</span><br><span class="line">                    minPrice = prices[i];  </span><br><span class="line">                &#125;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> maxProfit;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.接下来换一种思想比较简单的方法，现在需要找到最大的差值，且大的数在后面，小的数在前面，所以，可以两层嵌套，比较元素后面的值并选出最大的值。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span><span class="params">(prices)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prices.length - <span class="number">1</span>; i++) &#123;</span><br><span class="line">            <span class="keyword">for</span> (<span class="keyword">var</span> j = i + <span class="number">1</span>; j &lt; prices.length; j++) &#123;</span><br><span class="line">                <span class="keyword">var</span> profit = prices[j] - prices[i];</span><br><span class="line">                <span class="keyword">if</span> (profit &gt; maxprofit)</span><br><span class="line">                    maxprofit = profit;</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), 循环n(n-1)/2遍，效果很差。</p>
<p>3.接下来的方法和第一种类似，先去一个特别大的最小值和特别大的最大值，然后进行遍历，若当前元素小于最小值，则替换最小值，否则就与最小值比较，若大于最大差值，则替换最大差值。这个方法与第一种比不需要保存最大值。<br><figure class="highlight actionscript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> maxProfit = <span class="function"><span class="keyword">function</span><span class="params">(prices)</span> </span>&#123;</span><br><span class="line">     <span class="keyword">var</span> minprice = <span class="number">9999999</span>;</span><br><span class="line">     <span class="keyword">var</span> maxprofit = <span class="number">0</span>;</span><br><span class="line">        <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; prices.length; i++) &#123;</span><br><span class="line">            <span class="keyword">if</span> (prices[i] &lt; minprice)</span><br><span class="line">                minprice = prices[i];</span><br><span class="line">            <span class="keyword">else</span> <span class="keyword">if</span> (prices[i] - minprice &gt; maxprofit)</span><br><span class="line">                maxprofit = prices[i] - minprice;</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">return</span> maxprofit;</span><br><span class="line">  &#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[LeetCode Array -- 2.Remove Element]]></title>
      <url>/2018/01/23/leetCode/array/02.remove_element/</url>
      <content type="html"><![CDATA[<h2 id="Problem-two-Remove-Element"><a href="#Problem-two-Remove-Element" class="headerlink" title="Problem two: Remove Element"></a>Problem two: Remove Element</h2><p>Given an array and a value, remove all instances of that value in-place and return the new length.</p>
<p>Do not allocate extra space for another array, you must do this by modifying the input array in-place with O(1) extra memory.</p>
<p>The order of elements can be changed. It doesn’t matter what you leave beyond the new length.</p>
<p><strong>Example:</strong></p>
<blockquote>
<p>Given <strong>nums</strong> = [3,2,2,3], val = 3,</p>
</blockquote>
<p>Your function should return length = 2, with the first two elements of nums being 2.</p>
<p><strong>solution:</strong></p>
<p>1.最直接的方法是使用数组自带的splice方法，需要注意的是当remove掉相符合的元素后，要将下标减一，不然会造成数组减少一个元素后，原元素后面的元素序号会提前一个，会忽略掉下一个元素。</p>
<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">var</span> removeElement = <span class="function"><span class="keyword">function</span>(<span class="params">nums, val</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(nums[i] == val) &#123;</span><br><span class="line">            nums.splice(i, <span class="number">1</span>);</span><br><span class="line">            i -= <span class="number">1</span>;</span><br><span class="line">        &#125; </span><br><span class="line">    &#125; </span><br><span class="line">    <span class="keyword">return</span> nums.length;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
<p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
<p>2.另一种方法是在遍历数组过程中，如果元素的值等于对应的value，则将当前元素与最后一个元素交换位置，然后将数组长度减1，变相的去除数组的重复项，可惜的是，这种方法和splice()消耗的时间几近相同。<br><figure class="highlight maxima"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">var</span> removeElement = function(nums, val) &#123;</span><br><span class="line">    <span class="built_in">var</span> i = <span class="number">0</span>;</span><br><span class="line">    <span class="built_in">var</span> <span class="built_in">num</span> = nums.<span class="built_in">length</span>;</span><br><span class="line">    <span class="keyword">while</span> (i &lt; <span class="built_in">num</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (nums[i] == val) &#123;</span><br><span class="line">            nums[i] = nums[<span class="built_in">num</span> - <span class="number">1</span>];</span><br><span class="line">            <span class="built_in">num</span>--;</span><br><span class="line">        &#125; <span class="keyword">else</span> &#123;</span><br><span class="line">            i++;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">return</span> <span class="built_in">num</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure></p>
<p>复杂度分析：<br>Time Complexity：O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[leetCode Array -- 1.Find Pivot Index]]></title>
      <url>/2018/01/23/leetCode/array/01.find_pivot_index/</url>
      <content type="html"><![CDATA[<h2 id="Problem-one-Find-Pivot-Index"><a href="#Problem-one-Find-Pivot-Index" class="headerlink" title="Problem one: Find Pivot Index"></a>Problem one: Find Pivot Index</h2><p>Given an array of integers nums, write a method that returns the “pivot” index of this array.</p>
<p>We define the pivot index as the index where the sum of the numbers to the left of the index is equal to the sum of the numbers to the right of the index.</p>
<p>If no such index exists, we should return -1. If there are multiple pivot indexes, you should return the left-most pivot index.</p>
<p><strong>Example 1:</strong></p>
<blockquote>
<p><strong>Input:</strong><br><strong>nums</strong> = [1, 7, 3, 6, 5, 6]<br><strong>Output</strong>: 3<br><strong>Explanation</strong>:<br>The sum of the numbers to the left of index 3 (nums[3] = 6) is equal to the sum of numbers to the right of index 3.<br>Also, 3 is the first index where this occurs.</p>
</blockquote>
<p><strong>Example</strong> 2:</p>
<blockquote>
<p><strong>Input:</strong><br><strong>nums</strong> = [1, 2, 3]<br><strong>Output</strong>: -1<br><strong>Explanation</strong>:<br>There is no index that satisfies the conditions in the problem statement.</p>
</blockquote>
<p><strong>Note:</strong></p>
<ul>
<li>The length of nums will be in the range [0, 10000].</li>
<li>Each element nums[i] will be an integer in the range [-1000, 1000].</li>
</ul>
<p><strong>solution:</strong></p>
<ol>
<li>直接想到的是遍历数组，将每个元素左侧的元素和与右侧元素和比较，相同则返回对应元素下标。（若第一个元素右侧和为0，则返回第一个元素下标）。否则返回-1；<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> leftSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> rightSum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; nums.length; i++) &#123;</span><br><span class="line">        <span class="keyword">if</span>(i == <span class="number">0</span>) &#123;</span><br><span class="line">            leftSum =<span class="number">0</span>;</span><br><span class="line">        &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">            leftSum += nums[i<span class="number">-1</span>];</span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">for</span>(<span class="keyword">var</span> n = i+<span class="number">1</span>; n &lt; nums.length; n++) &#123;</span><br><span class="line">            rightSum += nums[n];    </span><br><span class="line">        &#125;</span><br><span class="line">        <span class="keyword">if</span>(leftSum == rightSum) </span><br><span class="line">            <span class="keyword">return</span> i;</span><br><span class="line">        rightSum = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>复杂度分析：<br>Time Complexity：O(n<sup>2</sup>), n为nums的长度；</p>
<ol>
<li>上一种方法的问题在于要用两遍for循环，时间复杂度过高，所以尽量减少嵌套：<figure class="highlight javascript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line">   <span class="keyword">var</span> pivotIndex = <span class="function"><span class="keyword">function</span>(<span class="params">nums</span>) </span>&#123;</span><br><span class="line">    <span class="keyword">var</span> leftSum =<span class="number">0</span>;</span><br><span class="line">    <span class="keyword">var</span> sum = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i&lt; nums.length; i++) </span><br><span class="line">        sum += nums[i];</span><br><span class="line">     <span class="keyword">for</span> (<span class="keyword">var</span> n = <span class="number">0</span>; n &lt; nums.length; n++) &#123;</span><br><span class="line">        <span class="keyword">if</span> (leftSum == (sum - leftSum - nums[n])) </span><br><span class="line">            <span class="keyword">return</span> n;</span><br><span class="line">        leftSum += nums[n];</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>
</li>
</ol>
<p>复杂度分析：<br>Time Complexity: O(n), n为nums的长度；</p>
]]></content>
      
        <categories>
            
            <category> leetCode </category>
            
        </categories>
        
        
        <tags>
            
            <tag> leetCode </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[搭建github博客]]></title>
      <url>/2018/01/12/blog/problem/%E6%90%AD%E5%BB%BAgithub%E5%8D%9A%E5%AE%A2/</url>
      <content type="html"><![CDATA[<h2 id="搭建github博客-amp-使用hexo博客框架-amp-使用material主题"><a href="#搭建github博客-amp-使用hexo博客框架-amp-使用material主题" class="headerlink" title="搭建github博客&amp;使用hexo博客框架&amp;使用material主题"></a>搭建github博客&amp;使用hexo博客框架&amp;使用material主题</h2><p>因为原先在CSDN上有各种各样的限制和难言之隐，所以在生庆哥的帮助和怂恿下，选择使用github搭建博客并个性化设置，主要说一下大体过程和期间的问题。主要的内容可以分为以下三类：</p>
<ul>
<li>搭建github博客</li>
<li>使用hexo框架</li>
<li>使用material主题</li>
</ul>
<h3 id="搭建github博客"><a href="#搭建github博客" class="headerlink" title="搭建github博客"></a>搭建github博客</h3><p>其实之前在学校的时候一直知道github看可以搭建博客，还可以直接使用对应的域名，但是出于各种原因一直没有自己搭建一个博客尝试尝试，终于，现在正好有时间和精力可以试试。<br>在个人github首页上，创建一个github.io的框架，即个人账户+仓库名，如：lpldplws.github.io。因为此仓库就是用来放博客的，所以在master分支上开发，然后在setting页面中选择launch automatic page generator生成博客项目。然后将该项目clone到本地，最初的博客就搭建成了~</p>
<p>个人博客地址是<a href="https://github.com/lpldplws/lpldplws.github.io" target="_blank" rel="noopener">lpldplws.github.io</a>。<br>接下来要做的就是redirect到自己的域名，在阿里上买了一个29一年的域名，名字是<a href="http://www.lpldplws.cn">lpldplws.cn</a>,需要做的是在clone下的项目的根目录下建立好映射，创建一个”CNAME”（没有后缀名）的文件，之后访问lpldplws.github.io就会redirect到此域名，或者您在对应的域名服务商上面修改CNAME到对应的github仓库地址也是可以的。<br>注意：此处因为是直接在master分支上创建的，之后也是在master分支上使用的框架和主题，导致最后hexo generate的内容保存到了github.io中，这部分是接下来一周需要解决的问题之一。</p>
<h3 id="使用hexo框架"><a href="#使用hexo框架" class="headerlink" title="使用hexo框架"></a>使用hexo框架</h3><p>之所以知道这个框架是因为咱们的FE团队的翻译框架就是这个，所以此处借鉴了以下，嘿嘿。<br>在<a href="https://hexo.io/" target="_blank" rel="noopener">hexo官网</a>上,介绍了这是一个简单高效的博客框架，在github.io仓库中，使用npm安装即可。虽然可以支持markdown的格式，但是其自带的tag也是非常方便的，我看还可以使用youtube视频，厉害了，这理所当然的成为下周需要学习的内容之一了。<br>还有一个比较深的体会是使用hexo的感觉就像开发机一样，通过hexo server相当于在开发机上查看效果，使用hexo generate和hexo deploy相当于部署在线上环境，就是少了review的部分，不过对于一个个人博客来说还是比较完善的了。</p>
<h3 id="使用material主题"><a href="#使用material主题" class="headerlink" title="使用material主题"></a>使用material主题</h3><p>使用hexo默认界面当然不能满足自己的审美了，在一番选择（选择恐惧症）后，终于选(sui)择(ji)了一个比较好看的theme，这就是<a href="https://material.viosey.com/" target="_blank" rel="noopener">material</a>，这个主题比较素雅，正好很吸引我~以下主要说明material主题配置中遇到的问题。其中主要的配置文件在<code>config.template.yaml</code>中，不过需要先将其改名为<code>config.yaml</code>。在页面配置中，按照流程可以选择对应的插件和效果，比较吸引人的是它的背景可以从必应上选择，后来因为颜色不匹配主题就去掉了，个人打算通过对选项加一个filter或者下到对应文件随机加载是个不错的选择，所以下周又新加了一项任务。还有一点就是评论系统和统计系统，个人选择的是<code>Valine</code>，因为考虑到可以使用对应后台查看信息，不过缺点就是有点丑。。。后来生庆哥说Google的后台数据处理用的人很多，所以打算抛弃当前评论系统，投入其他评论系统的怀抱。<br>对于独立页面部分还没有怎么看，下周来吧，除此之外，除了在mobile上效果还行，pc上两端有点空，所以想加一个音乐播放器，这部分打算选择网易云的api，实现一个音乐播放的效果。其他的内容就慢慢补全吧，这周过的虽然很累但还是很充实，个人也应该静下心来，虽然很多不会，但是相信通过付出比别人更多的努力，一定快速达到可以帮助到胡老师和FE团队的地步，fighting！</p>
]]></content>
      
        <categories>
            
            <category> 前端常见问题 </category>
            
        </categories>
        
        
        <tags>
            
            <tag> 前端问题 </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
